function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["modules-fields-fields-module"], {
  /***/
  "../../node_modules/igniteui-angular/fesm2015/igniteui-angular.js":
  /*!***************************************************************************************************************************!*\
    !*** C:/Users/KING/Desktop/Economic-Statistic/e-statistics/UI/node_modules/igniteui-angular/fesm2015/igniteui-angular.js ***!
    \***************************************************************************************************************************/

  /*! exports provided: AbsoluteScrollStrategy, AutoPositionStrategy, AvatarType, BaseFilteringStrategy, BaseProgress, BlockScrollStrategy, ButtonGroupAlignment, Calendar, CalendarHammerConfig, CalendarView, CloseScrollStrategy, ColumnDisplayOrder, ConnectedPositioningStrategy, ContainerPositionStrategy, CsvFileTypes, DataType, DataUtil, DateRangeType, DefaultSortingStrategy, Direction, DisplayDensity, DisplayDensityBase, DisplayDensityToken, DropPosition, ElasticPositionStrategy, FilterMode, FilteringExpressionsTree, FilteringExpressionsTreeType, FilteringLogic, FilteringStrategy, GlobalPositionStrategy, GridBaseAPIService, GridKeydownTargetType, GridSelectionMode, GridSummaryCalculationMode, GridSummaryPosition, GroupedRecords, HorizontalAlignment, IGX_CHECKBOX_REQUIRED_VALIDATOR, IGX_SWITCH_REQUIRED_VALIDATOR, IgxActionIconDirective, IgxAppendDropStrategy, IgxAutocompleteDirective, IgxAutocompleteModule, IgxAvatarComponent, IgxAvatarModule, IgxBadgeComponent, IgxBadgeModule, IgxBannerComponent, IgxBannerModule, IgxBaseExporter, IgxBaseTransactionService, IgxBooleanFilteringOperand, IgxBottomNavComponent, IgxBottomNavModule, IgxButtonDirective, IgxButtonGroupComponent, IgxButtonGroupModule, IgxButtonModule, IgxCalendarComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarModule, IgxCalendarMonthDirective, IgxCalendarScrollMonthDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarYearDirective, IgxCardActionsComponent, IgxCardActionsLayout, IgxCardComponent, IgxCardContentDirective, IgxCardFooterDirective, IgxCardHeaderComponent, IgxCardHeaderSubtitleDirective, IgxCardHeaderTitleDirective, IgxCardMediaDirective, IgxCardModule, IgxCardThumbnailDirective, IgxCardType, IgxCarouselComponent, IgxCarouselModule, IgxCellEditorTemplateDirective, IgxCellFooterTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellTemplateDirective, IgxCheckboxComponent, IgxCheckboxModule, IgxCheckboxRequiredDirective, IgxChipComponent, IgxChipsAreaComponent, IgxChipsModule, IgxCircularProgressBarComponent, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnHidingComponent, IgxColumnHidingModule, IgxColumnLayoutComponent, IgxColumnMovingDragDirective, IgxColumnMovingDropDirective, IgxColumnMovingService, IgxColumnPinningComponent, IgxColumnPinningItemDirective, IgxColumnPinningModule, IgxColumnResizerDirective, IgxComboComponent, IgxComboModule, IgxComboState, IgxCsvExporterOptions, IgxCsvExporterService, IgxDataLoadingTemplateDirective, IgxDataRecordSorting, IgxDateFilteringOperand, IgxDatePickerComponent, IgxDatePickerModule, IgxDatePipeComponent, IgxDateSummaryOperand, IgxDaysViewComponent, IgxDecimalPipeComponent, IgxDefaultDropStrategy, IgxDialogComponent, IgxDialogModule, IgxDividerDirective, IgxDividerModule, IgxDividerType, IgxDragDirective, IgxDragDropModule, IgxDragLocation, IgxDropDirective, IgxDropDownBase, IgxDropDownComponent, IgxDropDownGroupComponent, IgxDropDownItemBase, IgxDropDownItemComponent, IgxDropDownItemNavigationDirective, IgxDropDownModule, IgxEmptyListTemplateDirective, IgxExcelExporterOptions, IgxExcelExporterService, IgxExpansionPanelBodyComponent, IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelModule, IgxExporterOptionsBase, IgxFilterCellTemplateDirective, IgxFilterDirective, IgxFilterModule, IgxFilterOptions, IgxFilterPipe, IgxFilteringOperand, IgxFlexDirective, IgxFocusDirective, IgxFocusModule, IgxForOfContext, IgxForOfDirective, IgxForOfModule, IgxGridAPIService, IgxGridBaseComponent, IgxGridBodyDirective, IgxGridCellComponent, IgxGridCommonModule, IgxGridComponent, IgxGridForOfDirective, IgxGridGroupByRowComponent, IgxGridModule, IgxGridRowComponent, IgxGridTransaction, IgxGroupAreaDropDirective, IgxGroupByRowTemplateDirective, IgxGrouping, IgxHeaderCollapseIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHierarchicalGridAPIService, IgxHierarchicalGridBaseComponent, IgxHierarchicalGridCellComponent, IgxHierarchicalGridComponent, IgxHierarchicalGridModule, IgxHierarchicalRowComponent, IgxHierarchicalTransactionService, IgxHierarchicalTransactionServiceFactory, IgxHintDirective, IgxIconComponent, IgxIconModule, IgxIconService, IgxInputDirective, IgxInputGroupComponent, IgxInputGroupModule, IgxInputState, IgxInsertDropStrategy, IgxLabelDirective, IgxLayoutDirective, IgxLayoutModule, IgxLeftButtonStyleDirective, IgxLinearProgressBarComponent, IgxListActionDirective, IgxListBase, IgxListComponent, IgxListItemComponent, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective, IgxListLineDirective, IgxListLineSubTitleDirective, IgxListLineTitleDirective, IgxListModule, IgxListPanState, IgxListThumbnailDirective, IgxMaskDirective, IgxMaskModule, IgxMonthPickerBase, IgxMonthPickerComponent, IgxMonthsViewComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective, IgxNavbarComponent, IgxNavbarModule, IgxNavigationCloseDirective, IgxNavigationDrawerComponent, IgxNavigationDrawerModule, IgxNavigationModule, IgxNavigationService, IgxNavigationToggleDirective, IgxNumberFilteringOperand, IgxNumberSummaryOperand, IgxOverlayOutletDirective, IgxOverlayService, IgxPaginatorComponent, IgxPaginatorModule, IgxPrefixDirective, IgxPrefixModule, IgxPrependDropStrategy, IgxProgressBarModule, IgxProgressType, IgxRadioComponent, IgxRadioGroupDirective, IgxRadioModule, IgxResizeHandleDirective, IgxRightButtonStyleDirective, IgxRippleDirective, IgxRippleModule, IgxRowCollapsedIndicatorDirective, IgxRowComponent, IgxRowExpandedIndicatorDirective, IgxRowIslandAPIService, IgxRowIslandComponent, IgxSelectComponent, IgxSelectGroupComponent, IgxSelectItemComponent, IgxSelectModule, IgxSelectToggleIconDirective, IgxSlideComponent, IgxSliderComponent, IgxSliderModule, IgxSnackbarComponent, IgxSnackbarModule, IgxSorting, IgxStringFilteringOperand, IgxSuffixDirective, IgxSuffixModule, IgxSummaryOperand, IgxSwitchComponent, IgxSwitchModule, IgxSwitchRequiredDirective, IgxTabComponent, IgxTabItemComponent, IgxTabItemTemplateDirective, IgxTabPanelComponent, IgxTabTemplateDirective, IgxTabsComponent, IgxTabsGroupComponent, IgxTabsModule, IgxTextAlign, IgxTextHighlightDirective, IgxTextHighlightModule, IgxTextSelectionDirective, IgxTextSelectionModule, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxTimePickerComponent, IgxTimePickerModule, IgxToastComponent, IgxToastModule, IgxToastPosition, IgxToggleActionDirective, IgxToggleDirective, IgxToggleModule, IgxTooltipDirective, IgxTooltipModule, IgxTooltipTargetDirective, IgxTransactionService, IgxTreeGridAPIService, IgxTreeGridCellComponent, IgxTreeGridComponent, IgxTreeGridModule, IgxTreeGridRowComponent, IgxYearsViewComponent, InteractionMode, LabelPosition, NoOpScrollStrategy, PagingError, Point, PredefinedFormatOptions, RadioLabelPosition, RestrictDrag, RowEditPositionStrategy, ScrollStrategy, Size, SliderHandle, SliderType, SortingDirection, SwitchLabelPosition, TabsType, TimePickerHammerConfig, TransactionType, Type, VerticalAlignment, WEEKDAYS, blink, changei18n, convertInPercentage, fadeIn, fadeOut, filteringStateDefaults, flipBottom, flipHorBck, flipHorFwd, flipLeft, flipRight, flipTop, flipVerBck, flipVerFwd, getCurrentResourceStrings, getTypeNameForDebugging, getValueInProperRange, growVerIn, growVerOut, heartbeat, hierarchicalTransactionServiceFactory, isDateInRanges, isLeap, monthRange, pulsateBck, pulsateFwd, range, rotateInBl, rotateInBottom, rotateInBr, rotateInCenter, rotateInDiagonal1, rotateInDiagonal2, rotateInHor, rotateInLeft, rotateInRight, rotateInTl, rotateInTop, rotateInTr, rotateInVer, rotateOutBl, rotateOutBottom, rotateOutBr, rotateOutCenter, rotateOutDiagonal1, rotateOutDiagonal2, rotateOutHor, rotateOutLeft, rotateOutRight, rotateOutTl, rotateOutTop, rotateOutTr, rotateOutVer, scaleInBl, scaleInBottom, scaleInBr, scaleInCenter, scaleInHorCenter, scaleInHorLeft, scaleInHorRight, scaleInLeft, scaleInRight, scaleInTl, scaleInTop, scaleInTr, scaleInVerBottom, scaleInVerCenter, scaleInVerTop, scaleOutBl, scaleOutBottom, scaleOutBr, scaleOutCenter, scaleOutHorCenter, scaleOutHorLeft, scaleOutHorRight, scaleOutLeft, scaleOutRight, scaleOutTl, scaleOutTop, scaleOutTr, scaleOutVerBottom, scaleOutVerCenter, scaleOutVerTop, shakeBl, shakeBottom, shakeBr, shakeCenter, shakeHor, shakeLeft, shakeRight, shakeTl, shakeTop, shakeTr, shakeVer, slideInBl, slideInBottom, slideInBr, slideInLeft, slideInRight, slideInTl, slideInTop, slideInTr, slideOutBl, slideOutBottom, slideOutBr, slideOutLeft, slideOutRight, slideOutTl, slideOutTop, slideOutTr, swingInBottomBck, swingInBottomFwd, swingInLeftBck, swingInLeftFwd, swingInRightBck, swingInRightFwd, swingInTopBck, swingInTopFwd, swingOutBottomBck, swingOutBottomFwd, swingOutLeftBck, swingOutLefttFwd, swingOutRightBck, swingOutRightFwd, swingOutTopBck, swingOutTopFwd, weekDay, ɵa, ɵba, ɵbb, ɵbc, ɵbd, ɵbe, ɵbf, ɵbg, ɵbh, ɵbi, ɵbk, ɵbl, ɵbm, ɵbn, ɵbo, ɵbp, ɵbq, ɵbr, ɵbs, ɵbt, ɵbu, ɵbv, ɵbw, ɵbx, ɵby, ɵbz, ɵc, ɵca, ɵcb, ɵcc, ɵcd, ɵce, ɵcg, ɵch, ɵci, ɵcj, ɵck, ɵcl, ɵcm, ɵcn, ɵco, ɵcp, ɵcq, ɵcr, ɵcs, ɵct, ɵcu, ɵcv, ɵcw, ɵcx, ɵcy, ɵcz, ɵd, ɵda, ɵdb, ɵdc, ɵdd, ɵde, ɵdf, ɵdg, ɵdh, ɵdi, ɵdj, ɵdk, ɵdl, ɵdm, ɵdn, ɵdo, ɵdp, ɵdq, ɵdr, ɵds, ɵdt, ɵdu, ɵdv, ɵdw, ɵdx, ɵdy, ɵdz, ɵea, ɵeb, ɵec, ɵed, ɵee, ɵef, ɵeg, ɵeh, ɵei, ɵej, ɵek, ɵel, ɵem, ɵen, ɵeo, ɵep, ɵeq, ɵer, ɵes, ɵet, ɵeu, ɵev, ɵew, ɵex, ɵey, ɵez, ɵf, ɵfa, ɵfb, ɵfc, ɵfd, ɵfe, ɵff, ɵfg, ɵfh, ɵfi, ɵfj, ɵfk, ɵfl, ɵfm, ɵfn, ɵfo, ɵfp, ɵfq, ɵfr, ɵfs, ɵft, ɵfu, ɵfv, ɵfx, ɵfy, ɵfz, ɵg, ɵga, ɵgb, ɵgc, ɵgd, ɵge, ɵh, ɵi, ɵj, ɵk, ɵl, ɵm, ɵn, ɵo, ɵp, ɵq, ɵr, ɵs, ɵt, ɵu, ɵv, ɵw, ɵx, ɵy, ɵz */

  /***/
  function node_modulesIgniteuiAngularFesm2015IgniteuiAngularJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AbsoluteScrollStrategy", function () {
      return AbsoluteScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AutoPositionStrategy", function () {
      return AutoPositionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AvatarType", function () {
      return AvatarType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BaseFilteringStrategy", function () {
      return BaseFilteringStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BaseProgress", function () {
      return BaseProgress;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BlockScrollStrategy", function () {
      return BlockScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ButtonGroupAlignment", function () {
      return ButtonGroupAlignment;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Calendar", function () {
      return Calendar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CalendarHammerConfig", function () {
      return CalendarHammerConfig;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CalendarView", function () {
      return CalendarView;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CloseScrollStrategy", function () {
      return CloseScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ColumnDisplayOrder", function () {
      return ColumnDisplayOrder;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ConnectedPositioningStrategy", function () {
      return ConnectedPositioningStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ContainerPositionStrategy", function () {
      return ContainerPositionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CsvFileTypes", function () {
      return CsvFileTypes;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DataType", function () {
      return DataType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DataUtil", function () {
      return DataUtil;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DateRangeType", function () {
      return DateRangeType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DefaultSortingStrategy", function () {
      return DefaultSortingStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Direction", function () {
      return Direction$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DisplayDensity", function () {
      return DisplayDensity;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DisplayDensityBase", function () {
      return DisplayDensityBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DisplayDensityToken", function () {
      return DisplayDensityToken;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DropPosition", function () {
      return DropPosition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ElasticPositionStrategy", function () {
      return ElasticPositionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FilterMode", function () {
      return FilterMode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FilteringExpressionsTree", function () {
      return FilteringExpressionsTree;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FilteringExpressionsTreeType", function () {
      return FilteringExpressionsTreeType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FilteringLogic", function () {
      return FilteringLogic;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FilteringStrategy", function () {
      return FilteringStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GlobalPositionStrategy", function () {
      return GlobalPositionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GridBaseAPIService", function () {
      return GridBaseAPIService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GridKeydownTargetType", function () {
      return GridKeydownTargetType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GridSelectionMode", function () {
      return GridSelectionMode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GridSummaryCalculationMode", function () {
      return GridSummaryCalculationMode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GridSummaryPosition", function () {
      return GridSummaryPosition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GroupedRecords", function () {
      return GroupedRecords;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "HorizontalAlignment", function () {
      return HorizontalAlignment;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IGX_CHECKBOX_REQUIRED_VALIDATOR", function () {
      return IGX_CHECKBOX_REQUIRED_VALIDATOR;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IGX_SWITCH_REQUIRED_VALIDATOR", function () {
      return IGX_SWITCH_REQUIRED_VALIDATOR;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxActionIconDirective", function () {
      return IgxActionIconDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxAppendDropStrategy", function () {
      return IgxAppendDropStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxAutocompleteDirective", function () {
      return IgxAutocompleteDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxAutocompleteModule", function () {
      return IgxAutocompleteModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxAvatarComponent", function () {
      return IgxAvatarComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxAvatarModule", function () {
      return IgxAvatarModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxBadgeComponent", function () {
      return IgxBadgeComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxBadgeModule", function () {
      return IgxBadgeModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxBannerComponent", function () {
      return IgxBannerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxBannerModule", function () {
      return IgxBannerModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxBaseExporter", function () {
      return IgxBaseExporter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxBaseTransactionService", function () {
      return IgxBaseTransactionService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxBooleanFilteringOperand", function () {
      return IgxBooleanFilteringOperand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxBottomNavComponent", function () {
      return IgxBottomNavComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxBottomNavModule", function () {
      return IgxBottomNavModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxButtonDirective", function () {
      return IgxButtonDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxButtonGroupComponent", function () {
      return IgxButtonGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxButtonGroupModule", function () {
      return IgxButtonGroupModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxButtonModule", function () {
      return IgxButtonModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCalendarComponent", function () {
      return IgxCalendarComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCalendarHeaderTemplateDirective", function () {
      return IgxCalendarHeaderTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCalendarModule", function () {
      return IgxCalendarModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCalendarMonthDirective", function () {
      return IgxCalendarMonthDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCalendarScrollMonthDirective", function () {
      return IgxCalendarScrollMonthDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCalendarSubheaderTemplateDirective", function () {
      return IgxCalendarSubheaderTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCalendarYearDirective", function () {
      return IgxCalendarYearDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardActionsComponent", function () {
      return IgxCardActionsComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardActionsLayout", function () {
      return IgxCardActionsLayout;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardComponent", function () {
      return IgxCardComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardContentDirective", function () {
      return IgxCardContentDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardFooterDirective", function () {
      return IgxCardFooterDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardHeaderComponent", function () {
      return IgxCardHeaderComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardHeaderSubtitleDirective", function () {
      return IgxCardHeaderSubtitleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardHeaderTitleDirective", function () {
      return IgxCardHeaderTitleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardMediaDirective", function () {
      return IgxCardMediaDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardModule", function () {
      return IgxCardModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardThumbnailDirective", function () {
      return IgxCardThumbnailDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCardType", function () {
      return IgxCardType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCarouselComponent", function () {
      return IgxCarouselComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCarouselModule", function () {
      return IgxCarouselModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCellEditorTemplateDirective", function () {
      return IgxCellEditorTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCellFooterTemplateDirective", function () {
      return IgxCellFooterTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCellHeaderTemplateDirective", function () {
      return IgxCellHeaderTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCellTemplateDirective", function () {
      return IgxCellTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCheckboxComponent", function () {
      return IgxCheckboxComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCheckboxModule", function () {
      return IgxCheckboxModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCheckboxRequiredDirective", function () {
      return IgxCheckboxRequiredDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxChipComponent", function () {
      return IgxChipComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxChipsAreaComponent", function () {
      return IgxChipsAreaComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxChipsModule", function () {
      return IgxChipsModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCircularProgressBarComponent", function () {
      return IgxCircularProgressBarComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnComponent", function () {
      return IgxColumnComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnGroupComponent", function () {
      return IgxColumnGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnHidingComponent", function () {
      return IgxColumnHidingComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnHidingModule", function () {
      return IgxColumnHidingModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnLayoutComponent", function () {
      return IgxColumnLayoutComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnMovingDragDirective", function () {
      return IgxColumnMovingDragDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnMovingDropDirective", function () {
      return IgxColumnMovingDropDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnMovingService", function () {
      return IgxColumnMovingService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnPinningComponent", function () {
      return IgxColumnPinningComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnPinningItemDirective", function () {
      return IgxColumnPinningItemDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnPinningModule", function () {
      return IgxColumnPinningModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxColumnResizerDirective", function () {
      return IgxColumnResizerDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxComboComponent", function () {
      return IgxComboComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxComboModule", function () {
      return IgxComboModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxComboState", function () {
      return IgxComboState;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCsvExporterOptions", function () {
      return IgxCsvExporterOptions;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxCsvExporterService", function () {
      return IgxCsvExporterService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDataLoadingTemplateDirective", function () {
      return IgxDataLoadingTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDataRecordSorting", function () {
      return IgxDataRecordSorting;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDateFilteringOperand", function () {
      return IgxDateFilteringOperand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDatePickerComponent", function () {
      return IgxDatePickerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDatePickerModule", function () {
      return IgxDatePickerModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDatePipeComponent", function () {
      return IgxDatePipeComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDateSummaryOperand", function () {
      return IgxDateSummaryOperand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDaysViewComponent", function () {
      return IgxDaysViewComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDecimalPipeComponent", function () {
      return IgxDecimalPipeComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDefaultDropStrategy", function () {
      return IgxDefaultDropStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDialogComponent", function () {
      return IgxDialogComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDialogModule", function () {
      return IgxDialogModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDividerDirective", function () {
      return IgxDividerDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDividerModule", function () {
      return IgxDividerModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDividerType", function () {
      return IgxDividerType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDragDirective", function () {
      return IgxDragDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDragDropModule", function () {
      return IgxDragDropModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDragLocation", function () {
      return IgxDragLocation;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDropDirective", function () {
      return IgxDropDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDropDownBase", function () {
      return IgxDropDownBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDropDownComponent", function () {
      return IgxDropDownComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDropDownGroupComponent", function () {
      return IgxDropDownGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDropDownItemBase", function () {
      return IgxDropDownItemBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDropDownItemComponent", function () {
      return IgxDropDownItemComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDropDownItemNavigationDirective", function () {
      return IgxDropDownItemNavigationDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxDropDownModule", function () {
      return IgxDropDownModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxEmptyListTemplateDirective", function () {
      return IgxEmptyListTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxExcelExporterOptions", function () {
      return IgxExcelExporterOptions;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxExcelExporterService", function () {
      return IgxExcelExporterService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxExpansionPanelBodyComponent", function () {
      return IgxExpansionPanelBodyComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxExpansionPanelComponent", function () {
      return IgxExpansionPanelComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxExpansionPanelHeaderComponent", function () {
      return IgxExpansionPanelHeaderComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxExpansionPanelModule", function () {
      return IgxExpansionPanelModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxExporterOptionsBase", function () {
      return IgxExporterOptionsBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxFilterCellTemplateDirective", function () {
      return IgxFilterCellTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxFilterDirective", function () {
      return IgxFilterDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxFilterModule", function () {
      return IgxFilterModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxFilterOptions", function () {
      return IgxFilterOptions;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxFilterPipe", function () {
      return IgxFilterPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxFilteringOperand", function () {
      return IgxFilteringOperand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxFlexDirective", function () {
      return IgxFlexDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxFocusDirective", function () {
      return IgxFocusDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxFocusModule", function () {
      return IgxFocusModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxForOfContext", function () {
      return IgxForOfContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxForOfDirective", function () {
      return IgxForOfDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxForOfModule", function () {
      return IgxForOfModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridAPIService", function () {
      return IgxGridAPIService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridBaseComponent", function () {
      return IgxGridBaseComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridBodyDirective", function () {
      return IgxGridBodyDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridCellComponent", function () {
      return IgxGridCellComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridCommonModule", function () {
      return IgxGridCommonModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridComponent", function () {
      return IgxGridComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridForOfDirective", function () {
      return IgxGridForOfDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridGroupByRowComponent", function () {
      return IgxGridGroupByRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridModule", function () {
      return IgxGridModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridRowComponent", function () {
      return IgxGridRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGridTransaction", function () {
      return IgxGridTransaction;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGroupAreaDropDirective", function () {
      return IgxGroupAreaDropDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGroupByRowTemplateDirective", function () {
      return IgxGroupByRowTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxGrouping", function () {
      return IgxGrouping;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHeaderCollapseIndicatorDirective", function () {
      return IgxHeaderCollapseIndicatorDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHeaderExpandIndicatorDirective", function () {
      return IgxHeaderExpandIndicatorDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHierarchicalGridAPIService", function () {
      return IgxHierarchicalGridAPIService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHierarchicalGridBaseComponent", function () {
      return IgxHierarchicalGridBaseComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHierarchicalGridCellComponent", function () {
      return IgxHierarchicalGridCellComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHierarchicalGridComponent", function () {
      return IgxHierarchicalGridComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHierarchicalGridModule", function () {
      return IgxHierarchicalGridModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHierarchicalRowComponent", function () {
      return IgxHierarchicalRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHierarchicalTransactionService", function () {
      return IgxHierarchicalTransactionService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHierarchicalTransactionServiceFactory", function () {
      return IgxHierarchicalTransactionServiceFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxHintDirective", function () {
      return IgxHintDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxIconComponent", function () {
      return IgxIconComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxIconModule", function () {
      return IgxIconModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxIconService", function () {
      return IgxIconService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxInputDirective", function () {
      return IgxInputDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxInputGroupComponent", function () {
      return IgxInputGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxInputGroupModule", function () {
      return IgxInputGroupModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxInputState", function () {
      return IgxInputState;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxInsertDropStrategy", function () {
      return IgxInsertDropStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxLabelDirective", function () {
      return IgxLabelDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxLayoutDirective", function () {
      return IgxLayoutDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxLayoutModule", function () {
      return IgxLayoutModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxLeftButtonStyleDirective", function () {
      return IgxLeftButtonStyleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxLinearProgressBarComponent", function () {
      return IgxLinearProgressBarComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListActionDirective", function () {
      return IgxListActionDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListBase", function () {
      return IgxListBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListComponent", function () {
      return IgxListComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListItemComponent", function () {
      return IgxListItemComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListItemLeftPanningTemplateDirective", function () {
      return IgxListItemLeftPanningTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListItemRightPanningTemplateDirective", function () {
      return IgxListItemRightPanningTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListLineDirective", function () {
      return IgxListLineDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListLineSubTitleDirective", function () {
      return IgxListLineSubTitleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListLineTitleDirective", function () {
      return IgxListLineTitleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListModule", function () {
      return IgxListModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListPanState", function () {
      return IgxListPanState;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxListThumbnailDirective", function () {
      return IgxListThumbnailDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxMaskDirective", function () {
      return IgxMaskDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxMaskModule", function () {
      return IgxMaskModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxMonthPickerBase", function () {
      return IgxMonthPickerBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxMonthPickerComponent", function () {
      return IgxMonthPickerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxMonthsViewComponent", function () {
      return IgxMonthsViewComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavDrawerItemDirective", function () {
      return IgxNavDrawerItemDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavDrawerMiniTemplateDirective", function () {
      return IgxNavDrawerMiniTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavDrawerTemplateDirective", function () {
      return IgxNavDrawerTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavbarComponent", function () {
      return IgxNavbarComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavbarModule", function () {
      return IgxNavbarModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavigationCloseDirective", function () {
      return IgxNavigationCloseDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavigationDrawerComponent", function () {
      return IgxNavigationDrawerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavigationDrawerModule", function () {
      return IgxNavigationDrawerModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavigationModule", function () {
      return IgxNavigationModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavigationService", function () {
      return IgxNavigationService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNavigationToggleDirective", function () {
      return IgxNavigationToggleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNumberFilteringOperand", function () {
      return IgxNumberFilteringOperand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxNumberSummaryOperand", function () {
      return IgxNumberSummaryOperand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxOverlayOutletDirective", function () {
      return IgxOverlayOutletDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxOverlayService", function () {
      return IgxOverlayService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxPaginatorComponent", function () {
      return IgxPaginatorComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxPaginatorModule", function () {
      return IgxPaginatorModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxPrefixDirective", function () {
      return IgxPrefixDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxPrefixModule", function () {
      return IgxPrefixModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxPrependDropStrategy", function () {
      return IgxPrependDropStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxProgressBarModule", function () {
      return IgxProgressBarModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxProgressType", function () {
      return IgxProgressType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRadioComponent", function () {
      return IgxRadioComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRadioGroupDirective", function () {
      return IgxRadioGroupDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRadioModule", function () {
      return IgxRadioModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxResizeHandleDirective", function () {
      return IgxResizeHandleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRightButtonStyleDirective", function () {
      return IgxRightButtonStyleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRippleDirective", function () {
      return IgxRippleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRippleModule", function () {
      return IgxRippleModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRowCollapsedIndicatorDirective", function () {
      return IgxRowCollapsedIndicatorDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRowComponent", function () {
      return IgxRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRowExpandedIndicatorDirective", function () {
      return IgxRowExpandedIndicatorDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRowIslandAPIService", function () {
      return IgxRowIslandAPIService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxRowIslandComponent", function () {
      return IgxRowIslandComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSelectComponent", function () {
      return IgxSelectComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSelectGroupComponent", function () {
      return IgxSelectGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSelectItemComponent", function () {
      return IgxSelectItemComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSelectModule", function () {
      return IgxSelectModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSelectToggleIconDirective", function () {
      return IgxSelectToggleIconDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSlideComponent", function () {
      return IgxSlideComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSliderComponent", function () {
      return IgxSliderComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSliderModule", function () {
      return IgxSliderModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSnackbarComponent", function () {
      return IgxSnackbarComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSnackbarModule", function () {
      return IgxSnackbarModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSorting", function () {
      return IgxSorting;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxStringFilteringOperand", function () {
      return IgxStringFilteringOperand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSuffixDirective", function () {
      return IgxSuffixDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSuffixModule", function () {
      return IgxSuffixModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSummaryOperand", function () {
      return IgxSummaryOperand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSwitchComponent", function () {
      return IgxSwitchComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSwitchModule", function () {
      return IgxSwitchModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxSwitchRequiredDirective", function () {
      return IgxSwitchRequiredDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTabComponent", function () {
      return IgxTabComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTabItemComponent", function () {
      return IgxTabItemComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTabItemTemplateDirective", function () {
      return IgxTabItemTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTabPanelComponent", function () {
      return IgxTabPanelComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTabTemplateDirective", function () {
      return IgxTabTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTabsComponent", function () {
      return IgxTabsComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTabsGroupComponent", function () {
      return IgxTabsGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTabsModule", function () {
      return IgxTabsModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTextAlign", function () {
      return IgxTextAlign;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTextHighlightDirective", function () {
      return IgxTextHighlightDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTextHighlightModule", function () {
      return IgxTextHighlightModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTextSelectionDirective", function () {
      return IgxTextSelectionDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTextSelectionModule", function () {
      return IgxTextSelectionModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxThumbFromTemplateDirective", function () {
      return IgxThumbFromTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxThumbToTemplateDirective", function () {
      return IgxThumbToTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTimePickerComponent", function () {
      return IgxTimePickerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTimePickerModule", function () {
      return IgxTimePickerModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxToastComponent", function () {
      return IgxToastComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxToastModule", function () {
      return IgxToastModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxToastPosition", function () {
      return IgxToastPosition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxToggleActionDirective", function () {
      return IgxToggleActionDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxToggleDirective", function () {
      return IgxToggleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxToggleModule", function () {
      return IgxToggleModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTooltipDirective", function () {
      return IgxTooltipDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTooltipModule", function () {
      return IgxTooltipModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTooltipTargetDirective", function () {
      return IgxTooltipTargetDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTransactionService", function () {
      return IgxTransactionService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTreeGridAPIService", function () {
      return IgxTreeGridAPIService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTreeGridCellComponent", function () {
      return IgxTreeGridCellComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTreeGridComponent", function () {
      return IgxTreeGridComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTreeGridModule", function () {
      return IgxTreeGridModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxTreeGridRowComponent", function () {
      return IgxTreeGridRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IgxYearsViewComponent", function () {
      return IgxYearsViewComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InteractionMode", function () {
      return InteractionMode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LabelPosition", function () {
      return LabelPosition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NoOpScrollStrategy", function () {
      return NoOpScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PagingError", function () {
      return PagingError;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Point", function () {
      return Point;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PredefinedFormatOptions", function () {
      return PredefinedFormatOptions;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RadioLabelPosition", function () {
      return RadioLabelPosition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RestrictDrag", function () {
      return RestrictDrag;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RowEditPositionStrategy", function () {
      return RowEditPositionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ScrollStrategy", function () {
      return ScrollStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Size", function () {
      return Size;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SliderHandle", function () {
      return SliderHandle;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SliderType", function () {
      return SliderType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SortingDirection", function () {
      return SortingDirection;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SwitchLabelPosition", function () {
      return SwitchLabelPosition;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TabsType", function () {
      return TabsType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TimePickerHammerConfig", function () {
      return TimePickerHammerConfig;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TransactionType", function () {
      return TransactionType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Type", function () {
      return Type;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VerticalAlignment", function () {
      return VerticalAlignment;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WEEKDAYS", function () {
      return WEEKDAYS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "blink", function () {
      return blink;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "changei18n", function () {
      return changei18n;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "convertInPercentage", function () {
      return convertInPercentage;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "fadeIn", function () {
      return fadeIn;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "fadeOut", function () {
      return fadeOut;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "filteringStateDefaults", function () {
      return filteringStateDefaults;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flipBottom", function () {
      return flipBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flipHorBck", function () {
      return flipHorBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flipHorFwd", function () {
      return flipHorFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flipLeft", function () {
      return flipLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flipRight", function () {
      return flipRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flipTop", function () {
      return flipTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flipVerBck", function () {
      return flipVerBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flipVerFwd", function () {
      return flipVerFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getCurrentResourceStrings", function () {
      return getCurrentResourceStrings;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getTypeNameForDebugging", function () {
      return getTypeNameForDebugging;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getValueInProperRange", function () {
      return getValueInProperRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "growVerIn", function () {
      return growVerIn;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "growVerOut", function () {
      return growVerOut;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "heartbeat", function () {
      return heartbeat;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "hierarchicalTransactionServiceFactory", function () {
      return hierarchicalTransactionServiceFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isDateInRanges", function () {
      return isDateInRanges;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isLeap", function () {
      return isLeap;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "monthRange", function () {
      return monthRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pulsateBck", function () {
      return pulsateBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pulsateFwd", function () {
      return pulsateFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "range", function () {
      return range;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInBl", function () {
      return rotateInBl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInBottom", function () {
      return rotateInBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInBr", function () {
      return rotateInBr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInCenter", function () {
      return rotateInCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInDiagonal1", function () {
      return rotateInDiagonal1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInDiagonal2", function () {
      return rotateInDiagonal2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInHor", function () {
      return rotateInHor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInLeft", function () {
      return rotateInLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInRight", function () {
      return rotateInRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInTl", function () {
      return rotateInTl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInTop", function () {
      return rotateInTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInTr", function () {
      return rotateInTr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateInVer", function () {
      return rotateInVer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutBl", function () {
      return rotateOutBl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutBottom", function () {
      return rotateOutBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutBr", function () {
      return rotateOutBr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutCenter", function () {
      return rotateOutCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutDiagonal1", function () {
      return rotateOutDiagonal1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutDiagonal2", function () {
      return rotateOutDiagonal2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutHor", function () {
      return rotateOutHor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutLeft", function () {
      return rotateOutLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutRight", function () {
      return rotateOutRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutTl", function () {
      return rotateOutTl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutTop", function () {
      return rotateOutTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutTr", function () {
      return rotateOutTr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rotateOutVer", function () {
      return rotateOutVer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInBl", function () {
      return scaleInBl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInBottom", function () {
      return scaleInBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInBr", function () {
      return scaleInBr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInCenter", function () {
      return scaleInCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInHorCenter", function () {
      return scaleInHorCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInHorLeft", function () {
      return scaleInHorLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInHorRight", function () {
      return scaleInHorRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInLeft", function () {
      return scaleInLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInRight", function () {
      return scaleInRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInTl", function () {
      return scaleInTl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInTop", function () {
      return scaleInTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInTr", function () {
      return scaleInTr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInVerBottom", function () {
      return scaleInVerBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInVerCenter", function () {
      return scaleInVerCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleInVerTop", function () {
      return scaleInVerTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutBl", function () {
      return scaleOutBl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutBottom", function () {
      return scaleOutBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutBr", function () {
      return scaleOutBr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutCenter", function () {
      return scaleOutCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutHorCenter", function () {
      return scaleOutHorCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutHorLeft", function () {
      return scaleOutHorLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutHorRight", function () {
      return scaleOutHorRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutLeft", function () {
      return scaleOutLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutRight", function () {
      return scaleOutRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutTl", function () {
      return scaleOutTl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutTop", function () {
      return scaleOutTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutTr", function () {
      return scaleOutTr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutVerBottom", function () {
      return scaleOutVerBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutVerCenter", function () {
      return scaleOutVerCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scaleOutVerTop", function () {
      return scaleOutVerTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeBl", function () {
      return shakeBl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeBottom", function () {
      return shakeBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeBr", function () {
      return shakeBr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeCenter", function () {
      return shakeCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeHor", function () {
      return shakeHor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeLeft", function () {
      return shakeLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeRight", function () {
      return shakeRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeTl", function () {
      return shakeTl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeTop", function () {
      return shakeTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeTr", function () {
      return shakeTr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shakeVer", function () {
      return shakeVer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideInBl", function () {
      return slideInBl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideInBottom", function () {
      return slideInBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideInBr", function () {
      return slideInBr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideInLeft", function () {
      return slideInLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideInRight", function () {
      return slideInRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideInTl", function () {
      return slideInTl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideInTop", function () {
      return slideInTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideInTr", function () {
      return slideInTr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideOutBl", function () {
      return slideOutBl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideOutBottom", function () {
      return slideOutBottom;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideOutBr", function () {
      return slideOutBr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideOutLeft", function () {
      return slideOutLeft;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideOutRight", function () {
      return slideOutRight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideOutTl", function () {
      return slideOutTl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideOutTop", function () {
      return slideOutTop;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "slideOutTr", function () {
      return slideOutTr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingInBottomBck", function () {
      return swingInBottomBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingInBottomFwd", function () {
      return swingInBottomFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingInLeftBck", function () {
      return swingInLeftBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingInLeftFwd", function () {
      return swingInLeftFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingInRightBck", function () {
      return swingInRightBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingInRightFwd", function () {
      return swingInRightFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingInTopBck", function () {
      return swingInTopBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingInTopFwd", function () {
      return swingInTopFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingOutBottomBck", function () {
      return swingOutBottomBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingOutBottomFwd", function () {
      return swingOutBottomFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingOutLeftBck", function () {
      return swingOutLeftBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingOutLefttFwd", function () {
      return swingOutLefttFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingOutRightBck", function () {
      return swingOutRightBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingOutRightFwd", function () {
      return swingOutRightFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingOutTopBck", function () {
      return swingOutTopBck;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "swingOutTopFwd", function () {
      return swingOutTopFwd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "weekDay", function () {
      return weekDay;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵa", function () {
      return IGX_DROPDOWN_BASE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵba", function () {
      return IgxExpansionPanelDescriptionDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbb", function () {
      return IgxExpansionPanelIconDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbc", function () {
      return IgxCalendarBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbd", function () {
      return IgxDaysViewNavigationService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbe", function () {
      return IgxDayItemComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbf", function () {
      return IgxMonthViewSlotsCalendar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbg", function () {
      return IgxGetViewDateCalendar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbh", function () {
      return IgxComboAPIService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbi", function () {
      return IGX_COMBO_COMPONENT;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbk", function () {
      return IgxComboDropDownComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbl", function () {
      return IgxComboItemComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbm", function () {
      return IgxComboHeaderDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbn", function () {
      return IgxComboFooterDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbo", function () {
      return IgxComboItemDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbp", function () {
      return IgxComboEmptyDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbq", function () {
      return IgxComboHeaderItemDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbr", function () {
      return IgxComboAddItemDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbs", function () {
      return IgxComboToggleIconDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbt", function () {
      return IgxComboClearIconDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbu", function () {
      return IgxComboFilteringPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbv", function () {
      return IgxComboSortingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbw", function () {
      return IgxComboGroupingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbx", function () {
      return IgxComboFilterConditionPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵby", function () {
      return IgxComboAddItemComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbz", function () {
      return IgxDatePickerTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵc", function () {
      return ColumnChooserBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵca", function () {
      return IgxDatePickerActionsDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcb", function () {
      return IgxCalendarContainerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcc", function () {
      return DatePickerDisplayValuePipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcd", function () {
      return DatePickerInputValuePipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵce", function () {
      return IGX_DATE_PICKER_COMPONENT;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcg", function () {
      return IgxDialogTitleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵch", function () {
      return IgxDialogActionsDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵci", function () {
      return HammerGesturesManager;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcj", function () {
      return IgxGridCRUDService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵck", function () {
      return IgxGridSelectionService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcl", function () {
      return WatchChanges;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcm", function () {
      return WatchColumnChanges;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcn", function () {
      return notifyChanges;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵco", function () {
      return IgxGridColumnResizerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcp", function () {
      return IgxColumnResizingService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcq", function () {
      return IgxExcelStyleSortingTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcr", function () {
      return IgxExcelStyleMovingTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcs", function () {
      return IgxExcelStyleHidingTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵct", function () {
      return IgxExcelStylePinningTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcu", function () {
      return IgxGridExcelStyleFilteringComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcv", function () {
      return IgxExcelStyleLoadingValuesTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcw", function () {
      return IgxExcelStyleSearchComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcx", function () {
      return IgxGridHeaderGroupComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcy", function () {
      return IgxGridHeaderComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcz", function () {
      return IgxFilteringService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵd", function () {
      return IgxColumnHidingItemDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵda", function () {
      return IgxGridFilteringCellComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdb", function () {
      return IgxChipsAreaComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdc", function () {
      return IgxChipComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdd", function () {
      return IgxGridNavigationService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵde", function () {
      return IgxSummaryRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdf", function () {
      return IgxSummaryCellComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdg", function () {
      return IgxGridToolbarComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdh", function () {
      return IgxGridToolbarCustomContentDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdi", function () {
      return IgxRowSelectorDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdj", function () {
      return IgxHeadSelectorDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdk", function () {
      return IgxRowSelectorsModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdl", function () {
      return IgxRowDragDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdm", function () {
      return IgxDragIndicatorIconDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdn", function () {
      return IgxRowDragGhostDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdo", function () {
      return IgxRowDragModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdp", function () {
      return IgxGridFilteringRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdq", function () {
      return IgxTemplateOutletDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdr", function () {
      return IgxTemplateOutletModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵds", function () {
      return IgxRowEditTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdt", function () {
      return IgxRowEditTextDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdu", function () {
      return IgxRowEditActionsDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdv", function () {
      return IgxRowEditTabStopDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdw", function () {
      return IgxGridSummaryService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdx", function () {
      return ConnectedPositioningStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdy", function () {
      return IgxSummaryDataPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdz", function () {
      return IgxGridDragSelectDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵea", function () {
      return IgxGridFooterComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵeb", function () {
      return IgxAdvancedFilteringDialogComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵec", function () {
      return ItemPropertyValueChanged;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵed", function () {
      return ColumnChooserItemBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵee", function () {
      return IgxProcessBarTextTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵef", function () {
      return IgxGridPipesModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵeg", function () {
      return IgxGridCellStyleClassesPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵeh", function () {
      return IgxGridCellStylesPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵei", function () {
      return IgxGridNotGroupedPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵej", function () {
      return IgxGridTopLevelColumns;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵek", function () {
      return IgxGridFilterConditionPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵel", function () {
      return IgxGridTransactionPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵem", function () {
      return IgxGridPaginatorOptionsPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵen", function () {
      return IgxHasVisibleColumnsPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵeo", function () {
      return IgxGridExcelStyleFilteringModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵep", function () {
      return IgxDropDownComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵeq", function () {
      return IgxExcelStyleCustomDialogComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵer", function () {
      return IgxExcelStyleDefaultExpressionComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵes", function () {
      return IgxExcelStyleDateExpressionComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵet", function () {
      return IgxExcelStyleSortingComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵeu", function () {
      return IgxExcelStyleColumnMovingComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵev", function () {
      return IgxExcelStyleSearchFilterPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵew", function () {
      return IgxSelectItemNavigationDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵex", function () {
      return IgxGridSortingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵey", function () {
      return IgxGridGroupingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵez", function () {
      return IgxGridPagingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵf", function () {
      return IGX_EXPANSION_PANEL_COMPONENT;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfa", function () {
      return IgxGridFilteringPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfb", function () {
      return IgxGridSummaryPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfc", function () {
      return IgxTreeGridNavigationService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfd", function () {
      return IgxRowLoadingIndicatorTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfe", function () {
      return IgxTreeGridHierarchizingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵff", function () {
      return IgxTreeGridFlatteningPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfg", function () {
      return IgxTreeGridSortingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfh", function () {
      return IgxTreeGridPagingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfi", function () {
      return IgxTreeGridTransactionPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfj", function () {
      return IgxTreeGridFilteringPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfk", function () {
      return IgxTreeGridSummaryPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfl", function () {
      return IgxHierarchicalGridNavigationService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfm", function () {
      return GridBaseAPIService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfn", function () {
      return IgxChildGridRowComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfo", function () {
      return IgxGridHierarchicalPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfp", function () {
      return IgxGridHierarchicalPagingPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfq", function () {
      return IgxSliderThumbComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfr", function () {
      return IgxThumbLabelComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfs", function () {
      return IgxTabsBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵft", function () {
      return IgxTabItemBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfu", function () {
      return IgxTabsGroupBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfv", function () {
      return IGX_TIME_PICKER_COMPONENT;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfx", function () {
      return IgxItemListDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfy", function () {
      return IgxHourItemDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfz", function () {
      return IgxMinuteItemDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵg", function () {
      return PlatformUtil;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵga", function () {
      return IgxAmPmItemDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgb", function () {
      return IgxTimePickerTemplateDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgc", function () {
      return IgxTimePickerActionsDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgd", function () {
      return TimeDisplayFormatPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵge", function () {
      return TimeInputFormatPipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵh", function () {
      return EaseIn;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵi", function () {
      return EaseOut;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵj", function () {
      return IgxInputGroupBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵk", function () {
      return IgxForOfSyncService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵl", function () {
      return IgxForOfScrollSyncService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵm", function () {
      return DeprecateMethod;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵn", function () {
      return DeprecateProperty;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵo", function () {
      return IgxSelectionAPIService;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵp", function () {
      return IgxDragHandleDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵq", function () {
      return DisplayContainerComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵr", function () {
      return VirtualHelperComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵs", function () {
      return VirtualHelperBaseDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵt", function () {
      return HVirtualHelperComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵu", function () {
      return IgxScrollInertiaDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵv", function () {
      return IgxScrollInertiaModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵw", function () {
      return _isHierarchyMatch;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵx", function () {
      return _getHierarchy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵy", function () {
      return IgxBannerActionsDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵz", function () {
      return IgxExpansionPanelTitleDirective;
    });
    /* harmony import */


    var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/animations */
    "../../node_modules/@angular/animations/fesm2015/animations.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "../../node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/forms */
    "../../node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/common */
    "../../node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! rxjs */
    "../../node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! rxjs/operators */
    "../../node_modules/rxjs/_esm2015/operators/index.js");
    /* harmony import */


    var jszip_dist_jszip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! jszip/dist/jszip */
    "../../node_modules/jszip/dist/jszip.js");
    /* harmony import */


    var jszip_dist_jszip__WEBPACK_IMPORTED_MODULE_6___default =
    /*#__PURE__*/
    __webpack_require__.n(jszip_dist_jszip__WEBPACK_IMPORTED_MODULE_6__);
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! tslib */
    "../../node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! resize-observer-polyfill */
    "../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js");
    /* harmony import */


    var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! @angular/platform-browser */
    "../../node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */


    var EaseIn = {
      quad:
      /** @type {?} */
      "cubic-bezier(0.550, 0.085, 0.680, 0.530)",
      cubic:
      /** @type {?} */
      "cubic-bezier(0.550, 0.055, 0.675, 0.190)",
      quart:
      /** @type {?} */
      "cubic-bezier(0.895, 0.030, 0.685, 0.220)",
      quint:
      /** @type {?} */
      "cubic-bezier(0.755, 0.050, 0.855, 0.060)",
      sine:
      /** @type {?} */
      "cubic-bezier(0.470, 0.000, 0.745, 0.715)",
      expo:
      /** @type {?} */
      "cubic-bezier(0.950, 0.050, 0.795, 0.035)",
      circ:
      /** @type {?} */
      "cubic-bezier(0.600, 0.040, 0.980, 0.335)",
      back:
      /** @type {?} */
      "cubic-bezier(0.600, -0.280, 0.735, 0.045)"
    };
    /** @enum {string} */

    var EaseOut = {
      quad:
      /** @type {?} */
      "cubic-bezier(0.250, 0.460, 0.450, 0.940)",
      cubic:
      /** @type {?} */
      "cubic-bezier(0.215, 0.610, 0.355, 1.000)",
      quart:
      /** @type {?} */
      "cubic-bezier(0.165, 0.840, 0.440, 1.000)",
      quint:
      /** @type {?} */
      "cubic-bezier(0.230, 1.000, 0.320, 1.000)",
      sine:
      /** @type {?} */
      "cubic-bezier(0.390, 0.575, 0.565, 1.000)",
      expo:
      /** @type {?} */
      "cubic-bezier(0.190, 1.000, 0.220, 1.000)",
      circ:
      /** @type {?} */
      "cubic-bezier(0.075, 0.820, 0.165, 1.000)",
      back:
      /** @type {?} */
      "cubic-bezier(0.175, 0.885, 0.320, 1.275)"
    };
    /** @enum {string} */

    var EaseInOut = {
      quad:
      /** @type {?} */
      "cubic-bezier(0.455, 0.030, 0.515, 0.955)",
      cubic:
      /** @type {?} */
      "cubic-bezier(0.645, 0.045, 0.355, 1.000)",
      quart:
      /** @type {?} */
      "cubic-bezier(0.770, 0.000, 0.175, 1.000)",
      quint:
      /** @type {?} */
      "cubic-bezier(0.860, 0.000, 0.070, 1.000)",
      sine:
      /** @type {?} */
      "cubic-bezier(0.445, 0.050, 0.550, 0.950)",
      expo:
      /** @type {?} */
      "cubic-bezier(1.000, 0.000, 0.000, 1.000)",
      circ:
      /** @type {?} */
      "cubic-bezier(0.785, 0.135, 0.150, 0.860)",
      back:
      /** @type {?} */
      "cubic-bezier(0.680, -0.550, 0.265, 1.550)"
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var base = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{startOpacity}}"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{endOpacity}}"
    }))];
    /** @type {?} */

    var baseParams = {
      delay: '0s',
      duration: '350ms',
      easing: EaseOut.sine,
      endOpacity: 1,
      startOpacity: 0
    };
    /** @type {?} */

    var fadeIn = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base, {
      params: baseParams
    });
    /** @type {?} */

    var fadeOut = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base, {
      params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.sine,
        endOpacity: 0,
        startOpacity: 1
      }
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var baseRecipe = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      backfaceVisibility: 'hidden',
      transformStyle: 'preserve-3d'
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0,
      transform: "translateZ({{startDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{startAngle}}deg)"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 1,
      transform: "translateZ({{endDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{endAngle}}deg)"
    })]))];
    /** @type {?} */

    var baseParams$1 = {
      delay: '0s',
      duration: '600ms',
      easing: EaseOut.quad,
      endAngle: 180,
      endDistance: '0px',
      rotateX: 1,
      rotateY: 0,
      rotateZ: 0,
      startAngle: 0,
      startDistance: '0px'
    };
    /** @type {?} */

    var flipTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
      params: Object.assign({}, baseParams$1)
    });
    /** @type {?} */

    var flipBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
      params: Object.assign({}, baseParams$1, {
        endAngle: -180
      })
    });
    /** @type {?} */

    var flipLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
      params: Object.assign({}, baseParams$1, {
        rotateX: 0,
        rotateY: 1
      })
    });
    /** @type {?} */

    var flipRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
      params: Object.assign({}, baseParams$1, {
        endAngle: -180,
        rotateX: 0,
        rotateY: 1
      })
    });
    /** @type {?} */

    var flipHorFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
      params: Object.assign({}, baseParams$1, {
        endDistance: '170px'
      })
    });
    /** @type {?} */

    var flipHorBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
      params: Object.assign({}, baseParams$1, {
        endDistance: '-170px'
      })
    });
    /** @type {?} */

    var flipVerFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
      params: Object.assign({}, baseParams$1, {
        endDistance: '170px',
        rotateX: 0,
        rotateY: 1
      })
    });
    /** @type {?} */

    var flipVerBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe, {
      params: Object.assign({}, baseParams$1, {
        endDistance: '-170px',
        rotateX: 0,
        rotateY: 1
      })
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var baseRecipe$1 = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{startOpacity}}",
      transform: "rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{startAngle}}deg)",
      transformOrigin: "{{xPos}} {{yPos}}"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0,
      opacity: "{{endOpacity}}",
      transform: "rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{endAngle}}deg)",
      transformOrigin: "{{xPos}} {{yPos}}"
    }))];
    /** @type {?} */

    var baseInParams = {
      delay: '0s',
      duration: '600ms',
      easing: EaseOut.quad,
      endAngle: 0,
      endOpacity: 1,
      rotateX: 0,
      rotateY: 0,
      rotateZ: 1,
      startAngle: -360,
      startOpacity: 0,
      xPos: 'center',
      yPos: 'center'
    };
    /** @type {?} */

    var baseOutParams = Object.assign({}, baseInParams, {
      easing: EaseIn.quad,
      endOpacity: 0,
      startOpacity: 1
    });
    /** @type {?} */

    var rotateInCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams)
    });
    /** @type {?} */

    var rotateOutCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams)
    });
    /** @type {?} */

    var rotateInTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        xPos: 'top'
      })
    });
    /** @type {?} */

    var rotateOutTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        xPos: 'top'
      })
    });
    /** @type {?} */

    var rotateInRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        xPos: 'right'
      })
    });
    /** @type {?} */

    var rotateOutRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        xPos: 'right'
      })
    });
    /** @type {?} */

    var rotateInBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        xPos: 'bottom'
      })
    });
    /** @type {?} */

    var rotateOutBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        xPos: 'bottom'
      })
    });
    /** @type {?} */

    var rotateInLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        xPos: 'left'
      })
    });
    /** @type {?} */

    var rotateOutLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        xPos: 'left'
      })
    });
    /** @type {?} */

    var rotateInTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        xPos: 'right',
        yPos: 'top'
      })
    });
    /** @type {?} */

    var rotateOutTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        xPos: 'right',
        yPos: 'top'
      })
    });
    /** @type {?} */

    var rotateInBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        xPos: 'right',
        yPos: 'bottom'
      })
    });
    /** @type {?} */

    var rotateOutBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        xPos: 'right',
        yPos: 'bottom'
      })
    });
    /** @type {?} */

    var rotateInBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        xPos: 'left',
        yPos: 'bottom'
      })
    });
    /** @type {?} */

    var rotateOutBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        xPos: 'left',
        yPos: 'bottom'
      })
    });
    /** @type {?} */

    var rotateInTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        xPos: 'left',
        yPos: 'top'
      })
    });
    /** @type {?} */

    var rotateOutTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        xPos: 'left',
        yPos: 'top'
      })
    });
    /** @type {?} */

    var rotateInDiagonal1 = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        rotateX: 1,
        rotateY: 1,
        rotateZ: 0
      })
    });
    /** @type {?} */

    var rotateOutDiagonal1 = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        rotateX: 1,
        rotateY: 1,
        rotateZ: 0
      })
    });
    /** @type {?} */

    var rotateInDiagonal2 = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        rotateX: -1,
        rotateY: 1,
        rotateZ: 0
      })
    });
    /** @type {?} */

    var rotateOutDiagonal2 = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        rotateX: -1,
        rotateY: 1,
        rotateZ: 0
      })
    });
    /** @type {?} */

    var rotateInHor = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        rotateX: 0,
        rotateY: 1,
        rotateZ: 0
      })
    });
    /** @type {?} */

    var rotateOutHor = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        rotateX: 0,
        rotateY: 1,
        rotateZ: 0
      })
    });
    /** @type {?} */

    var rotateInVer = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseInParams, {
        rotateX: 1,
        rotateY: 0,
        rotateZ: 0
      })
    });
    /** @type {?} */

    var rotateOutVer = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$1, {
      params: Object.assign({}, baseOutParams, {
        rotateX: 1,
        rotateY: 0,
        rotateZ: 0
      })
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var baseRecipe$2 = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0,
      transform: "rotate(0deg) translate{{direction}}(0)",
      transformOrigin: "{{xPos}} {{yPos}}"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.1,
      transform: "rotate({{endAngle}}deg) translate{{direction}}(-{{startDistance}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.2,
      transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.3,
      transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.4,
      transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.5,
      transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.6,
      transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.7,
      transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.8,
      transform: "rotate(-{{endAngle}}deg) translate{{direction}}({{endDistance}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.9,
      transform: "rotate({{endAngle}}deg) translate{{direction}}(-{{endDistance}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 1,
      transform: "rotate(0deg) translate{{direction}}(0)",
      transformOrigin: "{{xPos}} {{yPos}}"
    })]))];
    /** @type {?} */

    var baseParams$2 = {
      delay: '0s',
      direction: 'X',
      duration: '800ms',
      easing: EaseInOut.quad,
      endAngle: 0,
      endDistance: '8px',
      startAngle: 0,
      startDistance: '10px',
      xPos: 'center',
      yPos: 'center'
    };
    /** @type {?} */

    var shakeHor = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'X'
      })
    });
    /** @type {?} */

    var shakeVer = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'Y'
      })
    });
    /** @type {?} */

    var shakeTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        endAngle: 2,
        endDistance: '0',
        startAngle: 4,
        startDistance: '0',
        yPos: 'top'
      })
    });
    /** @type {?} */

    var shakeBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'Y',
        endAngle: 2,
        endDistance: '0',
        startAngle: 4,
        startDistance: '0',
        yPos: 'bottom'
      })
    });
    /** @type {?} */

    var shakeRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'Y',
        endAngle: 2,
        endDistance: '0',
        startAngle: 4,
        startDistance: '0',
        xPos: 'right',
        yPos: 'center'
      })
    });
    /** @type {?} */

    var shakeLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'Y',
        endAngle: 2,
        endDistance: '0',
        startAngle: 4,
        startDistance: '0',
        xPos: 'left',
        yPos: 'center'
      })
    });
    /** @type {?} */

    var shakeCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'Y',
        endAngle: 8,
        endDistance: '0',
        startAngle: 10,
        startDistance: '0',
        xPos: 'center',
        yPos: 'center'
      })
    });
    /** @type {?} */

    var shakeTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'Y',
        endAngle: 2,
        endDistance: '0',
        startAngle: 4,
        startDistance: '0',
        xPos: 'right',
        yPos: 'top'
      })
    });
    /** @type {?} */

    var shakeBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'Y',
        endAngle: 2,
        endDistance: '0',
        startAngle: 4,
        startDistance: '0',
        xPos: 'right',
        yPos: 'bottom'
      })
    });
    /** @type {?} */

    var shakeBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'Y',
        endAngle: 2,
        endDistance: '0',
        startAngle: 4,
        startDistance: '0',
        xPos: 'left',
        yPos: 'bottom'
      })
    });
    /** @type {?} */

    var shakeTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(baseRecipe$2, {
      params: Object.assign({}, baseParams$2, {
        direction: 'Y',
        endAngle: 2,
        endDistance: '0',
        startAngle: 4,
        startDistance: '0',
        xPos: 'left',
        yPos: 'top'
      })
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var heartbeatBase = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      animationTimingFunction: "ease-out",
      transform: "scale(1)",
      transformOrigin: "center center"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      animationTimingFunction: "ease-in",
      offset: 0.1,
      transform: "scale(0.91)"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      animationTimingFunction: "ease-out",
      offset: 0.17,
      transform: "scale(0.98)"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      animationTimingFunction: "ease-in",
      offset: 0.33,
      transform: "scale(0.87)"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      animationTimingFunction: "ease-out",
      offset: 0.45,
      transform: "scale(1)"
    })]))];
    /** @type {?} */

    var heartbeatParams = {
      delay: '0s',
      duration: '1.5s',
      easing: 'ease-in-out'
    };
    /** @type {?} */

    var pulsateBase = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0,
      transform: "scale({{fromScale}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.5,
      transform: "scale({{toScale}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 1,
      transform: "scale({{fromScale}})"
    })]))];
    /** @type {?} */

    var pulsateParams = {
      delay: '0s',
      duration: '.5s',
      easing: 'ease-in-out',
      fromScale: 1,
      toScale: 1.1
    };
    /** @type {?} */

    var blinkBase = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["keyframes"])([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0,
      opacity: .8,
      transform: "scale({{fromScale}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 0.8,
      opacity: 0,
      transform: "scale({{midScale}})"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      offset: 1,
      opacity: 0,
      transform: "scale({{toScale}})"
    })]))];
    /** @type {?} */

    var blinkParams = {
      delay: '0s',
      duration: '.8s',
      easing: 'ease-in-out',
      fromScale: .2,
      midScale: 1.2,
      toScale: 2.2
    };
    /** @type {?} */

    var pulsateFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(pulsateBase, {
      params: Object.assign({}, pulsateParams)
    });
    /** @type {?} */

    var pulsateBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(pulsateBase, {
      params: Object.assign({}, pulsateParams, {
        toScale: .9
      })
    });
    /** @type {?} */

    var heartbeat = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(heartbeatBase, {
      params: Object.assign({}, heartbeatParams)
    });
    /** @type {?} */

    var blink = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(blinkBase, {
      params: Object.assign({}, blinkParams)
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var base$1 = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{startOpacity}}",
      transform: "scale{{direction}}({{fromScale}})",
      transformOrigin: "{{xPos}} {{yPos}}"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{endOpacity}}",
      transform: "scale{{direction}}({{toScale}})",
      transformOrigin: "{{xPos}} {{yPos}}"
    }))];
    /** @type {?} */

    var baseInParams$1 = {
      delay: '0s',
      direction: '',
      duration: '350ms',
      easing: EaseOut.quad,
      endOpacity: 1,
      fromScale: .5,
      startOpacity: 0,
      toScale: 1,
      xPos: '50%',
      yPos: '50%'
    };
    /** @type {?} */

    var baseOutParams$1 = Object.assign({}, baseInParams$1, {
      easing: EaseOut.sine,
      endOpacity: 0,
      fromScale: 1,
      startOpacity: 1,
      toScale: .5
    });
    /** @type {?} */

    var scaleInCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: baseInParams$1
    });
    /** @type {?} */

    var scaleInBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        xPos: '0',
        yPos: '100%'
      })
    });
    /** @type {?} */

    var scaleInVerCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        direction: 'Y',
        fromScale: .4
      })
    });
    /** @type {?} */

    var scaleInTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        xPos: '50%',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleInLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        xPos: '0',
        yPos: '50%'
      })
    });
    /** @type {?} */

    var scaleInVerTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        direction: 'Y',
        fromScale: .4,
        xPos: '100%',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleInTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        xPos: '100%',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleInTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        xPos: '0',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleInVerBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        direction: 'Y',
        fromScale: .4,
        xPos: '0',
        yPos: '100%'
      })
    });
    /** @type {?} */

    var scaleInRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        xPos: '100%',
        yPos: '50%'
      })
    });
    /** @type {?} */

    var scaleInHorCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        direction: 'X',
        fromScale: .4
      })
    });
    /** @type {?} */

    var scaleInBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        xPos: '100%',
        yPos: '100%'
      })
    });
    /** @type {?} */

    var scaleInHorLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        direction: 'X',
        fromScale: .4,
        xPos: '0',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleInBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        xPos: '50%',
        yPos: '100%'
      })
    });
    /** @type {?} */

    var scaleInHorRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseInParams$1, {
        direction: 'X',
        fromScale: .4,
        xPos: '100%',
        yPos: '100%'
      })
    });
    /** @type {?} */

    var scaleOutCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: baseOutParams$1
    });
    /** @type {?} */

    var scaleOutBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        xPos: '0',
        yPos: '100%'
      })
    });
    /** @type {?} */

    var scaleOutBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        xPos: '100%',
        yPos: '100%'
      })
    });
    /** @type {?} */

    var scaleOutVerCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        direction: 'Y',
        toScale: .3
      })
    });
    /** @type {?} */

    var scaleOutVerTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        direction: 'Y',
        toScale: .3,
        xPos: '100%',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleOutVerBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        direction: 'Y',
        toScale: .3,
        xPos: '0',
        yPos: '100%'
      })
    });
    /** @type {?} */

    var scaleOutTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        xPos: '50%',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleOutLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        xPos: '0',
        yPos: '50%'
      })
    });
    /** @type {?} */

    var scaleOutTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        xPos: '100%',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleOutTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        xPos: '0',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleOutRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        xPos: '100%',
        yPos: '50%'
      })
    });
    /** @type {?} */

    var scaleOutBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        xPos: '50%',
        yPos: '100%'
      })
    });
    /** @type {?} */

    var scaleOutHorCenter = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        direction: 'X',
        toScale: .3
      })
    });
    /** @type {?} */

    var scaleOutHorLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        direction: 'X',
        toScale: .3,
        xPos: '0',
        yPos: '0'
      })
    });
    /** @type {?} */

    var scaleOutHorRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$1, {
      params: Object.assign({}, baseOutParams$1, {
        direction: 'X',
        toScale: .3,
        xPos: '100%',
        yPos: '100%'
      })
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var base$2 = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{startOpacity}}",
      transform: "{{fromPosition}}"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{endOpacity}}",
      transform: "{{toPosition}}"
    }))];
    /** @type {?} */

    var baseInParams$2 = {
      delay: '0s',
      duration: '350ms',
      easing: EaseOut.quad,
      endOpacity: 1,
      fromPosition: 'translateY(-500px)',
      startOpacity: 0,
      toPosition: 'translateY(0)'
    };
    /** @type {?} */

    var baseOutParams$2 = {
      delay: '0s',
      duration: '350ms',
      easing: EaseIn.quad,
      endOpacity: 0,
      fromPosition: 'translateY(0)',
      startOpacity: 1,
      toPosition: 'translateY(-500px)'
    };
    /** @type {?} */

    var slideInTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: baseInParams$2
    });
    /** @type {?} */

    var slideInLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(-500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
      }
    });
    /** @type {?} */

    var slideInRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
      }
    });
    /** @type {?} */

    var slideInBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateY(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
      }
    });
    /** @type {?} */

    var slideInTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseInParams$2, {
        fromPosition: 'translateY(-500px) translateX(500px)',
        toPosition: 'translateY(0) translateX(0)'
      })
    });
    /** @type {?} */

    var slideInTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseInParams$2, {
        fromPosition: 'translateY(-500px) translateX(-500px)',
        toPosition: 'translateY(0) translateX(0)'
      })
    });
    /** @type {?} */

    var slideInBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseInParams$2, {
        fromPosition: 'translateY(500px) translateX(500px)',
        toPosition: 'translateY(0) translateX(0)'
      })
    });
    /** @type {?} */

    var slideInBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseInParams$2, {
        fromPosition: 'translateY(500px) translateX(-500px)',
        toPosition: 'translateY(0) translateX(0)'
      })
    });
    /** @type {?} */

    var slideOutTop = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: baseOutParams$2
    });
    /** @type {?} */

    var slideOutRight = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseOutParams$2, {
        toPosition: 'translateX(500px)'
      })
    });
    /** @type {?} */

    var slideOutBottom = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseIn.quad,
        endOpacity: 0,
        fromPosition: 'translateY(0)',
        startOpacity: 1,
        toPosition: 'translateY(500px)'
      }
    });
    /** @type {?} */

    var slideOutLeft = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseOutParams$2, {
        toPosition: 'translateX(-500px)'
      })
    });
    /** @type {?} */

    var slideOutTr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseOutParams$2, {
        fromPosition: 'translateY(0) translateX(0)',
        toPosition: 'translateY(-500px) translateX(500px)'
      })
    });
    /** @type {?} */

    var slideOutBr = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseOutParams$2, {
        fromPosition: 'translateY(0) translateX(0)',
        toPosition: 'translateY(500px) translateX(500px)'
      })
    });
    /** @type {?} */

    var slideOutBl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseOutParams$2, {
        fromPosition: 'translateY(0) translateX(0)',
        toPosition: 'translateY(500px) translateX(-500px)'
      })
    });
    /** @type {?} */

    var slideOutTl = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$2, {
      params: Object.assign({}, baseOutParams$2, {
        fromPosition: 'translateY(0) translateX(0)',
        toPosition: 'translateY(-500px) translateX(-500px)'
      })
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var swingBase = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{startOpacity}}",
      transform: "rotate{{direction}}({{startAngle}}deg)",
      transformOrigin: "{{xPos}} {{yPos}}"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{endOpacity}}",
      transform: "rotate{{direction}}({{endAngle}}deg)",
      transformOrigin: "{{xPos}} {{yPos}}"
    }))];
    /** @type {?} */

    var swingParams = {
      delay: '0s',
      direction: 'X',
      duration: '.5s',
      easing: EaseOut.back,
      endAngle: 0,
      endOpacity: 1,
      startAngle: -100,
      startOpacity: 0,
      xPos: 'top',
      yPos: 'center'
    };
    /** @type {?} */

    var swingOutParams = Object.assign({}, swingParams, {
      duration: '.55s',
      easing: EaseIn.back,
      endAngle: 70,
      endOpacity: 0,
      startAngle: 0,
      startOpacity: 1
    });
    /** @type {?} */

    var swingInTopFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingParams)
    });
    /** @type {?} */

    var swingInRightFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingParams, {
        direction: 'Y',
        xPos: 'center',
        yPos: 'right'
      })
    });
    /** @type {?} */

    var swingInBottomFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingParams, {
        startAngle: 100,
        xPos: 'bottom'
      })
    });
    /** @type {?} */

    var swingInLeftFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingParams, {
        direction: 'Y',
        startAngle: 100,
        xPos: 'center',
        yPos: 'left'
      })
    });
    /** @type {?} */

    var swingInTopBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingParams, {
        duration: '.6s',
        startAngle: 70
      })
    });
    /** @type {?} */

    var swingInRightBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingParams, {
        direction: 'Y',
        duration: '.6s',
        startAngle: 70,
        xPos: 'center',
        yPos: 'right'
      })
    });
    /** @type {?} */

    var swingInBottomBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingParams, {
        duration: '.6s',
        startAngle: -70,
        xPos: 'bottom'
      })
    });
    /** @type {?} */

    var swingInLeftBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingParams, {
        direction: 'Y',
        duration: '.6s',
        startAngle: -70,
        xPos: 'center',
        yPos: 'left'
      })
    });
    /** @type {?} */

    var swingOutTopFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingOutParams)
    });
    /** @type {?} */

    var swingOutRightFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingOutParams, {
        direction: 'Y',
        xPos: 'center',
        yPos: 'right'
      })
    });
    /** @type {?} */

    var swingOutBottomFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingOutParams, {
        endAngle: -70,
        xPos: 'bottom'
      })
    });
    /** @type {?} */

    var swingOutLefttFwd = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingOutParams, {
        direction: 'Y',
        endAngle: -70,
        xPos: 'center',
        yPos: 'left'
      })
    });
    /** @type {?} */

    var swingOutTopBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingOutParams, {
        duration: '.45s',
        endAngle: -100
      })
    });
    /** @type {?} */

    var swingOutRightBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingOutParams, {
        direction: 'Y',
        duration: '.45s',
        endAngle: -100,
        xPos: 'center',
        yPos: 'right'
      })
    });
    /** @type {?} */

    var swingOutBottomBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingOutParams, {
        duration: '.45s',
        endAngle: 100,
        xPos: 'bottom'
      })
    });
    /** @type {?} */

    var swingOutLeftBck = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(swingBase, {
      params: Object.assign({}, swingOutParams, {
        direction: 'Y',
        duration: '.45s',
        endAngle: 100,
        xPos: 'center',
        yPos: 'left'
      })
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var base$3 = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{ startOpacity }}",
      height: "{{ startHeight }}"
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])("{{duration}} {{delay}} {{easing}}", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      opacity: "{{ endOpacity }}",
      height: "{{ endHeight }}"
    }))];
    /** @type {?} */

    var baseParams$3 = {
      delay: '0s',
      duration: '350ms',
      easing: EaseIn.quad,
      startOpacity: 0,
      endOpacity: 1,
      startHeight: '',
      endHeight: ''
    };
    /** @type {?} */

    var growVerIn = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$3, {
      params: Object.assign({}, baseParams$3, {
        easing: EaseOut.quad,
        startOpacity: 0,
        endOpacity: 1,
        startHeight: '0px',
        endHeight: '*'
      })
    });
    /** @type {?} */

    var growVerOut = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animation"])(base$3, {
      params: Object.assign({}, baseParams$3, {
        easing: EaseOut.quad,
        startOpacity: 1,
        endOpacity: 0,
        startHeight: '*',
        endHeight: '0px'
      })
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Common service to be injected between components where those implementing common
     * ToggleView interface can register and toggle directives can call their methods.
     * TODO: Track currently active? Events?
     */

    var IgxNavigationService =
    /*#__PURE__*/
    function () {
      function IgxNavigationService() {
        _classCallCheck(this, IgxNavigationService);

        this.navs = {};
      }
      /**
       * @param {?} id
       * @param {?} navItem
       * @return {?}
       */


      _createClass(IgxNavigationService, [{
        key: "add",
        value: function add(id, navItem) {
          this.navs[id] = navItem;
        }
        /**
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "remove",
        value: function remove(id) {
          delete this.navs[id];
        }
        /**
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "get",
        value: function get(id) {
          if (id) {
            return this.navs[id];
          }
        }
        /**
         * @param {?} id
         * @param {...?} args
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle(id) {
          if (this.navs[id]) {
            var _this$navs$id;

            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }

            return (_this$navs$id = this.navs[id]).toggle.apply(_this$navs$id, args);
          }
        }
        /**
         * @param {?} id
         * @param {...?} args
         * @return {?}
         */

      }, {
        key: "open",
        value: function open(id) {
          if (this.navs[id]) {
            var _this$navs$id2;

            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }

            return (_this$navs$id2 = this.navs[id]).open.apply(_this$navs$id2, args);
          }
        }
        /**
         * @param {?} id
         * @param {...?} args
         * @return {?}
         */

      }, {
        key: "close",
        value: function close(id) {
          if (this.navs[id]) {
            var _this$navs$id3;

            for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }

            return (_this$navs$id3 = this.navs[id]).close.apply(_this$navs$id3, args);
          }
        }
      }]);

      return IgxNavigationService;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Directive that can toggle targets through provided NavigationService.
     *
     * Usage:
     * ```
     * <button igxNavToggle="ID"> Toggle </button>
     * ```
     * Where the `ID` matches the ID of compatible `IToggleView` component.
     */


    var IgxNavigationToggleDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} nav
       */
      function IgxNavigationToggleDirective(nav) {
        _classCallCheck(this, IgxNavigationToggleDirective);

        this.state = nav;
      }
      /**
       * @return {?}
       */


      _createClass(IgxNavigationToggleDirective, [{
        key: "toggleNavigationDrawer",
        value: function toggleNavigationDrawer() {
          this.state.toggle(this.target, true);
        }
      }]);

      return IgxNavigationToggleDirective;
    }();

    IgxNavigationToggleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxNavToggle]'
      }]
    }];
    /** @nocollapse */

    IgxNavigationToggleDirective.ctorParameters = function () {
      return [{
        type: IgxNavigationService
      }];
    };

    IgxNavigationToggleDirective.propDecorators = {
      target: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxNavToggle']
      }],
      toggleNavigationDrawer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click']
      }]
    };
    /**
     * Directive that can close targets through provided NavigationService.
     *
     * Usage:
     * ```
     * <button igxNavClose="ID"> Close </button>
     * ```
     * Where the `ID` matches the ID of compatible `IToggleView` component.
     */

    var IgxNavigationCloseDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} nav
       */
      function IgxNavigationCloseDirective(nav) {
        _classCallCheck(this, IgxNavigationCloseDirective);

        this.state = nav;
      }
      /**
       * @return {?}
       */


      _createClass(IgxNavigationCloseDirective, [{
        key: "closeNavigationDrawer",
        value: function closeNavigationDrawer() {
          this.state.close(this.target, true);
        }
      }]);

      return IgxNavigationCloseDirective;
    }();

    IgxNavigationCloseDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxNavClose]'
      }]
    }];
    /** @nocollapse */

    IgxNavigationCloseDirective.ctorParameters = function () {
      return [{
        type: IgxNavigationService
      }];
    };

    IgxNavigationCloseDirective.propDecorators = {
      target: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxNavClose']
      }],
      closeNavigationDrawer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click']
      }]
    };
    /**
     * @hidden
     */

    var IgxNavigationModule = function IgxNavigationModule() {
      _classCallCheck(this, IgxNavigationModule);
    };

    IgxNavigationModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
        exports: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
        providers: [IgxNavigationService]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @param {?} array
     * @param {?=} deep
     * @return {?}
     */

    function cloneArray(array, deep) {
      /** @type {?} */
      var arr = [];

      if (!array) {
        return arr;
      }
      /** @type {?} */


      var i = array.length;

      while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
      }

      return arr;
    }
    /**
     * Doesn't clone leaf items
     * @hidden
     * @param {?} array
     * @param {?} childDataKey
     * @return {?}
     */


    function cloneHierarchicalArray(array, childDataKey) {
      /** @type {?} */
      var result = [];

      if (!array) {
        return result;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;

          /** @type {?} */
          var clonedItem = cloneValue(item);

          if (Array.isArray(item[childDataKey])) {
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
          }

          result.push(clonedItem);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return result;
    }
    /**
     * Deep clones all first level keys of Obj2 and merges them to Obj1
     * @hidden
     * @param {?} obj1 Object to merge into
     * @param {?} obj2 Object to merge from
     * @return {?} Obj1 with merged cloned keys from Obj2
     */


    function mergeObjects(obj1, obj2) {
      if (!isObject(obj1)) {
        throw new Error("Cannot merge into ".concat(obj1, ". First param must be an object."));
      }

      if (!isObject(obj2)) {
        return obj1;
      }

      for (var _i2 = 0, _Object$keys = Object.keys(obj2); _i2 < _Object$keys.length; _i2++) {
        var key = _Object$keys[_i2];
        obj1[key] = cloneValue(obj2[key]);
      }

      return obj1;
    }
    /**
     * Creates deep clone of provided value.
     * Supports primitive values, dates and objects.
     * If passed value is array returns shallow copy of the array.
     * @hidden
     * @param {?} value value to clone
     * @return {?} Deep copy of provided value
     */


    function cloneValue(value) {
      if (isDate(value)) {
        return new Date(value.getTime());
      }

      if (Array.isArray(value)) {
        return _toConsumableArray(value);
      }

      if (value instanceof Map || value instanceof Set) {
        return value;
      }

      if (isObject(value)) {
        /** @type {?} */
        var result = {};

        for (var _i3 = 0, _Object$keys2 = Object.keys(value); _i3 < _Object$keys2.length; _i3++) {
          var key = _Object$keys2[_i3];
          result[key] = cloneValue(value[key]);
        }

        return result;
      }

      return value;
    }
    /**
     * Checks if provided variable is Object
     * @hidden
     * @param {?} value Value to check
     * @return {?} true if provided variable is Object
     */


    function isObject(value) {
      return value && value.toString() === '[object Object]';
    }
    /**
     * Checks if provided variable is Date
     * @hidden
     * @param {?} value Value to check
     * @return {?} true if provided variable is Date
     */


    function isDate(value) {
      return Object.prototype.toString.call(value) === '[object Date]';
    }
    /**
     * Checks if the two passed arguments are equal
     * Currently supports date objects
     * \@returns: `boolean`
     * @hidden
     * @param {?} obj1
     * @param {?} obj2
     * @return {?}
     */


    function isEqual(obj1, obj2) {
      if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
      }

      return obj1 === obj2;
    }
    /**
     * @hidden
     * Returns the actual size of the node content, using Range
     * ```typescript
     * let range = document.createRange();
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     *
     * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
     * ```
     * @param {?} range
     * @param {?} node
     * @return {?}
     */


    function getNodeSizeViaRange(range, node) {
      /** @type {?} */
      var overflow = null;

      if (!isFirefox()) {
        overflow = node.style.overflow; // we need that hack - otherwise content won't be measured correctly in IE/Edge

        node.style.overflow = 'visible';
      }

      range.selectNodeContents(node);
      /** @type {?} */

      var width = range.getBoundingClientRect().width;

      if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
      }

      return width;
    }
    /**
     * @hidden
     * @return {?}
     */


    function isIE() {
      return navigator.appVersion.indexOf('Trident/') > 0;
    }
    /**
     * @hidden
     * @return {?}
     */


    function isEdge() {
      /** @type {?} */
      var edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
      return edgeBrowser;
    }
    /**
     * @hidden
     * @return {?}
     */


    function isFirefox() {
      /** @type {?} */
      var firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
      return firefoxBrowser;
    }
    /**
     * @hidden
     */


    var PlatformUtil =
    /**
     * @param {?} platformId
     */
    function PlatformUtil(platformId) {
      _classCallCheck(this, PlatformUtil);

      this.platformId = platformId;
      this.isBrowser = Object(_angular_common__WEBPACK_IMPORTED_MODULE_3__["isPlatformBrowser"])(this.platformId);
      this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    };

    PlatformUtil.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    PlatformUtil.ctorParameters = function () {
      return [{
        type: Object,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["PLATFORM_ID"]]
        }]
      }];
    };
    /** @nocollapse */


    PlatformUtil.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function PlatformUtil_Factory() {
        return new PlatformUtil(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["PLATFORM_ID"]));
      },
      token: PlatformUtil,
      providedIn: "root"
    });
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */

    function isLeftClick(event) {
      return event.button === 0;
    }
    /**
     * @hidden
     * @param {?} key
     * @return {?}
     */


    function isNavigationKey(key) {
      return ['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright', 'home', 'end', 'space', 'spacebar', ' '].indexOf(key) !== -1;
    }
    /**
     * @hidden
     * @param {?} arr
     * @return {?}
     */


    function flatten(arr) {
      /** @type {?} */
      var result = [];
      arr.forEach(function (el) {
        result.push(el);

        if (el.children) {
          /** @type {?} */
          var children = Array.isArray(el.children) ? el.children : el.children.toArray();
          result = result.concat(flatten(children));
        }
      });
      return result;
    }
    /** @type {?} */


    var NAVIGATION_KEYS = new Set(['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright', 'home', 'end', 'space', 'spacebar', ' ']);
    /** @type {?} */

    var ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
    /** @type {?} */

    var ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
    /** @type {?} */

    var SUPPORTED_KEYS = new Set([].concat(_toConsumableArray(Array.from(NAVIGATION_KEYS)), ['tab', 'enter', 'f2', 'escape', 'esc']));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var SortingDirection = {
      None: 0,
      Asc: 1,
      Desc: 2
    };
    SortingDirection[SortingDirection.None] = 'None';
    SortingDirection[SortingDirection.Asc] = 'Asc';
    SortingDirection[SortingDirection.Desc] = 'Desc';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} h1
     * @param {?} h2
     * @return {?}
     */

    function _isHierarchyMatch(h1, h2) {
      if (h1.length !== h2.length) {
        return false;
      }

      return h1.every(function (level, index) {
        return level.fieldName === h2[index].fieldName && level.value === h2[index].value;
      });
    }
    /**
     * @param {?} gRow
     * @return {?}
     */


    function _getHierarchy(gRow) {
      /** @type {?} */
      var hierarchy = [];

      if (gRow !== undefined && gRow.expression) {
        hierarchy.push({
          fieldName: gRow.expression.fieldName,
          value: gRow.value
        });

        while (gRow.groupParent) {
          gRow = gRow.groupParent;
          hierarchy.unshift({
            fieldName: gRow.expression.fieldName,
            value: gRow.value
          });
        }
      }

      return hierarchy;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var DefaultSortingStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @protected
       */
      function DefaultSortingStrategy() {
        _classCallCheck(this, DefaultSortingStrategy);
      }
      /**
       * @return {?}
       */


      _createClass(DefaultSortingStrategy, [{
        key: "sort",

        /**
         * @param {?} data
         * @param {?} fieldName
         * @param {?} dir
         * @param {?} ignoreCase
         * @param {?} valueResolver
         * @return {?}
         */
        value: function sort(data, fieldName, dir, ignoreCase, valueResolver) {
          var _this2 = this;

          /** @type {?} */
          var key = fieldName;
          /** @type {?} */

          var reverse = dir === SortingDirection.Desc ? -1 : 1;
          /** @type {?} */

          var cmpFunc = function cmpFunc(obj1, obj2) {
            return _this2.compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver);
          };

          return this.arraySort(data, cmpFunc);
        }
        /**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */

      }, {
        key: "compareValues",
        value: function compareValues(a, b) {
          /** @type {?} */
          var an = a === null || a === undefined;
          /** @type {?} */

          var bn = b === null || b === undefined;

          if (an) {
            if (bn) {
              return 0;
            }

            return -1;
          } else if (bn) {
            return 1;
          }

          return a > b ? 1 : a < b ? -1 : 0;
        }
        /**
         * @protected
         * @param {?} obj1
         * @param {?} obj2
         * @param {?} key
         * @param {?} reverse
         * @param {?} ignoreCase
         * @param {?} valueResolver
         * @return {?}
         */

      }, {
        key: "compareObjects",
        value: function compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver) {
          /** @type {?} */
          var a = valueResolver(obj1, key);
          /** @type {?} */

          var b = valueResolver(obj2, key);

          if (ignoreCase) {
            a = a && a.toLowerCase ? a.toLowerCase() : a;
            b = b && b.toLowerCase ? b.toLowerCase() : b;
          }

          return reverse * this.compareValues(a, b);
        }
        /**
         * @protected
         * @param {?} data
         * @param {?=} compareFn
         * @return {?}
         */

      }, {
        key: "arraySort",
        value: function arraySort(data, compareFn) {
          return data.sort(compareFn);
        }
      }], [{
        key: "instance",
        value: function instance() {
          return this._instance || (this._instance = new this());
        }
      }]);

      return DefaultSortingStrategy;
    }();

    DefaultSortingStrategy._instance = null;

    var IgxSorting =
    /*#__PURE__*/
    function () {
      function IgxSorting() {
        _classCallCheck(this, IgxSorting);
      }

      _createClass(IgxSorting, [{
        key: "sort",

        /**
         * @param {?} data
         * @param {?} expressions
         * @return {?}
         */
        value: function sort(data, expressions) {
          return this.sortDataRecursive(data, expressions);
        }
        /**
         * @private
         * @param {?} data
         * @param {?} index
         * @param {?} expression
         * @return {?}
         */

      }, {
        key: "groupedRecordsByExpression",
        value: function groupedRecordsByExpression(data, index, expression) {
          /** @type {?} */
          var i;
          /** @type {?} */

          var groupval;
          /** @type {?} */

          var res = [];
          /** @type {?} */

          var key = expression.fieldName;
          /** @type {?} */

          var len = data.length;
          res.push(data[index]);
          groupval = this.getFieldValue(data[index], key);
          index++;
          /** @type {?} */

          var comparer = expression.groupingComparer || DefaultSortingStrategy.instance().compareValues;

          for (i = index; i < len; i++) {
            if (comparer(this.getFieldValue(data[i], key), groupval) === 0) {
              res.push(data[i]);
            } else {
              break;
            }
          }

          return res;
        }
        /**
         * @private
         * @template T
         * @param {?} data
         * @param {?} expressions
         * @param {?=} expressionIndex
         * @return {?}
         */

      }, {
        key: "sortDataRecursive",
        value: function sortDataRecursive(data, expressions) {
          var expressionIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          /** @type {?} */
          var i;
          /** @type {?} */

          var j;
          /** @type {?} */

          var expr;
          /** @type {?} */

          var gbData;
          /** @type {?} */

          var gbDataLen;
          /** @type {?} */

          var exprsLen = expressions.length;
          /** @type {?} */

          var dataLen = data.length;
          expressionIndex = expressionIndex || 0;

          if (expressionIndex >= exprsLen || dataLen <= 1) {
            return data;
          }

          expr = expressions[expressionIndex];

          if (!expr.strategy) {
            expr.strategy = DefaultSortingStrategy.instance();
          }

          data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue);

          if (expressionIndex === exprsLen - 1) {
            return data;
          } // in case of multiple sorting


          for (i = 0; i < dataLen; i++) {
            gbData = this.groupedRecordsByExpression(data, i, expr);
            gbDataLen = gbData.length;

            if (gbDataLen > 1) {
              gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1);
            }

            for (j = 0; j < gbDataLen; j++) {
              data[i + j] = gbData[j];
            }

            i += gbDataLen - 1;
          }

          return data;
        }
        /**
         * @protected
         * @template T
         * @param {?} data
         * @param {?} state
         * @param {?} level
         * @param {?} parent
         * @param {?} metadata
         * @param {?=} grid
         * @param {?=} groupsRecords
         * @param {?=} fullResult
         * @return {?}
         */

      }, {
        key: "groupDataRecursive",
        value: function groupDataRecursive(data, state, level, parent, metadata) {
          var _this3 = this;

          var grid = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
          var groupsRecords = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
          var fullResult = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {
            data: [],
            metadata: []
          };

          /** @type {?} */
          var expressions = state.expressions;
          /** @type {?} */

          var expansion = state.expansion;
          /** @type {?} */

          var i = 0;
          /** @type {?} */

          var result = [];

          var _loop = function _loop() {
            /** @type {?} */
            var group = _this3.groupedRecordsByExpression(data, i, expressions[level]);
            /** @type {?} */


            var groupRow = {
              expression: expressions[level],
              level: level,
              records: cloneArray(group),
              value: group[0][expressions[level].fieldName],
              groupParent: parent,
              groups: [],
              height: grid ? grid.renderedRowHeight : null
            };

            if (parent) {
              parent.groups.push(groupRow);
            } else {
              groupsRecords.push(groupRow);
            }
            /** @type {?} */


            var hierarchy = _getHierarchy(groupRow);
            /** @type {?} */


            var expandState = expansion.find(function (s) {
              return _isHierarchyMatch(s.hierarchy || [{
                fieldName: groupRow.expression.fieldName,
                value: groupRow.value
              }], hierarchy);
            });
            /** @type {?} */

            var expanded = expandState ? expandState.expanded : state.defaultExpanded;
            /** @type {?} */

            var recursiveResult = void 0;
            result.push(groupRow);
            metadata.push(null);
            fullResult.data.push(groupRow);
            fullResult.metadata.push(null);

            if (level < expressions.length - 1) {
              recursiveResult = _this3.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);

              if (expanded) {
                result = result.concat(recursiveResult);
              }
            } else {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = group[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var groupItem = _step2.value;
                  fullResult.metadata.push(groupRow);
                  fullResult.data.push(groupItem);
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              if (expanded) {
                var _result;

                metadata.push.apply(metadata, _toConsumableArray(fullResult.metadata.slice(fullResult.metadata.length - group.length)));

                (_result = result).push.apply(_result, _toConsumableArray(fullResult.data.slice(fullResult.data.length - group.length)));
              }
            }

            i += group.length;
          };

          while (i < data.length) {
            _loop();
          }

          return result;
        }
        /**
         * @protected
         * @param {?} obj
         * @param {?} key
         * @return {?}
         */

      }, {
        key: "getFieldValue",
        value: function getFieldValue(obj, key) {
          return obj[key];
        }
      }]);

      return IgxSorting;
    }();

    var IgxDataRecordSorting =
    /*#__PURE__*/
    function (_IgxSorting) {
      _inherits(IgxDataRecordSorting, _IgxSorting);

      function IgxDataRecordSorting() {
        _classCallCheck(this, IgxDataRecordSorting);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxDataRecordSorting).apply(this, arguments));
      }

      _createClass(IgxDataRecordSorting, [{
        key: "getFieldValue",

        /**
         * @protected
         * @param {?} obj
         * @param {?} key
         * @return {?}
         */
        value: function getFieldValue(obj, key) {
          return obj.data[key];
        }
      }]);

      return IgxDataRecordSorting;
    }(IgxSorting);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxGrouping =
    /*#__PURE__*/
    function (_IgxSorting2) {
      _inherits(IgxGrouping, _IgxSorting2);

      function IgxGrouping() {
        _classCallCheck(this, IgxGrouping);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxGrouping).apply(this, arguments));
      }

      _createClass(IgxGrouping, [{
        key: "groupBy",

        /**
         * @param {?} data
         * @param {?} state
         * @param {?=} grid
         * @param {?=} groupsRecords
         * @param {?=} fullResult
         * @return {?}
         */
        value: function groupBy(data, state, grid, groupsRecords) {
          var fullResult = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
            data: [],
            metadata: []
          };

          /** @type {?} */
          var metadata = [];
          /** @type {?} */

          var grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);
          return {
            data: grouping,
            metadata: metadata
          };
        }
      }]);

      return IgxGrouping;
    }(IgxSorting);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */


    var PagingError = {
      None: 0,
      IncorrectPageIndex: 1,
      IncorrectRecordsPerPage: 2
    };
    PagingError[PagingError.None] = 'None';
    PagingError[PagingError.IncorrectPageIndex] = 'IncorrectPageIndex';
    PagingError[PagingError.IncorrectRecordsPerPage] = 'IncorrectRecordsPerPage';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var FilteringLogic = {
      And: 0,
      Or: 1
    };
    FilteringLogic[FilteringLogic.And] = 'And';
    FilteringLogic[FilteringLogic.Or] = 'Or';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var FilteringExpressionsTreeType = {
      Regular: 0,
      Advanced: 1
    };
    FilteringExpressionsTreeType[FilteringExpressionsTreeType.Regular] = 'Regular';
    FilteringExpressionsTreeType[FilteringExpressionsTreeType.Advanced] = 'Advanced';

    var FilteringExpressionsTree =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} operator
       * @param {?=} fieldName
       */
      function FilteringExpressionsTree(operator, fieldName) {
        _classCallCheck(this, FilteringExpressionsTree);

        /**
         * Sets/gets the filtering operands.
         * ```typescript
         * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
         * const expression = [
         * {
         *   condition: IgxStringFilteringOperand.instance().condition('contains'),
         *   fieldName: 'Column Field',
         *   searchVal: 'Value',
         *   ignoreCase: false
         * }];
         * gridExpressionsTree.filteringOperands.push(expression);
         * this.grid.filteringExpressionsTree = gridExpressionsTree;
         * ```
         * ```typescript
         * let filteringOperands = gridExpressionsTree.filteringOperands;
         * ```
         * \@memberof FilteringExpressionsTree
         */
        this.filteringOperands = [];
        this.operator = operator;
        this.fieldName = fieldName;
      }
      /**
       * Checks if filtering expressions tree is empty.
       * @param {?} expressionTree filtering expressions tree.
       * @return {?}
       */


      _createClass(FilteringExpressionsTree, [{
        key: "find",

        /**
         * Returns the filtering expression for a column with the provided fieldName.
         * ```typescript
         * let filteringExpression = gridExpressionTree.find('Column Field');
         * ```
         * \@memberof FilteringExpressionsTree
         * @param {?} fieldName
         * @return {?}
         */
        value: function find(fieldName) {
          /** @type {?} */
          var index = this.findIndex(fieldName);

          if (index > -1) {
            return this.filteringOperands[index];
          }

          return null;
        }
        /**
         * Returns the index of the filtering expression for a column with the provided fieldName.
         * ```typescript
         * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
         * ```
         * \@memberof FilteringExpressionsTree
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "findIndex",
        value: function findIndex(fieldName) {
          /** @type {?} */
          var expr;

          for (var i = 0; i < this.filteringOperands.length; i++) {
            expr = this.filteringOperands[i];

            if (expr instanceof FilteringExpressionsTree) {
              if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {
                return i;
              }
            } else {
              if (
              /** @type {?} */
              expr.fieldName === fieldName) {
                return i;
              }
            }
          }

          return -1;
        }
        /**
         * @protected
         * @param {?} expressionsTree
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "isFilteringExpressionsTreeForColumn",
        value: function isFilteringExpressionsTreeForColumn(expressionsTree, fieldName) {
          if (expressionsTree.fieldName === fieldName) {
            return true;
          }
          /** @type {?} */


          var expr;

          for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
            expr = expressionsTree.filteringOperands[i];

            if (expr instanceof FilteringExpressionsTree) {
              return this.isFilteringExpressionsTreeForColumn(expr, fieldName);
            } else {
              return (
                /** @type {?} */
                expr.fieldName === fieldName
              );
            }
          }

          return false;
        }
      }], [{
        key: "empty",
        value: function empty(expressionTree) {
          return !expressionTree || !expressionTree.filteringOperands || !expressionTree.filteringOperands.length;
        }
      }]);

      return FilteringExpressionsTree;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @abstract
     */


    var BaseFilteringStrategy =
    /*#__PURE__*/
    function () {
      function BaseFilteringStrategy() {
        _classCallCheck(this, BaseFilteringStrategy);
      }

      _createClass(BaseFilteringStrategy, [{
        key: "findMatchByExpression",

        /**
         * @param {?} rec
         * @param {?} expr
         * @return {?}
         */
        value: function findMatchByExpression(rec, expr) {
          /** @type {?} */
          var cond = expr.condition;
          /** @type {?} */

          var val = this.getFieldValue(rec, expr.fieldName);
          return cond.logic(val, expr.searchVal, expr.ignoreCase);
        }
        /**
         * @param {?} rec
         * @param {?} expressions
         * @return {?}
         */

      }, {
        key: "matchRecord",
        value: function matchRecord(rec, expressions) {
          if (expressions) {
            if (expressions instanceof FilteringExpressionsTree) {
              /** @type {?} */
              var expressionsTree =
              /** @type {?} */
              expressions;
              /** @type {?} */

              var operator =
              /** @type {?} */
              expressionsTree.operator;
              /** @type {?} */

              var matchOperand;
              /** @type {?} */

              var operand;

              if (expressionsTree.filteringOperands && expressionsTree.filteringOperands.length) {
                for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
                  operand = expressionsTree.filteringOperands[i];
                  matchOperand = this.matchRecord(rec, operand); // Return false if at least one operand does not match and the filtering logic is And

                  if (!matchOperand && operator === FilteringLogic.And) {
                    return false;
                  } // Return true if at least one operand matches and the filtering logic is Or


                  if (matchOperand && operator === FilteringLogic.Or) {
                    return true;
                  }
                }

                return matchOperand;
              }

              return true;
            } else {
              /** @type {?} */
              var expression =
              /** @type {?} */
              expressions;
              return this.findMatchByExpression(rec, expression);
            }
          }

          return true;
        }
      }]);

      return BaseFilteringStrategy;
    }();

    var FilteringStrategy =
    /*#__PURE__*/
    function (_BaseFilteringStrateg) {
      _inherits(FilteringStrategy, _BaseFilteringStrateg);

      function FilteringStrategy() {
        _classCallCheck(this, FilteringStrategy);

        return _possibleConstructorReturn(this, _getPrototypeOf(FilteringStrategy).call(this));
      }
      /**
       * @return {?}
       */


      _createClass(FilteringStrategy, [{
        key: "filter",

        /**
         * @template T
         * @param {?} data
         * @param {?} expressionsTree
         * @param {?=} advancedExpressionsTree
         * @return {?}
         */
        value: function filter(data, expressionsTree, advancedExpressionsTree) {
          /** @type {?} */
          var i;
          /** @type {?} */

          var rec;
          /** @type {?} */

          var len = data.length;
          /** @type {?} */

          var res = [];

          if (FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree) || !len) {
            return data;
          }

          for (i = 0; i < len; i++) {
            rec = data[i];

            if (this.matchRecord(rec, expressionsTree) && this.matchRecord(rec, advancedExpressionsTree)) {
              res.push(rec);
            }
          }

          return res;
        }
        /**
         * @protected
         * @param {?} rec
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "getFieldValue",
        value: function getFieldValue(rec, fieldName) {
          return rec[fieldName];
        }
      }], [{
        key: "instance",
        value: function instance() {
          return this._instace || (this._instace = new this());
        }
      }]);

      return FilteringStrategy;
    }(BaseFilteringStrategy);

    FilteringStrategy._instace = null;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var TransactionType = {
      ADD: 'add',
      DELETE: 'delete',
      UPDATE: 'update'
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var DataType = {
      String: 'string',
      Number: 'number',
      Boolean: 'boolean',
      Date: 'date'
    };
    /**
     * @hidden
     */

    var DataUtil =
    /*#__PURE__*/
    function () {
      function DataUtil() {
        _classCallCheck(this, DataUtil);
      }

      _createClass(DataUtil, null, [{
        key: "sort",

        /**
         * @template T
         * @param {?} data
         * @param {?} expressions
         * @param {?=} sorting
         * @return {?}
         */
        value: function sort(data, expressions) {
          var sorting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new IgxSorting();
          return sorting.sort(data, expressions);
        }
        /**
         * @param {?} hierarchicalData
         * @param {?} expressions
         * @param {?=} parent
         * @return {?}
         */

      }, {
        key: "treeGridSort",
        value: function treeGridSort(hierarchicalData, expressions, parent) {
          /** @type {?} */
          var res = [];
          hierarchicalData.forEach(function (hr) {
            /** @type {?} */
            var rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;

            if (rec.children) {
              rec.children = DataUtil.treeGridSort(rec.children, expressions, rec);
            }

            res.push(rec);
          });
          res = DataUtil.sort(res, expressions, new IgxDataRecordSorting());
          return res;
        }
        /**
         * @param {?} hierarchicalRecord
         * @return {?}
         */

      }, {
        key: "cloneTreeGridRecord",
        value: function cloneTreeGridRecord(hierarchicalRecord) {
          /** @type {?} */
          var rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
          };
          return rec;
        }
        /**
         * @template T
         * @param {?} data
         * @param {?} state
         * @param {?=} grid
         * @param {?=} groupsRecords
         * @param {?=} fullResult
         * @return {?}
         */

      }, {
        key: "group",
        value: function group(data, state) {
          var grid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var groupsRecords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          var fullResult = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
            data: [],
            metadata: []
          };

          /** @type {?} */
          var grouping = new IgxGrouping();
          groupsRecords.splice(0, groupsRecords.length);
          return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
        }
        /**
         * @template T
         * @param {?} data
         * @param {?} state
         * @return {?}
         */

      }, {
        key: "page",
        value: function page(data, state) {
          if (!state) {
            return data;
          }
          /** @type {?} */


          var len = data.length;
          /** @type {?} */

          var index = state.index;
          /** @type {?} */

          var res = [];
          /** @type {?} */

          var recordsPerPage = state.recordsPerPage;
          state.metadata = {
            countPages: 0,
            countRecords: data.length,
            error: PagingError.None
          };

          if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
          }

          if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
          }

          state.metadata.countPages = Math.ceil(len / recordsPerPage);

          if (!len) {
            return data;
          }

          if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
          }

          return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
        }
        /**
         * @template T
         * @param {?} data
         * @param {?} state
         * @return {?}
         */

      }, {
        key: "filter",
        value: function filter(data, state) {
          if (!state.strategy) {
            state.strategy = new FilteringStrategy();
          }

          return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
        }
        /**
         * @param {?} state
         * @param {?} length
         * @return {?}
         */

      }, {
        key: "correctPagingState",
        value: function correctPagingState(state, length) {
          /** @type {?} */
          var maxPage = Math.ceil(length / state.recordsPerPage) - 1;

          if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
          }
        }
        /**
         * @param {?} gRow
         * @return {?}
         */

      }, {
        key: "getHierarchy",
        value: function getHierarchy(gRow) {
          return _getHierarchy(gRow);
        }
        /**
         * @param {?} h1
         * @param {?} h2
         * @return {?}
         */

      }, {
        key: "isHierarchyMatch",
        value: function isHierarchyMatch(h1, h2) {
          return _isHierarchyMatch(h1, h2);
        }
        /**
         * Merges all changes from provided transactions into provided data collection
         * @template T
         * @param {?} data Collection to merge
         * @param {?} transactions Transactions to merge into data
         * @param {?=} primaryKey Primary key of the collection, if any
         * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
         * @return {?} Provided data collections updated with all provided transactions
         */

      }, {
        key: "mergeTransactions",
        value: function mergeTransactions(data, transactions, primaryKey) {
          var deleteRows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          data.forEach(function (item, index) {
            /** @type {?} */
            var rowId = primaryKey ? item[primaryKey] : item;
            /** @type {?} */

            var transaction = transactions.find(function (t) {
              return t.id === rowId;
            });

            if (transaction && transaction.type === TransactionType.UPDATE) {
              data[index] = transaction.newValue;
            }
          });

          if (deleteRows) {
            transactions.filter(function (t) {
              return t.type === TransactionType.DELETE;
            }).forEach(function (t) {
              /** @type {?} */
              var index = primaryKey ? data.findIndex(function (d) {
                return d[primaryKey] === t.id;
              }) : data.findIndex(function (d) {
                return d === t.id;
              });

              if (0 <= index && index < data.length) {
                data.splice(index, 1);
              }
            });
          }

          data.push.apply(data, _toConsumableArray(transactions.filter(function (t) {
            return t.type === TransactionType.ADD;
          }).map(function (t) {
            return t.newValue;
          })));
          return data;
        }
        /**
         * Merges all changes from provided transactions into provided hierarchical data collection
         * @param {?} data Collection to merge
         * @param {?} transactions Transactions to merge into data
         * @param {?} childDataKey Data key of child collections
         * @param {?=} primaryKey Primary key of the collection, if any
         * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
         * @return {?} Provided data collections updated with all provided transactions
         */

      }, {
        key: "mergeHierarchicalTransactions",
        value: function mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey) {
          var _this4 = this;

          var deleteRows = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            var _loop2 = function _loop2() {
              var transaction = _step3.value;

              if (transaction.path) {
                /** @type {?} */
                var parent = _this4.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                /** @type {?} */


                var collection = parent ? parent[childDataKey] : data;

                switch (transaction.type) {
                  case TransactionType.ADD:
                    //  if there is no parent this is ADD row at root level
                    if (parent && !parent[childDataKey]) {
                      parent[childDataKey] = collection = [];
                    }

                    collection.push(transaction.newValue);
                    break;

                  case TransactionType.UPDATE:
                    /** @type {?} */
                    var updateIndex = collection.findIndex(function (x) {
                      return x[primaryKey] === transaction.id;
                    });

                    if (updateIndex !== -1) {
                      collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                    }

                    break;

                  case TransactionType.DELETE:
                    if (deleteRows) {
                      /** @type {?} */
                      var deleteIndex = collection.findIndex(function (r) {
                        return r[primaryKey] === transaction.id;
                      });

                      if (deleteIndex !== -1) {
                        collection.splice(deleteIndex, 1);
                      }
                    }

                    break;
                }
              } else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
              }
            };

            for (var _iterator3 = transactions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              _loop2();
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          return data;
        }
        /**
         * @param {?} dataType
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "parseValue",
        value: function parseValue(dataType, value) {
          if (dataType === DataType.Number) {
            value = parseFloat(value);
          }

          return value;
        }
        /**
         * @private
         * @param {?} data
         * @param {?} primaryKey
         * @param {?} childDataKey
         * @param {?} path
         * @return {?}
         */

      }, {
        key: "findParentFromPath",
        value: function findParentFromPath(data, primaryKey, childDataKey, path) {
          /** @type {?} */
          var collection = data;
          /** @type {?} */

          var result;
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            var _loop3 = function _loop3() {
              var id = _step4.value;
              result = collection && collection.find(function (x) {
                return x[primaryKey] === id;
              });

              if (!result) {
                return "break";
              }

              collection = result[childDataKey];
            };

            for (var _iterator4 = path[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _ret = _loop3();

              if (_ret === "break") break;
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          return result;
        }
      }]);

      return DataUtil;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var ExportUtilities =
    /*#__PURE__*/
    function () {
      function ExportUtilities() {
        _classCallCheck(this, ExportUtilities);
      }

      _createClass(ExportUtilities, null, [{
        key: "getKeysFromData",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function getKeysFromData(data) {
          /** @type {?} */
          var length = data.length;

          if (length === 0) {
            return [];
          }
          /** @type {?} */


          var dataEntry = data[0];
          /** @type {?} */

          var dataEntryMiddle = data[Math.floor(length / 2)];
          /** @type {?} */

          var dataEntryLast = data[length - 1];
          /** @type {?} */

          var keys1 = Object.keys(dataEntry);
          /** @type {?} */

          var keys2 = Object.keys(dataEntryMiddle);
          /** @type {?} */

          var keys3 = Object.keys(dataEntryLast);
          /** @type {?} */

          var keys = new Set(keys1.concat(keys2).concat(keys3));
          return !ExportUtilities.isSpecialData(data) ? Array.from(keys) : ['Column 1'];
        }
        /**
         * @param {?} blob
         * @param {?} fileName
         * @return {?}
         */

      }, {
        key: "saveBlobToFile",
        value: function saveBlobToFile(blob, fileName) {
          /** @type {?} */
          var a = document.createElement('a');

          if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blob, fileName);
          } else {
            /** @type {?} */
            var url = window.URL.createObjectURL(blob);
            a.download = fileName;
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
          }
        }
        /**
         * @param {?} s
         * @return {?}
         */

      }, {
        key: "stringToArrayBuffer",
        value: function stringToArrayBuffer(s) {
          /** @type {?} */
          var buf = new ArrayBuffer(s.length);
          /** @type {?} */

          var view = new Uint8Array(buf);

          for (var i = 0; i !== s.length; ++i) {
            /* tslint:disable no-bitwise */
            view[i] = s.charCodeAt(i) & 0xFF;
            /* tslint:enable no-bitwise */
          }

          return buf;
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "isSpecialData",
        value: function isSpecialData(data) {
          /** @type {?} */
          var dataEntry = data[0];
          return typeof dataEntry === 'string' || typeof dataEntry === 'number' || dataEntry instanceof Date;
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "hasValue",
        value: function hasValue(value) {
          return value !== undefined && value !== null;
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isNullOrWhitespaces",
        value: function isNullOrWhitespaces(value) {
          return value === undefined || value === null || !value.trim();
        }
      }]);

      return ExportUtilities;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @template T
     */


    var GridBaseAPIService =
    /*#__PURE__*/
    function () {
      function GridBaseAPIService() {
        _classCallCheck(this, GridBaseAPIService);

        this.editCellState = new Map();
        this.editRowState = new Map();
        this.destroyMap = new Map();
      }
      /**
       * @param {?} name
       * @return {?}
       */


      _createClass(GridBaseAPIService, [{
        key: "get_column_by_name",
        value: function get_column_by_name(name) {
          return this.grid.columnList.find(function (col) {
            return col.field === name;
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "get_summary_data",
        value: function get_summary_data() {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var data = grid.filteredData;

          if (!data) {
            if (grid.transactions.enabled) {
              data = DataUtil.mergeTransactions(cloneArray(grid.data), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
              /** @type {?} */

              var deletedRows = grid.transactions.getTransactionLog().filter(function (t) {
                return t.type === TransactionType.DELETE;
              }).map(function (t) {
                return t.id;
              });
              deletedRows.forEach(function (rowID) {
                /** @type {?} */
                var tempData = grid.primaryKey ? data.map(function (rec) {
                  return rec[grid.primaryKey];
                }) : data;
                /** @type {?} */

                var index = tempData.indexOf(rowID);

                if (index !== -1) {
                  data.splice(index, 1);
                }
              });
            } else {
              data = grid.data;
            }
          }

          return data;
        }
        /**
         * @hidden
         * \@internal
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "getRowData",
        value: function getRowData(rowID) {
          /** @type {?} */
          var data = this.get_all_data(this.grid.transactions.enabled);
          /** @type {?} */

          var index = this.get_row_index_in_data(rowID);
          return data[index];
        } // TODO: Refactor

        /**
         * @return {?}
         */

      }, {
        key: "escape_editMode",
        value: function escape_editMode() {
          this.grid.crudService.end();
        } // TODO: Refactor

        /**
         * @return {?}
         */

      }, {
        key: "get_cell_inEditMode",
        value: function get_cell_inEditMode() {
          return this.grid.crudService.cell;
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "get_row_index_in_data",
        value: function get_row_index_in_data(rowID) {
          /** @type {?} */
          var grid =
          /** @type {?} */
          this.grid;

          if (!grid) {
            return -1;
          }
          /** @type {?} */


          var data = this.get_all_data(grid.transactions.enabled);
          return grid.primaryKey ? data.findIndex(function (record) {
            return record[grid.primaryKey] === rowID;
          }) : data.indexOf(rowID);
        }
        /**
         * @param {?} rowSelector
         * @return {?}
         */

      }, {
        key: "get_row_by_key",
        value: function get_row_by_key(rowSelector) {
          /** @type {?} */
          var primaryKey = this.grid.primaryKey;

          if (primaryKey !== undefined && primaryKey !== null) {
            return this.grid.dataRowList.find(function (row) {
              return row.rowData[primaryKey] === rowSelector;
            });
          } else {
            return this.grid.dataRowList.find(function (row) {
              return row.rowData === rowSelector;
            });
          }
        }
        /**
         * @param {?} rowIndex
         * @return {?}
         */

      }, {
        key: "get_row_by_index",
        value: function get_row_by_index(rowIndex) {
          return this.grid.rowList.find(function (row) {
            return row.index === rowIndex;
          });
        }
        /**
         * @param {?} rowSelector
         * @param {?} field
         * @return {?}
         */

      }, {
        key: "get_cell_by_key",
        value: function get_cell_by_key(rowSelector, field) {
          /** @type {?} */
          var row = this.get_row_by_key(rowSelector);

          if (row && row.cells) {
            return row.cells.find(function (cell) {
              return cell.column.field === field;
            });
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?} columnIndex
         * @return {?}
         */

      }, {
        key: "get_cell_by_index",
        value: function get_cell_by_index(rowIndex, columnIndex) {
          /** @type {?} */
          var row = this.get_row_by_index(rowIndex);

          if (row && row.cells) {
            return row.cells.find(function (cell) {
              return cell.columnIndex === columnIndex;
            });
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?} columnIndex
         * @return {?}
         */

      }, {
        key: "get_cell_by_visible_index",
        value: function get_cell_by_visible_index(rowIndex, columnIndex) {
          /** @type {?} */
          var row = this.get_row_by_index(rowIndex);

          if (row && row.cells) {
            return row.cells.find(function (cell) {
              return cell.visibleColumnIndex === columnIndex;
            });
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "submit_value",
        value: function submit_value() {
          /** @type {?} */
          var cell = this.grid.crudService.cell;

          if (cell) {
            /** @type {?} */
            var args = this.update_cell(cell, cell.editValue);

            if (args.cancel) {
              return;
            }

            this.escape_editMode();
          }
        }
        /**
         * @param {?} cell
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "update_cell",
        value: function update_cell(cell, value) {
          /** @type {?} */
          var data = this.get_all_data(this.grid.transactions.enabled);
          /** @type {?} */

          var index = this.get_row_index_in_data(cell.id.rowID);
          cell.editValue = value;
          /** @type {?} */

          var args = cell.createEditEventArgs();
          this.grid.onCellEdit.emit(args);

          if (args.cancel) {
            return args;
          } // Cast to number after emit
          // TODO: Clean up this


          args.newValue = cell.castToNumber(args.newValue);

          if (isEqual(args.oldValue, args.newValue)) {
            return args;
          }

          this.grid.summaryService.clearSummaryCache(args);
          this.updateData(this.grid, cell.id.rowID, data[index], cell.rowData, _defineProperty({}, cell.column.field, args.newValue));

          if (this.grid.primaryKey === cell.column.field) {
            if (this.grid.selectionService.isRowSelected(cell.id.rowID)) {
              this.grid.selectionService.deselectRow(cell.id.rowID);
              this.grid.selectionService.selectRowById(args.newValue);
            }

            if (this.grid.hasSummarizedColumns) {
              this.grid.summaryService.removeSummaries(cell.id.rowID);
            }
          }

          if (!this.grid.rowEditable || !this.grid.crudService.row || this.grid.crudService.row.id !== cell.id.rowID || !this.grid.transactions.enabled) {
            this.grid.summaryService.clearSummaryCache(args);
            /** @type {?} */this.grid._pipeTrigger++;
          }

          return args;
        }
        /**
         * Updates related row of provided grid's data source with provided new row value
         * @protected
         * @param {?} grid Grid to update data for
         * @param {?} rowID ID of the row to update
         * @param {?} rowValueInDataSource Initial value of the row as it is in data source
         * @param {?} rowCurrentValue Current value of the row as it is with applied previous transactions
         * @param {?} rowNewValue New value of the row
         * @return {?}
         */

      }, {
        key: "updateData",
        value: function updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
          if (grid.transactions.enabled) {
            /** @type {?} */
            var transaction = {
              id: rowID,
              type: TransactionType.UPDATE,
              newValue: rowNewValue
            };
            grid.transactions.add(transaction, rowCurrentValue);
          } else {
            mergeObjects(rowValueInDataSource, rowNewValue);
          }
        }
        /**
         * @param {?} row
         * @param {?=} value
         * @return {?}
         */

      }, {
        key: "_update_row",
        value: function _update_row(row, value) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var rowInEditMode = grid.crudService.row;
          row.newData = value ? value : grid.transactions.getAggregatedValue(row.id, true);

          if (rowInEditMode && row.id === rowInEditMode.id) {
            row.data = Object.assign({}, row.data, rowInEditMode.transactionState); // TODO: Workaround for updating a row in edit mode through the API
          } else if (this.grid.transactions.enabled) {
            /** @type {?} */
            var state = grid.transactions.getState(row.id);
            row.data = state ? Object.assign({}, row.data, state.value) : row.data;
          }
        }
        /**
         * @param {?} row
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "update_row",
        value: function update_row(row, value) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var selected = grid.selectionService.isRowSelected(row.id);
          /** @type {?} */

          var rowInEditMode = grid.crudService.row;
          /** @type {?} */

          var data = this.get_all_data(grid.transactions.enabled);
          /** @type {?} */

          var index = this.get_row_index_in_data(row.id);
          /** @type {?} */

          var hasSummarized = grid.hasSummarizedColumns;

          this._update_row(row, value);
          /** @type {?} */


          var args = row.createEditEventArgs(); // If no valid row is found

          if (index === -1) {
            return args;
          }

          grid.onRowEdit.emit(args);

          if (args.cancel) {
            return args;
          }

          if (rowInEditMode) {
            /** @type {?} */
            var hasChanges = grid.transactions.getState(args.rowID, true);
            grid.transactions.endPending(false);

            if (!hasChanges) {
              return args;
            }
          }

          if (!args.newValue) {
            return args;
          }

          if (hasSummarized) {
            grid.summaryService.removeSummaries(args.rowID);
          }

          this.updateData(grid, row.id, data[index], args.oldValue, args.newValue);
          /** @type {?} */

          var newId = grid.primaryKey ? args.newValue[grid.primaryKey] : args.newValue;

          if (selected) {
            grid.selectionService.deselectRow(row.id);
            grid.selectionService.selectRowById(newId);
          }

          if (hasSummarized) {
            grid.summaryService.removeSummaries(newId);
          }

          /** @type {?} */grid._pipeTrigger++;
          return args;
        }
        /**
         * @protected
         * @param {?} value
         * @param {?} rowID
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "update_row_in_array",
        value: function update_row_in_array(value, rowID, index) {
          /** @type {?} */
          var grid = this.grid;
          grid.data[index] = value;
        }
        /**
         * @param {?} expression
         * @return {?}
         */

      }, {
        key: "sort",
        value: function sort(expression) {
          if (expression.dir === SortingDirection.None) {
            this.remove_grouping_expression(expression.fieldName);
          }
          /** @type {?} */


          var sortingState = cloneArray(this.grid.sortingExpressions);
          this.prepare_sorting_expression([sortingState], expression);
          this.grid.sortingExpressions = sortingState;
        }
        /**
         * @param {?} expressions
         * @return {?}
         */

      }, {
        key: "sort_multiple",
        value: function sort_multiple(expressions) {
          /** @type {?} */
          var sortingState = cloneArray(this.grid.sortingExpressions);
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = expressions[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var each = _step5.value;

              if (each.dir === SortingDirection.None) {
                this.remove_grouping_expression(each.fieldName);
              }

              this.prepare_sorting_expression([sortingState], each);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          this.grid.sortingExpressions = sortingState;
        }
        /**
         * @param {?} fieldName
         * @param {?} term
         * @param {?} conditionOrExpressionsTree
         * @param {?} ignoreCase
         * @return {?}
         */

      }, {
        key: "filter",
        value: function filter(fieldName, term, conditionOrExpressionsTree, ignoreCase) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var filteringTree = grid.filteringExpressionsTree;
          grid.endEdit(false);

          if (grid.paging) {
            grid.page = 0;
          }
          /** @type {?} */


          var fieldFilterIndex = filteringTree.findIndex(fieldName);

          if (fieldFilterIndex > -1) {
            filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
          }

          this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);
          grid.filteringExpressionsTree = filteringTree;
        }
        /**
         * @param {?} term
         * @param {?} condition
         * @param {?} ignoreCase
         * @return {?}
         */

      }, {
        key: "filter_global",
        value: function filter_global(term, condition, ignoreCase) {
          if (!condition) {
            return;
          }
          /** @type {?} */


          var grid = this.grid;
          /** @type {?} */

          var filteringTree = grid.filteringExpressionsTree;
          grid.endEdit(false);

          if (grid.paging) {
            grid.page = 0;
          }

          filteringTree.filteringOperands = [];
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = grid.columns[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var column = _step6.value;
              this.prepare_filtering_expression(filteringTree, column.field, term, condition, ignoreCase || column.filteringIgnoreCase);
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }

          grid.filteringExpressionsTree = filteringTree;
        }
        /**
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "clear_filter",
        value: function clear_filter(fieldName) {
          /** @type {?} */
          var grid = this.grid;
          grid.endEdit(false);
          /** @type {?} */

          var filteringState = grid.filteringExpressionsTree;
          /** @type {?} */

          var index = filteringState.findIndex(fieldName);

          if (index > -1) {
            filteringState.filteringOperands.splice(index, 1);
          } else if (!fieldName) {
            filteringState.filteringOperands = [];
          }

          grid.filteringExpressionsTree = filteringState;
        }
        /**
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "clear_sort",
        value: function clear_sort(fieldName) {
          /** @type {?} */
          var sortingState = this.grid.sortingExpressions;
          /** @type {?} */

          var index = sortingState.findIndex(function (expr) {
            return expr.fieldName === fieldName;
          });

          if (index > -1) {
            sortingState.splice(index, 1);
            this.grid.sortingExpressions = sortingState;
          }
        }
        /**
         * @protected
         * @param {?} filteringState
         * @param {?} fieldName
         * @param {?} searchVal
         * @param {?} conditionOrExpressionsTree
         * @param {?} ignoreCase
         * @param {?=} insertAtIndex
         * @return {?}
         */

      }, {
        key: "prepare_filtering_expression",
        value: function prepare_filtering_expression(filteringState, fieldName, searchVal, conditionOrExpressionsTree, ignoreCase) {
          var insertAtIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;

          /** @type {?} */
          var newExpressionsTree;
          /** @type {?} */

          var oldExpressionsTreeIndex = filteringState.findIndex(fieldName);
          /** @type {?} */

          var expressionsTree = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
          /** @type {?} */
          conditionOrExpressionsTree : null;
          /** @type {?} */

          var condition = conditionOrExpressionsTree instanceof FilteringExpressionsTree ? null :
          /** @type {?} */
          conditionOrExpressionsTree;
          /** @type {?} */

          var newExpression = {
            fieldName: fieldName,
            searchVal: searchVal,
            condition: condition,
            ignoreCase: ignoreCase
          };

          if (oldExpressionsTreeIndex === -1) {
            // no expressions tree found for this field
            if (expressionsTree) {
              if (insertAtIndex > -1) {
                filteringState.filteringOperands.splice(insertAtIndex, 0, expressionsTree);
              } else {
                filteringState.filteringOperands.push(expressionsTree);
              }
            } else if (condition) {
              // create expressions tree for this field and add the new expression to it
              newExpressionsTree = new FilteringExpressionsTree(filteringState.operator, fieldName);
              newExpressionsTree.filteringOperands.push(newExpression);
              filteringState.filteringOperands.push(newExpressionsTree);
            }
          }
        }
        /**
         * @protected
         * @param {?} stateCollections
         * @param {?} expression
         * @return {?}
         */

      }, {
        key: "prepare_sorting_expression",
        value: function prepare_sorting_expression(stateCollections, expression) {
          if (expression.dir === SortingDirection.None) {
            stateCollections.forEach(function (state) {
              state.splice(state.findIndex(function (expr) {
                return expr.fieldName === expression.fieldName;
              }), 1);
            });
            return;
          }
          /**
           * We need to make sure the states in each collection with same fields point to the same object reference.
           * If the different state collections provided have different sizes we need to get the largest one.
           * That way we can get the state reference from the largest one that has the same fieldName as the expression to prepare.
           * @type {?}
           */


          var maxCollection = stateCollections[0];

          for (var i = 1; i < stateCollections.length; i++) {
            if (maxCollection.length < stateCollections[i].length) {
              maxCollection = stateCollections[i];
            }
          }
          /** @type {?} */


          var maxExpr = maxCollection.find(function (expr) {
            return expr.fieldName === expression.fieldName;
          });
          stateCollections.forEach(function (collection) {
            /** @type {?} */
            var myExpr = collection.find(function (expr) {
              return expr.fieldName === expression.fieldName;
            });

            if (!myExpr && !maxExpr) {
              // Expression with this fieldName is missing from the current and the max collection.
              collection.push(expression);
            } else if (!myExpr && maxExpr) {
              // Expression with this fieldName is missing from the current and but the max collection has.
              collection.push(maxExpr);
              Object.assign(maxExpr, expression);
            } else {
              // The current collection has the expression so just update it.
              Object.assign(myExpr, expression);
            }
          });
        }
        /**
         * @protected
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "remove_grouping_expression",
        value: function remove_grouping_expression(fieldName) {}
        /**
         * @param {?=} name
         * @return {?}
         */

      }, {
        key: "clear_groupby",
        value: function clear_groupby(name) {}
        /**
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "should_apply_number_style",
        value: function should_apply_number_style(column) {
          return column.dataType === DataType.Number;
        }
        /**
         * @return {?}
         */

      }, {
        key: "get_data",
        value: function get_data() {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var data = grid.data ? grid.data : [];
          return data;
        }
        /**
         * @param {?=} includeTransactions
         * @return {?}
         */

      }, {
        key: "get_all_data",
        value: function get_all_data() {
          var includeTransactions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var data = grid.data ? grid.data : [];
          data = includeTransactions ? grid.dataWithAddedInTransactionRows : data;
          return data;
        }
        /**
         * @return {?}
         */

      }, {
        key: "get_filtered_data",
        value: function get_filtered_data() {
          return this.grid.filteredData;
        }
        /**
         * @protected
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "getSortStrategyPerColumn",
        value: function getSortStrategyPerColumn(fieldName) {
          return this.get_column_by_name(fieldName) ? this.get_column_by_name(fieldName).sortStrategy : undefined;
        }
        /**
         * @param {?} rowData
         * @return {?}
         */

      }, {
        key: "addRowToData",
        value: function addRowToData(rowData) {
          // Add row goes to transactions and if rowEditable is properly implemented, added rows will go to pending transactions
          // If there is a row in edit - > commit and close

          /** @type {?} */
          var grid = this.grid;

          if (grid.transactions.enabled) {
            /** @type {?} */
            var transactionId = grid.primaryKey ? rowData[grid.primaryKey] : rowData;
            /** @type {?} */

            var transaction = {
              id: transactionId,
              type: TransactionType.ADD,
              newValue: rowData
            };
            grid.transactions.add(transaction);
          } else {
            grid.data.push(rowData);
          }
        }
        /**
         * @param {?} rowID
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "deleteRowFromData",
        value: function deleteRowFromData(rowID, index) {
          //  if there is a row (index !== 0) delete it
          //  if there is a row in ADD or UPDATE state change it's state to DELETE

          /** @type {?} */
          var grid = this.grid;

          if (index !== -1) {
            if (grid.transactions.enabled) {
              /** @type {?} */
              var transaction = {
                id: rowID,
                type: TransactionType.DELETE,
                newValue: null
              };
              grid.transactions.add(transaction, grid.data[index]);
            } else {
              grid.data.splice(index, 1);
            }
          } else {
            /** @type {?} */
            var state = grid.transactions.getState(rowID);
            grid.transactions.add({
              id: rowID,
              type: TransactionType.DELETE,
              newValue: null
            }, state && state.recordRef);
          }
        }
        /**
         * @param {?} rowId
         * @return {?}
         */

      }, {
        key: "deleteRowById",
        value: function deleteRowById(rowId) {
          /** @type {?} */
          var index;
          /** @type {?} */

          var grid = this.grid;
          /** @type {?} */

          var data = this.get_all_data();

          if (grid.primaryKey) {
            index = data.map(function (record) {
              return record[grid.primaryKey];
            }).indexOf(rowId);
          } else {
            index = data.indexOf(rowId);
          }
          /** @type {?} */


          var state = grid.transactions.getState(rowId);
          /** @type {?} */

          var hasRowInNonDeletedState = state && state.type !== TransactionType.DELETE; //  if there is a row (index !== -1) and the we have cell in edit mode on same row exit edit mode
          //  if there is no row (index === -1), but there is a row in ADD or UPDATE state do as above
          //  Otherwise just exit - there is nothing to delete

          if (index !== -1 || hasRowInNonDeletedState) {
            // Always exit edit when row is deleted
            grid.endEdit(true);
          } else {
            return;
          } //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!


          grid.onRowDeleted.emit({
            data: data[index]
          });
          this.deleteRowFromData(rowId, index);
          grid.selectionService.isRowSelected(rowId) ? grid.selectionService.deselectRow(rowId) : grid.selectionService.clearHeaderCBState();
          /** @type {?} */grid._pipeTrigger++;
          grid.notifyChanges(); // Data needs to be recalculated if transactions are in place
          // If no transactions, `data` will be a reference to the grid getter, otherwise it will be stale

          /** @type {?} */

          var dataAfterDelete = grid.transactions.enabled ? grid.dataWithAddedInTransactionRows : data;
          grid.refreshSearch();

          if (dataAfterDelete.length % grid.perPage === 0 && dataAfterDelete.length / grid.perPage - 1 < grid.page && grid.page !== 0) {
            grid.page--;
          }
        }
        /**
         * @param {?} rowData
         * @return {?}
         */

      }, {
        key: "get_row_id",
        value: function get_row_id(rowData) {
          return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "row_deleted_transaction",
        value: function row_deleted_transaction(rowID) {
          /** @type {?} */
          var grid = this.grid;

          if (!grid) {
            return false;
          }

          if (!grid.transactions.enabled) {
            return false;
          }
          /** @type {?} */


          var state = grid.transactions.getState(rowID);

          if (state) {
            return state.type === TransactionType.DELETE;
          }

          return false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "atInexistingPage",
        value: function atInexistingPage() {
          return this.grid.totalPages - 1 > this.grid.page;
        }
      }]);

      return GridBaseAPIService;
    }();

    GridBaseAPIService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var TreeGridFilteringStrategy =
    /*#__PURE__*/
    function (_BaseFilteringStrateg2) {
      _inherits(TreeGridFilteringStrategy, _BaseFilteringStrateg2);

      function TreeGridFilteringStrategy() {
        _classCallCheck(this, TreeGridFilteringStrategy);

        return _possibleConstructorReturn(this, _getPrototypeOf(TreeGridFilteringStrategy).apply(this, arguments));
      }

      _createClass(TreeGridFilteringStrategy, [{
        key: "filter",

        /**
         * @param {?} data
         * @param {?} expressionsTree
         * @param {?=} advancedExpressionsTree
         * @return {?}
         */
        value: function filter(data, expressionsTree, advancedExpressionsTree) {
          return this.filterImpl(data, expressionsTree, advancedExpressionsTree, undefined);
        }
        /**
         * @private
         * @param {?} data
         * @param {?} expressionsTree
         * @param {?} advancedExpressionsTree
         * @param {?} parent
         * @return {?}
         */

      }, {
        key: "filterImpl",
        value: function filterImpl(data, expressionsTree, advancedExpressionsTree, parent) {
          /** @type {?} */
          var i;
          /** @type {?} */

          var rec;
          /** @type {?} */

          var len = data.length;
          /** @type {?} */

          var res = [];

          if (FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree) || !len) {
            return data;
          }

          for (i = 0; i < len; i++) {
            rec = DataUtil.cloneTreeGridRecord(data[i]);
            rec.parent = parent;

            if (rec.children) {
              /** @type {?} */
              var filteredChildren = this.filterImpl(rec.children, expressionsTree, advancedExpressionsTree, rec);
              rec.children = filteredChildren.length > 0 ? filteredChildren : null;
            }

            if (this.matchRecord(rec, expressionsTree) && this.matchRecord(rec, advancedExpressionsTree)) {
              res.push(rec);
            } else if (rec.children && rec.children.length > 0) {
              rec.isFilteredOutParent = true;
              res.push(rec);
            }
          }

          return res;
        }
        /**
         * @protected
         * @param {?} rec
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "getFieldValue",
        value: function getFieldValue(rec, fieldName) {
          /** @type {?} */
          var hierarchicalRecord =
          /** @type {?} */
          rec;
          return hierarchicalRecord.data[fieldName];
        }
      }]);

      return TreeGridFilteringStrategy;
    }(BaseFilteringStrategy);
    /**
     * @hidden
     */


    var IgxTreeGridFilteringPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxTreeGridFilteringPipe(gridAPI) {
        _classCallCheck(this, IgxTreeGridFilteringPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} hierarchyData
       * @param {?} expressionsTree
       * @param {?} filterStrategy
       * @param {?} advancedFilteringExpressionsTree
       * @param {?} id
       * @param {?} pipeTrigger
       * @param {?} filteringPipeTrigger
       * @return {?}
       */


      _createClass(IgxTreeGridFilteringPipe, [{
        key: "transform",
        value: function transform(hierarchyData, expressionsTree, filterStrategy, advancedFilteringExpressionsTree, id, pipeTrigger, filteringPipeTrigger) {
          /** @type {?} */
          var grid = this.gridAPI.grid;
          /** @type {?} */

          var state = {
            expressionsTree: expressionsTree,
            advancedExpressionsTree: advancedFilteringExpressionsTree,
            strategy: new TreeGridFilteringStrategy()
          };

          if (filterStrategy) {
            state.strategy = filterStrategy;
          }

          this.resetFilteredOutProperty(grid.records);

          if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            grid.filteredData = null;
            return hierarchyData;
          }
          /** @type {?} */


          var result = this.filter(hierarchyData, state);
          /** @type {?} */

          var filteredData = [];
          this.expandAllRecursive(grid, result, grid.expansionStates, filteredData);
          grid.filteredData = filteredData;
          return result;
        }
        /**
         * @private
         * @param {?} map
         * @return {?}
         */

      }, {
        key: "resetFilteredOutProperty",
        value: function resetFilteredOutProperty(map) {
          /** @type {?} */
          var keys = Array.from(map.keys());

          for (var i = 0; i < keys.length; i++) {
            map.get(keys[i]).isFilteredOutParent = undefined;
          }
        }
        /**
         * @private
         * @param {?} grid
         * @param {?} data
         * @param {?} expandedStates
         * @param {?} filteredData
         * @return {?}
         */

      }, {
        key: "expandAllRecursive",
        value: function expandAllRecursive(grid, data, expandedStates, filteredData) {
          for (var i = 0; i < data.length; i++) {
            /** @type {?} */
            var rec = data[i];
            filteredData.push(rec.data);
            this.updateNonProcessedRecord(grid, rec);

            if (rec.children && rec.children.length > 0) {
              expandedStates.set(rec.rowID, true);
              this.expandAllRecursive(grid, rec.children, expandedStates, filteredData);
            }
          }
        }
        /**
         * @private
         * @param {?} grid
         * @param {?} record
         * @return {?}
         */

      }, {
        key: "updateNonProcessedRecord",
        value: function updateNonProcessedRecord(grid, record) {
          /** @type {?} */
          var rec = grid.records.get(record.rowID);
          rec.isFilteredOutParent = record.isFilteredOutParent;
        }
        /**
         * @private
         * @param {?} data
         * @param {?} state
         * @return {?}
         */

      }, {
        key: "filter",
        value: function filter(data, state) {
          return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
        }
      }]);

      return IgxTreeGridFilteringPipe;
    }();

    IgxTreeGridFilteringPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'treeGridFiltering',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxTreeGridFilteringPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @abstract
     */


    var IgxBaseExporter =
    /*#__PURE__*/
    function () {
      function IgxBaseExporter() {
        _classCallCheck(this, IgxBaseExporter);

        this.flatRecords = [];
        this._isTreeGrid = false;
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        /**
         * This event is emitted when a row is exported.
         * ```typescript
         * this.exporterService.onRowExport.subscribe((args: IRowExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxBaseExporter
         */

        this.onRowExport = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event is emitted when a column is exported.
         * ```typescript
         * this.exporterService.onColumnExport.subscribe((args: IColumnExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxBaseExporter
         */

        this.onColumnExport = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * Method for exporting IgxGrid component's data.
       * ```typescript
       * this.exporterService.export(this.igxGridForExport, this.exportOptions);
       * ```
       * \@memberof IgxBaseExporter
       * @param {?} grid
       * @param {?} options
       * @return {?}
       */


      _createClass(IgxBaseExporter, [{
        key: "export",
        value: function _export(grid, options) {
          var _this5 = this;

          if (options === undefined || options === null) {
            throw Error('No options provided!');
          }
          /** @type {?} */


          var columns = grid.columnList.toArray();
          this._columnList = new Array(columns.length);
          /** @type {?} */

          var hiddenColumns = [];
          /** @type {?} */

          var lastVisbleColumnIndex = -1;
          columns.forEach(function (column) {
            /** @type {?} */
            var columnHeader = column.header !== '' ? column.header : column.field;
            /** @type {?} */

            var exportColumn = !column.hidden || options.ignoreColumnsVisibility;
            /** @type {?} */

            var index = options.ignoreColumnsOrder ? column.index : column.visibleIndex;
            /** @type {?} */

            var columnInfo = {
              header: columnHeader,
              field: column.field,
              skip: !exportColumn,
              formatter: column.formatter,
              skipFormatter: false
            };

            if (index !== -1) {
              _this5._columnList[index] = columnInfo;
              lastVisbleColumnIndex = Math.max(lastVisbleColumnIndex, index);
            } else {
              hiddenColumns.push(columnInfo);
            }

            if (column.pinned && exportColumn) {
              _this5._indexOfLastPinnedColumn++;
            }
          }); // Append the hidden columns to the end of the list

          hiddenColumns.forEach(function (hiddenColumn) {
            _this5._columnList[++lastVisbleColumnIndex] = hiddenColumn;
          });
          /** @type {?} */

          var data = this.prepareData(grid, options);
          this.exportData(data, options);
        }
        /**
         * Method for exporting any kind of array data.
         * ```typescript
         * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
         * ```
         * \@memberof IgxBaseExporter
         * @param {?} data
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "exportData",
        value: function exportData(data, options) {
          var _this6 = this;

          if (options === undefined || options === null) {
            throw Error('No options provided!');
          }

          if (!this._columnList || this._columnList.length === 0) {
            /** @type {?} */
            var keys = ExportUtilities.getKeysFromData(data);
            this._columnList = keys.map(function (k) {
              return {
                header: k,
                field: k,
                skip: false
              };
            });
          }
          /** @type {?} */


          var skippedPinnedColumnsCount = 0;
          /** @type {?} */

          var columnsWithoutHeaderCount = 1;

          this._columnList.forEach(function (column, index) {
            if (!column.skip) {
              /** @type {?} */
              var columnExportArgs = {
                header: ExportUtilities.isNullOrWhitespaces(column.header) ? 'Column' + columnsWithoutHeaderCount++ : column.header,
                field: column.field,
                columnIndex: index,
                cancel: false,
                skipFormatter: false
              };

              _this6.onColumnExport.emit(columnExportArgs);

              column.header = columnExportArgs.header;
              column.skip = columnExportArgs.cancel;
              column.skipFormatter = columnExportArgs.skipFormatter;

              if (column.skip && index <= _this6._indexOfLastPinnedColumn) {
                skippedPinnedColumnsCount++;
              }

              if (_this6._sort && _this6._sort.fieldName === column.field) {
                if (column.skip) {
                  _this6._sort = null;
                } else {
                  _this6._sort.fieldName = column.header;
                }
              }
            }
          });

          this._indexOfLastPinnedColumn -= skippedPinnedColumnsCount;
          /** @type {?} */

          var dataToExport = new Array();
          /** @type {?} */

          var isSpecialData = ExportUtilities.isSpecialData(data);
          data.forEach(function (row, index) {
            _this6.exportRow(dataToExport, row, index, isSpecialData);
          });
          this.exportDataImplementation(dataToExport, options);
          this.resetDefaults();
        }
        /**
         * @private
         * @param {?} data
         * @param {?} rowData
         * @param {?} index
         * @param {?} isSpecialData
         * @return {?}
         */

      }, {
        key: "exportRow",
        value: function exportRow(data, rowData, index, isSpecialData) {
          var _this7 = this;

          /** @type {?} */
          var row;

          if (!isSpecialData) {
            row = this._columnList.reduce(function (a, e) {
              if (!e.skip) {
                /** @type {?} */
                var rawValue = _this7._isTreeGrid ? rowData.data[e.field] : rowData[e.field];
                a[e.header] = e.formatter && !e.skipFormatter ? e.formatter(rawValue) : rawValue;
              }

              return a;
            }, {});
          } else {
            row = this._isTreeGrid ? rowData.data : rowData;
          }
          /** @type {?} */


          var rowArgs = {
            rowData: row,
            rowIndex: index,
            cancel: false
          };
          this.onRowExport.emit(rowArgs);

          if (!rowArgs.cancel) {
            data.push({
              rowData: rowArgs.rowData,
              originalRowData: rowData
            });
          }
        }
        /**
         * @private
         * @param {?} grid
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "prepareData",
        value: function prepareData(grid, options) {
          this.flatRecords = [];
          /** @type {?} */

          var rootRecords = grid.rootRecords;
          this._isTreeGrid = rootRecords !== undefined;

          if (this._isTreeGrid) {
            this.prepareHierarchicalData(rootRecords);
          }
          /** @type {?} */


          var data = this._isTreeGrid ? this.flatRecords : grid.data;

          if ((grid.filteringExpressionsTree && grid.filteringExpressionsTree.filteringOperands.length > 0 || grid.advancedFilteringExpressionsTree && grid.advancedFilteringExpressionsTree.filteringOperands.length > 0) && !options.ignoreFiltering) {
            /** @type {?} */
            var filteringState = {
              expressionsTree: grid.filteringExpressionsTree,
              advancedExpressionsTree: grid.advancedFilteringExpressionsTree,
              logic: grid.filteringLogic
            };

            if (this._isTreeGrid) {
              this.flatRecords = [];
              filteringState.strategy = new TreeGridFilteringStrategy();
              rootRecords = filteringState.strategy.filter(rootRecords, filteringState.expressionsTree, filteringState.advancedExpressionsTree);
              this.prepareHierarchicalData(rootRecords);
              data = this.flatRecords;
            } else {
              data = DataUtil.filter(data, filteringState);
            }
          }

          if (grid.sortingExpressions && grid.sortingExpressions.length > 0 && !options.ignoreSorting) {
            this._sort = cloneValue(grid.sortingExpressions[0]);

            if (this._isTreeGrid) {
              this.flatRecords = [];
              rootRecords = DataUtil.treeGridSort(rootRecords, grid.sortingExpressions);
              this.prepareHierarchicalData(rootRecords);
              data = this.flatRecords;
            } else {
              data = DataUtil.sort(data, grid.sortingExpressions);
            }
          }

          return data;
        }
        /**
         * @private
         * @param {?} records
         * @return {?}
         */

      }, {
        key: "prepareHierarchicalData",
        value: function prepareHierarchicalData(records) {
          if (!records) {
            return;
          }

          for (var i = 0; i < records.length; i++) {
            /** @type {?} */
            var hierarchicalRecord = records[i];
            this.flatRecords.push(hierarchicalRecord);
            this.prepareHierarchicalData(hierarchicalRecord.children);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "resetDefaults",
        value: function resetDefaults() {
          this._columnList = [];
          this._indexOfLastPinnedColumn = -1;
          this._sort = null;
          this.flatRecords = [];
        }
      }]);

      return IgxBaseExporter;
    }();

    IgxBaseExporter.propDecorators = {
      onRowExport: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onColumnExport: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var CharSeparatedValueData =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _data
       * @param {?} valueDelimiter
       */
      function CharSeparatedValueData(_data, valueDelimiter) {
        _classCallCheck(this, CharSeparatedValueData);

        this._data = _data;
        this._headerRecord = '';
        this._dataRecords = '';
        this._eor = '\r\n';
        this._escapeCharacters = ['\r', '\n', '\r\n'];
        this._delimiterLength = 1;
        this._isSpecialData = false;
        this.setDelimiter(valueDelimiter);
      }
      /**
       * @return {?}
       */


      _createClass(CharSeparatedValueData, [{
        key: "prepareData",
        value: function prepareData() {
          if (!this._data || this._data.length === 0) {
            return '';
          }
          /** @type {?} */


          var keys = ExportUtilities.getKeysFromData(this._data);

          if (keys.length === 0) {
            return '';
          }

          this._isSpecialData = ExportUtilities.isSpecialData(this._data);

          this._escapeCharacters.push(this._delimiter);

          this._headerRecord = this.processHeaderRecord(keys, this._escapeCharacters);
          this._dataRecords = this.processDataRecords(this._data, keys, this._escapeCharacters);
          return this._headerRecord + this._dataRecords;
        }
        /**
         * @private
         * @param {?} value
         * @param {?} escapeChars
         * @return {?}
         */

      }, {
        key: "processField",
        value: function processField(value, escapeChars) {
          /** @type {?} */
          var safeValue = ExportUtilities.hasValue(value) ? String(value) : '';

          if (escapeChars.some(function (v) {
            return safeValue.includes(v);
          })) {
            safeValue = "\"".concat(safeValue, "\"");
          }

          return safeValue + this._delimiter;
        }
        /**
         * @private
         * @param {?} keys
         * @param {?} escapeChars
         * @return {?}
         */

      }, {
        key: "processHeaderRecord",
        value: function processHeaderRecord(keys, escapeChars) {
          /** @type {?} */
          var recordData = '';
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = keys[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var keyName = _step7.value;
              recordData += this.processField(keyName, this._escapeCharacters);
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                _iterator7["return"]();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }

          return recordData.slice(0, -this._delimiterLength) + this._eor;
        }
        /**
         * @private
         * @param {?} record
         * @param {?} keys
         * @param {?} escapeChars
         * @return {?}
         */

      }, {
        key: "processRecord",
        value: function processRecord(record, keys, escapeChars) {
          /** @type {?} */
          var recordData = '';
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = keys[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var keyName = _step8.value;

              /** @type {?} */
              var value = record[keyName] !== undefined ? record[keyName] : this._isSpecialData ? record : '';
              recordData += this.processField(value, this._escapeCharacters);
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                _iterator8["return"]();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }

          return recordData.slice(0, -this._delimiterLength) + this._eor;
        }
        /**
         * @private
         * @param {?} currentData
         * @param {?} keys
         * @param {?} escapeChars
         * @return {?}
         */

      }, {
        key: "processDataRecords",
        value: function processDataRecords(currentData, keys, escapeChars) {
          /** @type {?} */
          var dataRecords = '';
          var _iteratorNormalCompletion9 = true;
          var _didIteratorError9 = false;
          var _iteratorError9 = undefined;

          try {
            for (var _iterator9 = currentData[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
              var row = _step9.value;
              dataRecords += this.processRecord(row, keys, escapeChars);
            }
          } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                _iterator9["return"]();
              }
            } finally {
              if (_didIteratorError9) {
                throw _iteratorError9;
              }
            }
          }

          return dataRecords;
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setDelimiter",
        value: function setDelimiter(value) {
          this._delimiter = value;
          this._delimiterLength = value.length;
        }
      }]);

      return CharSeparatedValueData;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @abstract
     */


    var IgxExporterOptionsBase =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} fileName
       * @param {?} _fileExtension
       */
      function IgxExporterOptionsBase(fileName, _fileExtension) {
        _classCallCheck(this, IgxExporterOptionsBase);

        this._fileExtension = _fileExtension;
        /**
         * Specifies whether hidden columns should be exported.
         * ```typescript
         * let ignoreColumnsVisibility = this.exportOptions.ignoreColumnsVisibility;
         * this.exportOptions.ignoreColumnsVisibility = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */

        this.ignoreColumnsVisibility = false;
        /**
         * Specifies whether filtered out rows should be exported.
         * ```typescript
         * let ignoreFiltering = this.exportOptions.ignoreFiltering;
         * this.exportOptions.ignoreFiltering = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */

        this.ignoreFiltering = false;
        /**
         * Specifies if the exporter should ignore the current column order in the IgxGrid.
         * ```typescript
         * let ignoreColumnsOrder = this.exportOptions.ignoreColumnsOrder;
         * this.exportOptions.ignoreColumnsOrder = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */

        this.ignoreColumnsOrder = false;
        /**
         * Specifies whether the exported data should be sorted as in the provided IgxGrid.
         * ```typescript
         * let ignoreSorting = this.exportOptions.ignoreSorting;
         * this.exportOptions.ignoreSorting = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */

        this.ignoreSorting = false;
        this.setFileName(fileName);
      }
      /**
       * @private
       * @param {?} fileName
       * @return {?}
       */


      _createClass(IgxExporterOptionsBase, [{
        key: "setFileName",
        value: function setFileName(fileName) {
          this._fileName = fileName + (fileName.endsWith(this._fileExtension) === false ? this._fileExtension : '');
        }
        /**
         * Gets the file name which will be used for the exporting operation.
         * ```typescript
         * let fileName = this.exportOptions.fileName;
         * ```
         * \@memberof IgxExporterOptionsBase
         * @return {?}
         */

      }, {
        key: "fileName",
        get: function get() {
          return this._fileName;
        }
        /**
         * Sets the file name which will be used for the exporting operation.
         * ```typescript
         * this.exportOptions.fileName = 'exportedData01';
         * ```
         * \@memberof IgxExporterOptionsBase
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.setFileName(value);
        }
      }]);

      return IgxExporterOptionsBase;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Objects of this class are used to configure the CSV exporting process.
     */


    var IgxCsvExporterOptions =
    /*#__PURE__*/
    function (_IgxExporterOptionsBa) {
      _inherits(IgxCsvExporterOptions, _IgxExporterOptionsBa);

      /**
       * @param {?} fileName
       * @param {?} fileType
       */
      function IgxCsvExporterOptions(fileName, fileType) {
        var _this8;

        _classCallCheck(this, IgxCsvExporterOptions);

        _this8 = _possibleConstructorReturn(this, _getPrototypeOf(IgxCsvExporterOptions).call(this, fileName, IgxCsvExporterOptions.getExtensionFromFileType(fileType)));

        _this8.setFileType(fileType);

        _this8.setDelimiter();

        return _this8;
      }
      /**
       * @private
       * @param {?} fType
       * @return {?}
       */


      _createClass(IgxCsvExporterOptions, [{
        key: "setFileType",

        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        value: function setFileType(value) {
          if (value !== undefined && value !== null && value !== this._fileType) {
            this._fileType = value;
            /** @type {?} */

            var extension = IgxCsvExporterOptions.getExtensionFromFileType(value);

            if (!this.fileName.endsWith(extension)) {
              /** @type {?} */
              var oldExt = '.' + this.fileName.split('.').pop();
              /** @type {?} */

              var newName = this.fileName.replace(oldExt, extension);
              this._fileExtension = extension;
              this.fileName = newName;
            }
          }
        }
        /**
         * @private
         * @param {?=} value
         * @return {?}
         */

      }, {
        key: "setDelimiter",
        value: function setDelimiter(value) {
          if (value !== undefined && value !== '' && value !== null) {
            this._valueDelimiter = value;
          } else {
            switch (this.fileType) {
              case CsvFileTypes.CSV:
                this._valueDelimiter = ',';
                break;

              case CsvFileTypes.TSV:
              case CsvFileTypes.TAB:
                this._valueDelimiter = '\t';
                break;
            }
          }
        }
      }, {
        key: "valueDelimiter",

        /**
         * Gets the value delimiter which will be used for the exporting operation.
         * ```typescript
         * let delimiter = this.exportOptions.valueDelimiter;
         * ```
         * \@memberof IgxCsvExporterOptions
         * @return {?}
         */
        get: function get() {
          return this._valueDelimiter;
        }
        /**
         * Sets a value delimiter which will overwrite the default delimiter of the selected export format.
         * ```typescript
         * this.exportOptions.valueDelimiter = '|';
         * ```
         * \@memberof IgxCsvExporterOptions
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.setDelimiter(value);
        }
        /**
         * Gets the CSV export format.
         * ```typescript
         * let filetype = this.exportOptions.fileType;
         * ```
         * \@memberof IgxCsvExporterOptions
         * @return {?}
         */

      }, {
        key: "fileType",
        get: function get() {
          return this._fileType;
        }
        /**
         * Sets the CSV export format.
         * ```typescript
         * this.exportOptions.fileType = CsvFileTypes.TAB;
         * ```
         * \@memberof IgxCsvExporterOptions
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.setFileType(value);
        }
      }], [{
        key: "getExtensionFromFileType",
        value: function getExtensionFromFileType(fType) {
          /** @type {?} */
          var extension = '';

          switch (fType) {
            case CsvFileTypes.CSV:
              extension = '.csv';
              break;

            case CsvFileTypes.TSV:
              extension = '.tsv';
              break;

            case CsvFileTypes.TAB:
              extension = '.tab';
              break;

            default:
              throw Error('Unsupported CSV file type!');
          }

          return extension;
        }
      }]);

      return IgxCsvExporterOptions;
    }(IgxExporterOptionsBase);
    /** @enum {number} */


    var CsvFileTypes = {
      /**
       * Character Separated Values, default separator is "comma", default file extension is .csv
       */
      CSV: 0,

      /**
       * Tab Separated Values, default separator is tab, default file extension is .tsv
       */
      TSV: 1,

      /**
       * Tab Separated Values, default separator is tab, default file extension is .tab
       */
      TAB: 2
    };
    CsvFileTypes[CsvFileTypes.CSV] = 'CSV';
    CsvFileTypes[CsvFileTypes.TSV] = 'TSV';
    CsvFileTypes[CsvFileTypes.TAB] = 'TAB';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * **Ignite UI for Angular CSV Exporter Service** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_csv.html)
     *
     * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from
     * both raw data (array) or from an `IgxGrid`.
     *
     * Example:
     * ```typescript
     * public localData = [
     *   { Name: "Eric Ridley", Age: "26" },
     *   { Name: "Alanis Brook", Age: "22" },
     *   { Name: "Jonathan Morris", Age: "23" }
     * ];
     *
     * constructor(private csvExportService: IgxCsvExporterService) {
     * }
     *
     * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions("FileName", CsvFileTypes.CSV);
     * this.csvExportService.exportData(this.localData, opt);
     * ```
     */

    var IgxCsvExporterService =
    /*#__PURE__*/
    function (_IgxBaseExporter) {
      _inherits(IgxCsvExporterService, _IgxBaseExporter);

      function IgxCsvExporterService() {
        var _this9;

        _classCallCheck(this, IgxCsvExporterService);

        _this9 = _possibleConstructorReturn(this, _getPrototypeOf(IgxCsvExporterService).apply(this, arguments));
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: ICsvExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxCsvExporterService
         */

        _this9.onExportEnded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this9;
      }
      /**
       * @protected
       * @param {?} data
       * @param {?} options
       * @return {?}
       */


      _createClass(IgxCsvExporterService, [{
        key: "exportDataImplementation",
        value: function exportDataImplementation(data, options) {
          data = data.map(function (item) {
            return item.rowData;
          });
          /** @type {?} */

          var csvData = new CharSeparatedValueData(data, options.valueDelimiter);
          this._stringData = csvData.prepareData();
          this.saveFile(options);
          this.onExportEnded.emit({
            csvData: this._stringData
          });
        }
        /**
         * @private
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "saveFile",
        value: function saveFile(options) {
          switch (options.fileType) {
            case CsvFileTypes.CSV:
              this.exportFile(this._stringData, options.fileName, 'text/csv;charset=utf-8;');
              break;

            case CsvFileTypes.TSV:
            case CsvFileTypes.TAB:
              this.exportFile(this._stringData, options.fileName, 'text/tab-separated-values;charset=utf-8;');
              break;
          }
        }
        /**
         * @private
         * @param {?} data
         * @param {?} fileName
         * @param {?} fileType
         * @return {?}
         */

      }, {
        key: "exportFile",
        value: function exportFile(data, fileName, fileType) {
          /** @type {?} */
          var blob = new Blob(["\uFEFF", data], {
            type: fileType
          });
          ExportUtilities.saveBlobToFile(blob, fileName);
        }
      }]);

      return IgxCsvExporterService;
    }(IgxBaseExporter);

    IgxCsvExporterService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    IgxCsvExporterService.propDecorators = {
      onExportEnded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var ExcelFolderTypes = {
      RootExcelFolder: 0,
      RootRelsExcelFolder: 1,
      DocPropsExcelFolder: 2,
      XLExcelFolder: 3,
      XLRelsExcelFolder: 4,
      ThemeExcelFolder: 5,
      WorksheetsExcelFolder: 6,
      WorksheetsRelsExcelFolder: 7,
      TablesExcelFolder: 8
    };
    ExcelFolderTypes[ExcelFolderTypes.RootExcelFolder] = 'RootExcelFolder';
    ExcelFolderTypes[ExcelFolderTypes.RootRelsExcelFolder] = 'RootRelsExcelFolder';
    ExcelFolderTypes[ExcelFolderTypes.DocPropsExcelFolder] = 'DocPropsExcelFolder';
    ExcelFolderTypes[ExcelFolderTypes.XLExcelFolder] = 'XLExcelFolder';
    ExcelFolderTypes[ExcelFolderTypes.XLRelsExcelFolder] = 'XLRelsExcelFolder';
    ExcelFolderTypes[ExcelFolderTypes.ThemeExcelFolder] = 'ThemeExcelFolder';
    ExcelFolderTypes[ExcelFolderTypes.WorksheetsExcelFolder] = 'WorksheetsExcelFolder';
    ExcelFolderTypes[ExcelFolderTypes.WorksheetsRelsExcelFolder] = 'WorksheetsRelsExcelFolder';
    ExcelFolderTypes[ExcelFolderTypes.TablesExcelFolder] = 'TablesExcelFolder';
    /** @enum {number} */

    var ExcelFileTypes = {
      RootRelsFile: 0,
      AppFile: 1,
      CoreFile: 2,
      WorkbookRelsFile: 3,
      ThemeFile: 4,
      WorksheetFile: 5,
      StyleFile: 6,
      WorkbookFile: 7,
      ContentTypesFile: 8,
      SharedStringsFile: 9,
      WorksheetRelsFile: 10,
      TablesFile: 11
    };
    ExcelFileTypes[ExcelFileTypes.RootRelsFile] = 'RootRelsFile';
    ExcelFileTypes[ExcelFileTypes.AppFile] = 'AppFile';
    ExcelFileTypes[ExcelFileTypes.CoreFile] = 'CoreFile';
    ExcelFileTypes[ExcelFileTypes.WorkbookRelsFile] = 'WorkbookRelsFile';
    ExcelFileTypes[ExcelFileTypes.ThemeFile] = 'ThemeFile';
    ExcelFileTypes[ExcelFileTypes.WorksheetFile] = 'WorksheetFile';
    ExcelFileTypes[ExcelFileTypes.StyleFile] = 'StyleFile';
    ExcelFileTypes[ExcelFileTypes.WorkbookFile] = 'WorkbookFile';
    ExcelFileTypes[ExcelFileTypes.ContentTypesFile] = 'ContentTypesFile';
    ExcelFileTypes[ExcelFileTypes.SharedStringsFile] = 'SharedStringsFile';
    ExcelFileTypes[ExcelFileTypes.WorksheetRelsFile] = 'WorksheetRelsFile';
    ExcelFileTypes[ExcelFileTypes.TablesFile] = 'TablesFile';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var ExcelStrings =
    /*#__PURE__*/
    function () {
      function ExcelStrings() {
        _classCallCheck(this, ExcelStrings);
      }

      _createClass(ExcelStrings, null, [{
        key: "getRels",

        /**
         * @return {?}
         */
        value: function getRels() {
          return ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
        }
        /**
         * @return {?}
         */

      }, {
        key: "getApp",
        value: function getApp() {
          return ExcelStrings.XML_STRING + '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>';
        }
        /**
         * @return {?}
         */

      }, {
        key: "getCore",
        value: function getCore() {
          return ExcelStrings.XML_STRING + '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator></dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2015-06-05T18:17:20Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2015-06-05T18:17:26Z</dcterms:modified></cp:coreProperties>';
        }
        /**
         * @return {?}
         */

      }, {
        key: "getTheme",
        value: function getTheme() {
          return ExcelStrings.XML_STRING + '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="5B9BD5"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="4472C4"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック Light"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线 Light"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>';
        }
        /**
         * @param {?} hasNonStringValues
         * @return {?}
         */

      }, {
        key: "getStyles",
        value: function getStyles(hasNonStringValues) {
          /** @type {?} */
          var additionalCellXF = '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
          /** @type {?} */

          var cellXFCount = hasNonStringValues ? 2 : 1;
          return ExcelStrings.XML_STRING + '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="' + cellXFCount + '"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>' + additionalCellXF + '</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
        }
        /**
         * @return {?}
         */

      }, {
        key: "getWorkbook",
        value: function getWorkbook() {
          return ExcelStrings.XML_STRING + '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><fileVersion appName="xl" lastEdited="6" lowestEdited="6" rupBuild="14420"/><workbookPr filterPrivacy="1" defaultThemeVersion="164011"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="22260" windowHeight="12645"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="162913"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>';
        }
        /**
         * @return {?}
         */

      }, {
        key: "getWorksheetRels",
        value: function getWorksheetRels() {
          return ExcelStrings.XML_STRING + "<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/table\" Target=\"../tables/table1.xml\"/></Relationships>";
        }
        /**
         * @param {?} hasSharedStrings
         * @return {?}
         */

      }, {
        key: "getWorkbookRels",
        value: function getWorkbookRels(hasSharedStrings) {
          /** @type {?} */
          var retVal = ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>';

          if (hasSharedStrings) {
            retVal += ExcelStrings.SHARED_STRING_RELATIONSHIP;
          }

          retVal += '</Relationships>';
          return retVal;
        }
        /**
         * @param {?} dimension
         * @param {?} freezePane
         * @param {?} cols
         * @param {?} sheetData
         * @param {?} hasTable
         * @param {?=} hasGroupedRows
         * @param {?=} outlineLevel
         * @return {?}
         */

      }, {
        key: "getSheetXML",
        value: function getSheetXML(dimension, freezePane, cols, sheetData, hasTable) {
          var hasGroupedRows = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
          var outlineLevel = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;

          /** @type {?} */
          var tableParts = hasTable ? '<tableParts count="1"><tablePart r:id="rId1"/></tableParts>' : '';
          /** @type {?} */

          var sheetOutlineProp = hasGroupedRows ? '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>' : '';
          /** @type {?} */

          var sOutlineLevel = outlineLevel > 0 ? "outlineLevelRow=\"".concat(outlineLevel, "\"") : ''; // return ExcelStrings.XML_STRING +
          //     '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><dimension ref="' + dimension + '"/><sheetViews><sheetView tabSelected="1" workbookViewId="0">' + freezePane + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/>' + cols + sheetData + '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>' + tableParts + '</worksheet>';

          return "".concat(ExcelStrings.XML_STRING, "\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">\n").concat(sheetOutlineProp, "\n<dimension ref=\"").concat(dimension, "\"/>\n<sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\">").concat(freezePane, "</sheetView></sheetViews>\n<sheetFormatPr defaultRowHeight=\"15\" ").concat(sOutlineLevel, " x14ac:dyDescent=\"0.25\"/>\n").concat(cols, "\n").concat(sheetData, "\n<pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\"/>\n").concat(tableParts, "</worksheet>");
        }
        /**
         * @param {?} count
         * @param {?} uniqueCount
         * @param {?} table
         * @return {?}
         */

      }, {
        key: "getSharedStringXML",
        value: function getSharedStringXML(count, uniqueCount, table) {
          return ExcelStrings.XML_STRING + '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">' + table + '</sst>';
        }
        /**
         * @param {?} hasSharedStrings
         * @param {?} hasTable
         * @return {?}
         */

      }, {
        key: "getContentTypesXML",
        value: function getContentTypesXML(hasSharedStrings, hasTable) {
          /** @type {?} */
          var contentTypes = ExcelStrings.XML_STRING + "<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">\n            <Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"/>\n            <Default Extension=\"xml\" ContentType=\"application/xml\"/>\n            <Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"/>\n            <Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"/>\n            <Override PartName=\"/xl/theme/theme1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.theme+xml\"/>\n            <Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"/>\n            <Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\"/>\n            <Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\"/>";
          contentTypes += hasSharedStrings ? "\t<Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\"/>" : '';
          contentTypes += hasTable ? "<Override PartName=\"/xl/tables/table1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\"/>" : '';
          contentTypes += "</Types>";
          return contentTypes;
        }
        /**
         * @param {?} dimension
         * @param {?} tableColumns
         * @param {?} sort
         * @return {?}
         */

      }, {
        key: "getTablesXML",
        value: function getTablesXML(dimension, tableColumns, sort) {
          return "".concat(ExcelStrings.XML_STRING, "<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"").concat(dimension, "\" totalsRowShown=\"0\">\n    <autoFilter ref=\"").concat(dimension, "\"/>").concat(sort).concat(tableColumns, "<tableStyleInfo name=\"TableStyleMedium2\" showFirstColumn=\"0\" showLastColumn=\"0\" showRowStripes=\"1\" showColumnStripes=\"0\"/>\n</table>");
        }
        /* tslint:enable max-line-length */

        /**
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "getExcelColumn",
        value: function getExcelColumn(index) {
          // Returns the excel column name for given 0-based index
          // For example 27 should return "AB"

          /** @type {?} */
          var returnString = '';

          while (index >= 0) {
            /** @type {?} */
            var _char = index % 26;

            returnString = String.fromCharCode(65 + _char) + returnString;
            index = Math.floor(index / 26) - 1;
          }

          return returnString;
        }
      }]);

      return ExcelStrings;
    }();
    /* tslint:disable max-line-length */


    ExcelStrings.XML_STRING = '<?xml version="1.0" encoding="UTF-8"?>\r\n';
    ExcelStrings.SHARED_STRING_RELATIONSHIP = '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var RootRelsFile =
    /*#__PURE__*/
    function () {
      function RootRelsFile() {
        _classCallCheck(this, RootRelsFile);
      }

      _createClass(RootRelsFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          folder.file('.rels', ExcelStrings.getRels());
        }
      }]);

      return RootRelsFile;
    }();
    /**
     * @hidden
     */


    var AppFile =
    /*#__PURE__*/
    function () {
      function AppFile() {
        _classCallCheck(this, AppFile);
      }

      _createClass(AppFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          folder.file('app.xml', ExcelStrings.getApp());
        }
      }]);

      return AppFile;
    }();
    /**
     * @hidden
     */


    var CoreFile =
    /*#__PURE__*/
    function () {
      function CoreFile() {
        _classCallCheck(this, CoreFile);
      }

      _createClass(CoreFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          folder.file('core.xml', ExcelStrings.getCore());
        }
      }]);

      return CoreFile;
    }();
    /**
     * @hidden
     */


    var WorkbookRelsFile =
    /*#__PURE__*/
    function () {
      function WorkbookRelsFile() {
        _classCallCheck(this, WorkbookRelsFile);
      }

      _createClass(WorkbookRelsFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          /** @type {?} */
          var hasSharedStrings = worksheetData.isEmpty === false;
          folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
        }
      }]);

      return WorkbookRelsFile;
    }();
    /**
     * @hidden
     */


    var ThemeFile =
    /*#__PURE__*/
    function () {
      function ThemeFile() {
        _classCallCheck(this, ThemeFile);
      }

      _createClass(ThemeFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          folder.file('theme1.xml', ExcelStrings.getTheme());
        }
      }]);

      return ThemeFile;
    }();
    /**
     * @hidden
     */


    var WorksheetFile =
    /*#__PURE__*/
    function () {
      function WorksheetFile() {
        _classCallCheck(this, WorksheetFile);
      }

      _createClass(WorksheetFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          /** @type {?} */
          var sheetData = [];
          /** @type {?} */

          var cols = [];
          /** @type {?} */

          var dimension;
          /** @type {?} */

          var dictionary = worksheetData.dataDictionary;
          /** @type {?} */

          var freezePane = '';
          /** @type {?} */

          var maxOutlineLevel = 0;

          if (worksheetData.isEmpty) {
            sheetData.push('<sheetData/>');
            dimension = 'A1';
          } else {
            sheetData.push('<sheetData>');
            /** @type {?} */

            var height = worksheetData.options.rowHeight;
            /** @type {?} */

            var rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
            sheetData.push("<row r=\"1\"".concat(rowHeight, ">"));

            for (var i = 0; i < worksheetData.columnCount; i++) {
              /** @type {?} */
              var column = ExcelStrings.getExcelColumn(i) + 1;
              /** @type {?} */

              var value = dictionary.saveValue(worksheetData.keys[i], i, true);
              sheetData.push("<c r=\"".concat(column, "\" t=\"s\"><v>").concat(value, "</v></c>"));
            }

            sheetData.push('</row>');

            for (var _i4 = 1; _i4 < worksheetData.rowCount; _i4++) {
              if (!worksheetData.isTreeGridData) {
                sheetData.push("<row r=\"".concat(_i4 + 1, "\"").concat(rowHeight, ">"));
              } else {
                /** @type {?} */
                var rowData = worksheetData.data[_i4 - 1].originalRowData;
                /** @type {?} */

                var sCollapsed = !rowData.expanded ? '' : rowData.expanded === true ? '' : " collapsed=\"1\"";
                /** @type {?} */

                var sHidden = rowData.parent && this.hasCollapsedParent(rowData) ? " hidden=\"1\"" : '';
                /** @type {?} */

                var rowOutlineLevel = rowData.level ? rowData.level : 0;
                /** @type {?} */

                var sOutlineLevel = rowOutlineLevel > 0 ? " outlineLevel=\"".concat(rowOutlineLevel, "\"") : '';
                maxOutlineLevel = maxOutlineLevel < rowOutlineLevel ? rowOutlineLevel : maxOutlineLevel;
                sheetData.push("<row r=\"".concat(_i4 + 1, "\"").concat(rowHeight).concat(sOutlineLevel).concat(sCollapsed).concat(sHidden, ">"));
              }

              for (var j = 0; j < worksheetData.columnCount; j++) {
                /** @type {?} */
                var cellData = WorksheetFile.getCellData(worksheetData, _i4, j);
                sheetData.push(cellData);
              }

              sheetData.push('</row>');
            }

            sheetData.push('</sheetData>');
            dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
            cols.push('<cols>');

            for (var _i5 = 0; _i5 < worksheetData.columnCount; _i5++) {
              /** @type {?} */
              var width = dictionary.columnWidths[_i5]; // Use the width provided in the options if it exists

              /** @type {?} */

              var widthInTwips = worksheetData.options.columnWidth ? worksheetData.options.columnWidth : Math.max(width / 96 * 14.4, WorksheetFile.MIN_WIDTH);
              cols.push("<col min=\"".concat(_i5 + 1, "\" max=\"").concat(_i5 + 1, "\" width=\"").concat(widthInTwips, "\" customWidth=\"1\"/>"));
            }

            cols.push('</cols>');

            if (worksheetData.indexOfLastPinnedColumn !== -1 && !worksheetData.options.ignorePinning && !worksheetData.options.ignoreColumnsOrder) {
              /** @type {?} */
              var frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
              /** @type {?} */

              var firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
              freezePane = "<pane xSplit=\"".concat(frozenColumnCount, "\" topLeftCell=\"").concat(firstCell, "\" activePane=\"topRight\" state=\"frozen\"/>");
            }
          }
          /** @type {?} */


          var hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
          folder.file('sheet1.xml', ExcelStrings.getSheetXML(dimension, freezePane, cols.join(''), sheetData.join(''), hasTable, worksheetData.isTreeGridData, maxOutlineLevel));
        }
        /**
         * @private
         * @param {?} rowData
         * @return {?}
         */

      }, {
        key: "hasCollapsedParent",
        value: function hasCollapsedParent(rowData) {
          /** @type {?} */
          var result = !rowData.parent.expanded;

          while (rowData.parent) {
            result = result || !rowData.parent.expanded;
            rowData = rowData.parent;
          }

          return result;
        }
        /* tslint:disable member-ordering */

        /**
         * @private
         * @param {?} worksheetData
         * @param {?} row
         * @param {?} column
         * @return {?}
         */

      }], [{
        key: "getCellData",
        value: function getCellData(worksheetData, row, column) {
          /** @type {?} */
          var dictionary = worksheetData.dataDictionary;
          /** @type {?} */

          var columnName = ExcelStrings.getExcelColumn(column) + (row + 1);
          /** @type {?} */

          var columnHeader = worksheetData.keys[column];
          /** @type {?} */

          var rowData = worksheetData.data[row - 1].rowData;
          /** @type {?} */

          var cellValue = worksheetData.isSpecialData ? rowData : rowData[columnHeader];

          if (cellValue === undefined || cellValue === null) {
            return "<c r=\"".concat(columnName, "\" s=\"1\"/>");
          } else {
            /** @type {?} */
            var savedValue = dictionary.saveValue(cellValue, column, false);
            /** @type {?} */

            var isSavedAsString = savedValue !== -1;
            /** @type {?} */

            var value = isSavedAsString ? savedValue : cellValue;
            /** @type {?} */

            var type = isSavedAsString ? " t=\"s\"" : '';
            /** @type {?} */

            var format = isSavedAsString ? '' : " s=\"1\"";
            return "<c r=\"".concat(columnName, "\"").concat(type).concat(format, "><v>").concat(value, "</v></c>");
          }
        }
      }]);

      return WorksheetFile;
    }();

    WorksheetFile.MIN_WIDTH = 8.34;
    /**
     * @hidden
     */

    var StyleFile =
    /*#__PURE__*/
    function () {
      function StyleFile() {
        _classCallCheck(this, StyleFile);
      }

      _createClass(StyleFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          folder.file('styles.xml', ExcelStrings.getStyles(worksheetData.dataDictionary && worksheetData.dataDictionary.hasNonStringValues));
        }
      }]);

      return StyleFile;
    }();
    /**
     * @hidden
     */


    var WorkbookFile =
    /*#__PURE__*/
    function () {
      function WorkbookFile() {
        _classCallCheck(this, WorkbookFile);
      }

      _createClass(WorkbookFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          folder.file('workbook.xml', ExcelStrings.getWorkbook());
        }
      }]);

      return WorkbookFile;
    }();
    /**
     * @hidden
     */


    var ContentTypesFile =
    /*#__PURE__*/
    function () {
      function ContentTypesFile() {
        _classCallCheck(this, ContentTypesFile);
      }

      _createClass(ContentTypesFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
        }
      }]);

      return ContentTypesFile;
    }();
    /**
     * @hidden
     */


    var SharedStringsFile =
    /*#__PURE__*/
    function () {
      function SharedStringsFile() {
        _classCallCheck(this, SharedStringsFile);
      }

      _createClass(SharedStringsFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          /** @type {?} */
          var dict = worksheetData.dataDictionary;
          /** @type {?} */

          var sortedValues = dict.getKeys();
          /** @type {?} */

          var sharedStrings = new Array(sortedValues.length);
          var _iteratorNormalCompletion10 = true;
          var _didIteratorError10 = false;
          var _iteratorError10 = undefined;

          try {
            for (var _iterator10 = sortedValues[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
              var value = _step10.value;
              sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
            }
          } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                _iterator10["return"]();
              }
            } finally {
              if (_didIteratorError10) {
                throw _iteratorError10;
              }
            }
          }

          folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
        }
      }]);

      return SharedStringsFile;
    }();
    /**
     * @hidden
     */


    var TablesFile =
    /*#__PURE__*/
    function () {
      function TablesFile() {
        _classCallCheck(this, TablesFile);
      }

      _createClass(TablesFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          /** @type {?} */
          var columnCount = worksheetData.columnCount;
          /** @type {?} */

          var lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
          /** @type {?} */

          var dimension = 'A1:' + lastColumn;
          /** @type {?} */

          var values = worksheetData.keys;
          /** @type {?} */

          var sortString = '';
          /** @type {?} */

          var tableColumns = '<tableColumns count="' + columnCount + '">';

          for (var i = 0; i < columnCount; i++) {
            /** @type {?} */
            var value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
          }

          tableColumns += '</tableColumns>';

          if (worksheetData.sort) {
            /** @type {?} */
            var sortingExpression = worksheetData.sort;
            /** @type {?} */

            var sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            /** @type {?} */

            var dir = sortingExpression.dir - 1;
            sortString = "<sortState ref=\"A2:".concat(lastColumn, "\"><sortCondition descending=\"").concat(dir, "\" ref=\"").concat(sc, "1:").concat(sc, "15\"/></sortState>");
          }

          folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
        }
      }]);

      return TablesFile;
    }();
    /**
     * @hidden
     */


    var WorksheetRelsFile =
    /*#__PURE__*/
    function () {
      function WorksheetRelsFile() {
        _classCallCheck(this, WorksheetRelsFile);
      }

      _createClass(WorksheetRelsFile, [{
        key: "writeElement",

        /**
         * @param {?} folder
         * @param {?} worksheetData
         * @return {?}
         */
        value: function writeElement(folder, worksheetData) {
          folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
        }
      }]);

      return WorksheetRelsFile;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var RootExcelFolder =
    /*#__PURE__*/
    function () {
      function RootExcelFolder() {
        _classCallCheck(this, RootExcelFolder);
      }

      _createClass(RootExcelFolder, [{
        key: "childFiles",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function childFiles(data) {
          return [ExcelFileTypes.ContentTypesFile];
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "childFolders",
        value: function childFolders(data) {
          return [ExcelFolderTypes.RootRelsExcelFolder, ExcelFolderTypes.DocPropsExcelFolder, ExcelFolderTypes.XLExcelFolder];
        }
      }, {
        key: "folderName",

        /**
         * @return {?}
         */
        get: function get() {
          return '';
        }
      }]);

      return RootExcelFolder;
    }();
    /**
     * @hidden
     */


    var RootRelsExcelFolder =
    /*#__PURE__*/
    function () {
      function RootRelsExcelFolder() {
        _classCallCheck(this, RootRelsExcelFolder);
      }

      _createClass(RootRelsExcelFolder, [{
        key: "childFiles",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function childFiles(data) {
          return [ExcelFileTypes.RootRelsFile];
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "childFolders",
        value: function childFolders(data) {
          return [];
        }
      }, {
        key: "folderName",

        /**
         * @return {?}
         */
        get: function get() {
          return '_rels';
        }
      }]);

      return RootRelsExcelFolder;
    }();
    /**
     * @hidden
     */


    var DocPropsExcelFolder =
    /*#__PURE__*/
    function () {
      function DocPropsExcelFolder() {
        _classCallCheck(this, DocPropsExcelFolder);
      }

      _createClass(DocPropsExcelFolder, [{
        key: "childFiles",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function childFiles(data) {
          return [ExcelFileTypes.AppFile, ExcelFileTypes.CoreFile];
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "childFolders",
        value: function childFolders(data) {
          return [];
        }
      }, {
        key: "folderName",

        /**
         * @return {?}
         */
        get: function get() {
          return 'docProps';
        }
      }]);

      return DocPropsExcelFolder;
    }();
    /**
     * @hidden
     */


    var XLExcelFolder =
    /*#__PURE__*/
    function () {
      function XLExcelFolder() {
        _classCallCheck(this, XLExcelFolder);
      }

      _createClass(XLExcelFolder, [{
        key: "childFiles",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function childFiles(data) {
          /** @type {?} */
          var retVal = [ExcelFileTypes.StyleFile, ExcelFileTypes.WorkbookFile];

          if (!data.isEmpty) {
            retVal.push(ExcelFileTypes.SharedStringsFile);
          }

          return retVal;
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "childFolders",
        value: function childFolders(data) {
          /** @type {?} */
          var retVal = [ExcelFolderTypes.XLRelsExcelFolder, ExcelFolderTypes.ThemeExcelFolder, ExcelFolderTypes.WorksheetsExcelFolder];

          if (!data.isEmpty && data.options.exportAsTable) {
            retVal.push(ExcelFolderTypes.TablesExcelFolder);
          }

          return retVal;
        }
      }, {
        key: "folderName",

        /**
         * @return {?}
         */
        get: function get() {
          return 'xl';
        }
      }]);

      return XLExcelFolder;
    }();
    /**
     * @hidden
     */


    var XLRelsExcelFolder =
    /*#__PURE__*/
    function () {
      function XLRelsExcelFolder() {
        _classCallCheck(this, XLRelsExcelFolder);
      }

      _createClass(XLRelsExcelFolder, [{
        key: "childFiles",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function childFiles(data) {
          return [ExcelFileTypes.WorkbookRelsFile];
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "childFolders",
        value: function childFolders(data) {
          return [];
        }
      }, {
        key: "folderName",

        /**
         * @return {?}
         */
        get: function get() {
          return '_rels';
        }
      }]);

      return XLRelsExcelFolder;
    }();
    /**
     * @hidden
     */


    var ThemeExcelFolder =
    /*#__PURE__*/
    function () {
      function ThemeExcelFolder() {
        _classCallCheck(this, ThemeExcelFolder);
      }

      _createClass(ThemeExcelFolder, [{
        key: "childFiles",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function childFiles(data) {
          return [ExcelFileTypes.ThemeFile];
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "childFolders",
        value: function childFolders(data) {
          return [];
        }
      }, {
        key: "folderName",

        /**
         * @return {?}
         */
        get: function get() {
          return 'theme';
        }
      }]);

      return ThemeExcelFolder;
    }();
    /**
     * @hidden
     */


    var WorksheetsExcelFolder =
    /*#__PURE__*/
    function () {
      function WorksheetsExcelFolder() {
        _classCallCheck(this, WorksheetsExcelFolder);
      }

      _createClass(WorksheetsExcelFolder, [{
        key: "childFiles",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function childFiles(data) {
          return [ExcelFileTypes.WorksheetFile];
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "childFolders",
        value: function childFolders(data) {
          return data.isEmpty || !data.options.exportAsTable ? [] : [ExcelFolderTypes.WorksheetsRelsExcelFolder];
        }
      }, {
        key: "folderName",

        /**
         * @return {?}
         */
        get: function get() {
          return 'worksheets';
        }
      }]);

      return WorksheetsExcelFolder;
    }();
    /**
     * @hidden
     */


    var TablesExcelFolder =
    /*#__PURE__*/
    function () {
      function TablesExcelFolder() {
        _classCallCheck(this, TablesExcelFolder);
      }

      _createClass(TablesExcelFolder, [{
        key: "childFiles",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function childFiles(data) {
          return [ExcelFileTypes.TablesFile];
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "childFolders",
        value: function childFolders(data) {
          return [];
        }
      }, {
        key: "folderName",

        /**
         * @return {?}
         */
        get: function get() {
          return 'tables';
        }
      }]);

      return TablesExcelFolder;
    }();
    /**
     * @hidden
     */


    var WorksheetsRelsExcelFolder =
    /*#__PURE__*/
    function () {
      function WorksheetsRelsExcelFolder() {
        _classCallCheck(this, WorksheetsRelsExcelFolder);
      }

      _createClass(WorksheetsRelsExcelFolder, [{
        key: "childFiles",

        /**
         * @param {?} data
         * @return {?}
         */
        value: function childFiles(data) {
          return [ExcelFileTypes.WorksheetRelsFile];
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "childFolders",
        value: function childFolders(data) {
          return [];
        }
      }, {
        key: "folderName",

        /**
         * @return {?}
         */
        get: function get() {
          return '_rels';
        }
      }]);

      return WorksheetsRelsExcelFolder;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var ExcelElementsFactory =
    /*#__PURE__*/
    function () {
      function ExcelElementsFactory() {
        _classCallCheck(this, ExcelElementsFactory);
      }

      _createClass(ExcelElementsFactory, null, [{
        key: "getExcelFolder",

        /**
         * @param {?} type
         * @return {?}
         */
        value: function getExcelFolder(type) {
          switch (type) {
            case ExcelFolderTypes.RootExcelFolder:
              return new RootExcelFolder();

            case ExcelFolderTypes.RootRelsExcelFolder:
              return new RootRelsExcelFolder();

            case ExcelFolderTypes.DocPropsExcelFolder:
              return new DocPropsExcelFolder();

            case ExcelFolderTypes.XLExcelFolder:
              return new XLExcelFolder();

            case ExcelFolderTypes.XLRelsExcelFolder:
              return new XLRelsExcelFolder();

            case ExcelFolderTypes.ThemeExcelFolder:
              return new ThemeExcelFolder();

            case ExcelFolderTypes.WorksheetsExcelFolder:
              return new WorksheetsExcelFolder();

            case ExcelFolderTypes.WorksheetsRelsExcelFolder:
              return new WorksheetsRelsExcelFolder();

            case ExcelFolderTypes.TablesExcelFolder:
              return new TablesExcelFolder();

            default:
              throw new Error('Unknown excel folder type!');
          }
        }
        /**
         * @param {?} type
         * @return {?}
         */

      }, {
        key: "getExcelFile",
        value: function getExcelFile(type) {
          switch (type) {
            case ExcelFileTypes.RootRelsFile:
              return new RootRelsFile();

            case ExcelFileTypes.AppFile:
              return new AppFile();

            case ExcelFileTypes.CoreFile:
              return new CoreFile();

            case ExcelFileTypes.WorkbookRelsFile:
              return new WorkbookRelsFile();

            case ExcelFileTypes.ThemeFile:
              return new ThemeFile();

            case ExcelFileTypes.WorksheetFile:
              return new WorksheetFile();

            case ExcelFileTypes.StyleFile:
              return new StyleFile();

            case ExcelFileTypes.WorkbookFile:
              return new WorkbookFile();

            case ExcelFileTypes.ContentTypesFile:
              return new ContentTypesFile();

            case ExcelFileTypes.SharedStringsFile:
              return new SharedStringsFile();

            case ExcelFileTypes.WorksheetRelsFile:
              return new WorksheetRelsFile();

            case ExcelFileTypes.TablesFile:
              return new TablesFile();

            default:
              throw Error('Unknown excel file type!');
          }
        }
      }]);

      return ExcelElementsFactory;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var WorksheetDataDictionary =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} columnCount
       * @param {?} columnWidth
       */
      function WorksheetDataDictionary(columnCount, columnWidth) {
        _classCallCheck(this, WorksheetDataDictionary);

        this.hasNonStringValues = false;
        this._dictionary = {};
        this._widthsDictionary = {};
        this._counter = 0;
        this.dirtyKeyCollections();
        this._calculateColumnWidth = !columnWidth;
        this._columnWidths = new Array(columnCount);
        this._columnTypeInfo = new Array(columnCount);

        if (!this._calculateColumnWidth) {
          this._columnWidths.fill(columnWidth);
        }

        this.stringsCount = 0;
      }
      /**
       * @return {?}
       */


      _createClass(WorksheetDataDictionary, [{
        key: "saveValue",

        /**
         * @param {?} value
         * @param {?} column
         * @param {?} isHeader
         * @return {?}
         */
        value: function saveValue(value, column, isHeader) {
          if (this._columnTypeInfo[column] === undefined && isHeader === false) {
            this._columnTypeInfo[column] = typeof value === 'string' || typeof value === 'boolean' || value instanceof Date;
          }
          /** @type {?} */


          var sanitizedValue = '';
          /** @type {?} */

          var isSavedAsString = this._columnTypeInfo[column] || isHeader;

          if (isSavedAsString) {
            sanitizedValue = this.sanitizeValue(value);

            if (this._dictionary[sanitizedValue] === undefined) {
              this._dictionary[sanitizedValue] = this._counter++;
              this.dirtyKeyCollections();
            }

            this.stringsCount++;
          } else {
            this.hasNonStringValues = true;
          }

          if (this._calculateColumnWidth) {
            /** @type {?} */
            var width = this.getTextWidth(value);
            /** @type {?} */

            var maxWidth = Math.max(this._columnWidths[column] || 0, width);
            this._columnWidths[column] = maxWidth;
          }

          return isSavedAsString ? this.getSanitizedValue(sanitizedValue) : -1;
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "getValue",
        value: function getValue(value) {
          return this.getSanitizedValue(this.sanitizeValue(value));
        }
        /**
         * @param {?} sanitizedValue
         * @return {?}
         */

      }, {
        key: "getSanitizedValue",
        value: function getSanitizedValue(sanitizedValue) {
          return this._dictionary[sanitizedValue];
        }
        /**
         * @return {?}
         */

      }, {
        key: "getKeys",
        value: function getKeys() {
          if (!this._keysAreValid) {
            this._keys = Object.keys(this._dictionary);
            this._keysAreValid = true;
          }

          return this._keys;
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "getTextWidth",
        value: function getTextWidth(value) {
          if (this._widthsDictionary[value] === undefined) {
            /** @type {?} */
            var context = this.getContext();
            /** @type {?} */

            var metrics = context.measureText(value);
            this._widthsDictionary[value] = metrics.width + WorksheetDataDictionary.TEXT_PADDING;
          }

          return this._widthsDictionary[value];
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getContext",
        value: function getContext() {
          if (!this._context) {
            /** @type {?} */
            var canvas = document.createElement('canvas');
            this._context = canvas.getContext('2d');
            this._context.font = WorksheetDataDictionary.DEFAULT_FONT;
          }

          return this._context;
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "sanitizeValue",
        value: function sanitizeValue(value) {
          if (ExportUtilities.hasValue(value) === false) {
            return '';
          } else {
            /** @type {?} */
            var stringValue = String(value);
            return stringValue.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "dirtyKeyCollections",
        value: function dirtyKeyCollections() {
          this._keysAreValid = false;
        }
      }, {
        key: "columnWidths",
        get: function get() {
          return this._columnWidths;
        }
      }]);

      return WorksheetDataDictionary;
    }();

    WorksheetDataDictionary.DEFAULT_FONT = '11pt Calibri';
    WorksheetDataDictionary.TEXT_PADDING = 5;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var WorksheetData =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _data
       * @param {?} options
       * @param {?} indexOfLastPinnedColumn
       * @param {?} sort
       * @param {?=} isTreeGridData
       */
      function WorksheetData(_data, options, indexOfLastPinnedColumn, sort) {
        var isTreeGridData = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        _classCallCheck(this, WorksheetData);

        this._data = _data;
        this.options = options;
        this.indexOfLastPinnedColumn = indexOfLastPinnedColumn;
        this.sort = sort;
        this.isTreeGridData = isTreeGridData;
        this.initializeData();
      }
      /**
       * @return {?}
       */


      _createClass(WorksheetData, [{
        key: "initializeData",

        /**
         * @private
         * @return {?}
         */
        value: function initializeData() {
          if (!this._data || this._data.length === 0) {
            return;
          }
          /** @type {?} */


          var actualData = this._data.map(function (item) {
            return item.rowData;
          });

          this._keys = ExportUtilities.getKeysFromData(actualData);

          if (this._keys.length === 0) {
            return;
          }

          this._isSpecialData = ExportUtilities.isSpecialData(actualData);
          this._columnCount = this._keys.length;
          this._rowCount = this._data.length + 1;
          this._dataDictionary = new WorksheetDataDictionary(this._columnCount, this.options.columnWidth);
        }
      }, {
        key: "data",
        get: function get() {
          return this._data;
        }
        /**
         * @return {?}
         */

      }, {
        key: "columnCount",
        get: function get() {
          return this._columnCount;
        }
        /**
         * @return {?}
         */

      }, {
        key: "rowCount",
        get: function get() {
          return this._rowCount;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isEmpty",
        get: function get() {
          return !this.rowCount || !this._columnCount;
        }
        /**
         * @return {?}
         */

      }, {
        key: "keys",
        get: function get() {
          return this._keys;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isSpecialData",
        get: function get() {
          return this._isSpecialData;
        }
        /**
         * @return {?}
         */

      }, {
        key: "dataDictionary",
        get: function get() {
          return this._dataDictionary;
        }
      }]);

      return WorksheetData;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * **Ignite UI for Angular Excel Exporter Service** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)
     *
     * The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from both raw data
     * (array) or from an `IgxGrid`.
     *
     * Example:
     * ```typescript
     * public localData = [
     *   { Name: "Eric Ridley", Age: "26" },
     *   { Name: "Alanis Brook", Age: "22" },
     *   { Name: "Jonathan Morris", Age: "23" }
     * ];
     *
     * constructor(private excelExportService: IgxExcelExporterService) {
     * }
     *
     * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions("FileName"));
     * ```
     */


    var IgxExcelExporterService =
    /*#__PURE__*/
    function (_IgxBaseExporter2) {
      _inherits(IgxExcelExporterService, _IgxBaseExporter2);

      function IgxExcelExporterService() {
        var _this10;

        _classCallCheck(this, IgxExcelExporterService);

        _this10 = _possibleConstructorReturn(this, _getPrototypeOf(IgxExcelExporterService).apply(this, arguments));
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: IExcelExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxExcelExporterService
         */

        _this10.onExportEnded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this10;
      }
      /**
       * @private
       * @param {?} folder
       * @param {?} zip
       * @param {?} worksheetData
       * @return {?}
       */


      _createClass(IgxExcelExporterService, [{
        key: "exportDataImplementation",

        /**
         * @protected
         * @param {?} data
         * @param {?} options
         * @return {?}
         */
        value: function exportDataImplementation(data, options) {
          var _this11 = this;

          if (this._isTreeGrid) {
            /** @type {?} */
            var maxLevel = 0;
            data.forEach(function (r) {
              maxLevel = Math.max(maxLevel, r.originalRowData.level);
            });

            if (maxLevel > 7) {
              throw Error('Can create an outline of up to eight levels!');
            }
          }
          /** @type {?} */


          var worksheetData = new WorksheetData(data, options, this._indexOfLastPinnedColumn, this._sort, this._isTreeGrid);
          this._xlsx = new jszip_dist_jszip__WEBPACK_IMPORTED_MODULE_6__();
          /** @type {?} */

          var rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);
          IgxExcelExporterService.populateFolder(rootFolder, this._xlsx, worksheetData);

          this._xlsx.generateAsync(IgxExcelExporterService.ZIP_OPTIONS).then(function (result) {
            _this11.saveFile(result, options.fileName);

            _this11.onExportEnded.emit({
              xlsx: _this11._xlsx
            });
          });
        }
        /**
         * @private
         * @param {?} data
         * @param {?} fileName
         * @return {?}
         */

      }, {
        key: "saveFile",
        value: function saveFile(data, fileName) {
          /** @type {?} */
          var blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {
            type: ''
          });
          ExportUtilities.saveBlobToFile(blob, fileName);
        }
      }], [{
        key: "populateFolder",
        value: function populateFolder(folder, zip, worksheetData) {
          var _iteratorNormalCompletion11 = true;
          var _didIteratorError11 = false;
          var _iteratorError11 = undefined;

          try {
            for (var _iterator11 = folder.childFolders(worksheetData)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
              var childFolder = _step11.value;

              /** @type {?} */
              var folderIntance = ExcelElementsFactory.getExcelFolder(childFolder);
              /** @type {?} */

              var zipFolder = zip.folder(folderIntance.folderName);
              IgxExcelExporterService.populateFolder(folderIntance, zipFolder, worksheetData);
            }
          } catch (err) {
            _didIteratorError11 = true;
            _iteratorError11 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
                _iterator11["return"]();
              }
            } finally {
              if (_didIteratorError11) {
                throw _iteratorError11;
              }
            }
          }

          var _iteratorNormalCompletion12 = true;
          var _didIteratorError12 = false;
          var _iteratorError12 = undefined;

          try {
            for (var _iterator12 = folder.childFiles(worksheetData)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var childFile = _step12.value;

              /** @type {?} */
              var fileInstance = ExcelElementsFactory.getExcelFile(childFile);
              fileInstance.writeElement(zip, worksheetData);
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
                _iterator12["return"]();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
        }
      }]);

      return IgxExcelExporterService;
    }(IgxBaseExporter);

    IgxExcelExporterService.ZIP_OPTIONS = {
      compression: 'DEFLATE',
      type: 'base64'
    };
    IgxExcelExporterService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    IgxExcelExporterService.propDecorators = {
      onExportEnded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Objects of this class are used to configure the Excel exporting process.
     */

    var IgxExcelExporterOptions =
    /*#__PURE__*/
    function (_IgxExporterOptionsBa2) {
      _inherits(IgxExcelExporterOptions, _IgxExporterOptionsBa2);

      /**
       * @param {?} fileName
       */
      function IgxExcelExporterOptions(fileName) {
        var _this12;

        _classCallCheck(this, IgxExcelExporterOptions);

        _this12 = _possibleConstructorReturn(this, _getPrototypeOf(IgxExcelExporterOptions).call(this, fileName, '.xlsx'));
        /**
         * Specifies if column pinning should be ignored. If ignoreColumnsOrder is set to true,
         * this option will always be considered as set to true.
         * ```typescript
         * let ignorePinning = this.exportOptions.ignorePinning;
         * this.exportOptions.ignorePinning = true;
         * ```
         * \@memberof IgxExcelExporterOptions
         */

        _this12.ignorePinning = false;
        /**
         * Specifies whether the exported data should be formatted as Excel table. (True by default)
         * ```typescript
         * let exportAsTable = this.exportOptions.exportAsTable;
         * this.exportOptions.exportAsTable = false;
         * ```
         * \@memberof IgxExcelExporterOptions
         */

        _this12.exportAsTable = true;
        return _this12;
      }
      /**
       * Gets the width of the columns in the exported excel file.
       * ```typescript
       * let width = this.exportOptions.columnWidth;
       * ```
       * \@memberof IgxExcelExporterOptions
       * @return {?}
       */


      _createClass(IgxExcelExporterOptions, [{
        key: "columnWidth",
        get: function get() {
          return this._columnWidth;
        }
        /**
         * Sets the width of the columns in the exported excel file. If left unspecified or 0,
         * the width of the largest string in the column will be used.
         * ```typescript
         * this.exportOptions.columnWidth = 55;
         * ```
         * \@memberof IgxExcelExporterOptions
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value < 0) {
            throw Error('Invalid value for column width!');
          }

          this._columnWidth = value;
        }
        /**
         * Gets the height of the rows in the exported excel file.
         * ```typescript
         * let height = this.exportOptions.rowHeight;
         * ```
         * \@memberof IgxExcelExporterOptions
         * @return {?}
         */

      }, {
        key: "rowHeight",
        get: function get() {
          return this._rowHeight;
        }
        /**
         * Sets the height of the rows in the exported excel file. If left unspecified or 0,
         * the default height of the excel rows will be used.
         * ```typescript
         * this.exportOptions.rowHeight = 25;
         * ```
         * \@memberof IgxExcelExporterOptions
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value < 0) {
            throw Error('Invalid value for row height!');
          }

          this._rowHeight = value;
        }
      }]);

      return IgxExcelExporterOptions;
    }(IgxExporterOptionsBase);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */


    var HorizontalAlignment = {
      Left: -1,
      Center: -0.5,
      Right: 0
    };
    HorizontalAlignment[HorizontalAlignment.Left] = 'Left';
    HorizontalAlignment[HorizontalAlignment.Center] = 'Center';
    HorizontalAlignment[HorizontalAlignment.Right] = 'Right';
    /** @enum {number} */

    var VerticalAlignment = {
      Top: -1,
      Middle: -0.5,
      Bottom: 0
    };
    VerticalAlignment[VerticalAlignment.Top] = 'Top';
    VerticalAlignment[VerticalAlignment.Middle] = 'Middle';
    VerticalAlignment[VerticalAlignment.Bottom] = 'Bottom';

    var Point =
    /**
     * @param {?} x
     * @param {?} y
     */
    function Point(x, y) {
      _classCallCheck(this, Point);

      this.x = x;
      this.y = y;
    };
    /**
     * @hidden
     */


    var Util =
    /*#__PURE__*/
    function () {
      function Util() {
        _classCallCheck(this, Util);
      }

      _createClass(Util, null, [{
        key: "getTargetRect",

        /**
         * @hidden
         * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0,0,0 rectangle
         * if no target is provided
         * @param {?} settings Overlay settings for which to calculate target rectangle
         * @return {?}
         */
        value: function getTargetRect(settings) {
          /** @type {?} */
          var targetRect = {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
          };

          if (settings.target instanceof HTMLElement) {
            targetRect =
            /** @type {?} */
            settings.target.getBoundingClientRect();
          } else if (settings.target instanceof Point) {
            /** @type {?} */
            var targetPoint =
            /** @type {?} */
            settings.target;
            targetRect = {
              bottom: targetPoint.y,
              height: 0,
              left: targetPoint.x,
              right: targetPoint.x,
              top: targetPoint.y,
              width: 0
            };
          }

          return targetRect;
        }
        /**
         * @hidden \@internal
         * @param {?} document
         * @return {?}
         */

      }, {
        key: "getViewportRect",
        value: function getViewportRect(document) {
          /** @type {?} */
          var width = document.documentElement.clientWidth;
          /** @type {?} */

          var height = document.documentElement.clientHeight;
          /** @type {?} */

          var scrollPosition = Util.getViewportScrollPosition(document);
          return {
            top: scrollPosition.y,
            left: scrollPosition.x,
            right: scrollPosition.x + width,
            bottom: scrollPosition.y + height,
            width: width,
            height: height
          };
        }
        /**
         * @hidden \@internal
         * @param {?} document
         * @return {?}
         */

      }, {
        key: "getViewportScrollPosition",
        value: function getViewportScrollPosition(document) {
          /** @type {?} */
          var documentElement = document.documentElement;
          /** @type {?} */

          var documentRect = documentElement.getBoundingClientRect();
          /** @type {?} */

          var horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
          /** @type {?} */

          var verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
          return new Point(horizontalScrollPosition, verticalScrollPosition);
        }
        /**
         * @hidden \@internal
         * @param {?} object
         * @return {?}
         */

      }, {
        key: "cloneInstance",
        value: function cloneInstance(object) {
          /** @type {?} */
          var clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
          clonedObj.settings = cloneValue(clonedObj.settings);
          return clonedObj;
        }
      }]);

      return Util;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Positions the element based on the directions passed in trough PositionSettings.
     * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
     */


    var GlobalPositionStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?=} settings
       */
      function GlobalPositionStrategy(settings) {
        _classCallCheck(this, GlobalPositionStrategy);

        this._defaultSettings = {
          horizontalDirection: HorizontalAlignment.Center,
          verticalDirection: VerticalAlignment.Middle,
          horizontalStartPoint: HorizontalAlignment.Center,
          verticalStartPoint: VerticalAlignment.Middle,
          openAnimation: fadeIn,
          closeAnimation: fadeOut,
          minSize: {
            width: 0,
            height: 0
          }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
      }
      /**
       * \@inheritdoc
       * @param {?} contentElement
       * @param {?=} size
       * @param {?=} document
       * @param {?=} initialCall
       * @return {?}
       */


      _createClass(GlobalPositionStrategy, [{
        key: "position",
        value: function position(contentElement, size, document, initialCall) {
          contentElement.classList.add('igx-overlay__content--relative');
          contentElement.parentElement.classList.add('igx-overlay__wrapper--flex');
          this.setPosition(contentElement, this.settings);
        }
        /**
         * @protected
         * @param {?} contentElement
         * @param {?} settings
         * @return {?}
         */

      }, {
        key: "setPosition",
        value: function setPosition(contentElement, settings) {
          switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
              contentElement.parentElement.style.justifyContent = 'flex-start';
              break;

            case HorizontalAlignment.Center:
              contentElement.parentElement.style.justifyContent = 'center';
              break;

            case HorizontalAlignment.Right:
              contentElement.parentElement.style.justifyContent = 'flex-end';
              break;

            default:
              break;
          }

          switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
              contentElement.parentElement.style.alignItems = 'flex-start';
              break;

            case VerticalAlignment.Middle:
              contentElement.parentElement.style.alignItems = 'center';
              break;

            case VerticalAlignment.Bottom:
              contentElement.parentElement.style.alignItems = 'flex-end';
              break;

            default:
              break;
          }
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "clone",
        value: function clone() {
          return Util.cloneInstance(this);
        }
      }]);

      return GlobalPositionStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @abstract
     */


    var ScrollStrategy =
    /**
     * @param {?=} scrollContainer
     */
    function ScrollStrategy(scrollContainer) {
      _classCallCheck(this, ScrollStrategy);
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Empty scroll strategy. Does nothing.
     */


    var NoOpScrollStrategy =
    /*#__PURE__*/
    function (_ScrollStrategy) {
      _inherits(NoOpScrollStrategy, _ScrollStrategy);

      /**
       * @param {?=} scrollContainer
       */
      function NoOpScrollStrategy(scrollContainer) {
        _classCallCheck(this, NoOpScrollStrategy);

        return _possibleConstructorReturn(this, _getPrototypeOf(NoOpScrollStrategy).call(this, scrollContainer));
      }
      /**
       * \@inheritdoc
       * @param {?} document
       * @param {?} overlayService
       * @param {?} id
       * @return {?}
       */


      _createClass(NoOpScrollStrategy, [{
        key: "initialize",
        value: function initialize(document, overlayService, id) {}
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "attach",
        value: function attach() {}
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {}
      }]);

      return NoOpScrollStrategy;
    }(ScrollStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @param {?} message
     * @return {?}
     */


    function DeprecateMethod(message) {
      /** @type {?} */
      var isMessageShown = false;
      return function (target, key, descriptor) {
        if (descriptor && descriptor.value) {
          /** @type {?} */
          var originalMethod = descriptor.value;

          descriptor.value = function () {
            /** @type {?} */
            var targetName = typeof target === 'function' ? target.name : target.constructor.name;
            isMessageShown = showMessage("".concat(targetName, ".").concat(key, ": ").concat(message), isMessageShown);
            return originalMethod.call(this, arguments);
          };

          return descriptor;
        }
      };
    }
    /**
     * @hidden
     * @param {?} message
     * @return {?}
     */


    function DeprecateProperty(message) {
      return function (target, key) {
        /** @type {?} */
        var isMessageShown = false;
        /** @type {?} */

        var messageToDisplay = "".concat(target.constructor.name, ".").concat(key, ": ").concat(message); // if the target already has the property defined

        /** @type {?} */

        var originalDescriptor = Object.getOwnPropertyDescriptor(target, key);

        if (originalDescriptor) {
          /** @type {?} */
          var getter;
          /** @type {?} */

          var setter;
          getter = originalDescriptor.get;
          setter = originalDescriptor.set;

          if (getter) {
            originalDescriptor.get = function () {
              isMessageShown = showMessage(messageToDisplay, isMessageShown);
              return getter.call(this);
            };
          }

          if (setter) {
            originalDescriptor.set = function (value) {
              isMessageShown = showMessage(messageToDisplay, isMessageShown);
              setter.call(this, value);
            };
          }

          return originalDescriptor;
        } // the target doesn't contain a descriptor for that property, so create one
        // use backing field to set/get the value of the property to ensure there won't be infinite recursive calls

        /** @type {?} */


        var newKey = generateUniqueKey(target, key);
        Object.defineProperty(target, key, {
          configurable: true,
          enumerable: true,
          set: function set(value) {
            isMessageShown = showMessage(messageToDisplay, isMessageShown);
            this[newKey] = value;
          },
          get: function get() {
            isMessageShown = showMessage(messageToDisplay, isMessageShown);
            return this[newKey];
          }
        });
      };
    }
    /**
     * @hidden
     * @param {?} target
     * @param {?} key
     * @return {?}
     */


    function generateUniqueKey(target, key) {
      /** @type {?} */
      var newKey = '_' + key;

      while (target.hasOwnProperty(newKey)) {
        newKey = '_' + newKey;
      }

      return newKey;
    }
    /**
     * @hidden
     * @param {?} message
     * @param {?} isMessageShown
     * @return {?}
     */


    function showMessage(message, isMessageShown) {
      if (!isMessageShown && Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])()) {
        console.warn(message);
      }

      return true;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var warningShown = false;
    /**
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay_main.html)
     * The overlay service allows users to show components on overlay div above all other elements in the page.
     */

    var IgxOverlayService =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _factoryResolver
       * @param {?} _appRef
       * @param {?} _injector
       * @param {?} builder
       * @param {?} document
       * @param {?} _zone
       */
      function IgxOverlayService(_factoryResolver, _appRef, _injector, builder, document, _zone) {
        var _this13 = this;

        _classCallCheck(this, IgxOverlayService);

        this._factoryResolver = _factoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this.builder = builder;
        this.document = document;
        this._zone = _zone;
        this._componentId = 0;
        this._overlayInfos = [];
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._defaultSettings = {
          positionStrategy: new GlobalPositionStrategy(),
          scrollStrategy: new NoOpScrollStrategy(),
          modal: true,
          closeOnOutsideClick: true
        };
        /**
         * Emitted before the component is opened.
         * ```typescript
         * onOpening(event: OverlayCancelableEventArgs){
         *     const onOpening = event;
         * }
         * ```
         */

        this.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the component is opened and all animations are finished.
         * ```typescript
         * onOpened(event: OverlayEventArgs){
         *     const onOpened = event;
         * }
         * ```
         */

        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before the component is closed.
         * ```typescript
         * onClosing(event: OverlayCancelableEventArgs){
         *     const onClosing = event;
         * }
         * ```
         */

        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the component is closed and all animations are finished.
         * ```typescript
         * onClosed(event: OverlayEventArgs){
         *     const onClosed = event;
         * }
         * ```
         */

        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before animation is started
         * ```typescript
         * onAnimation(event: OverlayAnimationEventArgs){
         *     const onAnimation = event;
         * }
         * ```
         */

        this.onAnimation = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();

        this.documentClicked = function (ev) {
          //  if we get to modal overlay just return - we should not close anything under it
          //  if we get to non-modal overlay do the next:
          //   1. Check it has close on outside click. If not go on to next overlay;
          //   2. If true check if click is on the element. If it is on the element we have closed
          //  already all previous non-modal with close on outside click elements, so we return. If
          //  not close the overlay and check next
          for (var i = _this13._overlayInfos.length; i--;) {
            /** @type {?} */
            var info = _this13._overlayInfos[i];

            if (info.settings.modal) {
              return;
            }

            if (info.settings.closeOnOutsideClick) {
              /** @type {?} */
              var target =
              /** @type {?} */
              ev.target; //  if the click is on the element do not close this overlay

              if (!info.elementRef.nativeElement.contains(target)) {
                // if we should exclude position target check if the click is over it. If so do not close overlay

                /** @type {?} */
                var positionTarget =
                /** @type {?} */
                info.settings.positionStrategy.settings.target;
                /** @type {?} */

                var clickOnPositionTarget = false;

                if (positionTarget) {
                  clickOnPositionTarget = positionTarget.contains(target);
                }

                if (!(info.settings.excludePositionTarget && clickOnPositionTarget)) {
                  //  if the click is outside click, but close animation has started do nothing
                  if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {
                    _this13._hide(info.id, ev);
                  }
                }
              } else {
                //  TODO: should we return here, or continue with next overlays
                return;
              }
            }
          }
        };
        /**
         * @hidden
         */


        this.repositionAll = function () {
          for (var i = _this13._overlayInfos.length; i--;) {
            _this13.reposition(_this13._overlayInfos[i].id);
          }
        };

        this._document =
        /** @type {?} */
        this.document;
      }
      /**
       * @param {?} component
       * @param {?=} settings
       * @param {?=} moduleRef
       * @return {?}
       */


      _createClass(IgxOverlayService, [{
        key: "attach",
        value: function attach(component, settings, moduleRef) {
          /** @type {?} */
          var info;
          info = this.getOverlayInfo(component, moduleRef); //  if there is no info most probably wrong type component was provided and we just go out

          if (!info) {
            return null;
          }

          info.id = (this._componentId++).toString();
          settings = Object.assign({}, this._defaultSettings, settings);
          info.settings = settings;

          this._overlayInfos.push(info);

          return info.id;
        }
        /**
         * @param {?} compOrId
         * @param {?=} settings
         * @return {?}
         */

      }, {
        key: "show",
        value: function show(compOrId, settings) {
          /** @type {?} */
          var info;
          /** @type {?} */

          var id;

          if (typeof compOrId === 'string') {
            id = compOrId;
            info = this.getOverlayById(compOrId);

            if (!info) {
              console.warn('igxOverlay.show was called with wrong id: ' + compOrId);
              return null;
            }
          } else {
            warningShown = showMessage('`show(component, settings?)` overload is deprecated. Use `attach(component)` to obtain an Id.' + 'Then `show(id, settings?)` with provided Id.', warningShown);
            id = (this._componentId++).toString();
            info = this.getOverlayInfo(compOrId); //  if there is no info most probably wrong type component was provided and we just go out

            if (!info) {
              return;
            }

            info.id = id;
          }

          settings = Object.assign({}, this._defaultSettings, info.settings, settings);
          info.settings = settings;

          this._show(info);

          return id;
        }
        /**
         * Hides the component with the ID provided as a parameter.
         * ```typescript
         * this.overlay.hide(id);
         * ```
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "hide",
        value: function hide(id) {
          this._hide(id);
        }
        /**
         * Hides all the components and the overlay.
         * ```typescript
         * this.overlay.hideAll();
         * ```
         * @return {?}
         */

      }, {
        key: "hideAll",
        value: function hideAll() {
          // since overlays are removed on animation done, que all hides
          for (var i = this._overlayInfos.length; i--;) {
            this.hide(this._overlayInfos[i].id);
          }
        }
        /**
         * Repositions the component with ID provided as a parameter.
         * ```typescript
         * this.overlay.reposition(id);
         * ```
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "reposition",
        value: function reposition(id) {
          /** @type {?} */
          var overlayInfo = this.getOverlayById(id);

          if (!overlayInfo || !overlayInfo.settings) {
            console.error('Wrong id provided in overlay.reposition method. Id: ' + id);
            return;
          }
          /** @type {?} */


          var contentElement = overlayInfo.elementRef.nativeElement.parentElement;
          /** @type {?} */

          var contentElementRect = contentElement.getBoundingClientRect();
          overlayInfo.settings.positionStrategy.position(contentElement, {
            width: contentElementRect.width,
            height: contentElementRect.height
          }, this._document, false);
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "_show",
        value: function _show(info) {
          /** @type {?} */
          var eventArgs = {
            id: info.id,
            componentRef: info.componentRef,
            cancel: false
          };
          this.onOpening.emit(eventArgs);

          if (eventArgs.cancel) {
            if (info.componentRef) {
              this._appRef.detachView(info.componentRef.hostView);

              info.componentRef.destroy();
            }

            return;
          } //  if there is no close animation player, or there is one but it is not started yet we are in clear
          //  opening. Otherwise, if there is close animation player playing animation now we should not setup
          //  overlay this is already done


          if (!info.closeAnimationPlayer || info.closeAnimationPlayer && !info.closeAnimationPlayer.hasStarted()) {
            /** @type {?} */
            var elementRect = info.elementRef.nativeElement.getBoundingClientRect();
            info.initialSize = {
              width: elementRect.width,
              height: elementRect.height
            };
            info.hook = this.placeElementHook(info.elementRef.nativeElement);
            this.moveElementToOverlay(info);

            if (info.componentRef) {
              info.componentRef.changeDetectorRef.detectChanges();
            }

            this.updateSize(info);

            if (this._overlayInfos.indexOf(info) === -1) {
              this._overlayInfos.push(info);
            }

            info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, {
              width: info.initialSize.width,
              height: info.initialSize.height
            }, document, true);
            info.settings.scrollStrategy.initialize(this._document, this, info.id);
            info.settings.scrollStrategy.attach();
          }

          this.addOutsideClickListener(info);
          this.addResizeHandler(info.id);

          if (info.settings.modal) {
            this.setupModalWrapper(info);
          }

          if (info.settings.positionStrategy.settings.openAnimation) {
            this.playOpenAnimation(info);
          } else {
            //  to eliminate flickering show the element just before onOpened fire
            info.elementRef.nativeElement.parentElement.style.visibility = '';
            this.onOpened.emit({
              id: info.id,
              componentRef: info.componentRef
            });
          }
        }
        /**
         * @private
         * @param {?} id
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "_hide",
        value: function _hide(id, event) {
          /** @type {?} */
          var info = this.getOverlayById(id);

          if (!info) {
            console.warn('igxOverlay.hide was called with wrong id: ' + id);
            return;
          }
          /** @type {?} */


          var eventArgs = {
            id: id,
            componentRef: info.componentRef,
            cancel: false,
            event: event
          };
          this.onClosing.emit(eventArgs);

          if (eventArgs.cancel) {
            return;
          } //  TODO: synchronize where these are added/attached and where removed/detached


          info.settings.scrollStrategy.detach();
          this.removeOutsideClickListener(info);
          this.removeResizeHandler(info.id);
          /** @type {?} */

          var child = info.elementRef.nativeElement;

          if (info.settings.modal) {
            /** @type {?} */
            var parent =
            /** @type {?} */
            child.parentNode.parentNode;
            this.applyAnimationParams(parent, info.settings.positionStrategy.settings.closeAnimation);
            parent.classList.remove('igx-overlay__wrapper--modal');
            parent.classList.add('igx-overlay__wrapper');
          }

          if (info.settings.positionStrategy.settings.closeAnimation) {
            this.playCloseAnimation(info);
          } else {
            this.onCloseDone(info);
          }
        }
        /**
         * @private
         * @param {?} component
         * @param {?=} moduleRef
         * @return {?}
         */

      }, {
        key: "getOverlayInfo",
        value: function getOverlayInfo(component, moduleRef) {
          /** @type {?} */
          var info = {
            ngZone: this._zone
          };

          if (component instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]) {
            info.elementRef =
            /** @type {?} */
            component;
          } else {
            /** @type {?} */
            var dynamicFactory;
            /** @type {?} */

            var factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;

            try {
              dynamicFactory = factoryResolver.resolveComponentFactory(component);
            } catch (error) {
              console.error(error);
              return null;
            }
            /** @type {?} */


            var injector = moduleRef ? moduleRef.injector : this._injector;
            /** @type {?} */

            var dynamicComponent = dynamicFactory.create(injector);

            this._appRef.attachView(dynamicComponent.hostView); // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.

            /** @type {?} */


            var element = dynamicComponent.location.nativeElement;
            info.elementRef =
            /** @type {?} */
            {
              nativeElement: element
            };
            info.componentRef = dynamicComponent;
          }

          return info;
        }
        /**
         * @private
         * @param {?} element
         * @return {?}
         */

      }, {
        key: "placeElementHook",
        value: function placeElementHook(element) {
          if (!element.parentElement) {
            return null;
          }
          /** @type {?} */


          var hook = this._document.createElement('div');

          element.parentElement.insertBefore(hook, element);
          return hook;
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "moveElementToOverlay",
        value: function moveElementToOverlay(info) {
          /** @type {?} */
          var wrapperElement = this.getWrapperElement();
          /** @type {?} */

          var contentElement = this.getContentElement(wrapperElement, info.settings.modal);
          this.getOverlayElement(info).appendChild(wrapperElement);
          /** @type {?} */

          var elementScrollTop = info.elementRef.nativeElement.scrollTop;
          contentElement.appendChild(info.elementRef.nativeElement);

          if (elementScrollTop) {
            info.elementRef.nativeElement.scrollTop = elementScrollTop;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getWrapperElement",
        value: function getWrapperElement() {
          /** @type {?} */
          var wrapper = this._document.createElement('div');

          wrapper.classList.add('igx-overlay__wrapper');
          return wrapper;
        }
        /**
         * @private
         * @param {?} wrapperElement
         * @param {?} modal
         * @return {?}
         */

      }, {
        key: "getContentElement",
        value: function getContentElement(wrapperElement, modal) {
          /** @type {?} */
          var content = this._document.createElement('div');

          if (modal) {
            content.classList.add('igx-overlay__content--modal');
            content.addEventListener('click', function (ev) {
              ev.stopPropagation();
            });
          } else {
            content.classList.add('igx-overlay__content');
          }

          content.addEventListener('scroll', function (ev) {
            ev.stopPropagation();
          }); //  hide element to eliminate flickering. Show the element exactly before animation starts

          content.style.visibility = 'hidden';
          wrapperElement.appendChild(content);
          return content;
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "getOverlayElement",
        value: function getOverlayElement(info) {
          if (info.settings.outlet) {
            return info.settings.outlet.nativeElement;
          }

          if (!this._overlayElement) {
            this._overlayElement = this._document.createElement('div');

            this._overlayElement.classList.add('igx-overlay');

            this._document.body.appendChild(this._overlayElement);
          }

          return this._overlayElement;
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "updateSize",
        value: function updateSize(info) {
          if (info.componentRef) {
            //  if we are positioning component this is first time it gets visible
            //  and we can finally get its size
            info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();
          } // set content div width only if element to show has width


          if (info.initialSize.width !== 0) {
            info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';
          }
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "setupModalWrapper",
        value: function setupModalWrapper(info) {
          var _this14 = this;

          /** @type {?} */
          var wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;
          Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(wrapperElement, 'keydown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function (ev) {
            return ev.key === 'Escape' || ev.key === 'Esc';
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function () {
            return _this14.hide(info.id);
          });
          wrapperElement.classList.remove('igx-overlay__wrapper');
          this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);
          wrapperElement.classList.add('igx-overlay__wrapper--modal');
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "onCloseDone",
        value: function onCloseDone(info) {
          this.cleanUp(info);
          this.onClosed.emit({
            id: info.id,
            componentRef: info.componentRef
          });
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "cleanUp",
        value: function cleanUp(info) {
          /** @type {?} */
          var child = info.elementRef.nativeElement;
          /** @type {?} */

          var outlet = this.getOverlayElement(info);

          if (!outlet.contains(child)) {
            console.warn('Component with id:' + info.id + ' is already removed!');
            return;
          }

          outlet.removeChild(child.parentNode.parentNode);

          if (info.componentRef) {
            this._appRef.detachView(info.componentRef.hostView);

            info.componentRef.destroy();
          }

          if (info.hook) {
            info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);
            info.hook.parentElement.removeChild(info.hook);
          }
          /** @type {?} */


          var index = this._overlayInfos.indexOf(info);

          this._overlayInfos.splice(index, 1); // this._overlayElement.parentElement check just for tests that manually delete the element


          if (this._overlayInfos.length === 0 && this._overlayElement && this._overlayElement.parentElement) {
            this._overlayElement.parentElement.removeChild(this._overlayElement);

            this._overlayElement = null;
          }
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "playOpenAnimation",
        value: function playOpenAnimation(info) {
          var _this15 = this;

          if (!info.openAnimationPlayer) {
            /** @type {?} */
            var animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);
            info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement); //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack

            /** @type {?} */

            var innerRenderer =
            /** @type {?} */
            info.openAnimationPlayer._renderer;
            info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.openAnimationPlayer.onDone(function () {
              _this15.onOpened.emit({
                id: info.id,
                componentRef: info.componentRef
              });

              if (info.openAnimationPlayer) {
                info.openAnimationPlayer.reset();
                info.openAnimationPlayer = null;
              }

              if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                info.closeAnimationPlayer.reset();
              }
            });
          } //  if there is opening animation already started do nothing


          if (info.openAnimationPlayer.hasStarted()) {
            return;
          } //  if there is closing animation already started start open animation from where close one has reached
          //  and remove close animation


          if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one

            /** @type {?} */
            var position = 1 - info.closeAnimationInnerPlayer.getPosition();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
            info.openAnimationPlayer.init();
            info.openAnimationPlayer.setPosition(position);
          }

          this.onAnimation.emit({
            id: info.id,
            animationPlayer: info.openAnimationPlayer,
            animationType: 'open'
          }); //  to eliminate flickering show the element just before animation start

          info.elementRef.nativeElement.parentElement.style.visibility = '';
          info.openAnimationPlayer.play();
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "playCloseAnimation",
        value: function playCloseAnimation(info) {
          var _this16 = this;

          if (!info.closeAnimationPlayer) {
            /** @type {?} */
            var animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);
            info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement); //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack

            /** @type {?} */

            var innerRenderer =
            /** @type {?} */
            info.closeAnimationPlayer._renderer;
            info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.closeAnimationPlayer.onDone(function () {
              if (info.closeAnimationPlayer) {
                info.closeAnimationPlayer.reset();
                info.closeAnimationPlayer = null;
              }

              if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                info.openAnimationPlayer.reset();
              }

              _this16.onCloseDone(info);
            });
          } //  if there is closing animation already started do nothing


          if (info.closeAnimationPlayer.hasStarted()) {
            return;
          } //  if there is opening animation already started start close animation from where open one has reached
          //  and remove open animation


          if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one

            /** @type {?} */
            var position = 1 - info.openAnimationInnerPlayer.getPosition();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
            info.closeAnimationPlayer.init();
            info.closeAnimationPlayer.setPosition(position);
          }

          this.onAnimation.emit({
            id: info.id,
            animationPlayer: info.closeAnimationPlayer,
            animationType: 'close'
          });
          info.closeAnimationPlayer.play();
        } //  TODO: check if applyAnimationParams will work with complex animations

        /**
         * @private
         * @param {?} wrapperElement
         * @param {?} animationOptions
         * @return {?}
         */

      }, {
        key: "applyAnimationParams",
        value: function applyAnimationParams(wrapperElement, animationOptions) {
          if (!animationOptions) {
            wrapperElement.style.transitionDuration = '0ms';
            return;
          }

          if (animationOptions.type === 10
          /* AnimateRef */
          ) {
              animationOptions =
              /** @type {?} */
              animationOptions.animation;
            }

          if (!animationOptions.options || !animationOptions.options.params) {
            return;
          }
          /** @type {?} */


          var params =
          /** @type {?} */
          animationOptions.options.params;

          if (params.duration) {
            wrapperElement.style.transitionDuration = params.duration;
          }

          if (params.easing) {
            wrapperElement.style.transitionTimingFunction = params.easing;
          }
        }
        /**
         * @hidden \@internal
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "getOverlayById",
        value: function getOverlayById(id) {
          if (!id) {
            return null;
          }
          /** @type {?} */


          var info = this._overlayInfos.find(function (e) {
            return e.id === id;
          });

          return info;
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "addOutsideClickListener",
        value: function addOutsideClickListener(info) {
          var _this17 = this;

          if (info.settings.closeOnOutsideClick) {
            if (info.settings.modal) {
              Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(info.elementRef.nativeElement.parentElement.parentElement, 'click').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (e) {
                return _this17._hide(info.id, e);
              });
            } else if ( //  if all overlays minus closing overlays equals one add the handler
            this._overlayInfos.filter(function (x) {
              return x.settings.closeOnOutsideClick && !x.settings.modal;
            }).length - this._overlayInfos.filter(function (x) {
              return x.settings.closeOnOutsideClick && !x.settings.modal && x.closeAnimationPlayer && x.closeAnimationPlayer.hasStarted();
            }).length === 1) {
              this._document.addEventListener('click', this.documentClicked, true);
            }
          }
        }
        /**
         * @private
         * @param {?} info
         * @return {?}
         */

      }, {
        key: "removeOutsideClickListener",
        value: function removeOutsideClickListener(info) {
          if (info.settings.modal === false) {
            /** @type {?} */
            var shouldRemoveClickEventListener = true;

            this._overlayInfos.forEach(function (o) {
              if (o.settings.modal === false && o.id !== info.id) {
                shouldRemoveClickEventListener = false;
              }
            });

            if (shouldRemoveClickEventListener) {
              this._document.removeEventListener('click', this.documentClicked, true);
            }
          }
        }
        /**
         * @private
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "addResizeHandler",
        value: function addResizeHandler(id) {
          /** @type {?} */
          var closingOverlaysCount = this._overlayInfos.filter(function (o) {
            return o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted();
          }).length;

          if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.addEventListener('resize', this.repositionAll);
          }
        }
        /**
         * @private
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "removeResizeHandler",
        value: function removeResizeHandler(id) {
          /** @type {?} */
          var closingOverlaysCount = this._overlayInfos.filter(function (o) {
            return o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted();
          }).length;

          if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.removeEventListener('resize', this.repositionAll);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
      }]);

      return IgxOverlayService;
    }();

    IgxOverlayService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    IgxOverlayService.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ApplicationRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]
      }, {
        type: _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };
    /** @nocollapse */


    IgxOverlayService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function IgxOverlayService_Factory() {
        return new IgxOverlayService(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ApplicationRef"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["INJECTOR"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]));
      },
      token: IgxOverlayService,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Positions the element inside the containing outlet based on the directions passed in trough PositionSettings.
     * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
     */

    var ContainerPositionStrategy =
    /*#__PURE__*/
    function (_GlobalPositionStrate) {
      _inherits(ContainerPositionStrategy, _GlobalPositionStrate);

      /**
       * @param {?=} settings
       */
      function ContainerPositionStrategy(settings) {
        _classCallCheck(this, ContainerPositionStrategy);

        return _possibleConstructorReturn(this, _getPrototypeOf(ContainerPositionStrategy).call(this, settings));
      }
      /**
       * \@inheritdoc
       * @param {?} contentElement
       * @param {?=} size
       * @param {?=} document
       * @param {?=} initialCall
       * @return {?}
       */


      _createClass(ContainerPositionStrategy, [{
        key: "position",
        value: function position(contentElement, size, document, initialCall) {
          contentElement.classList.add('igx-overlay__content--relative');
          contentElement.parentElement.classList.add('igx-overlay__wrapper--flex-container');
          this.setPosition(contentElement, this.settings);
        }
      }]);

      return ContainerPositionStrategy;
    }(GlobalPositionStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Positions the element based on the directions and start point passed in trough PositionSettings.
     * It is possible to either pass a start point or an HTMLElement as a positioning base.
     */


    var ConnectedPositioningStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?=} settings
       */
      function ConnectedPositioningStrategy(settings) {
        _classCallCheck(this, ConnectedPositioningStrategy);

        this._defaultSettings = {
          // default Point(0, 0) in getPointFromPositionsSettings
          target: null,
          horizontalDirection: HorizontalAlignment.Right,
          verticalDirection: VerticalAlignment.Bottom,
          horizontalStartPoint: HorizontalAlignment.Left,
          verticalStartPoint: VerticalAlignment.Bottom,
          openAnimation: scaleInVerTop,
          closeAnimation: scaleOutVerTop,
          minSize: {
            width: 0,
            height: 0
          }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
      }
      /**
       * \@inheritdoc
       * @param {?} contentElement
       * @param {?} size
       * @param {?=} document
       * @param {?=} initialCall
       * @return {?}
       */


      _createClass(ConnectedPositioningStrategy, [{
        key: "position",
        value: function position(contentElement, size, document, initialCall) {
          /** @type {?} */
          var targetRect = Util.getTargetRect(this.settings);
          /** @type {?} */

          var contentElementRect = contentElement.getBoundingClientRect();
          this.setStyle(contentElement, targetRect, contentElementRect);
        }
        /**
         * \@inheritdoc
         * Creates clone of this position strategy
         * @return {?} clone of this position strategy
         */

      }, {
        key: "clone",
        value: function clone() {
          return Util.cloneInstance(this);
        }
        /**
         * Sets element's style which effectively positions provided element according
         * to provided position settings
         * @protected
         * @param {?} element Element to position
         * @param {?} targetRect Bounding rectangle of strategy target
         * @param {?} elementRect Bounding rectangle of the element
         * @return {?}
         */

      }, {
        key: "setStyle",
        value: function setStyle(element, targetRect, elementRect) {
          /** @type {?} */
          var startPoint = {
            x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint,
            y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint
          };
          /** @type {?} */

          var wrapperRect = element.parentElement.getBoundingClientRect(); //  clean up styles - if auto position strategy is chosen we may pass here several times

          element.style.right = '';
          element.style.left = '';
          element.style.bottom = '';
          element.style.top = '';

          switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
              element.style.right = "".concat(Math.round(wrapperRect.right - startPoint.x), "px");
              break;

            case HorizontalAlignment.Center:
              element.style.left = "".concat(Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2), "px");
              break;

            case HorizontalAlignment.Right:
              element.style.left = "".concat(Math.round(startPoint.x - wrapperRect.left), "px");
              break;
          }

          switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
              element.style.bottom = "".concat(Math.round(wrapperRect.bottom - startPoint.y), "px");
              break;

            case VerticalAlignment.Middle:
              element.style.top = "".concat(Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2), "px");
              break;

            case VerticalAlignment.Bottom:
              element.style.top = "".concat(Math.round(startPoint.y - wrapperRect.top), "px");
              break;
          }
        }
      }]);

      return ConnectedPositioningStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @abstract
     */


    var BaseFitPositionStrategy =
    /*#__PURE__*/
    function (_ConnectedPositioning) {
      _inherits(BaseFitPositionStrategy, _ConnectedPositioning);

      function BaseFitPositionStrategy() {
        _classCallCheck(this, BaseFitPositionStrategy);

        return _possibleConstructorReturn(this, _getPrototypeOf(BaseFitPositionStrategy).apply(this, arguments));
      }

      _createClass(BaseFitPositionStrategy, [{
        key: "position",

        /**
         * \@inheritdoc
         * @param {?} contentElement
         * @param {?} size
         * @param {?=} document
         * @param {?=} initialCall
         * @return {?}
         */
        value: function position(contentElement, size, document, initialCall) {
          /** @type {?} */
          var targetRect = Util.getTargetRect(this.settings);
          /** @type {?} */

          var contentElementRect = contentElement.getBoundingClientRect();

          if (initialCall) {
            /** @type {?} */
            var connectedFit = {};
            connectedFit.targetRect = targetRect;
            connectedFit.contentElementRect = contentElementRect;
            this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
            this.settings = Object.assign({}, this._initialSettings);
            connectedFit.viewPortRect = Util.getViewportRect(document);
            this.updateViewPortFit(connectedFit);

            if (!connectedFit.fitHorizontal || !connectedFit.fitVertical) {
              this.fitInViewport(contentElement, connectedFit);
            }
          }

          this.setStyle(contentElement, targetRect, contentElementRect);
        }
        /**
         * Checks if element can fit in viewport and updates provided connectedFit
         * with the result
         * @protected
         * @param {?} connectedFit connectedFit to update
         * @return {?}
         */

      }, {
        key: "updateViewPortFit",
        value: function updateViewPortFit(connectedFit) {
          connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection);
          connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
          connectedFit.fitHorizontal = 0 < connectedFit.left && connectedFit.right < connectedFit.viewPortRect.width;
          connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection);
          connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
          connectedFit.fitVertical = 0 < connectedFit.top && connectedFit.bottom < connectedFit.viewPortRect.height;
        }
        /**
         * Calculates the position of the left border of the element if it gets positioned
         * with provided start point and direction
         * @protected
         * @param {?} targetRect Rectangle of the target where element is attached
         * @param {?} elementRect Rectangle of the element
         * @param {?} startPoint Start point of the target
         * @param {?} direction Direction in which to show the element
         * @return {?}
         */

      }, {
        key: "calculateLeft",
        value: function calculateLeft(targetRect, elementRect, startPoint, direction) {
          return targetRect.right + targetRect.width * startPoint + elementRect.width * direction;
        }
        /**
         * Calculates the position of the top border of the element if it gets positioned
         * with provided position settings related to the target
         * @protected
         * @param {?} targetRect Rectangle of the target where element is attached
         * @param {?} elementRect Rectangle of the element
         * @param {?} startPoint Start point of the target
         * @param {?} direction Direction in which to show the element
         * @return {?}
         */

      }, {
        key: "calculateTop",
        value: function calculateTop(targetRect, elementRect, startPoint, direction) {
          return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction;
        }
      }]);

      return BaseFitPositionStrategy;
    }(ConnectedPositioningStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Positions the element as in **Connected** positioning strategy and re-positions the element in
     * the view port (calculating a different start point) in case the element is partially getting out of view
     */


    var AutoPositionStrategy =
    /*#__PURE__*/
    function (_BaseFitPositionStrat) {
      _inherits(AutoPositionStrategy, _BaseFitPositionStrat);

      function AutoPositionStrategy() {
        _classCallCheck(this, AutoPositionStrategy);

        return _possibleConstructorReturn(this, _getPrototypeOf(AutoPositionStrategy).apply(this, arguments));
      }

      _createClass(AutoPositionStrategy, [{
        key: "fitInViewport",

        /**
         * \@inheritdoc
         * @protected
         * @param {?} element
         * @param {?} connectedFit
         * @return {?}
         */
        value: function fitInViewport(element, connectedFit) {
          /** @type {?} */
          var transformString = [];

          if (!connectedFit.fitHorizontal) {
            if (this.canFlipHorizontal(connectedFit)) {
              this.flipHorizontal();
            } else {
              /** @type {?} */
              var horizontalPush = this.horizontalPush(connectedFit);
              transformString.push("translateX(".concat(horizontalPush, "px)"));
            }
          }

          if (!connectedFit.fitVertical) {
            if (this.canFlipVertical(connectedFit)) {
              this.flipVertical();
            } else {
              /** @type {?} */
              var verticalPush = this.verticalPush(connectedFit);
              transformString.push("translateY(".concat(verticalPush, "px)"));
            }
          }

          element.style.transform = transformString.join(' ').trim();
        }
        /**
         * Checks if element can be flipped without get off the viewport
         * @private
         * @param {?} connectedFit connectedFit object containing all necessary parameters
         * @return {?} true if element can be flipped and stain in viewport
         */

      }, {
        key: "canFlipHorizontal",
        value: function canFlipHorizontal(connectedFit) {
          //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
          //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
          //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
          //  this way:
          //  (-1) * (Left + 1) = 0 = Right
          //  (-1) * (Center + 1) = -0.5 = Center
          //  (-1) * (Right + 1) = -1 = Left

          /** @type {?} */
          var flippedStartPoint = -1 * (this.settings.horizontalStartPoint + 1);
          /** @type {?} */

          var flippedDirection = -1 * (this.settings.horizontalDirection + 1);
          /** @type {?} */

          var leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
          /** @type {?} */

          var rightBorder = leftBorder + connectedFit.contentElementRect.width;
          return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
        }
        /**
         * Checks if element can be flipped without get off the viewport
         * @private
         * @param {?} connectedFit connectedFit object containing all necessary parameters
         * @return {?} true if element can be flipped and stain in viewport
         */

      }, {
        key: "canFlipVertical",
        value: function canFlipVertical(connectedFit) {
          /** @type {?} */
          var flippedStartPoint = -1 * (this.settings.verticalStartPoint + 1);
          /** @type {?} */

          var flippedDirection = -1 * (this.settings.verticalDirection + 1);
          /** @type {?} */

          var topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
          /** @type {?} */

          var bottomBorder = topBorder + connectedFit.contentElementRect.height;
          return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
        }
        /**
         * Flips direction and start point of the position settings
         * @private
         * @return {?}
         */

      }, {
        key: "flipHorizontal",
        value: function flipHorizontal() {
          switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
              this.settings.horizontalDirection = HorizontalAlignment.Right;
              break;

            case HorizontalAlignment.Right:
              this.settings.horizontalDirection = HorizontalAlignment.Left;
              break;
          }

          switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
              this.settings.horizontalStartPoint = HorizontalAlignment.Right;
              break;

            case HorizontalAlignment.Right:
              this.settings.horizontalStartPoint = HorizontalAlignment.Left;
              break;
          }
        }
        /**
         * Flips direction and start point of the position settings
         * @private
         * @return {?}
         */

      }, {
        key: "flipVertical",
        value: function flipVertical() {
          switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
              this.settings.verticalDirection = VerticalAlignment.Bottom;
              break;

            case VerticalAlignment.Bottom:
              this.settings.verticalDirection = VerticalAlignment.Top;
              break;
          }

          switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
              this.settings.verticalStartPoint = VerticalAlignment.Bottom;
              break;

            case VerticalAlignment.Bottom:
              this.settings.verticalStartPoint = VerticalAlignment.Top;
              break;
          }
        }
        /**
         * Calculates necessary horizontal push according to provided connectedFit
         * @private
         * @param {?} connectedFit connectedFit object containing all necessary parameters
         * @return {?} amount of necessary translation which will push the element into viewport
         */

      }, {
        key: "horizontalPush",
        value: function horizontalPush(connectedFit) {
          /** @type {?} */
          var leftExtend = connectedFit.left;
          /** @type {?} */

          var rightExtend = connectedFit.right - connectedFit.viewPortRect.right; //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
          //  as much as it is beyond the screen.
          //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
          //  extend but with amount not bigger than what left between left border of screen and left border of
          //  overlay, e.g. leftExtend

          if (leftExtend < 0) {
            return Math.abs(leftExtend);
          } else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
          } else {
            return 0;
          }
        }
        /**
         * Calculates necessary vertical push according to provided connectedFit
         * @private
         * @param {?} connectedFit connectedFit object containing all necessary parameters
         * @return {?} amount of necessary translation which will push the element into viewport
         */

      }, {
        key: "verticalPush",
        value: function verticalPush(connectedFit) {
          /** @type {?} */
          var topExtend = connectedFit.top;
          /** @type {?} */

          var bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.bottom;

          if (topExtend < 0) {
            return Math.abs(topExtend);
          } else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
          } else {
            return 0;
          }
        }
      }]);

      return AutoPositionStrategy;
    }(BaseFitPositionStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Positions the element as in **Connected** positioning strategy and resize the element
     * to fit in the view port in case the element is partially getting out of view
     */


    var ElasticPositionStrategy =
    /*#__PURE__*/
    function (_BaseFitPositionStrat2) {
      _inherits(ElasticPositionStrategy, _BaseFitPositionStrat2);

      function ElasticPositionStrategy() {
        _classCallCheck(this, ElasticPositionStrategy);

        return _possibleConstructorReturn(this, _getPrototypeOf(ElasticPositionStrategy).apply(this, arguments));
      }

      _createClass(ElasticPositionStrategy, [{
        key: "fitInViewport",

        /**
         * \@inheritdoc
         * @protected
         * @param {?} element
         * @param {?} connectedFit
         * @return {?}
         */
        value: function fitInViewport(element, connectedFit) {
          element.classList.add('igx-overlay__content--elastic');
          /** @type {?} */

          var transformString = [];

          if (!connectedFit.fitHorizontal) {
            /** @type {?} */
            var maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);
            /** @type {?} */

            var leftExtend = Math.max(0, 0 - connectedFit.left);
            /** @type {?} */

            var rightExtend = Math.max(0, connectedFit.right - connectedFit.viewPortRect.width);
            /** @type {?} */

            var reduction = Math.min(maxReduction, leftExtend + rightExtend);
            element.style.width = "".concat(connectedFit.contentElementRect.width - reduction, "px"); //  if direction is center and element goes off the screen in left direction we should push the
            //  element to the right. Prevents left still going out of view when normally positioned

            if (this.settings.horizontalDirection === HorizontalAlignment.Center) {
              //  the amount of translation depends on whether element goes off the screen to the left,
              //  to the right or in both directions, as well as how much it goes of the screen and finally
              //  on the minSize. The translation should be proportional between left and right extend
              //  taken from the reduction

              /** @type {?} */
              var translation = leftExtend * reduction / (leftExtend + rightExtend);

              if (translation > 0) {
                transformString.push("translateX(".concat(translation, "px)"));
              }
            }
          }

          if (!connectedFit.fitVertical) {
            /** @type {?} */
            var _maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);
            /** @type {?} */


            var topExtend = Math.max(0, 0 - connectedFit.top);
            /** @type {?} */

            var bottomExtend = Math.max(0, connectedFit.bottom - connectedFit.viewPortRect.height);
            /** @type {?} */

            var _reduction = Math.min(_maxReduction, topExtend + bottomExtend);

            element.style.height = "".concat(connectedFit.contentElementRect.height - _reduction, "px"); //  if direction is middle and element goes off the screen in top direction we should push the
            //  element to the bottom. Prevents top still going out of view when normally positioned

            if (this.settings.verticalDirection === VerticalAlignment.Middle) {
              //  the amount of translation depends on whether element goes off the screen to the top,
              //  to the bottom or in both directions, as well as how much it goes of the screen and finally
              //  on the minSize. The translation should be proportional between top and bottom extend
              //  taken from the reduction

              /** @type {?} */
              var _translation = topExtend * _reduction / (topExtend + bottomExtend);

              if (_translation > 0) {
                transformString.push("translateY(".concat(_translation, "px)"));
              }
            }
          }

          element.style.transform = transformString.join(' ').trim();
        }
      }]);

      return ElasticPositionStrategy;
    }(BaseFitPositionStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * On scroll reposition the overlay content.
     */


    var AbsoluteScrollStrategy =
    /*#__PURE__*/
    function (_ScrollStrategy2) {
      _inherits(AbsoluteScrollStrategy, _ScrollStrategy2);

      /**
       * @param {?=} scrollContainer
       */
      function AbsoluteScrollStrategy(scrollContainer) {
        var _this18;

        _classCallCheck(this, AbsoluteScrollStrategy);

        _this18 = _possibleConstructorReturn(this, _getPrototypeOf(AbsoluteScrollStrategy).call(this, scrollContainer));
        _this18._initialized = false;

        _this18.onScroll = function () {
          _this18._overlayService.repositionAll();
        };

        _this18._scrollContainer = scrollContainer;
        return _this18;
      }
      /**
       * \@inheritdoc
       * @param {?} document
       * @param {?} overlayService
       * @param {?} id
       * @return {?}
       */


      _createClass(AbsoluteScrollStrategy, [{
        key: "initialize",
        value: function initialize(document, overlayService, id) {
          if (this._initialized) {
            return;
          }

          this._overlayService = overlayService;
          this._id = id;
          this._document = document;
          this._zone = overlayService.getOverlayById(id).ngZone;
          this._initialized = true;
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "attach",
        value: function attach() {
          var _this19 = this;

          if (this._zone) {
            this._zone.runOutsideAngular(function () {
              _this19.addScrollEventListener();
            });
          } else {
            this.addScrollEventListener();
          }
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll, true);
          } else {
            this._document.removeEventListener('scroll', this.onScroll, true);
          }

          this._initialized = false;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "addScrollEventListener",
        value: function addScrollEventListener() {
          if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll, true);
          } else {
            this._document.addEventListener('scroll', this.onScroll, true);
          }
        }
      }]);

      return AbsoluteScrollStrategy;
    }(ScrollStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Prevents scrolling while the overlay content is shown.
     */


    var BlockScrollStrategy =
    /*#__PURE__*/
    function (_ScrollStrategy3) {
      _inherits(BlockScrollStrategy, _ScrollStrategy3);

      /**
       * @param {?=} scrollContainer
       */
      function BlockScrollStrategy(scrollContainer) {
        var _this20;

        _classCallCheck(this, BlockScrollStrategy);

        _this20 = _possibleConstructorReturn(this, _getPrototypeOf(BlockScrollStrategy).call(this, scrollContainer));
        _this20._initialized = false;

        _this20.onScroll = function (ev) {
          ev.preventDefault();

          if (!_this20._sourceElement || _this20._sourceElement !== ev.target) {
            _this20._sourceElement =
            /** @type {?} */
            ev.target;
            _this20._initialScrollTop = _this20._sourceElement.scrollTop;
            _this20._initialScrollLeft = _this20._sourceElement.scrollLeft;
          }

          _this20._sourceElement.scrollTop = _this20._initialScrollTop;
          _this20._sourceElement.scrollLeft = _this20._initialScrollLeft;
        };

        return _this20;
      }
      /**
       * \@inheritdoc
       * @param {?} document
       * @param {?} overlayService
       * @param {?} id
       * @return {?}
       */


      _createClass(BlockScrollStrategy, [{
        key: "initialize",
        value: function initialize(document, overlayService, id) {
          if (this._initialized) {
            return;
          }

          this._document = document;
          this._initialized = true;
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "attach",
        value: function attach() {
          this._document.addEventListener('scroll', this.onScroll, true);
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          this._document.removeEventListener('scroll', this.onScroll, true);

          this._sourceElement = null;
          this._initialScrollTop = 0;
          this._initialScrollLeft = 0;
          this._initialized = false;
        }
      }]);

      return BlockScrollStrategy;
    }(ScrollStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded
     */


    var CloseScrollStrategy =
    /*#__PURE__*/
    function (_ScrollStrategy4) {
      _inherits(CloseScrollStrategy, _ScrollStrategy4);

      /**
       * @param {?=} scrollContainer
       */
      function CloseScrollStrategy(scrollContainer) {
        var _this21;

        _classCallCheck(this, CloseScrollStrategy);

        _this21 = _possibleConstructorReturn(this, _getPrototypeOf(CloseScrollStrategy).call(this, scrollContainer));
        _this21._initialized = false;

        _this21.onScroll = function (ev) {
          if (!_this21._sourceElement) {
            return;
          }

          _this21.cumulativeScrollTop += _this21._sourceElement.scrollTop;
          _this21.cumulativeScrollLeft += _this21._sourceElement.scrollLeft;

          if (Math.abs(_this21.cumulativeScrollTop - _this21.initialScrollTop) > _this21._threshold || Math.abs(_this21.cumulativeScrollLeft - _this21.initialScrollLeft) > _this21._threshold) {
            _this21._document.removeEventListener('scroll', _this21.onScroll, true);

            _this21._overlayService.hide(_this21._id);
          }
        };

        _this21._scrollContainer = scrollContainer;
        _this21._threshold = 10;
        _this21.cumulativeScrollTop = 0;
        _this21.cumulativeScrollLeft = 0;
        return _this21;
      }
      /**
       * \@inheritdoc
       * @param {?} document
       * @param {?} overlayService
       * @param {?} id
       * @return {?}
       */


      _createClass(CloseScrollStrategy, [{
        key: "initialize",
        value: function initialize(document, overlayService, id) {
          if (this._initialized) {
            return;
          }

          this._overlayService = overlayService;
          this._id = id;
          this._document = document;
          this._initialized = true;
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "attach",
        value: function attach() {
          if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll);

            this._sourceElement = this._scrollContainer;
          } else {
            this._document.addEventListener('scroll', this.onScroll);

            if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
              this._sourceElement =
              /** @type {?} */
              document.documentElement;
            } else if (document.body.scrollHeight > document.body.clientHeight) {
              this._sourceElement =
              /** @type {?} */
              document.body;
            }
          }

          if (!this._sourceElement) {
            return;
          }

          this.cumulativeScrollTop = 0;
          this.cumulativeScrollLeft = 0;
          this.initialScrollTop = this._sourceElement.scrollTop;
          this.initialScrollLeft = this._sourceElement.scrollLeft;
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "detach",
        value: function detach() {
          // TODO: check why event listener removes only on first call and remains on each next!!!
          if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll);
          } else {
            this._document.removeEventListener('scroll', this.onScroll);
          }

          this._sourceElement = null;
          this.cumulativeScrollTop = 0;
          this.cumulativeScrollLeft = 0;
          this.initialScrollTop = 0;
          this.initialScrollLeft = 0;
          this._initialized = false;
        }
      }]);

      return CloseScrollStrategy;
    }(ScrollStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @template T, S
     */


    var IgxBaseTransactionService =
    /*#__PURE__*/
    function () {
      function IgxBaseTransactionService() {
        _classCallCheck(this, IgxBaseTransactionService);

        this._isPending = false;
        this._pendingTransactions = [];
        this._pendingStates = new Map();
        /**
         * \@inheritdoc
         */

        this.onStateUpdate = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * \@inheritdoc
       * @return {?}
       */


      _createClass(IgxBaseTransactionService, [{
        key: "add",

        /**
         * \@inheritdoc
         * @param {?} transaction
         * @param {?=} recordRef
         * @return {?}
         */
        value: function add(transaction, recordRef) {
          if (this._isPending) {
            this.updateState(this._pendingStates, transaction, recordRef);

            this._pendingTransactions.push(transaction);
          }
        }
        /**
         * \@inheritdoc
         * @param {?=} id
         * @return {?}
         */

      }, {
        key: "getTransactionLog",
        value: function getTransactionLog(id) {
          return [];
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "undo",
        value: function undo() {}
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "redo",
        value: function redo() {}
        /**
         * \@inheritdoc
         * @param {?} mergeChanges
         * @return {?}
         */

      }, {
        key: "getAggregatedChanges",
        value: function getAggregatedChanges(mergeChanges) {
          var _this22 = this;

          /** @type {?} */
          var result = [];

          this._pendingStates.forEach(function (state, key) {
            /** @type {?} */
            var value = mergeChanges ? _this22.getAggregatedValue(key, mergeChanges) : state.value;
            result.push(
            /** @type {?} */
            {
              id: key,
              newValue: value,
              type: state.type
            });
          });

          return result;
        }
        /**
         * \@inheritdoc
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "getState",
        value: function getState(id) {
          return this._pendingStates.get(id);
        }
        /**
         * \@inheritdoc
         * @param {?} id
         * @param {?} mergeChanges
         * @return {?}
         */

      }, {
        key: "getAggregatedValue",
        value: function getAggregatedValue(id, mergeChanges) {
          /** @type {?} */
          var state = this._pendingStates.get(id);

          if (!state) {
            return null;
          }

          if (mergeChanges) {
            return this.updateValue(state);
          }

          return state.value;
        }
        /**
         * \@inheritdoc
         * @param {?} data
         * @param {?=} id
         * @return {?}
         */

      }, {
        key: "commit",
        value: function commit(data, id) {}
        /**
         * \@inheritdoc
         * @param {?=} id
         * @return {?}
         */

      }, {
        key: "clear",
        value: function clear(id) {
          this._pendingStates.clear();

          this._pendingTransactions = [];
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "startPending",
        value: function startPending() {
          this._isPending = true;
        }
        /**
         * \@inheritdoc
         * @param {?} commit
         * @return {?}
         */

      }, {
        key: "endPending",
        value: function endPending(commit) {
          this._isPending = false;

          this._pendingStates.clear();

          this._pendingTransactions = [];
        }
        /**
         * Updates the provided states collection according to passed transaction and recordRef
         * @protected
         * @param {?} states States collection to apply the update to
         * @param {?} transaction Transaction to apply to the current state
         * @param {?=} recordRef Reference to the value of the record in data source, if any, where transaction should be applied
         * @return {?}
         */

      }, {
        key: "updateState",
        value: function updateState(states, transaction, recordRef) {
          /** @type {?} */
          var state = states.get(transaction.id);

          if (state) {
            if (isObject(state.value)) {
              mergeObjects(state.value, transaction.newValue);
            } else {
              state.value = transaction.newValue;
            }
          } else {
            state =
            /** @type {?} */
            {
              value: cloneValue(transaction.newValue),
              recordRef: recordRef,
              type: transaction.type
            };
            states.set(transaction.id, state);
          }
        }
        /**
         * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
         * @protected
         * @param {?} state State to update value for
         * @return {?} updated value including all the changes in provided state
         */

      }, {
        key: "updateValue",
        value: function updateValue(state) {
          return this.mergeValues(state.recordRef, state.value);
        }
        /**
         * Merges second values in first value and the result in empty object. If values are primitive type
         * returns second value if exists, or first value.
         * @protected
         * @template U
         * @param {?} first Value to merge into
         * @param {?} second Value to merge
         * @return {?}
         */

      }, {
        key: "mergeValues",
        value: function mergeValues(first, second) {
          /** @type {?} */
          var result;

          if (isObject(first) || isObject(second)) {
            result = mergeObjects(mergeObjects({}, first), second);
          } else {
            result = second ? second : first;
          }

          return result;
        }
      }, {
        key: "canRedo",
        get: function get() {
          return false;
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "canUndo",
        get: function get() {
          return false;
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "enabled",
        get: function get() {
          return this._isPending;
        }
      }]);

      return IgxBaseTransactionService;
    }();

    IgxBaseTransactionService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @template T, S
     */

    var IgxTransactionService =
    /*#__PURE__*/
    function (_IgxBaseTransactionSe) {
      _inherits(IgxTransactionService, _IgxBaseTransactionSe);

      function IgxTransactionService() {
        var _this23;

        _classCallCheck(this, IgxTransactionService);

        _this23 = _possibleConstructorReturn(this, _getPrototypeOf(IgxTransactionService).apply(this, arguments));
        _this23._transactions = [];
        _this23._redoStack = [];
        _this23._undoStack = [];
        _this23._states = new Map();
        /**
         * \@inheritdoc
         */

        _this23.onStateUpdate = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this23;
      }
      /**
       * \@inheritdoc
       * @return {?}
       */


      _createClass(IgxTransactionService, [{
        key: "add",

        /**
         * \@inheritdoc
         * @param {?} transaction
         * @param {?=} recordRef
         * @return {?}
         */
        value: function add(transaction, recordRef) {
          /** @type {?} */
          var states = this._isPending ? this._pendingStates : this._states;
          this.verifyAddedTransaction(states, transaction, recordRef);
          this.addTransaction(transaction, states, recordRef);
        }
        /**
         * @protected
         * @param {?} transaction
         * @param {?} states
         * @param {?=} recordRef
         * @return {?}
         */

      }, {
        key: "addTransaction",
        value: function addTransaction(transaction, states, recordRef) {
          this.updateState(states, transaction, recordRef);
          /** @type {?} */

          var transactions = this._isPending ? this._pendingTransactions : this._transactions;
          transactions.push(transaction);

          if (!this._isPending) {
            this._undoStack.push([{
              transaction: transaction,
              recordRef: recordRef
            }]);

            this._redoStack = [];
            this.onStateUpdate.emit();
          }
        }
        /**
         * \@inheritdoc
         * @param {?=} id
         * @return {?}
         */

      }, {
        key: "getTransactionLog",
        value: function getTransactionLog(id) {
          if (id !== undefined) {
            return this._transactions.filter(function (t) {
              return t.id === id;
            });
          }

          return _toConsumableArray(this._transactions);
        }
        /**
         * \@inheritdoc
         * @param {?} mergeChanges
         * @return {?}
         */

      }, {
        key: "getAggregatedChanges",
        value: function getAggregatedChanges(mergeChanges) {
          var _this24 = this;

          /** @type {?} */
          var result = [];

          this._states.forEach(function (state, key) {
            /** @type {?} */
            var value = mergeChanges ? _this24.mergeValues(state.recordRef, state.value) : state.value;
            result.push(
            /** @type {?} */
            {
              id: key,
              newValue: value,
              type: state.type
            });
          });

          return result;
        }
        /**
         * \@inheritdoc
         * @param {?} id
         * @param {?=} pending
         * @return {?}
         */

      }, {
        key: "getState",
        value: function getState(id) {
          var pending = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return pending ? this._pendingStates.get(id) : this._states.get(id);
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "getAggregatedValue",

        /**
         * \@inheritdoc
         * @param {?} id
         * @param {?} mergeChanges
         * @return {?}
         */
        value: function getAggregatedValue(id, mergeChanges) {
          /** @type {?} */
          var state = this._states.get(id);
          /** @type {?} */


          var pendingState = _get(_getPrototypeOf(IgxTransactionService.prototype), "getState", this).call(this, id); //  if there is no state and there is no pending state return null


          if (!state && !pendingState) {
            return null;
          }
          /** @type {?} */


          var pendingChange = _get(_getPrototypeOf(IgxTransactionService.prototype), "getAggregatedValue", this).call(this, id, false);
          /** @type {?} */


          var change = state && state.value;
          /** @type {?} */

          var aggregatedValue = this.mergeValues(change, pendingChange);

          if (mergeChanges) {
            /** @type {?} */
            var originalValue = state ? state.recordRef : pendingState.recordRef;
            aggregatedValue = this.mergeValues(originalValue, aggregatedValue);
          }

          return aggregatedValue;
        }
        /**
         * \@inheritdoc
         * @param {?} commit
         * @return {?}
         */

      }, {
        key: "endPending",
        value: function endPending(commit) {
          this._isPending = false;

          if (commit) {
            /** @type {?} */
            var actions = []; // don't use addTransaction due to custom undo handling

            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
              for (var _iterator13 = this._pendingTransactions[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                var transaction = _step13.value;

                /** @type {?} */
                var pendingState = this._pendingStates.get(transaction.id);

                this._transactions.push(transaction);

                this.updateState(this._states, transaction, pendingState.recordRef);
                actions.push({
                  transaction: transaction,
                  recordRef: pendingState.recordRef
                });
              }
            } catch (err) {
              _didIteratorError13 = true;
              _iteratorError13 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
                  _iterator13["return"]();
                }
              } finally {
                if (_didIteratorError13) {
                  throw _iteratorError13;
                }
              }
            }

            this._undoStack.push(actions);

            this._redoStack = [];
            this.onStateUpdate.emit();
          }

          _get(_getPrototypeOf(IgxTransactionService.prototype), "endPending", this).call(this, commit);
        }
        /**
         * \@inheritdoc
         * @param {?} data
         * @param {?=} id
         * @return {?}
         */

      }, {
        key: "commit",
        value: function commit(data, id) {
          var _this25 = this;

          if (id !== undefined) {
            /** @type {?} */
            var state = this.getState(id);

            if (state) {
              this.updateRecord(data, state);
            }
          } else {
            this._states.forEach(function (s) {
              _this25.updateRecord(data, s);
            });
          }

          this.clear(id);
        }
        /**
         * \@inheritdoc
         * @param {?=} id
         * @return {?}
         */

      }, {
        key: "clear",
        value: function clear(id) {
          if (id !== undefined) {
            this._transactions = this._transactions.filter(function (t) {
              return t.id !== id;
            });

            this._states["delete"](id); //  Undo stack is an array of actions. Each action is array of transaction like objects
            //  We are going trough all the actions. For each action we are filtering out transactions
            //  with provided id. Finally if any action ends up as empty array we are removing it from
            //  undo stack


            this._undoStack = this._undoStack.map(function (a) {
              return a.filter(function (t) {
                return t.transaction.id !== id;
              });
            }).filter(function (a) {
              return a.length > 0;
            });
          } else {
            this._transactions = [];

            this._states.clear();

            this._undoStack = [];
          }

          this._redoStack = [];
          this.onStateUpdate.emit();
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "undo",
        value: function undo() {
          if (this._undoStack.length <= 0) {
            return;
          }
          /** @type {?} */


          var lastActions = this._undoStack.pop();

          this._transactions.splice(this._transactions.length - lastActions.length);

          this._redoStack.push(lastActions);

          this._states.clear();

          var _iteratorNormalCompletion14 = true;
          var _didIteratorError14 = false;
          var _iteratorError14 = undefined;

          try {
            for (var _iterator14 = this._undoStack[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
              var currentActions = _step14.value;
              var _iteratorNormalCompletion15 = true;
              var _didIteratorError15 = false;
              var _iteratorError15 = undefined;

              try {
                for (var _iterator15 = currentActions[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                  var transaction = _step15.value;
                  this.updateState(this._states, transaction.transaction, transaction.recordRef);
                }
              } catch (err) {
                _didIteratorError15 = true;
                _iteratorError15 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
                    _iterator15["return"]();
                  }
                } finally {
                  if (_didIteratorError15) {
                    throw _iteratorError15;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
                _iterator14["return"]();
              }
            } finally {
              if (_didIteratorError14) {
                throw _iteratorError14;
              }
            }
          }

          this.onStateUpdate.emit();
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "redo",
        value: function redo() {
          if (this._redoStack.length > 0) {
            /** @type {?} */
            var actions;
            actions = this._redoStack.pop();
            var _iteratorNormalCompletion16 = true;
            var _didIteratorError16 = false;
            var _iteratorError16 = undefined;

            try {
              for (var _iterator16 = actions[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                var action = _step16.value;
                this.updateState(this._states, action.transaction, action.recordRef);

                this._transactions.push(action.transaction);
              }
            } catch (err) {
              _didIteratorError16 = true;
              _iteratorError16 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
                  _iterator16["return"]();
                }
              } finally {
                if (_didIteratorError16) {
                  throw _iteratorError16;
                }
              }
            }

            this._undoStack.push(actions);

            this.onStateUpdate.emit();
          }
        }
        /**
         * Verifies if the passed transaction is correct. If not throws an exception.
         * @protected
         * @param {?} states
         * @param {?} transaction Transaction to be verified
         * @param {?=} recordRef
         * @return {?}
         */

      }, {
        key: "verifyAddedTransaction",
        value: function verifyAddedTransaction(states, transaction, recordRef) {
          /** @type {?} */
          var state = states.get(transaction.id);

          switch (transaction.type) {
            case TransactionType.ADD:
              if (state) {
                //  cannot add same item twice
                throw new Error("Cannot add this transaction. Transaction with id: ".concat(transaction.id, " has been already added."));
              }

              break;

            case TransactionType.DELETE:
            case TransactionType.UPDATE:
              if (state && state.type === TransactionType.DELETE) {
                //  cannot delete or update deleted items
                throw new Error("Cannot add this transaction. Transaction with id: ".concat(transaction.id, " has been already deleted."));
              }

              if (!state && !recordRef && !this._isPending) {
                //  cannot initially add transaction or delete item with no recordRef
                throw new Error("Cannot add this transaction. This is first transaction of type ".concat(transaction.type, " ") + "for id ".concat(transaction.id, ". For first transaction of this type recordRef is mandatory."));
              }

              break;
          }
        }
        /**
         * Updates the provided states collection according to passed transaction and recordRef
         * @protected
         * @param {?} states States collection to apply the update to
         * @param {?} transaction Transaction to apply to the current state
         * @param {?=} recordRef Reference to the value of the record in data source, if any, where transaction should be applied
         * @return {?}
         */

      }, {
        key: "updateState",
        value: function updateState(states, transaction, recordRef) {
          /** @type {?} */
          var state = states.get(transaction.id); //  if TransactionType is ADD simply add transaction to states;
          //  if TransactionType is DELETE:
          //    - if there is state with this id of type ADD remove it from the states;
          //    - if there is state with this id of type UPDATE change its type to DELETE;
          //    - if there is no state with this id add transaction to states;
          //  if TransactionType is UPDATE:
          //    - if there is state with this id of type ADD merge new value and state recordRef into state new value
          //    - if there is state with this id of type UPDATE merge new value into state new value
          //    - if there is state with this id and state type is DELETE change its type to UPDATE
          //    - if there is no state with this id add transaction to states;

          if (state) {
            switch (transaction.type) {
              case TransactionType.DELETE:
                if (state.type === TransactionType.ADD) {
                  states["delete"](transaction.id);
                } else if (state.type === TransactionType.UPDATE) {
                  state.value = transaction.newValue;
                  state.type = TransactionType.DELETE;
                }

                break;

              case TransactionType.UPDATE:
                if (isObject(state.value)) {
                  if (state.type === TransactionType.ADD) {
                    state.value = this.mergeValues(state.value, transaction.newValue);
                  }

                  if (state.type === TransactionType.UPDATE) {
                    mergeObjects(state.value, transaction.newValue);
                  }
                } else {
                  state.value = transaction.newValue;
                }

            }
          } else {
            state =
            /** @type {?} */
            {
              value: cloneValue(transaction.newValue),
              recordRef: recordRef,
              type: transaction.type
            };
            states.set(transaction.id, state);
          } //  should not clean pending state. This will happen automatically on endPending call


          if (!this._isPending) {
            this.cleanState(transaction.id, states);
          }
        }
        /**
         * Compares the state with recordRef and clears all duplicated values. If any state ends as
         * empty object removes it from states.
         * @protected
         * @param {?} id
         * @param {?} states
         * @return {?}
         */

      }, {
        key: "cleanState",
        value: function cleanState(id, states) {
          /** @type {?} */
          var state = states.get(id); //  do nothing if
          //  there is no state, or
          //  there is no state value (e.g. DELETED transaction), or
          //  there is no recordRef (e.g. ADDED transaction)

          if (state && state.value && state.recordRef) {
            //  if state's value is object compare each key with the ones in recordRef
            //  if values in any key are the same delete it from state's value
            //  if state's value is not object, simply compare with recordRef and remove
            //  the state if they are equal
            if (isObject(state.recordRef)) {
              for (var _i6 = 0, _Object$keys3 = Object.keys(state.value); _i6 < _Object$keys3.length; _i6++) {
                var key = _Object$keys3[_i6];

                if (JSON.stringify(state.recordRef[key]) === JSON.stringify(state.value[key])) {
                  delete state.value[key];
                }
              } //  if state's value is empty remove the state from the states, only if state is not DELETE type


              if (state.type !== TransactionType.DELETE && Object.keys(state.value).length === 0) {
                states["delete"](id);
              }
            } else {
              if (state.recordRef === state.value) {
                states["delete"](id);
              }
            }
          }
        }
        /**
         * Updates state related record in the provided data
         * @protected
         * @param {?} data Data source to update
         * @param {?} state State to update data from
         * @return {?}
         */

      }, {
        key: "updateRecord",
        value: function updateRecord(data, state) {
          /** @type {?} */
          var index = data.findIndex(function (i) {
            return JSON.stringify(i) === JSON.stringify(state.recordRef || {});
          });

          switch (state.type) {
            case TransactionType.ADD:
              data.push(state.value);
              break;

            case TransactionType.DELETE:
              if (0 <= index && index < data.length) {
                data.splice(index, 1);
              }

              break;

            case TransactionType.UPDATE:
              if (0 <= index && index < data.length) {
                data[index] = this.updateValue(state);
              }

              break;
          }
        }
      }, {
        key: "canUndo",
        get: function get() {
          return this._undoStack.length > 0;
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "canRedo",
        get: function get() {
          return this._redoStack.length > 0;
        }
      }, {
        key: "enabled",
        get: function get() {
          return true;
        }
      }]);

      return IgxTransactionService;
    }(IgxBaseTransactionService);

    IgxTransactionService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@experimental \@hidden
     * @template T, S
     */

    var IgxHierarchicalTransactionService =
    /*#__PURE__*/
    function (_IgxTransactionServic) {
      _inherits(IgxHierarchicalTransactionService, _IgxTransactionServic);

      function IgxHierarchicalTransactionService() {
        _classCallCheck(this, IgxHierarchicalTransactionService);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxHierarchicalTransactionService).apply(this, arguments));
      }

      _createClass(IgxHierarchicalTransactionService, [{
        key: "getAggregatedChanges",

        /**
         * @param {?} mergeChanges
         * @return {?}
         */
        value: function getAggregatedChanges(mergeChanges) {
          var _this26 = this;

          /** @type {?} */
          var result = [];

          this._states.forEach(function (state, key) {
            /** @type {?} */
            var value = mergeChanges ? _this26.mergeValues(state.recordRef, state.value) : cloneValue(state.value);

            _this26.clearArraysFromObject(value);

            result.push(
            /** @type {?} */
            {
              id: key,
              path: state.path,
              newValue: value,
              type: state.type
            });
          });

          return result;
        }
        /**
         * @protected
         * @param {?} states
         * @param {?} transaction
         * @param {?=} recordRef
         * @return {?}
         */

      }, {
        key: "updateState",
        value: function updateState(states, transaction, recordRef) {
          _get(_getPrototypeOf(IgxHierarchicalTransactionService.prototype), "updateState", this).call(this, states, transaction, recordRef); //  if transaction has no path, e.g. flat data source, get out


          if (!transaction.path) {
            return;
          }
          /** @type {?} */


          var currentState = states.get(transaction.id);

          if (currentState) {
            currentState.path = transaction.path;
          } //  if transaction has path, Hierarchical data source, and it is DELETE
          //  type transaction for all child rows remove ADD states and update
          //  transaction type and value of UPDATE states


          if (transaction.type === TransactionType.DELETE) {
            states.forEach(function (v, k) {
              if (v.path && v.path.indexOf(transaction.id) !== -1) {
                switch (v.type) {
                  case TransactionType.ADD:
                    states["delete"](k);
                    break;

                  case TransactionType.UPDATE:
                    states.get(k).type = TransactionType.DELETE;
                    states.get(k).value = null;
                }
              }
            });
          }
        }
        /**
         * Applies all transactions over the provided data
         * @param {?} data Data source to update
         * @param {?=} primaryKey Primary key of the hierarchical data
         * @param {?=} childDataKey Kye of child data collection
         * @param {?=} id Optional record id to commit transactions for
         * @return {?}
         */

      }, {
        key: "commit",
        value: function commit(data, primaryKey, childDataKey, id) {
          if (childDataKey !== undefined) {
            /** @type {?} */
            var transactions = this.getAggregatedChanges(true);

            if (id !== undefined) {
              transactions = transactions.filter(function (t) {
                return t.id === id;
              });
            }

            DataUtil.mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, true);
          } else {
            _get(_getPrototypeOf(IgxHierarchicalTransactionService.prototype), "commit", this).call(this, data, id);
          }

          this.clear(id);
        } //  TODO: remove this method. Force cloning to strip child arrays when needed instead

        /**
         * @private
         * @param {?} obj
         * @return {?}
         */

      }, {
        key: "clearArraysFromObject",
        value: function clearArraysFromObject(obj) {
          if (obj) {
            for (var _i7 = 0, _Object$keys4 = Object.keys(obj); _i7 < _Object$keys4.length; _i7++) {
              var prop = _Object$keys4[_i7];

              if (Array.isArray(obj[prop])) {
                delete obj[prop];
              }
            }
          }
        }
      }]);

      return IgxHierarchicalTransactionService;
    }(IgxTransactionService);

    IgxHierarchicalTransactionService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxToggleDirective =
    /*#__PURE__*/
    function () {
      /**
       * @hidden
       * @param {?} elementRef
       * @param {?} cdr
       * @param {?} overlayService
       * @param {?} navigationService
       */
      function IgxToggleDirective(elementRef, cdr, overlayService, navigationService) {
        var _this27 = this;

        _classCallCheck(this, IgxToggleDirective);

        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._overlaySubFilter = [Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function (x) {
          return x.id === _this27._overlayId;
        }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)];
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */

        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */

        this.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */

        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */

        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._collapsed = true;

        this.overlayClosed = function () {
          _this27._collapsed = true;

          _this27.cdr.detectChanges();

          delete _this27._overlayId;

          _this27.unsubscribe();

          _this27.onClosed.emit();
        };
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxToggleDirective, [{
        key: "open",

        /**
         * Opens the toggle.
         *
         * ```typescript
         * this.myToggle.open();
         * ```
         * @param {?=} overlaySettings
         * @return {?}
         */
        value: function open(overlaySettings) {
          var _this$overlayService$,
              _this28 = this,
              _this$overlayService$2,
              _this$overlayService$3;

          //  if there is open animation do nothing
          //  if toggle is not collapsed and there is no close animation do nothing

          /** @type {?} */
          var info = this.overlayService.getOverlayById(this._overlayId);
          /** @type {?} */

          var hasOpenAnimation = info ? info.openAnimationPlayer : false;
          /** @type {?} */

          var hasCloseAnimation = info ? info.closeAnimationPlayer : false;

          if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
            return;
          }

          if (!info) {
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
          }

          this._collapsed = false;
          this.cdr.detectChanges();
          /** @type {?} */

          var openEventArgs = {
            cancel: false
          };
          this.onOpening.emit(openEventArgs);

          if (openEventArgs.cancel) {
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
          }

          this.overlayService.show(this._overlayId, overlaySettings);
          this.unsubscribe();
          this._overlayOpenedSub = (_this$overlayService$ = this.overlayService.onOpened).pipe.apply(_this$overlayService$, _toConsumableArray(this._overlaySubFilter)).subscribe(function () {
            _this28.onOpened.emit();
          });
          this._overlayClosingSub = (_this$overlayService$2 = this.overlayService.onClosing).pipe.apply(_this$overlayService$2, _toConsumableArray(this._overlaySubFilter)).subscribe(function (e) {
            /** @type {?} */
            var eventArgs = {
              cancel: false,
              event: e.event
            };

            _this28.onClosing.emit(eventArgs);

            e.cancel = eventArgs.cancel; //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once

            if (!e.cancel) {
              _this28.clearSubscription(_this28._overlayClosingSub);
            }
          });
          this._overlayClosedSub = (_this$overlayService$3 = this.overlayService.onClosed).pipe.apply(_this$overlayService$3, _toConsumableArray(this._overlaySubFilter)).subscribe(this.overlayClosed);
        }
        /**
         * Closes the toggle.
         *
         * ```typescript
         * this.myToggle.close();
         * ```
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          //  if toggle is collapsed do nothing
          //  if there is close animation do nothing, toggle will close anyway

          /** @type {?} */
          var info = this.overlayService.getOverlayById(this._overlayId);
          /** @type {?} */

          var hasCloseAnimation = info ? info.closeAnimationPlayer : false;

          if (this._collapsed || hasCloseAnimation) {
            return;
          }

          this.overlayService.hide(this._overlayId);
        }
        /**
         * Opens or closes the toggle, depending on its current state.
         *
         * ```typescript
         * this.myToggle.toggle();
         * ```
         * @param {?=} overlaySettings
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle(overlaySettings) {
          //  if toggle is collapsed call open
          //  if there is close animation call open
          if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
          } else {
            this.close();
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "reposition",

        /**
         * Repositions the toggle.
         * ```typescript
         * this.myToggle.reposition();
         * ```
         * @return {?}
         */
        value: function reposition() {
          this.overlayService.reposition(this._overlayId);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
          }

          if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
          }

          this.unsubscribe();
          this.destroy$.next(true);
          this.destroy$.complete();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "unsubscribe",
        value: function unsubscribe() {
          this.clearSubscription(this._overlayOpenedSub);
          this.clearSubscription(this._overlayClosingSub);
          this.clearSubscription(this._overlayClosedSub);
        }
        /**
         * @private
         * @param {?} subscription
         * @return {?}
         */

      }, {
        key: "clearSubscription",
        value: function clearSubscription(subscription) {
          if (subscription && !subscription.closed) {
            subscription.unsubscribe();
          }
        }
      }, {
        key: "collapsed",
        get: function get() {
          return this._collapsed;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "element",
        get: function get() {
          return this.elementRef.nativeElement;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hiddenClass",
        get: function get() {
          return this.collapsed;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "defaultClass",
        get: function get() {
          return !this.collapsed;
        }
      }, {
        key: "isClosing",
        get: function get() {
          /** @type {?} */
          var info = this.overlayService.getOverlayById(this._overlayId);
          return info ? info.closeAnimationPlayer : false;
        }
      }]);

      return IgxToggleDirective;
    }();

    IgxToggleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'toggle',
        selector: '[igxToggle]'
      }]
    }];
    /** @nocollapse */

    IgxToggleDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxOverlayService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxOverlayService]
        }]
      }, {
        type: IgxNavigationService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    IgxToggleDirective.propDecorators = {
      onOpened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onOpening: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hiddenClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-toggle--hidden']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-hidden']
      }],
      defaultClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-toggle']
      }]
    };

    var IgxToggleActionDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?} navigationService
       */
      function IgxToggleActionDirective(element, navigationService) {
        _classCallCheck(this, IgxToggleActionDirective);

        this.element = element;
        this.navigationService = navigationService;
      }
      /**
       * @hidden
       * @param {?} target
       * @return {?}
       */


      _createClass(IgxToggleActionDirective, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this._overlayDefaults = {
            positionStrategy: new ConnectedPositioningStrategy({
              target: this.element.nativeElement
            }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludePositionTarget: true
          };
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onClick",
        value: function onClick() {
          if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
          }
          /** @type {?} */


          var clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
          this.updateOverlaySettings(clonedSettings);
          this.target.toggle(clonedSettings);
        }
        /**
         * Updates provided overlay settings
         * @protected
         * @param {?} settings settings to update
         * @return {?} returns updated copy of provided overlay settings
         */

      }, {
        key: "updateOverlaySettings",
        value: function updateOverlaySettings(settings) {
          if (settings && settings.positionStrategy) {
            /** @type {?} */
            var positionStrategyClone = settings.positionStrategy.clone();
            positionStrategyClone.settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
          }

          return settings;
        }
      }, {
        key: "target",
        set: function set(target) {
          if (target !== null && target !== '') {
            this._target = target;
          }
        }
        /**
         * @hidden
         * @return {?}
         */
        ,
        get: function get() {
          if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
          }

          return this._target;
        }
      }]);

      return IgxToggleActionDirective;
    }();

    IgxToggleActionDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'toggle-action',
        selector: '[igxToggleAction]'
      }]
    }];
    /** @nocollapse */

    IgxToggleActionDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: IgxNavigationService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    IgxToggleActionDirective.propDecorators = {
      overlaySettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      outlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxToggleOutlet']
      }],
      target: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxToggleAction']
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click']
      }]
    };
    /**
     * Mark an element as an igxOverlay outlet container.
     * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
     * ```html
     * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
     * ```
     */

    var IgxOverlayOutletDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       */
      function IgxOverlayOutletDirective(element) {
        _classCallCheck(this, IgxOverlayOutletDirective);

        this.element = element;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxOverlayOutletDirective, [{
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
      }]);

      return IgxOverlayOutletDirective;
    }();

    IgxOverlayOutletDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'overlay-outlet',
        selector: '[igxOverlayOutlet]'
      }]
    }];
    /** @nocollapse */

    IgxOverlayOutletDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxToggleModule = function IgxToggleModule() {
      _classCallCheck(this, IgxToggleModule);
    };

    IgxToggleModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
        exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
        providers: [IgxNavigationService]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var Navigate = {
      Up: -1,
      Down: 1
    };
    Navigate[Navigate.Up] = 'Up';
    Navigate[Navigate.Down] = 'Down';
    /** @enum {string} */

    var DropDownActionKey = {
      ESCAPE: 'escape',
      ENTER: 'enter',
      SPACE: 'space'
    };
    /** @type {?} */

    var IGX_DROPDOWN_BASE = 'IgxDropDownBaseToken';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxSelectionAPIService =
    /*#__PURE__*/
    function () {
      function IgxSelectionAPIService() {
        _classCallCheck(this, IgxSelectionAPIService);

        /**
         * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
         * If the primaryKey is omitted, then selection is based on the item data
         */
        this.selection = new Map();
      }
      /**
       * Get current component selection.
       * @param {?} componentID ID of the component.
       * @return {?}
       */


      _createClass(IgxSelectionAPIService, [{
        key: "get",
        value: function get(componentID) {
          return this.selection.get(componentID);
        }
        /**
         * Set new component selection.
         * @param {?} componentID ID of the component.
         * @param {?} newSelection The new component selection to be set.
         * @return {?}
         */

      }, {
        key: "set",
        value: function set(componentID, newSelection) {
          if (!componentID) {
            throw Error('Invalid value for component id!');
          }

          this.selection.set(componentID, newSelection);
        }
        /**
         * Clears selection for component.
         * @param {?} componentID ID of the component.
         * @return {?}
         */

      }, {
        key: "clear",
        value: function clear(componentID) {
          this.selection.set(componentID, this.get_empty());
        }
        /**
         * Get current component selection length.
         * @param {?} componentID ID of the component.
         * @return {?}
         */

      }, {
        key: "size",
        value: function size(componentID) {
          /** @type {?} */
          var sel = this.get(componentID);
          return sel ? sel.size : 0;
        }
        /**
         * Creates new selection that consist of the new item added to the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the select_item() one.
         * @param {?} componentID ID of the component, which we add new item to.
         * @param {?} itemID ID of the item to add to component selection.
         * @param {?=} sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
         *
         * @return {?} Selection after the new item is added.
         */

      }, {
        key: "add_item",
        value: function add_item(componentID, itemID, sel) {
          if (!sel) {
            sel = new Set(this.get(componentID));
          }

          if (sel === undefined) {
            sel = this.get_empty();
          }

          if (!itemID && itemID !== 0) {
            throw Error('Invalid value for item id!');
          }

          sel.add(itemID);
          return sel;
        }
        /**
         * Creates new selection that consist of the new items added to the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the select_items() one.
         * @param {?} componentID ID of the component, which we add new items to.
         * @param {?} itemIDs Array of IDs of the items to add to component selection.
         * @param {?=} clearSelection If true it will clear previous selection.
         *
         * @return {?} Selection after the new items are added.
         */

      }, {
        key: "add_items",
        value: function add_items(componentID, itemIDs, clearSelection) {
          var _this29 = this;

          /** @type {?} */
          var selection;

          if (clearSelection) {
            selection = this.get_empty();
          } else if (itemIDs && itemIDs.length === 0) {
            selection = new Set(this.get(componentID));
          }

          itemIDs.forEach(function (item) {
            return selection = _this29.add_item(componentID, item, selection);
          });
          return selection;
        }
        /**
         * Add item to the current component selection.
         * @param {?} componentID ID of the component, which we add new item to.
         * @param {?} itemID ID of the item to add to component selection.
         * @param {?=} sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
         * @return {?}
         */

      }, {
        key: "select_item",
        value: function select_item(componentID, itemID, sel) {
          this.set(componentID, this.add_item(componentID, itemID, sel));
        }
        /**
         * Add items to the current component selection.
         * @param {?} componentID ID of the component, which we add new items to.
         * @param {?} itemID
         * @param {?=} clearSelection If true it will clear previous selection.
         * @return {?}
         */

      }, {
        key: "select_items",
        value: function select_items(componentID, itemID, clearSelection) {
          this.set(componentID, this.add_items(componentID, itemID, clearSelection));
        }
        /**
         * Creates new selection that consist of the new items excluded from the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the deselect_item() one.
         * @param {?} componentID ID of the component, which we remove items from.
         * @param {?} itemID ID of the item to remove from component selection.
         * @param {?=} sel Used internally only by the selection (delete_items method) to accumulate deselected items.
         *
         * @return {?} Selection after the item is removed.
         */

      }, {
        key: "delete_item",
        value: function delete_item(componentID, itemID, sel) {
          if (!sel) {
            sel = new Set(this.get(componentID));
          }

          if (sel === undefined) {
            return;
          }

          sel["delete"](itemID);
          return sel;
        }
        /**
         * Creates new selection that consist of the new items removed to the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the deselect_items() one.
         * @param {?} componentID ID of the component, which we remove items from.
         * @param {?} itemIDs
         * @return {?} Selection after the items are removed.
         */

      }, {
        key: "delete_items",
        value: function delete_items(componentID, itemIDs) {
          var _this30 = this;

          /** @type {?} */
          var selection;
          itemIDs.forEach(function (deselectedItem) {
            return selection = _this30.delete_item(componentID, deselectedItem, selection);
          });
          return selection;
        }
        /**
         * Remove item from the current component selection.
         * @param {?} componentID ID of the component, which we remove item from.
         * @param {?} itemID ID of the item to remove from component selection.
         * @param {?=} sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
         * @return {?}
         */

      }, {
        key: "deselect_item",
        value: function deselect_item(componentID, itemID, sel) {
          this.set(componentID, this.delete_item(componentID, itemID, sel));
        }
        /**
         * Remove items to the current component selection.
         * @param {?} componentID ID of the component, which we add new items to.
         * @param {?} itemID
         * @param {?=} clearSelection
         * @return {?}
         */

      }, {
        key: "deselect_items",
        value: function deselect_items(componentID, itemID, clearSelection) {
          this.set(componentID, this.delete_items(componentID, itemID));
        }
        /**
         * Check if the item is selected in the component selection.
         * @param {?} componentID ID of the component.
         * @param {?} itemID ID of the item to search.
         *
         * @return {?} If item is selected.
         */

      }, {
        key: "is_item_selected",
        value: function is_item_selected(componentID, itemID) {
          /** @type {?} */
          var sel = this.get(componentID);

          if (!sel) {
            return false;
          }

          return sel.has(itemID);
        }
        /**
         * Get first element in the selection.
         * This is correct when we have only one item in the collection (for single selection purposes)
         * and the method returns that item.
         * @param {?} componentID ID of the component.
         *
         * @return {?} First element in the set.
         */

      }, {
        key: "first_item",
        value: function first_item(componentID) {
          /** @type {?} */
          var sel = this.get(componentID);

          if (sel && sel.size > 0) {
            return sel.values().next().value;
          }
        }
        /**
         * Returns whether all items are selected.
         * @param {?} componentID ID of the component.
         * @param {?} dataCount
         * @return {?} If all items are selected.
         */

      }, {
        key: "are_all_selected",
        value: function are_all_selected(componentID, dataCount) {
          return dataCount > 0 && dataCount === this.size(componentID);
        }
        /**
         * Returns whether any of the items is selected.
         * @param {?} componentID ID of the component.
         * @return {?} If there is any item selected.
         */

      }, {
        key: "are_none_selected",
        value: function are_none_selected(componentID) {
          return this.size(componentID) === 0;
        }
        /**
         * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
         * @param {?} data Entire data array.
         * @param {?=} primaryKey Data primary key.
         *
         * @return {?} Array of identifiers, either primary key values or the entire data array.
         */

      }, {
        key: "get_all_ids",
        value: function get_all_ids(data, primaryKey) {
          // If primaryKey is 0, this should still map to the property
          return primaryKey !== undefined && primaryKey !== null ? data.map(function (x) {
            return x[primaryKey];
          }) : data;
        }
        /**
         * Returns empty selection collection.
         * @return {?} empty set.
         */

      }, {
        key: "get_empty",
        value: function get_empty() {
          return new Set();
        }
      }]);

      return IgxSelectionAPIService;
    }();

    IgxSelectionAPIService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    IgxSelectionAPIService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function IgxSelectionAPIService_Factory() {
        return new IgxSelectionAPIService();
      },
      token: IgxSelectionAPIService,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID = 0;
    /**
     * The `<igx-drop-down-item>` is a container intended for row items in
     * a `<igx-drop-down>` container.
     */

    var IgxDropDownGroupComponent =
    /*#__PURE__*/
    function () {
      function IgxDropDownGroupComponent() {
        _classCallCheck(this, IgxDropDownGroupComponent);

        this._id = NEXT_ID++;
        /**
         * @hidden \@internal
         */

        this.role = 'group';
        /**
         * @hidden \@internal
         */

        this.groupClass = true;
        /**
         * Sets/gets if the item group is disabled
         *
         * ```typescript
         * const myDropDownGroup: IgxDropDownGroupComponent = this.dropdownGroup;
         * // get
         * ...
         * const groupState: boolean = myDropDownGroup.disabled;
         * ...
         * //set
         * ...
         * myDropDownGroup,disabled = false;
         * ...
         * ```
         *
         * ```html
         * <igx-drop-down-item-group [label]="'My Items'" [disabled]="true">
         *     <igx-drop-down-item *ngFor="let item of items[index]" [value]="item.value">
         *         {{ item.text }}
         *     </igx-drop-down-item>
         * </igx-drop-down-item-group>
         * ```
         *
         * **NOTE:** All items inside of a disabled drop down group will be treated as disabled
         */

        this.disabled = false;
      }
      /**
       * @hidden \@internal
       * @return {?}
       */


      _createClass(IgxDropDownGroupComponent, [{
        key: "labelId",
        get: function get() {
          return "igx-item-group-label-".concat(this._id);
        }
        /**
         * @return {?}
         */

      }, {
        key: "labelledBy",
        get: function get() {
          return this.labelId;
        }
      }]);

      return IgxDropDownGroupComponent;
    }();

    IgxDropDownGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-drop-down-item-group',
        template: "\n        <label id=\"{{labelId}}\">{{ label }}</label>\n        <ng-content select=\"igx-drop-down-item\"></ng-content>\n    "
      }]
    }];
    IgxDropDownGroupComponent.propDecorators = {
      labelledBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ["attr.aria-labelledby"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      groupClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__group']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ["attr.aria-disabled"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__group--disabled']
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$1 = 0;
    /** @type {?} */

    var warningShown$1 = false;
    /**
     * An abstract class defining a drop-down item:
     * With properties / styles for selection, highlight, height
     * Bindable property for passing data (`value: any`)
     * Parent component (has to be used under a parent with type `IDropDownBase`)
     * Method for handling click on Host()
     * @abstract
     */

    var IgxDropDownItemBase =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} dropDown
       * @param {?} elementRef
       * @param {?} group
       * @param {?=} selection
       */
      function IgxDropDownItemBase(dropDown, elementRef, group, selection) {
        _classCallCheck(this, IgxDropDownItemBase);

        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.group = group;
        this.selection = selection;
        /**
         * @hidden
         */

        this._focused = false;
        this._selected = false;
        this._index = null;
        this._disabled = false;
        /**
         * Sets/gets the `id` of the item.
         * ```html
         * <igx-drop-down-item [id] = 'igx-drop-down-item-0'></igx-drop-down-item>
         * ```
         * ```typescript
         * let itemId =  this.item.id;
         * ```
         * \@memberof IgxSelectItemComponent
         */

        this.id = "igx-drop-down-item-".concat(NEXT_ID$1++);
        /**
         * @hidden
         */

        this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets/sets the `role` attribute of the item. Default is 'option'.
         *
         * ```html
         *  <igx-drop-down-item [role]="customRole"></igx-drop-down-item>
         * ```
         */

        this.role = 'option';
      }
      /**
       * @protected
       * @return {?}
       */


      _createClass(IgxDropDownItemBase, [{
        key: "clicked",

        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */
        value: function clicked(event) {}
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (this._selected) {
            /** @type {?} */
            var dropDownSelectedItem = this.dropDown.selectedItem;

            if (!dropDownSelectedItem) {
              this.dropDown.selectItem(this);
            } else if (this.hasIndex ? this._index !== dropDownSelectedItem.index || this.value !== dropDownSelectedItem.value : this !== dropDownSelectedItem) {
              this.dropDown.selectItem(this);
            }
          }
        }
      }, {
        key: "hasIndex",
        get: function get() {
          return this._index !== null && this._index !== undefined;
        }
        /**
         * @hidden \@internal
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */

      }, {
        key: "itemID",
        get: function get() {
          return (
            /** @type {?} */
            this
          );
        }
        /**
         * The data index of the dropdown item.
         *
         * ```typescript
         * // get the data index of the selected dropdown item
         * let selectedItemIndex = this.dropdown.selectedItem.index
         * ```
         * @return {?}
         */

      }, {
        key: "index",
        get: function get() {
          if (this._index === null) {
            warningShown$1 = showMessage('IgxDropDownItemBase: Automatic index is deprecated.' + 'Bind in the template instead using `<igx-drop-down-item [index]="i"` instead.`', warningShown$1);
            return this.itemIndex;
          }

          return this._index;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._index = value;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "itemStyle",
        get: function get() {
          return !this.isHeader;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "itemStyleCosy",
        get: function get() {
          return this.dropDown.displayDensity === 'cosy' && !this.isHeader;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "itemStyleCompact",
        get: function get() {
          return this.dropDown.displayDensity === 'compact' && !this.isHeader;
        }
        /**
         * Sets/Gets if the item is the currently selected one in the dropdown
         *
         * ```typescript
         *  let mySelectedItem = this.dropdown.selectedItem;
         *  let isMyItemSelected = mySelectedItem.selected; // true
         * ```
         *
         * Two-way data binding
         * ```html
         * <igx-drop-down-item [(selected)]='model.isSelected'></igx-drop-down-item>
         * ```
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this._selected;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this.isHeader) {
            return;
          }

          this._selected = value;
          this.selectedChange.emit(this._selected);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "isSelected",
        get: function get() {
          return this.selected;
        }
        /**
         * @hidden \@internal
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.selected = value;
        }
        /**
         * Sets/gets if the given item is focused
         * ```typescript
         *  let mySelectedItem = this.dropdown.selectedItem;
         *  let isMyItemFocused = mySelectedItem.focused;
         * ```
         * @return {?}
         */

      }, {
        key: "focused",
        get: function get() {
          return !this.isHeader && !this.disabled && this._focused;
        }
        /**
         * ```html
         *  <igx-drop-down-item *ngFor="let item of items" focused={{!item.focused}}>
         *      <div>
         *          {{item.field}}
         *      </div>
         *  </igx-drop-down-item>
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._focused = value;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "isFocused",
        get: function get() {
          return this.focused;
        }
        /**
         * @hidden \@internal
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.focused = value;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "headerClassCosy",
        get: function get() {
          return this.isHeader && this.dropDown.displayDensity === 'cosy';
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "headerClassCompact",
        get: function get() {
          return this.isHeader && this.dropDown.displayDensity === 'compact';
        }
        /**
         * Sets/gets if the given item is disabled
         *
         * ```typescript
         *  // get
         *  let mySelectedItem = this.dropdown.selectedItem;
         *  let myItemIsDisabled = mySelectedItem.disabled;
         * ```
         *
         * ```html
         *  <igx-drop-down-item *ngFor="let item of items" disabled={{!item.disabled}}>
         *      <div>
         *          {{item.field}}
         *      </div>
         *  </igx-drop-down-item>
         * ```
         * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this.group ? this.group.disabled || this._disabled : this._disabled;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._disabled = value;
        }
        /**
         * Gets item index
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "itemIndex",
        get: function get() {
          return this.dropDown.items.indexOf(this);
        }
        /**
         * Gets item element height
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "elementHeight",
        get: function get() {
          return this.elementRef.nativeElement.clientHeight;
        }
        /**
         * Get item html element
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "element",
        get: function get() {
          return this.elementRef;
        }
      }]);

      return IgxDropDownItemBase;
    }();
    /** @nocollapse */


    IgxDropDownItemBase.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_DROPDOWN_BASE]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: IgxDropDownGroupComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: IgxSelectionAPIService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxSelectionAPIService]
        }]
      }];
    };

    IgxDropDownItemBase.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      index: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      itemStyle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__item']
      }],
      itemStyleCosy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__item--cosy']
      }],
      itemStyleCompact: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__item--compact']
      }],
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-selected']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__item--selected']
      }],
      selectedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      isSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      focused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__item--focused']
      }],
      isHeader: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__header']
      }],
      headerClassCosy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__header--cosy']
      }],
      headerClassCompact: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__header--compact']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-disabled']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down__item--disabled']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      clicked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("IgxDropDownItemBase `isSelected` property is deprecated.\n" + "Use `selected` instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxDropDownItemBase.prototype, "isSelected", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("IgxDropDownItemBase `isFocused` property is depracated.\n" + "Use `focused` instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxDropDownItemBase.prototype, "isFocused", null);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The `<igx-drop-down-item>` is a container intended for row items in
     * a `<igx-drop-down>` container.
     */

    var IgxDropDownItemComponent =
    /*#__PURE__*/
    function (_IgxDropDownItemBase) {
      _inherits(IgxDropDownItemComponent, _IgxDropDownItemBase);

      function IgxDropDownItemComponent() {
        _classCallCheck(this, IgxDropDownItemComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxDropDownItemComponent).apply(this, arguments));
      }

      _createClass(IgxDropDownItemComponent, [{
        key: "clicked",

        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */
        value: function clicked(event) {
          if (this.disabled || this.isHeader) {
            /** @type {?} */
            var focusedItem = this.dropDown.items.find(function (item) {
              return item.focused;
            });

            if (this.dropDown.allowItemsFocus && focusedItem) {
              focusedItem.element.nativeElement.focus({
                preventScroll: true
              });
            }

            return;
          }

          if (this.selection) {
            this.dropDown.selectItem(this, event);
          }
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "mousedownHandler",
        value: function mousedownHandler(event) {
          event.preventDefault();
        }
      }, {
        key: "focused",

        /**
         * \@inheritdoc
         * @return {?}
         */
        get: function get() {
          /** @type {?} */
          var focusedState = this._focused;

          if (this.hasIndex) {
            /** @type {?} */
            var focusedItem = this.selection.first_item("".concat(this.dropDown.id, "-active"));
            /** @type {?} */

            var focusedIndex = focusedItem ? focusedItem.index : -1;
            focusedState = this._index === focusedIndex;
          }

          return !this.isHeader && !this.disabled && focusedState;
        }
        /**
         * \@inheritdoc
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._focused = value;
        }
        /**
         * \@inheritdoc
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          if (this.hasIndex) {
            /** @type {?} */
            var item = this.selection.first_item("".concat(this.dropDown.id));
            return item ? item.index === this._index && item.value === this.value : false;
          }

          return this._selected;
        }
        /**
         * \@inheritdoc
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this.isHeader) {
            return;
          }

          this._selected = value;
          this.selectedChange.emit(this._selected);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "setTabIndex",
        get: function get() {
          /** @type {?} */
          var shouldSetTabIndex = this.dropDown.allowItemsFocus && !(this.disabled || this.isHeader);

          if (shouldSetTabIndex) {
            return 0;
          } else {
            return null;
          }
        }
      }]);

      return IgxDropDownItemComponent;
    }(IgxDropDownItemBase);

    IgxDropDownItemComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-drop-down-item',
        template: "<ng-content></ng-content>"
      }]
    }];
    IgxDropDownItemComponent.propDecorators = {
      setTabIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      clicked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }],
      mousedownHandler: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['mousedown', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var DisplayDensity = {
      comfortable: 'comfortable',
      cosy: 'cosy',
      compact: 'compact'
    };
    /**
     * Defines the DisplayDensity DI token.
     * @type {?}
     */

    var DisplayDensityToken = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('DisplayDensity');
    /**
     * Base class containing all logic required for implementing DisplayDensity.
     */

    var DisplayDensityBase =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} displayDensityOptions
       */
      function DisplayDensityBase(displayDensityOptions) {
        _classCallCheck(this, DisplayDensityBase);

        this.displayDensityOptions = displayDensityOptions;
        this.onDensityChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.oldDisplayDensityOptions = {
          displayDensity: DisplayDensity.comfortable
        };
        Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
      }
      /**
       * Returns the theme of the component.
       * The default theme is `comfortable`.
       * Available options are `comfortable`, `cosy`, `compact`.
       * ```typescript
       * let componentTheme = this.component.displayDensity;
       * ```
       * @return {?}
       */


      _createClass(DisplayDensityBase, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this.initialDensity = this._displayDensity;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (!this._displayDensity && this.displayDensityOptions && this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
            /** @type {?} */
            var densityChangedArgs = {
              oldDensity: this.oldDisplayDensityOptions.displayDensity,
              newDensity: this.displayDensityOptions.displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
            this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
          }
        }
        /**
         * Given a style class of a component/element returns the modified version of it based
         * on the current display density.
         * @protected
         * @param {?} baseStyleClass
         * @return {?}
         */

      }, {
        key: "getComponentDensityClass",
        value: function getComponentDensityClass(baseStyleClass) {
          switch (this.displayDensity) {
            case DisplayDensity.cosy:
              return "".concat(baseStyleClass, "--").concat(DisplayDensity.cosy);

            case DisplayDensity.compact:
              return "".concat(baseStyleClass, "--").concat(DisplayDensity.compact);

            default:
              return baseStyleClass;
          }
        }
      }, {
        key: "displayDensity",
        get: function get() {
          return this._displayDensity || this.displayDensityOptions && this.displayDensityOptions.displayDensity || DisplayDensity.comfortable;
        }
        /**
         * Sets the theme of the component.
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          /** @type {?} */
          var currentDisplayDensity = this._displayDensity;
          this._displayDensity =
          /** @type {?} */
          val;

          if (currentDisplayDensity !== this._displayDensity) {
            /** @type {?} */
            var densityChangedArgs = {
              oldDensity: currentDisplayDensity,
              newDensity: this._displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
          }
        }
      }]);

      return DisplayDensityBase;
    }();

    DisplayDensityBase.propDecorators = {
      displayDensity: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onDensityChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$2 = 0;
    /**
     * An abstract class, defining a drop-down component, with:
     * Properties for display styles and classes
     * A collection items of type `IgxDropDownItemBase`
     * Properties and methods for navigating (highlighting/focusing) items from the collection
     * Properties and methods for selecting items from the collection
     * @abstract
     */

    var IgxDropDownBase =
    /*#__PURE__*/
    function (_DisplayDensityBase) {
      _inherits(IgxDropDownBase, _DisplayDensityBase);

      /**
       * @param {?} elementRef
       * @param {?} cdr
       * @param {?} _displayDensityOptions
       */
      function IgxDropDownBase(elementRef, cdr, _displayDensityOptions) {
        var _this31;

        _classCallCheck(this, IgxDropDownBase);

        _this31 = _possibleConstructorReturn(this, _getPrototypeOf(IgxDropDownBase).call(this, _displayDensityOptions));
        _this31.elementRef = elementRef;
        _this31.cdr = cdr;
        _this31._displayDensityOptions = _displayDensityOptions;
        _this31._focusedItem = null;
        _this31._id = "igx-drop-down-".concat(NEXT_ID$2++);
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-drop-down (onSelection)='handleSelection()'></igx-drop-down>
         * ```
         */

        _this31.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets/Sets the drop down's container max height.
         *
         * ```typescript
         * // get
         * let maxHeight = this.dropdown.maxHeight;
         * ```
         * ```html
         * <!--set-->
         * <igx-drop-down [maxHeight]='200px'></igx-drop-down>
         * ```
         */

        _this31.maxHeight = null;
        /**
         * @hidden \@internal
         */

        _this31.cssClass = true;
        return _this31;
      }
      /**
       * Get dropdown's html element of it scroll container
       * @protected
       * @return {?}
       */


      _createClass(IgxDropDownBase, [{
        key: "onItemActionKey",

        /**
         * Keydown Handler
         * @param {?} key
         * @param {?=} event
         * @return {?}
         */
        value: function onItemActionKey(key, event) {
          switch (key) {
            case DropDownActionKey.ENTER:
            case DropDownActionKey.SPACE:
              this.selectItem(this.focusedItem, event);
              break;

            case DropDownActionKey.ESCAPE:
          }
        }
        /**
         * Emits onSelection with the target item & event
         * @hidden \@internal
         * @param {?=} newSelection the item selected
         * @param {?=} event the event that triggered the call
         * @return {?}
         */

      }, {
        key: "selectItem",
        value: function selectItem(newSelection, event) {
          this.onSelection.emit({
            newSelection: newSelection,
            oldSelection: null,
            cancel: false
          });
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "navigate",

        /**
         * @protected
         * @param {?} direction
         * @param {?=} currentIndex
         * @return {?}
         */
        value: function navigate(direction, currentIndex) {
          /** @type {?} */
          var index = -1;

          if (this._focusedItem) {
            index = currentIndex ? currentIndex : this.focusedItem.itemIndex;
          }
          /** @type {?} */


          var newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
          this.navigateItem(newIndex);
        }
        /**
         * @protected
         * @param {?} startIndex
         * @param {?} direction
         * @return {?}
         */

      }, {
        key: "getNearestSiblingFocusableItemIndex",
        value: function getNearestSiblingFocusableItemIndex(startIndex, direction) {
          /** @type {?} */
          var index = startIndex;
          /** @type {?} */

          var items = this.items;

          while (items[index + direction] && items[index + direction].disabled) {
            index += direction;
          }

          index += direction;

          if (index >= 0 && index < items.length) {
            return index;
          } else {
            return -1;
          }
        }
        /**
         * Navigates to the item on the specified index
         * @param {?} newIndex number - the index of the item in the `items` collection
         * @return {?}
         */

      }, {
        key: "navigateItem",
        value: function navigateItem(newIndex) {
          if (newIndex !== -1) {
            /** @type {?} */
            var oldItem = this._focusedItem;
            /** @type {?} */

            var newItem = this.items[newIndex];

            if (oldItem) {
              oldItem.focused = false;
            }

            this.focusedItem = newItem;
            this.scrollToHiddenItem(newItem);
            this.focusedItem.focused = true;
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "navigateFirst",
        value: function navigateFirst() {
          this.navigate(Navigate.Down, -1);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "navigateLast",
        value: function navigateLast() {
          this.navigate(Navigate.Up, this.items.length);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "navigateNext",
        value: function navigateNext() {
          this.navigate(Navigate.Down);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "navigatePrev",
        value: function navigatePrev() {
          this.navigate(Navigate.Up);
        }
        /**
         * @protected
         * @param {?} newItem
         * @return {?}
         */

      }, {
        key: "scrollToHiddenItem",
        value: function scrollToHiddenItem(newItem) {
          /** @type {?} */
          var elementRect = newItem.element.nativeElement.getBoundingClientRect();
          /** @type {?} */

          var parentRect = this.scrollContainer.getBoundingClientRect();

          if (parentRect.top > elementRect.top) {
            this.scrollContainer.scrollTop -= parentRect.top - elementRect.top;
          }

          if (parentRect.bottom < elementRect.bottom) {
            this.scrollContainer.scrollTop += elementRect.bottom - parentRect.bottom;
          }
        }
      }, {
        key: "scrollContainer",
        get: function get() {
          return this.element;
        }
        /**
         * Get all non-header items
         *
         * ```typescript
         * let myDropDownItems = this.dropdown.items;
         * ```
         * @return {?}
         */

      }, {
        key: "items",
        get: function get() {
          /** @type {?} */
          var items = [];

          if (this.children !== undefined) {
            var _iteratorNormalCompletion17 = true;
            var _didIteratorError17 = false;
            var _iteratorError17 = undefined;

            try {
              for (var _iterator17 = this.children.toArray()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                var child = _step17.value;

                if (!child.isHeader) {
                  items.push(child);
                }
              }
            } catch (err) {
              _didIteratorError17 = true;
              _iteratorError17 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
                  _iterator17["return"]();
                }
              } finally {
                if (_didIteratorError17) {
                  throw _iteratorError17;
                }
              }
            }
          }

          return items;
        }
        /**
         * Get all header items
         *
         * ```typescript
         * let myDropDownHeaderItems = this.dropdown.headers;
         * ```
         * @return {?}
         */

      }, {
        key: "headers",
        get: function get() {
          /** @type {?} */
          var headers = [];

          if (this.children !== undefined) {
            var _iteratorNormalCompletion18 = true;
            var _didIteratorError18 = false;
            var _iteratorError18 = undefined;

            try {
              for (var _iterator18 = this.children.toArray()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                var child = _step18.value;

                if (child.isHeader) {
                  headers.push(child);
                }
              }
            } catch (err) {
              _didIteratorError18 = true;
              _iteratorError18 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
                  _iterator18["return"]();
                }
              } finally {
                if (_didIteratorError18) {
                  throw _iteratorError18;
                }
              }
            }
          }

          return headers;
        }
        /**
         * Get dropdown html element
         *
         * ```typescript
         * let myDropDownElement = this.dropdown.element;
         * ```
         * @return {?}
         */

      }, {
        key: "element",
        get: function get() {
          return this.elementRef.nativeElement;
        }
      }, {
        key: "focusedItem",
        get: function get() {
          return this._focusedItem;
        }
        /**
         * @hidden \@internal
         * @param {?} item
         * @return {?}
         */
        ,
        set: function set(item) {
          this._focusedItem = item;
        }
      }]);

      return IgxDropDownBase;
    }(DisplayDensityBase);
    /** @nocollapse */


    IgxDropDownBase.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxDropDownBase.propDecorators = {
      onSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      height: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      maxHeight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.maxHeight']
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-down']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var DisplayContainerComponent =
    /**
     * @param {?} cdr
     * @param {?} _viewContainer
     */
    function DisplayContainerComponent(cdr, _viewContainer) {
      _classCallCheck(this, DisplayContainerComponent);

      this.cdr = cdr;
      this._viewContainer = _viewContainer;
      this.cssClass = 'igx-display-container';
      this.notVirtual = true;
    };

    DisplayContainerComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-display-container',
        template: "\n        <ng-template\n            #display_container\n            igxScrollInertia\n            [IgxScrollInertiaScrollContainer]=\"scrollContainer\"\n            [IgxScrollInertiaDirection]=\"scrollDirection\">\n        </ng-template>\n    "
      }]
    }];
    /** @nocollapse */

    DisplayContainerComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }];
    };

    DisplayContainerComponent.propDecorators = {
      _vcr: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['display_container', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"],
          "static": true
        }]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class']
      }],
      notVirtual: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-display-container--inactive']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var VirtualHelperBaseDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} cdr
       */
      function VirtualHelperBaseDirective(elementRef, cdr) {
        _classCallCheck(this, VirtualHelperBaseDirective);

        this.elementRef = elementRef;
        this.cdr = cdr;
        this.scrollAmount = 0;
        this._size = 0;
      }
      /**
       * @param {?} event
       * @return {?}
       */


      _createClass(VirtualHelperBaseDirective, [{
        key: "onScroll",
        value: function onScroll(event) {
          this.scrollAmount = event.target.scrollTop || event.target.scrollLeft;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",

        /**
         * @return {?}
         */
        value: function ngOnDestroy() {
          this.destroyed = true;
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.elementRef.nativeElement;
        }
      }, {
        key: "size",
        set: function set(value) {
          if (this.destroyed) {
            return;
          }

          this._size = value;
          this.cdr.detectChanges();
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._size;
        }
      }]);

      return VirtualHelperBaseDirective;
    }();

    VirtualHelperBaseDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxVirtualHelperBase]'
      }]
    }];
    /** @nocollapse */

    VirtualHelperBaseDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    VirtualHelperBaseDirective.propDecorators = {
      onScroll: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['scroll', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var HVirtualHelperComponent =
    /*#__PURE__*/
    function (_VirtualHelperBaseDir) {
      _inherits(HVirtualHelperComponent, _VirtualHelperBaseDir);

      /**
       * @param {?} elementRef
       * @param {?} cdr
       */
      function HVirtualHelperComponent(elementRef, cdr) {
        var _this32;

        _classCallCheck(this, HVirtualHelperComponent);

        _this32 = _possibleConstructorReturn(this, _getPrototypeOf(HVirtualHelperComponent).call(this, elementRef, cdr));
        _this32.elementRef = elementRef;
        _this32.cdr = cdr;
        _this32.cssClasses = 'igx-vhelper--horizontal';
        return _this32;
      }

      return HVirtualHelperComponent;
    }(VirtualHelperBaseDirective);

    HVirtualHelperComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-horizontal-virtual-helper',
        template: '<div #horizontal_container class="igx-vhelper__placeholder-content" [style.width.px]="size"></div>'
      }]
    }];
    /** @nocollapse */

    HVirtualHelperComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    HVirtualHelperComponent.propDecorators = {
      _vcr: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['horizontal_container', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"],
          "static": true
        }]
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cssClasses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var VirtualHelperComponent =
    /*#__PURE__*/
    function (_VirtualHelperBaseDir2) {
      _inherits(VirtualHelperComponent, _VirtualHelperBaseDir2);

      /**
       * @param {?} elementRef
       * @param {?} cdr
       */
      function VirtualHelperComponent(elementRef, cdr) {
        var _this33;

        _classCallCheck(this, VirtualHelperComponent);

        _this33 = _possibleConstructorReturn(this, _getPrototypeOf(VirtualHelperComponent).call(this, elementRef, cdr));
        _this33.elementRef = elementRef;
        _this33.cdr = cdr;
        _this33.cssClasses = 'igx-vhelper--vertical';
        return _this33;
      }

      return VirtualHelperComponent;
    }(VirtualHelperBaseDirective);

    VirtualHelperComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-virtual-helper',
        template: '<div #container class="igx-vhelper__placeholder-content" [style.height.px]="size"></div>'
      }]
    }];
    /** @nocollapse */

    VirtualHelperComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    VirtualHelperComponent.propDecorators = {
      scrollTop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['scrollTop']
      }],
      _vcr: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['container', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"],
          "static": true
        }]
      }],
      itemsLength: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cssClasses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxScrollInertiaDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?} _zone
       */
      function IgxScrollInertiaDirective(element, _zone) {
        _classCallCheck(this, IgxScrollInertiaDirective);

        this.element = element;
        this._zone = _zone;
        this.wheelStep = 50;
        this.inertiaStep = 1.5;
        this.swipeToleranceX = 20;
        this.inertiaDeltaY = 3;
        this.inertiaDeltaX = 2;
        this.inertiaDuration = 0.5;
        this._savedSpeedsX = [];
        this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ? 'msSetPointerCapture' : 'setPointerCapture';
        this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ? 'msReleasePointerCapture' : 'releasePointerCapture';
      }
      /**
       * @return {?}
       */


      _createClass(IgxScrollInertiaDirective, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this34 = this;

          this._zone.runOutsideAngular(function () {
            /** @type {?} */
            var targetElem = _this34.element.nativeElement.parentElement || _this34.element.nativeElement.parentNode;
            targetElem.addEventListener('wheel', function (evt) {
              _this34.onWheel(evt);
            });
            targetElem.addEventListener('touchstart', function (evt) {
              _this34.onTouchStart(evt);
            });
            targetElem.addEventListener('touchmove', function (evt) {
              _this34.onTouchMove(evt);
            });
            targetElem.addEventListener('touchend', function (evt) {
              _this34.onTouchEnd(evt);
            });
            targetElem.addEventListener('pointerdown', function (evt) {
              _this34.onPointerDown(evt);
            });
            targetElem.addEventListener('pointerup', function (evt) {
              _this34.onPointerUp(evt);
            });
            targetElem.addEventListener('MSGestureStart', function (evt) {
              _this34.onMSGestureStart(evt);
            });
            targetElem.addEventListener('MSGestureChange', function (evt) {
              _this34.onMSGestureChange(evt);
            });
          });
        }
        /**
         * @hidden
         * Function that is called when scrolling with the mouse wheel or using touchpad
         * @protected
         * @param {?} evt
         * @return {?}
         */

      }, {
        key: "onWheel",
        value: function onWheel(evt) {
          // if no scrollbar return
          if (!this.IgxScrollInertiaScrollContainer) {
            return;
          }
          /** @type {?} */


          var scrollDeltaX;
          /** @type {?} */

          var scrollDeltaY;
          /** @type {?} */

          var scrollStep = this.wheelStep;
          /** @type {?} */

          var minWheelStep = 1 / this.wheelStep;
          this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
          this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;

          if (evt.wheelDeltaX) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaX = -evt.wheelDeltaX / 120;

            if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
              scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
            }
          } else if (evt.deltaX) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            scrollDeltaX = this.calcAxisCoords(evt.deltaX, -1, 1);
          }
          /** Get delta for the Y axis*/


          if (evt.wheelDeltaY) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaY = -evt.wheelDeltaY / 120;

            if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
              scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
            }
          } else if (evt.deltaY) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            scrollDeltaY = this.calcAxisCoords(evt.deltaY, -1, 1);
          }

          if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
            this._scrollToX(this._startX + scrollDeltaX * scrollStep);
            /** @type {?} */


            var curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
            /** @type {?} */

            var maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);

            if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
              // Prevent navigating through pages when scrolling on Mac
              evt.preventDefault();
            }
          } else if (scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
            this._scrollToY(this._startY + scrollDeltaY * scrollStep);

            this.preventParentScroll(evt, true);
          }
        }
        /**
         * @hidden
         * When there is still room to scroll up/down prevent the parent elements from scrolling too.
         * @protected
         * @param {?} evt
         * @param {?} preventDefault
         * @return {?}
         */

      }, {
        key: "preventParentScroll",
        value: function preventParentScroll(evt, preventDefault) {
          /** @type {?} */
          var curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
          /** @type {?} */

          var maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight - this.IgxScrollInertiaScrollContainer.offsetHeight;

          if (0 < curScrollTop && curScrollTop < maxScrollTop) {
            if (preventDefault) {
              evt.preventDefault();
            }

            if (evt.stopPropagation) {
              evt.stopPropagation();
            }
          }
        }
        /**
         * @hidden
         * Function that is called the first moment we start interacting with the content on a touch device
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onTouchStart",
        value: function onTouchStart(event) {
          if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
            return false;
          } // stops any current ongoing inertia


          cancelAnimationFrame(this._touchInertiaAnimID);
          /** @type {?} */

          var touch = event.touches[0];
          this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
          this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
          this._touchStartX = touch.pageX;
          this._touchStartY = touch.pageY;
          this._lastTouchEnd = new Date().getTime();
          this._lastTouchX = touch.pageX;
          this._lastTouchY = touch.pageY;
          this._savedSpeedsX = [];
          this._savedSpeedsY = []; // Vars regarding swipe offset

          this._totalMovedX = 0;
          this._offsetRecorded = false;
          this._offsetDirection = 0;
          this._touchPrevented = false;

          if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
          }
        }
        /**
         * @hidden
         * Function that is called when we need to scroll the content based on touch interactions
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onTouchMove",
        value: function onTouchMove(event) {
          if (typeof MSGesture === 'function') {
            this._touchPrevented = false;
            return false;
          }

          if (!this.IgxScrollInertiaScrollContainer) {
            return;
          }
          /** @type {?} */


          var touch = event.touches[0];
          /** @type {?} */

          var destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
          /** @type {?} */

          var destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
          /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */

          /* **********************************************************/

          /** @type {?} */

          var timeFromLastTouch = new Date().getTime() - this._lastTouchEnd;

          if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
            /** @type {?} */
            var speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
            /** @type {?} */

            var speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch; // Save the last 5 speeds between two touchmoves on X axis

            if (this._savedSpeedsX.length < 5) {
              this._savedSpeedsX.push(speedX);
            } else {
              this._savedSpeedsX.shift();

              this._savedSpeedsX.push(speedX);
            } // Save the last 5 speeds between two touchmoves on Y axis


            if (this._savedSpeedsY.length < 5) {
              this._savedSpeedsY.push(speedY);
            } else {
              this._savedSpeedsY.shift();

              this._savedSpeedsY.push(speedY);
            }
          }

          this._lastTouchEnd = new Date().getTime();
          this._lastMovedX = this._lastTouchX - touch.pageX;
          this._lastMovedY = this._lastTouchY - touch.pageY;
          this._lastTouchX = touch.pageX;
          this._lastTouchY = touch.pageY;
          this._totalMovedX += this._lastMovedX;
          /** @type {?} */

          var scrolledXY;
          /*	Do not scroll using touch untill out of the swipeToleranceX bounds */

          if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            scrolledXY = this._scrollTo(this._startX, destY);
          } else {
            /*	Record the direction the first time we are out of the swipeToleranceX bounds.
            *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
            if (!this._offsetRecorded) {
              this._offsetDirection = Math.sign(destX - this._startX);
              this._offsetRecorded = true;
            }
            /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
            don't change it after that ever until touchend and again touchstart */


            scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
          }

          if (scrolledXY.x === 0 && scrolledXY.y === 0) {
            this._touchPrevented = true;
          } // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow


          if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, true);
          }
        }
        /**
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onTouchEnd",
        value: function onTouchEnd(event) {
          if (typeof MSGesture === 'function') {
            return;
          }
          /** @type {?} */


          var speedX = 0;
          /** @type {?} */

          var speedY = 0; // savedSpeedsX and savedSpeedsY have same length

          for (var i = 0; i < this._savedSpeedsX.length; i++) {
            speedX += this._savedSpeedsX[i];
            speedY += this._savedSpeedsY[i];
          }

          speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
          speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0; // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia

          if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) && (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
            this._inertiaInit(speedX, speedY);
          }

          if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
          }
        }
        /**
         * @hidden
         * Function that is called when we need to detect touch starting on a touch device on IE/Edge
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onPointerDown",
        value: function onPointerDown(event) {
          if (!event || event.pointerType !== 2 && event.pointerType !== 'touch' || typeof MSGesture !== 'function') {
            return true;
          }

          if (!this.IgxScrollInertiaScrollContainer) {
            return;
          } // setPointerCaptureFName is the name of the function that is supported


          event.target[this.setPointerCaptureFName](this._pointer = event.pointerId); // create gestureObject only one time to prevent overlapping during intertia

          if (!this._gestureObject) {
            this._gestureObject = new MSGesture();
            this._gestureObject.target = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
          }

          this._gestureObject.addPointer(this._pointer);
        }
        /**
         * @hidden
         * Function that is called when we need to detect touch ending on a touch device on IE/Edge
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onPointerUp",
        value: function onPointerUp(event) {
          if (!this._pointer) {
            return true;
          }

          if (!this.IgxScrollInertiaScrollContainer) {
            return;
          }
          /* releasePointerCaptureFName is the name of the function that is supported */


          event.target[this.releasePointerCaptureFName](this._pointer);
          delete this._pointer;
        }
        /**
         * @hidden
         *  Function that is called when a gesture begins on IE/Edge
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onMSGestureStart",
        value: function onMSGestureStart(event) {
          if (!this.IgxScrollInertiaScrollContainer) {
            return;
          }

          this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
          this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
          this._touchStartX = event.screenX;
          this._touchStartY = event.screenY; // Vars regarding swipe offset

          this._totalMovedX = 0;
          this._offsetRecorded = false;
          this._offsetDirection = 0;
          return false;
        }
        /**
         * @hidden
         * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onMSGestureChange",
        value: function onMSGestureChange(event) {
          if (!this.IgxScrollInertiaScrollContainer) {
            return;
          }
          /** @type {?} */


          var touchPos = event;
          /** @type {?} */

          var destX = this._startX + this._touchStartX - touchPos.screenX;
          /** @type {?} */

          var destY = this._startY + this._touchStartY - touchPos.screenY;
          /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */

          this._totalMovedX = this._touchStartX - touchPos.screenX;

          if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            /* Do not scroll horizontally yet while in the tolerance range */
            this._scrollToY(destY);
          } else {
            if (!this._offsetRecorded) {
              this._offsetDirection = Math.sign(destX - this._startX);
              this._offsetRecorded = true;
            }
            /* Once the tolerance is exceeded it can be scrolled horizontally */


            this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
          }

          return false;
        }
        /**
         * @private
         * @param {?} target
         * @param {?} min
         * @param {?} max
         * @return {?}
         */

      }, {
        key: "calcAxisCoords",
        value: function calcAxisCoords(target, min, max) {
          if (target === undefined || target < min) {
            target = min;
          } else if (target > max) {
            target = max;
          }

          return target;
        }
        /**
         * @private
         * @param {?} destX
         * @param {?} destY
         * @return {?}
         */

      }, {
        key: "_scrollTo",
        value: function _scrollTo(destX, destY) {
          /** @type {?} */
          var curPosX = this.IgxScrollInertiaScrollContainer.scrollLeft;
          /** @type {?} */

          var curPosY = this.IgxScrollInertiaScrollContainer.scrollTop; // TODO Trigger scrolling event?

          /** @type {?} */

          var scrolledX = this._scrollToX(destX);
          /** @type {?} */


          var scrolledY = this._scrollToY(destY);

          return {
            x: scrolledX,
            y: scrolledY
          };
        }
        /**
         * @private
         * @param {?} dest
         * @return {?}
         */

      }, {
        key: "_scrollToX",
        value: function _scrollToX(dest) {
          this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
        }
        /**
         * @private
         * @param {?} dest
         * @return {?}
         */

      }, {
        key: "_scrollToY",
        value: function _scrollToY(dest) {
          this.IgxScrollInertiaScrollContainer.scrollTop = dest;
        }
        /**
         * @protected
         * @param {?} speedX
         * @param {?} speedY
         * @return {?}
         */

      }, {
        key: "_inertiaInit",
        value: function _inertiaInit(speedX, speedY) {
          var _this35 = this;

          /** @type {?} */
          var stepModifer = this.inertiaStep;
          /** @type {?} */

          var inertiaDuration = this.inertiaDuration;
          /** @type {?} */

          var x = 0;
          this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
          this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop; // Sets timeout until executing next movement iteration of the inertia

          /** @type {?} */

          var inertiaStep = function inertiaStep() {
            if (x > 6) {
              cancelAnimationFrame(_this35._touchInertiaAnimID);
              return;
            }

            if (Math.abs(speedX) > Math.abs(speedY)) {
              x += 0.05 / (1 * inertiaDuration);
            } else {
              x += 0.05 / (1 * inertiaDuration);
            }

            if (x <= 1) {
              // We use constant quation to determine the offset without speed falloff befor x reaches 1
              if (Math.abs(speedY) <= Math.abs(speedX) * _this35.inertiaDeltaY) {
                _this35._nextX += 1 * speedX * 15 * stepModifer;
              }

              if (Math.abs(speedY) >= Math.abs(speedX) * _this35.inertiaDeltaX) {
                _this35._nextY += 1 * speedY * 15 * stepModifer;
              }
            } else {
              // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
              if (Math.abs(speedY) <= Math.abs(speedX) * _this35.inertiaDeltaY) {
                _this35._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
              }

              if (Math.abs(speedY) >= Math.abs(speedX) * _this35.inertiaDeltaX) {
                _this35._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
              }
            } // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse


            _this35._scrollTo(_this35._nextX, _this35._nextY);

            _this35._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
          }; // Start inertia and continue it recursively


          this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _this36 = this;

          this._zone.runOutsideAngular(function () {
            /** @type {?} */
            var targetElem = _this36.element.nativeElement.parentElement || _this36.element.nativeElement.parentNode;
            targetElem.removeEventListener('wheel', function (evt) {
              _this36.onWheel(evt);
            });
            targetElem.removeEventListener('touchstart', function (evt) {
              _this36.onTouchStart(evt);
            });
            targetElem.removeEventListener('touchmove', function (evt) {
              _this36.onTouchMove(evt);
            });
            targetElem.removeEventListener('touchend', function (evt) {
              _this36.onTouchEnd(evt);
            });
            targetElem.removeEventListener('pointerdown', function (evt) {
              _this36.onPointerDown(evt);
            });
            targetElem.removeEventListener('pointerup', function (evt) {
              _this36.onPointerUp(evt);
            });
            targetElem.removeEventListener('MSGestureStart', function (evt) {
              _this36.onMSGestureStart(evt);
            });
            targetElem.removeEventListener('MSGestureChange', function (evt) {
              _this36.onMSGestureChange(evt);
            });
          });
        }
      }]);

      return IgxScrollInertiaDirective;
    }();

    IgxScrollInertiaDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxScrollInertia]'
      }]
    }];
    /** @nocollapse */

    IgxScrollInertiaDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };

    IgxScrollInertiaDirective.propDecorators = {
      IgxScrollInertiaDirection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      IgxScrollInertiaScrollContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      wheelStep: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      inertiaStep: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      swipeToleranceX: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      inertiaDeltaY: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      inertiaDeltaX: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      inertiaDuration: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @hidden
     */

    var IgxScrollInertiaModule = function IgxScrollInertiaModule() {
      _classCallCheck(this, IgxScrollInertiaModule);
    };

    IgxScrollInertiaModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxScrollInertiaDirective],
        exports: [IgxScrollInertiaDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxForOfSyncService =
    /*#__PURE__*/
    function () {
      function IgxForOfSyncService() {
        _classCallCheck(this, IgxForOfSyncService);

        this._master = new Map();
      }
      /**
       * @hidden
       * @param {?} directive
       * @return {?}
       */


      _createClass(IgxForOfSyncService, [{
        key: "isMaster",
        value: function isMaster(directive) {
          return this._master.get(directive.igxForScrollOrientation) === directive;
        }
        /**
         * @hidden
         * @param {?} directive
         * @param {?=} forced
         * @return {?}
         */

      }, {
        key: "setMaster",
        value: function setMaster(directive) {
          var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          /** @type {?} */
          var orientation = directive.igxForScrollOrientation;

          if (orientation && (forced || !this._master.has(orientation))) {
            this._master.set(orientation, directive);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "resetMaster",
        value: function resetMaster() {
          this._master.clear();
        }
        /**
         * @hidden
         * @param {?} dir
         * @return {?}
         */

      }, {
        key: "sizesCache",
        value: function sizesCache(dir) {
          return this._master.get(dir).sizesCache;
        }
        /**
         * @hidden
         * @param {?} dir
         * @return {?}
         */

      }, {
        key: "chunkSize",
        value: function chunkSize(dir) {
          return this._master.get(dir).state.chunkSize;
        }
      }]);

      return IgxForOfSyncService;
    }();

    IgxForOfSyncService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    IgxForOfSyncService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function IgxForOfSyncService_Factory() {
        return new IgxForOfSyncService();
      },
      token: IgxForOfSyncService,
      providedIn: "root"
    });

    var IgxForOfScrollSyncService =
    /*#__PURE__*/
    function () {
      function IgxForOfScrollSyncService() {
        _classCallCheck(this, IgxForOfScrollSyncService);

        this._masterScroll = new Map();
      }
      /**
       * @param {?} dir
       * @param {?} scroll
       * @return {?}
       */


      _createClass(IgxForOfScrollSyncService, [{
        key: "setScrollMaster",
        value: function setScrollMaster(dir, scroll) {
          this._masterScroll.set(dir, scroll);
        }
        /**
         * @param {?} dir
         * @return {?}
         */

      }, {
        key: "getScrollMaster",
        value: function getScrollMaster(dir) {
          return this._masterScroll.get(dir);
        }
      }]);

      return IgxForOfScrollSyncService;
    }();

    IgxForOfScrollSyncService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    IgxForOfScrollSyncService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function IgxForOfScrollSyncService_Factory() {
        return new IgxForOfScrollSyncService();
      },
      token: IgxForOfScrollSyncService,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@publicApi
     * @template T
     */

    var IgxForOfContext =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} $implicit
       * @param {?} index
       * @param {?} count
       */
      function IgxForOfContext($implicit, index, count) {
        _classCallCheck(this, IgxForOfContext);

        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
      }
      /**
       * A function that returns whether the element is the first or not
       * @return {?}
       */


      _createClass(IgxForOfContext, [{
        key: "first",
        get: function get() {
          return this.index === 0;
        }
        /**
         * A function that returns whether the element is the last or not
         * @return {?}
         */

      }, {
        key: "last",
        get: function get() {
          return this.index === this.count - 1;
        }
        /**
         * A function that returns whether the element is even or not
         * @return {?}
         */

      }, {
        key: "even",
        get: function get() {
          return this.index % 2 === 0;
        }
        /**
         * A function that returns whether the element is odd or not
         * @return {?}
         */

      }, {
        key: "odd",
        get: function get() {
          return !this.even;
        }
      }]);

      return IgxForOfContext;
    }();
    /**
     * @template T
     */


    var IgxForOfDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _viewContainer
       * @param {?} _template
       * @param {?} _differs
       * @param {?} resolver
       * @param {?} cdr
       * @param {?} _zone
       * @param {?} syncScrollService
       */
      function IgxForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService) {
        _classCallCheck(this, IgxForOfDirective);

        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.resolver = resolver;
        this.cdr = cdr;
        this._zone = _zone;
        this.syncScrollService = syncScrollService;
        /**
         * An \@Input property that specifies the scroll orientation.
         * Scroll orientation can be "vertical" or "horizontal".
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
         * ```
         */

        this.igxForScrollOrientation = 'vertical';
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */

        this.state = {
          startIndex: 0,
          chunkSize: 0
        };
        /**
         * The total count of the virtual data items, when using remote service.
         * ```typescript
         * this.parentVirtDir.totalItemCount = data.Count;
         * ```
         */

        this.totalItemCount = null;
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
         * ```
         * ```typescript
         * chunkLoad(e){
         * alert("chunk loaded!");
         * }
         * ```
         */

        this.onChunkLoad = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden \@internal
         * An event that is emitted when scrollbar visibility has changed.
         */

        this.onScrollbarVisibilityChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after the rendered content size of the igxForOf has been changed.
         */

        this.onContentSizeChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */

        this.onDataChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onBeforeViewDestroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */

        this.onChunkPreload = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._sizesCache = [];
        this._differ = null;
        this.heightCache = [];
        this.MAX_PERF_SCROLL_DIFF = 4;
        /**
         * Height that is being virtualized.
         */

        this._virtHeight = 0;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
         */

        this._virtHeightRatio = 1;
        /**
         * Internal track for scroll top that is being virtualized
         */

        this._virtScrollTop = 0;
        /**
         * If the next onScroll event is triggered due to internal setting of scrollTop
         */

        this._bScrollInternal = false; // End properties related to virtual height handling

        this._embeddedViews = [];
        this.contentResizeNotify = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */

        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
      }
      /**
       * @return {?}
       */


      _createClass(IgxForOfDirective, [{
        key: "removeScrollEventListeners",

        /**
         * @hidden
         * @protected
         * @return {?}
         */
        value: function removeScrollEventListeners() {
          var _this37 = this;

          if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(function () {
              return _this37.scrollComponent.nativeElement.removeEventListener('scroll', _this37.func);
            });
          } else {
            this._zone.runOutsideAngular(function () {
              return _this37.scrollComponent.nativeElement.removeEventListener('scroll', _this37.verticalScrollHandler);
            });
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "verticalScrollHandler",
        value: function verticalScrollHandler(event) {
          this.onScroll(event);
        }
        /**
         * @return {?}
         */

      }, {
        key: "isScrollable",
        value: function isScrollable() {
          return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this38 = this;

          /** @type {?} */
          var totalSize = 0;
          /** @type {?} */

          var vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
          this.igxForSizePropName = this.igxForSizePropName || 'width';
          /** @type {?} */

          var dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
          this.dc = this._viewContainer.createComponent(dcFactory, 0);
          this.dc.instance.scrollDirection = this.igxForScrollOrientation;

          if (typeof MSGesture === 'function') {
            // On Edge and IE when scrolling on touch the page scroll instead of the grid.
            this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
          }

          if (this.igxForOf && this.igxForOf.length) {
            totalSize = this.initSizesCache(this.igxForOf);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            this.state.chunkSize = this._calculateChunkSize();
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);

            if (this.scrollComponent) {
              this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache, 0), this.igxForOf.length - this.state.chunkSize);
            }

            for (var i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize && this.igxForOf[i] !== undefined; i++) {
              /** @type {?} */
              var input = this.igxForOf[i];
              /** @type {?} */

              var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));

              this._embeddedViews.push(embeddedView);
            }
          }

          if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            /** @type {?} */

            var factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
            this.scrollComponent = vc.createComponent(factory).instance;
            this._maxHeight = this._calcMaxBrowserHeight();
            this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;
            this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);

            this._zone.runOutsideAngular(function () {
              _this38.verticalScrollHandler = _this38.verticalScrollHandler.bind(_this38);

              _this38.scrollComponent.nativeElement.addEventListener('scroll', _this38.verticalScrollHandler);

              _this38.dc.instance.scrollContainer = _this38.scrollComponent.nativeElement;
            });
            /** @type {?} */


            var destructor = Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$);
            this.contentResizeNotify.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function () {
              return _this38.igxForContainerSize && _this38.igxForOf && _this38.igxForOf.length > 0;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttleTime"])(40, undefined, {
              leading: true,
              trailing: true
            })).subscribe(function () {
              _this38._zone.runTask(function () {
                _this38.updateSizes();
              });
            });
          }

          if (this.igxForScrollOrientation === 'horizontal') {
            this.func = function (evt) {
              _this38.onHScroll(evt);
            };

            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);

            if (!this.scrollComponent) {
              /** @type {?} */
              var hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
              this.scrollComponent = vc.createComponent(hvFactory).instance;
              this.scrollComponent.size = totalSize;
              this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);

              this._zone.runOutsideAngular(function () {
                _this38.scrollComponent.nativeElement.addEventListener('scroll', _this38.func);

                _this38.dc.instance.scrollContainer = _this38.scrollComponent.nativeElement;
              });
            } else {
              this._zone.runOutsideAngular(function () {
                _this38.scrollComponent.nativeElement.addEventListener('scroll', _this38.func);

                _this38.dc.instance.scrollContainer = _this38.scrollComponent.nativeElement;
              });
            }

            this._updateHScrollOffset();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this39 = this;

          if (this.igxForScrollOrientation === 'vertical') {
            this._zone.runOutsideAngular(function () {
              _this39.contentObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](function () {
                return _this39.contentResizeNotify.next();
              });

              _this39.contentObserver.observe(_this39.dc.instance._viewContainer.element.nativeElement);
            });
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.removeScrollEventListeners();
          this.destroy$.next(true);
          this.destroy$.complete();

          if (this.contentObserver) {
            this.contentObserver.disconnect();
          }
        }
        /**
         * @hidden
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          /** @type {?} */
          var forOf = 'igxForOf';

          if (forOf in changes) {
            /** @type {?} */
            var value = changes[forOf].currentValue;

            if (!this._differ && value) {
              try {
                this._differ = this._differs.find(value).create(this.igxForTrackBy);
              } catch (e) {
                throw new Error("Cannot find a differ supporting object \"".concat(value, "\" of type \"").concat(getTypeNameForDebugging(value), "\".\n                     NgFor only supports binding to Iterables such as Arrays."));
              }
            }
          }
          /** @type {?} */


          var defaultItemSize = 'igxForItemSize';

          if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);

            this._applyChanges();
          }
          /** @type {?} */


          var containerSize = 'igxForContainerSize';

          if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          var _this40 = this;

          if (this._differ) {
            /** @type {?} */
            var changes = this._differ.diff(this.igxForOf);

            if (changes) {
              //  re-init cache.
              if (!this.igxForOf) {
                this.igxForOf = [];
              }

              this._updateSizeCache();

              this._zone.run(function () {
                _this40._applyChanges();

                _this40.cdr.markForCheck();

                _this40._updateScrollOffset();

                _this40.onDataChanged.emit();
              });
            }
          }
        }
        /**
         * Shifts the scroll thumb position.
         * ```typescript
         * this.parentVirtDir.addScrollTop(5);
         * ```
         * @param {?} addTop negative value to scroll up and positive to scroll down;
         * @return {?}
         */

      }, {
        key: "addScrollTop",
        value: function addScrollTop(addTop) {
          if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
            return false;
          }
          /** @type {?} */


          var originalVirtScrollTop = this._virtScrollTop;
          /** @type {?} */

          var containerSize = parseInt(this.igxForContainerSize, 10);
          /** @type {?} */

          var maxVirtScrollTop = this._virtHeight - containerSize;
          this._bScrollInternal = true;
          this._virtScrollTop += addTop;
          this._virtScrollTop = this._virtScrollTop > 0 ? this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop : 0;
          this.scrollPosition += addTop / this._virtHeightRatio;

          if (Math.abs(addTop / this._virtHeightRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px

            /** @type {?} */
            var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop); // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;

            this.dc.instance._viewContainer.element.nativeElement.style.top = -scrollOffset + 'px';
          }
          /** @type {?} */


          var maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;

          if (this._virtScrollTop > 0 && this.scrollPosition === 0 || this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
          } else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.scrollPosition = 0;
          } else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.scrollPosition = maxRealScrollTop;
          }

          return this._virtScrollTop !== originalVirtScrollTop;
        }
        /**
         * Scrolls to the specified index.
         * ```typescript
         * this.parentVirtDir.scrollTo(5);
         * ```
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "scrollTo",
        value: function scrollTo(index) {
          if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
          }
          /** @type {?} */


          var containerSize = parseInt(this.igxForContainerSize, 10);
          /** @type {?} */

          var isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
          /** @type {?} */

          var nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;

          if (nextScroll < 0) {
            return;
          }

          if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition = nextScroll;
          } else {
            /** @type {?} */
            var maxVirtScrollTop = this._virtHeight - containerSize;

            if (nextScroll > maxVirtScrollTop) {
              nextScroll = maxVirtScrollTop;
            }

            this._bScrollInternal = true;
            this._virtScrollTop = nextScroll;
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
            this._adjustToIndex = !isPrevItem ? index : null;
          }
        }
        /**
         * Scrolls by one item into the appropriate next direction.
         * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
         * ```typescript
         * this.parentVirtDir.scrollNext();
         * ```
         * @return {?}
         */

      }, {
        key: "scrollNext",
        value: function scrollNext() {
          /** @type {?} */
          var scr = Math.ceil(this.scrollPosition);
          /** @type {?} */

          var endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
          this.scrollTo(endIndex);
        }
        /**
         * Scrolls by one item into the appropriate previous direction.
         * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
         * ```typescript
         * this.parentVirtDir.scrollPrev();
         * ```
         * @return {?}
         */

      }, {
        key: "scrollPrev",
        value: function scrollPrev() {
          this.scrollTo(this.state.startIndex - 1);
        }
        /**
         * Scrolls by one page into the appropriate next direction.
         * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
         * ```typescript
         * this.parentVirtDir.scrollNextPage();
         * ```
         * @return {?}
         */

      }, {
        key: "scrollNextPage",
        value: function scrollNextPage() {
          if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition += parseInt(this.igxForContainerSize, 10);
          } else {
            this.addScrollTop(parseInt(this.igxForContainerSize, 10));
          }
        }
        /**
         * Scrolls by one page into the appropriate previous direction.
         * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
         * ```typescript
         * this.parentVirtDir.scrollPrevPage();
         * ```
         * @return {?}
         */

      }, {
        key: "scrollPrevPage",
        value: function scrollPrevPage() {
          if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition -= parseInt(this.igxForContainerSize, 10);
          } else {
            /** @type {?} */
            var containerSize = parseInt(this.igxForContainerSize, 10);
            this.addScrollTop(-containerSize);
          }
        }
        /**
         * @hidden
         * @param {?} colIndex
         * @return {?}
         */

      }, {
        key: "getColumnScrollLeft",
        value: function getColumnScrollLeft(colIndex) {
          return this.sizesCache[colIndex];
        }
        /**
         * Returns the total number of items that are fully visible.
         * ```typescript
         * this.parentVirtDir.getItemCountInView();
         * ```
         * @return {?}
         */

      }, {
        key: "getItemCountInView",
        value: function getItemCountInView() {
          /** @type {?} */
          var startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);

          if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
          }
          /** @type {?} */


          var endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
          return endIndex - startIndex;
        }
        /**
         * Returns a reference to the scrollbar DOM element.
         * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
         * ```typescript
         * dir.getScroll();
         * ```
         * @return {?}
         */

      }, {
        key: "getScroll",
        value: function getScroll() {
          return this.scrollComponent.nativeElement;
        }
        /**
         * Returns the size of the element at the specified index.
         * ```typescript
         * this.parentVirtDir.getSizeAt(1);
         * ```
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "getSizeAt",
        value: function getSizeAt(index) {
          return this.sizesCache[index + 1] - this.sizesCache[index];
        }
        /**
         * Returns the scroll offset of the element at the specified index.
         * ```typescript
         * this.parentVirtDir.getScrollForIndex(1);
         * ```
         * @param {?} index
         * @param {?=} bottom
         * @return {?}
         */

      }, {
        key: "getScrollForIndex",
        value: function getScrollForIndex(index, bottom) {
          /** @type {?} */
          var containerSize = parseInt(this.igxForContainerSize, 10);
          /** @type {?} */

          var scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
          return scroll;
        }
        /**
         * @hidden
         * Function that is called when scrolling vertically
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onScroll",
        value: function onScroll(event) {
          /* in certain situations this may be called when no scrollbar is visible */
          if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
          }
          /** @type {?} */


          var containerSize = parseInt(this.igxForContainerSize, 10);
          /** @type {?} */

          var maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
          /** @type {?} */

          var realPercentScrolled = maxRealScrollTop !== 0 ? event.target.scrollTop / maxRealScrollTop : 0;

          if (!this._bScrollInternal) {
            /** @type {?} */
            var maxVirtScrollTop = this._virtHeight - containerSize;
            this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
          } else {
            this._bScrollInternal = false;
          }
          /** @type {?} */


          var prevStartIndex = this.state.startIndex;
          /** @type {?} */

          var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
          this.dc.instance._viewContainer.element.nativeElement.style.top = -scrollOffset + 'px';
          this.dc.changeDetectorRef.detectChanges();

          if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
          }
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "updateSizes",
        value: function updateSizes() {
          this.recalcUpdateSizes();

          this._applyChanges();

          this._updateScrollOffset();

          this.onContentSizeChange.emit();
        }
        /**
         * @hidden
         * Function that recaculates and updates cache sizes.
         * @return {?}
         */

      }, {
        key: "recalcUpdateSizes",
        value: function recalcUpdateSizes() {
          /** @type {?} */
          var dimension = this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
          /** @type {?} */

          var diffs = [];
          /** @type {?} */

          var totalDiff = 0;
          /** @type {?} */

          var l = this._embeddedViews.length;
          /** @type {?} */

          var rNodes = this._embeddedViews.map(function (view) {
            return view.rootNodes.find(function (node) {
              return node.nodeType === Node.ELEMENT_NODE;
            }) || view.rootNodes[0].nextElementSibling;
          });

          for (var i = 0; i < l; i++) {
            /** @type {?} */
            var rNode = rNodes[i];

            if (rNode) {
              /** @type {?} */
              var h = rNode.offsetHeight || parseInt(this.igxForItemSize, 10);
              /** @type {?} */

              var index = this.state.startIndex + i;

              if (!this.isRemote && !this.igxForOf[index]) {
                continue;
              }
              /** @type {?} */


              var oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
              /** @type {?} */

              var newVal = dimension === 'height' ? h : rNode.clientWidth;

              if (dimension === 'height') {
                this.heightCache[index] = newVal;
              } else {
                this.igxForOf[index][dimension] = newVal;
              }
              /** @type {?} */


              var currDiff = newVal - oldVal;
              diffs.push(currDiff);
              totalDiff += currDiff;
              this.sizesCache[index + 1] += totalDiff;
            }
          } // update cache


          if (Math.abs(totalDiff) > 0) {
            for (var j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
              this.sizesCache[j] += totalDiff;
            } // update scrBar heights/widths


            if (this.igxForScrollOrientation === 'horizontal') {
              /** @type {?} */
              var totalWidth = parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10) + totalDiff;
              this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
            }
            /** @type {?} */


            var reducer = function reducer(acc, val) {
              return acc + val;
            };

            if (this.igxForScrollOrientation === 'vertical') {
              /** @type {?} */
              var scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
              /** @type {?} */

              var hSum = this.heightCache.reduce(reducer);

              if (hSum > this._maxHeight) {
                this._virtHeightRatio = hSum / this._maxHeight;
              }

              this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);
              this._virtHeight = hSum;

              if (!this.scrollComponent.destroyed) {
                this.scrollComponent.cdr.detectChanges();
              }

              if (scrToBottom && !this._isAtBottomIndex) {
                /** @type {?} */
                var containerSize = parseInt(this.igxForContainerSize, 10);
                /** @type {?} */

                var maxVirtScrollTop = this._virtHeight - containerSize;
                this._bScrollInternal = true;
                this._virtScrollTop = maxVirtScrollTop;
                this.scrollPosition = maxVirtScrollTop;
                return;
              }

              if (this._adjustToIndex) {
                // in case scrolled to specific index where after scroll heights are changed
                // need to adjust the offsets so that item is last in view.

                /** @type {?} */
                var updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                /** @type {?} */

                var sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                /** @type {?} */

                var currOffset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                this.dc.instance._viewContainer.element.nativeElement.style.top = currOffset - sumDiffs + 'px';
                this._adjustToIndex = null;
              }
            }
          }
        }
        /**
         * @hidden
         * @protected
         * @param {?} inScrollTop
         * @return {?}
         */

      }, {
        key: "fixedUpdateAllElements",
        value: function fixedUpdateAllElements(inScrollTop) {
          /** @type {?} */
          var count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
          /** @type {?} */

          var newStart = this.getIndexAt(inScrollTop, this.sizesCache, 0);

          if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
          }
          /** @type {?} */


          var prevStart = this.state.startIndex;
          /** @type {?} */

          var diff = newStart - this.state.startIndex;
          this.state.startIndex = newStart;

          if (diff) {
            this.onChunkPreload.emit(this.state);

            if (!this.isRemote) {
              /*recalculate and apply page size.*/
              if (diff > 0 && diff <= this.MAX_PERF_SCROLL_DIFF) {
                this.moveApplyScrollNext(prevStart);
              } else if (diff < 0 && Math.abs(diff) <= this.MAX_PERF_SCROLL_DIFF) {
                this.moveApplyScrollPrev(prevStart);
              } else {
                this.fixedApplyScroll();
              }
            }
          }

          return inScrollTop - this.sizesCache[this.state.startIndex];
        }
        /**
         * @hidden
         * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
         * @protected
         * @param {?} prevIndex
         * @return {?}
         */

      }, {
        key: "moveApplyScrollNext",
        value: function moveApplyScrollNext(prevIndex) {
          /** @type {?} */
          var start = prevIndex + this.state.chunkSize;

          for (var i = start; i < start + this.state.startIndex - prevIndex && this.igxForOf[i] !== undefined; i++) {
            /** @type {?} */
            var input = this.igxForOf[i];
            /** @type {?} */

            var embView = this._embeddedViews.shift();
            /** @type {?} */


            var cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            cntx.count = this.igxForOf.length;
            /** @type {?} */

            var view = this.dc.instance._vcr.detach(0);

            this.dc.instance._vcr.insert(view);

            this._embeddedViews.push(embView);
          }
        }
        /**
         * @hidden
         * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
         * @protected
         * @param {?} prevIndex
         * @return {?}
         */

      }, {
        key: "moveApplyScrollPrev",
        value: function moveApplyScrollPrev(prevIndex) {
          for (var i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            /** @type {?} */
            var input = this.igxForOf[i];
            /** @type {?} */

            var embView = this._embeddedViews.pop();
            /** @type {?} */


            var cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            /** @type {?} */

            var view = this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);

            this.dc.instance._vcr.insert(view, 0);

            this._embeddedViews.unshift(embView);
          }
        }
        /**
         * @hidden
         * @protected
         * @param {?} input
         * @return {?}
         */

      }, {
        key: "getContextIndex",
        value: function getContextIndex(input) {
          return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
        }
        /**
         * @hidden
         * The function applies an optimized state change through context change for each view
         * @protected
         * @return {?}
         */

      }, {
        key: "fixedApplyScroll",
        value: function fixedApplyScroll() {
          /** @type {?} */
          var j = 0;
          /** @type {?} */

          var endIndex = this.state.startIndex + this.state.chunkSize;

          for (var i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            /** @type {?} */
            var input = this.igxForOf[i];
            /** @type {?} */

            var embView = this._embeddedViews[j++];
            /** @type {?} */

            var cntx =
            /** @type {?} */
            embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            cntx.count = this.igxForOf.length;
          }
        }
        /**
         * @hidden
         * Function that is called when scrolling horizontally
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onHScroll",
        value: function onHScroll(event) {
          /* in certain situations this may be called when no scrollbar is visible */
          if (!parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
          }
          /** @type {?} */


          var prevStartIndex = this.state.startIndex; // Updating horizontal chunks

          /** @type {?} */

          var scrollOffset = this.fixedUpdateAllElements(event.target.scrollLeft);
          this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
          this.dc.changeDetectorRef.detectChanges();

          if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
          }
        }
        /**
         * Gets the function used to track changes in the items collection.
         * By default the object references are compared. However this can be optimized if you have unique identifier
         * value that can be used for the comparison instead of the object ref or if you have some other property values
         * in the item object that should be tracked for changes.
         * This option is similar to ngForTrackBy.
         * ```typescript
         * const trackFunc = this.parentVirtDir.igxForTrackBy;
         * ```
         * @return {?}
         */

      }, {
        key: "_applyChanges",

        /**
         * @hidden
         * @protected
         * @return {?}
         */
        value: function _applyChanges() {
          /** @type {?} */
          var prevChunkSize = this.state.chunkSize;
          this.applyChunkSizeChange();

          this._recalcScrollBarSize();

          if (this.igxForOf && this.igxForOf.length && this.dc) {
            /** @type {?} */
            var embeddedViewCopy = Object.assign([], this._embeddedViews);
            /** @type {?} */

            var startIndex = this.state.startIndex;
            /** @type {?} */

            var endIndex = this.state.chunkSize + this.state.startIndex;

            if (this.isRemote) {
              startIndex = 0;
              endIndex = this.igxForOf.length;
            }

            for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
              /** @type {?} */
              var input = this.igxForOf[i];
              /** @type {?} */

              var embView = embeddedViewCopy.shift();
              /** @type {?} */

              var cntx =
              /** @type {?} */
              embView.context;
              cntx.$implicit = input;
              cntx.index = this.getContextIndex(input);
              cntx.count = this.igxForOf.length;
            }

            if (prevChunkSize !== this.state.chunkSize) {
              this.onChunkLoad.emit(this.state);
            }
          }
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "_calcMaxBrowserHeight",
        value: function _calcMaxBrowserHeight() {
          /** @type {?} */
          var div = document.createElement('div');
          /** @type {?} */

          var style = div.style;
          style.position = 'absolute';
          style.top = '9999999999999999px';
          document.body.appendChild(div);
          /** @type {?} */

          var size = Math.abs(div.getBoundingClientRect()['top']);
          document.body.removeChild(div);
          return size;
        }
        /**
         * @hidden
         * Recalculates the chunkSize based on current startIndex and returns the new size.
         * This should be called after this.state.startIndex is updated, not before.
         * @protected
         * @return {?}
         */

      }, {
        key: "_calculateChunkSize",
        value: function _calculateChunkSize() {
          /** @type {?} */
          var chunkSize = 0;

          if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache) {
              this.initSizesCache(this.igxForOf);
            }

            chunkSize = this._calcMaxChunkSize();

            if (this.igxForOf && chunkSize > this.igxForOf.length) {
              chunkSize = this.igxForOf.length;
            }
          } else {
            if (this.igxForOf) {
              chunkSize = this.igxForOf.length;
            }
          }

          return chunkSize;
        }
        /**
         * @hidden
         * @protected
         * @param {?} viewref
         * @param {?} nodeName
         * @return {?}
         */

      }, {
        key: "getElement",
        value: function getElement(viewref, nodeName) {
          /** @type {?} */
          var elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
          return elem.length > 0 ? elem[0] : null;
        }
        /**
         * @hidden
         * @protected
         * @param {?} items
         * @return {?}
         */

      }, {
        key: "initSizesCache",
        value: function initSizesCache(items) {
          /** @type {?} */
          var totalSize = 0;
          /** @type {?} */

          var size = 0;
          /** @type {?} */

          var dimension = this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
          /** @type {?} */

          var i = 0;
          this.sizesCache = [];
          this.heightCache = [];
          this.sizesCache.push(0);
          /** @type {?} */

          var count = this.isRemote ? this.totalItemCount : items.length;

          for (i; i < count; i++) {
            if (dimension === 'height') {
              // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
              size = parseInt(this.igxForItemSize, 10) || 0;
              this.heightCache.push(size);
            } else {
              size = this._getItemSize(items[i], dimension);
            }

            totalSize += size;
            this.sizesCache.push(totalSize);
          }

          return totalSize;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_updateSizeCache",
        value: function _updateSizeCache() {
          if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
          }
          /** @type {?} */


          var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) {
            return acc + val;
          }) : 0;
          /** @type {?} */

          var newHeight = this.initSizesCache(this.igxForOf);
          /** @type {?} */

          var diff = oldHeight - newHeight; // if data has been changed while container is scrolled
          // should update scroll top/left according to change so that same startIndex is in view

          if (Math.abs(diff) > 0 && this.scrollPosition > 0) {
            this.recalcUpdateSizes();
            /** @type {?} */

            var offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
          }
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "_calcMaxChunkSize",
        value: function _calcMaxChunkSize() {
          var _this41 = this;

          /** @type {?} */
          var i = 0;
          /** @type {?} */

          var length = 0;
          /** @type {?} */

          var maxLength = 0;
          /** @type {?} */

          var arr = [];
          /** @type {?} */

          var sum = 0;
          /** @type {?} */

          var availableSize = parseInt(this.igxForContainerSize, 10);

          if (!availableSize) {
            return 0;
          }
          /** @type {?} */


          var dimension = this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
          /** @type {?} */

          var reducer = function reducer(accumulator, currentItem) {
            return accumulator + _this41._getItemSize(currentItem, dimension);
          };

          for (i; i < this.igxForOf.length; i++) {
            /** @type {?} */
            var item = this.igxForOf[i];

            if (dimension === 'height') {
              item = {
                value: this.igxForOf[i],
                height: this.heightCache[i]
              };
            }
            /** @type {?} */


            var size = dimension === 'height' ? this.heightCache[i] : this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);

            if (sum < availableSize) {
              arr.push(item);
              length = arr.length;

              if (i === this.igxForOf.length - 1) {
                // reached end without exceeding
                // include prev items until size is filled or first item is reached.

                /** @type {?} */
                var curItem = dimension === 'height' ? arr[0].value : arr[0];
                /** @type {?} */

                var prevIndex = this.igxForOf.indexOf(curItem) - 1;

                while (prevIndex >= 0 && sum <= availableSize) {
                  curItem = dimension === 'height' ? arr[0].value : arr[0];
                  prevIndex = this.igxForOf.indexOf(curItem) - 1;
                  /** @type {?} */

                  var prevItem = this.igxForOf[prevIndex];
                  /** @type {?} */

                  var prevSize = dimension === 'height' ? this.heightCache[prevIndex] : parseInt(prevItem[dimension], 10);
                  sum = arr.reduce(reducer, prevSize);
                  arr.unshift(prevItem);
                  length = arr.length;
                }
              }
            } else {
              arr.push(item);
              length = arr.length + 1;
              arr.shift();
            }

            if (length > maxLength) {
              maxLength = length;
            }
          }

          return maxLength;
        }
        /**
         * @hidden
         * @protected
         * @param {?} left
         * @param {?} set
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "getIndexAt",
        value: function getIndexAt(left, set, index) {
          /** @type {?} */
          var start = 0;
          /** @type {?} */

          var end = set.length - 1;

          if (left === 0) {
            return 0;
          }

          while (start <= end) {
            /** @type {?} */
            var midIdx = Math.floor((start + end) / 2);
            /** @type {?} */

            var midLeft = set[midIdx];
            /** @type {?} */

            var cmp = left - midLeft;

            if (cmp > 0) {
              start = midIdx + 1;
            } else if (cmp < 0) {
              end = midIdx - 1;
            } else {
              return midIdx;
            }
          }

          return end;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_recalcScrollBarSize",
        value: function _recalcScrollBarSize() {
          /** @type {?} */
          var count = this.isRemote ? this.totalItemCount : this.igxForOf ? this.igxForOf.length : 0;
          this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
          /** @type {?} */

          var scrollable = this.isScrollable();

          if (this.igxForScrollOrientation === 'horizontal') {
            /** @type {?} */
            var totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
            this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
            this.scrollComponent.size = totalWidth;

            if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
              this.scrollPosition = 0;
            }
          }

          if (this.igxForScrollOrientation === 'vertical') {
            this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.scrollComponent.size = this._calcHeight();

            if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {
              this.scrollPosition = 0; // Need to reset the scrollAmount value here, because
              // Firefox will not fire the scrollComponent scroll event handler

              this.scrollComponent.scrollAmount = 0;
            }
          }

          if (scrollable !== this.isScrollable()) {
            // scrollbar visibility has changed
            this.onScrollbarVisibilityChanged.emit();
          }
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_calcHeight",
        value: function _calcHeight() {
          /** @type {?} */
          var height;

          if (this.heightCache) {
            height = this.heightCache.reduce(function (acc, val) {
              return acc + val;
            }, 0);
          } else {
            height = this.initSizesCache(this.igxForOf);
          }

          this._virtHeight = height;

          if (height > this._maxHeight) {
            this._virtHeightRatio = height / this._maxHeight;
            height = this._maxHeight;
          }

          return height;
        }
        /**
         * @protected
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "_recalcOnContainerChange",
        value: function _recalcOnContainerChange(changes) {
          this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
          this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
          /** @type {?} */

          var prevChunkSize = this.state.chunkSize;
          this.applyChunkSizeChange();

          this._recalcScrollBarSize();

          if (prevChunkSize !== this.state.chunkSize) {
            this.onChunkLoad.emit(this.state);
          }

          if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {
            // Updating horizontal chunks and offsets based on the new scrollLeft

            /** @type {?} */
            var scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
          }
        }
        /**
         * @hidden
         * Removes an elemenet from the embedded views and updates chunkSize.
         * @protected
         * @return {?}
         */

      }, {
        key: "removeLastElem",
        value: function removeLastElem() {
          /** @type {?} */
          var oldElem = this._embeddedViews.pop();

          this.onBeforeViewDestroyed.emit(oldElem);
          oldElem.destroy();
          this.state.chunkSize--;
        }
        /**
         * @hidden
         * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
         * @protected
         * @return {?}
         */

      }, {
        key: "addLastElem",
        value: function addLastElem() {
          var _this42 = this;

          /** @type {?} */
          var elemIndex = this.state.startIndex + this.state.chunkSize;

          if (!this.isRemote && !this.igxForOf) {
            return;
          }

          if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
          }
          /** @type {?} */


          var input = this.igxForOf[elemIndex];
          /** @type {?} */

          var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));

          this._embeddedViews.push(embeddedView);

          this.state.chunkSize++;

          this._zone.run(function () {
            _this42.cdr.markForCheck();
          });
        }
        /**
         * Recalculates chunkSize and adds/removes elements if need due to the change.
         * this.state.chunkSize is updated in \@addLastElem() or \@removeLastElem()
         * @protected
         * @return {?}
         */

      }, {
        key: "applyChunkSizeChange",
        value: function applyChunkSizeChange() {
          /** @type {?} */
          var chunkSize = this.isRemote ? this.igxForOf ? this.igxForOf.length : 0 : this._calculateChunkSize();

          if (chunkSize > this.state.chunkSize) {
            /** @type {?} */
            var diff = chunkSize - this.state.chunkSize;

            for (var i = 0; i < diff; i++) {
              this.addLastElem();
            }
          } else if (chunkSize < this.state.chunkSize) {
            /** @type {?} */
            var _diff = this.state.chunkSize - chunkSize;

            for (var _i8 = 0; _i8 < _diff; _i8++) {
              this.removeLastElem();
            }
          }
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_updateScrollOffset",
        value: function _updateScrollOffset() {
          if (this.igxForScrollOrientation === 'horizontal') {
            this._updateHScrollOffset();
          } else {
            this._updateVScrollOffset();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_updateVScrollOffset",
        value: function _updateVScrollOffset() {
          /** @type {?} */
          var scrollOffset = 0;
          /** @type {?} */

          var vScroll = this.scrollComponent.nativeElement;
          scrollOffset = vScroll && this.scrollComponent.size ? this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
          this.dc.instance._viewContainer.element.nativeElement.style.top = -scrollOffset + 'px';
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_updateHScrollOffset",
        value: function _updateHScrollOffset() {
          /** @type {?} */
          var scrollOffset = 0;
          scrollOffset = this.scrollComponent.nativeElement && this.scrollComponent.size ? this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
          this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
        /**
         * @private
         * @param {?} item
         * @param {?} dimension
         * @return {?}
         */

      }, {
        key: "_getItemSize",
        value: function _getItemSize(item, dimension) {
          /** @type {?} */
          var dim = item[dimension];
          return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
        }
      }, {
        key: "displayContainer",
        get: function get() {
          return this.dc.instance._viewContainer.element.nativeElement;
        }
        /**
         * @return {?}
         */

      }, {
        key: "virtualHelper",
        get: function get() {
          return this.scrollComponent.nativeElement;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "sizesCache",
        get: function get() {
          return this._sizesCache;
        }
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._sizesCache = value;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_isScrolledToBottom",
        get: function get() {
          if (!this.getScroll()) {
            return true;
          }
          /** @type {?} */


          var scrollHeight = this.getScroll().scrollHeight; // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
          // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.

          return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_isAtBottomIndex",
        get: function get() {
          return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "isRemote",
        get: function get() {
          return this.totalItemCount !== null;
        }
        /**
         *
         * Gets/Sets the scroll position.
         * ```typescript
         * const position = directive.scrollPosition;
         * directive.scrollPosition = value;
         * ```
         * @return {?}
         */

      }, {
        key: "scrollPosition",
        get: function get() {
          return this.scrollComponent.scrollAmount;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (val === this.scrollComponent.scrollAmount) {
            return;
          }

          if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollLeft = val;
          } else if (this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollTop = val;
          }
        }
      }, {
        key: "igxForTrackBy",
        get: function get() {
          return this._trackByFn;
        }
        /**
         * Sets the function used to track changes in the items collection.
         * This function can be set in scenarios where you want to optimize or
         * customize the tracking of changes for the items in the collection.
         * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
         * ```typescript
         * this.parentVirtDir.igxForTrackBy = (index, item) => {
         *      return item.id + item.width;
         * };
         * ```
         * @param {?} fn
         * @return {?}
         */
        ,
        set: function set(fn) {
          this._trackByFn = fn;
        }
      }]);

      return IgxForOfDirective;
    }();

    IgxForOfDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxFor][igxForOf]'
      }]
    }];
    /** @nocollapse */

    IgxForOfDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: IgxForOfScrollSyncService
      }];
    };

    IgxForOfDirective.propDecorators = {
      igxForOf: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      igxForSizePropName: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      igxForScrollOrientation: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      igxForScrollContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      igxForContainerSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      igxForItemSize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onChunkLoad: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onScrollbarVisibilityChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onContentSizeChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onDataChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onBeforeViewDestroyed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onChunkPreload: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      igxForTrackBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @param {?} type
     * @return {?}
     */

    function getTypeNameForDebugging(type) {
      /** @type {?} */
      var name = 'name';
      return type[name] || typeof type;
    }
    /**
     * @template T
     */


    var IgxGridForOfDirective =
    /*#__PURE__*/
    function (_IgxForOfDirective) {
      _inherits(IgxGridForOfDirective, _IgxForOfDirective);

      /**
       * @param {?} _viewContainer
       * @param {?} _template
       * @param {?} _differs
       * @param {?} resolver
       * @param {?} cdr
       * @param {?} _zone
       * @param {?} syncScrollService
       * @param {?} syncService
       */
      function IgxGridForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, syncService) {
        var _this43;

        _classCallCheck(this, IgxGridForOfDirective);

        _this43 = _possibleConstructorReturn(this, _getPrototypeOf(IgxGridForOfDirective).call(this, _viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService));
        _this43.syncScrollService = syncScrollService;
        _this43.syncService = syncService;
        /**
         * @hidden \@internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */

        _this43.onDataChanging = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this43;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(IgxGridForOfDirective, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          this.syncService.setMaster(this);

          _get(_getPrototypeOf(IgxGridForOfDirective.prototype), "ngOnInit", this).call(this);

          this.removeScrollEventListeners();
        }
        /**
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          /** @type {?} */
          var forOf = 'igxGridForOf';
          this.syncService.setMaster(this);

          if (forOf in changes) {
            /** @type {?} */
            var value = changes[forOf].currentValue;

            if (!this._differ && value) {
              try {
                this._differ = this._differs.find(value).create(this.igxForTrackBy);
              } catch (e) {
                throw new Error("Cannot find a differ supporting object \"".concat(value, "\" of type \"").concat(getTypeNameForDebugging(value), "\".\n                     NgFor only supports binding to Iterables such as Arrays."));
              }
            }
          }
          /** @type {?} */


          var defaultItemSize = 'igxForItemSize';

          if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
          }
          /** @type {?} */


          var containerSize = 'igxForContainerSize';

          if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
          }
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "getItemSize",

        /**
         * @protected
         * @param {?} item
         * @return {?}
         */
        value: function getItemSize(item) {
          /** @type {?} */
          var size = 0;
          /** @type {?} */

          var dimension = this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';

          if (dimension === 'height') {
            size = parseInt(this.igxForItemSize, 10) || 0;

            if (item && item.summaries) {
              size = item.max;
            } else if (item && item.groups && item.height) {
              size = item.height;
            }
          } else {
            size = parseInt(item[dimension], 10) || 0;
          }

          return size;
        }
        /**
         * @protected
         * @param {?} items
         * @return {?}
         */

      }, {
        key: "initSizesCache",
        value: function initSizesCache(items) {
          if (!this.syncService.isMaster(this)) {
            /** @type {?} */
            var masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
          }
          /** @type {?} */


          var totalSize = 0;
          /** @type {?} */

          var size = 0;
          /** @type {?} */

          var i = 0;
          this.sizesCache = [];
          this.heightCache = [];
          this.sizesCache.push(0);
          /** @type {?} */

          var count = this.isRemote ? this.totalItemCount : items.length;

          for (i; i < count; i++) {
            size = this.getItemSize(items[i]);

            if (this.itemsDimension === 'height') {
              this.heightCache.push(size);
            }

            totalSize += size;
            this.sizesCache.push(totalSize);
          }

          return totalSize;
        }
        /**
         * @protected
         * @param {?=} changes
         * @return {?}
         */

      }, {
        key: "_updateSizeCache",
        value: function _updateSizeCache() {
          var _this44 = this;

          var changes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
          }
          /** @type {?} */


          var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) {
            return acc + val;
          }) : 0;
          /** @type {?} */

          var newHeight = oldHeight;

          if (changes && !this.isRemote) {
            newHeight = this.handleCacheChanges(changes);
          } else {
            newHeight = this.initSizesCache(this.igxForOf);
          }
          /** @type {?} */


          var diff = oldHeight - newHeight; // if data has been changed while container is scrolled
          // should update scroll top/left according to change so that same startIndex is in view

          if (Math.abs(diff) > 0) {
            // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.
            // So leaving as is for the moment.
            requestAnimationFrame(function () {
              _this44.recalcUpdateSizes();
              /** @type {?} */


              var offset = parseInt(_this44.dc.instance._viewContainer.element.nativeElement.style.top, 10);

              if (_this44.scrollPosition !== 0) {
                _this44.scrollPosition = _this44.sizesCache[_this44.state.startIndex] - offset;
              } else {
                _this44._updateScrollOffset();
              }
            });
          }
        }
        /**
         * @protected
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "handleCacheChanges",
        value: function handleCacheChanges(changes) {
          var _this45 = this;

          /** @type {?} */
          var identityChanges = [];
          /** @type {?} */

          var newHeightCache = [];
          /** @type {?} */

          var newSizesCache = [];
          newSizesCache.push(0);
          /** @type {?} */

          var newHeight = 0; // When there are more than one removed items the changes are not reliable so those with identity change should be default size.

          /** @type {?} */

          var numRemovedItems = 0;
          changes.forEachRemovedItem(function () {
            return numRemovedItems++;
          }); // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.

          changes.forEachIdentityChange(function (item) {
            if (item.currentIndex !== item.previousIndex) {
              // Filter out ones that have not changed their index.
              identityChanges[item.currentIndex] = item;
            }
          }); // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.

          changes.forEachItem(function (item) {
            if (item.previousIndex !== null && (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
              // Reuse cache on those who have previousIndex.
              // When there are more than one removed items currently the changes are not readable so ones with identity change
              // should be racalculated.
              newHeightCache[item.currentIndex] = _this45.heightCache[item.previousIndex];
            } else {
              // Assign default item size.
              newHeightCache[item.currentIndex] = _this45.getItemSize(item.item);
            }

            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
          });
          this.heightCache = newHeightCache;
          this.sizesCache = newSizesCache;
          return newHeight;
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "assumeMaster",
        value: function assumeMaster() {
          this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
          this.syncService.setMaster(this, true);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (this._differ) {
            /** @type {?} */
            var changes = this._differ.diff(this.igxForOf);

            if (changes) {
              /** @type {?} */
              var args = {
                containerSize: this.igxForContainerSize
              };
              this.onDataChanging.emit(args); //  re-init cache.

              if (!this.igxForOf) {
                this.igxForOf = [];
              }
              /* we need to reset the master dir if all rows are removed
              (e.g. because of filtering); if all columns are hidden, rows are
              still rendered empty, so we should not reset master */


              if (!this.igxForOf.length && this.igxForScrollOrientation === 'vertical') {
                this.syncService.resetMaster();
              }

              this.syncService.setMaster(this);
              this.igxForContainerSize = args.containerSize;

              this._updateSizeCache(changes);

              this._applyChanges();

              this._updateScrollOffset();

              this.onDataChanged.emit();
            }
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onScroll",
        value: function onScroll(event) {
          var _this46 = this;

          if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
          }
          /** @type {?} */


          var containerSize = parseInt(this.igxForContainerSize, 10);
          /** @type {?} */

          var maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
          /** @type {?} */

          var realPercentScrolled = maxRealScrollTop !== 0 ? event.target.scrollTop / maxRealScrollTop : 0;

          if (!this._bScrollInternal) {
            /** @type {?} */
            var maxVirtScrollTop = this._virtHeight - containerSize;
            this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
          } else {
            this._bScrollInternal = false;
          }
          /** @type {?} */


          var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
          this.dc.instance._viewContainer.element.nativeElement.style.top = -scrollOffset + 'px';

          this._zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
            _this46.recalcUpdateSizes();
          });

          this.cdr.markForCheck();
        }
        /**
         * @param {?} scrollAmount
         * @return {?}
         */

      }, {
        key: "onHScroll",
        value: function onHScroll(scrollAmount) {
          /* in certain situations this may be called when no scrollbar is visible */
          if (!this.scrollComponent || !parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
          } // Updating horizontal chunks

          /** @type {?} */


          var scrollOffset = this.fixedUpdateAllElements(scrollAmount);
          this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "addLastElem",
        value: function addLastElem() {
          /** @type {?} */
          var elemIndex = this.state.startIndex + this.state.chunkSize;

          if (!this.isRemote && !this.igxForOf) {
            return;
          }

          if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
          }
          /** @type {?} */


          var input = this.igxForOf[elemIndex];
          /** @type {?} */

          var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));

          this._embeddedViews.push(embeddedView);

          this.state.chunkSize++;
        }
        /**
         * @protected
         * @param {?} prevChunkSize
         * @return {?}
         */

      }, {
        key: "_updateViews",
        value: function _updateViews(prevChunkSize) {
          if (this.igxForOf && this.igxForOf.length && this.dc) {
            /** @type {?} */
            var embeddedViewCopy = Object.assign([], this._embeddedViews);
            /** @type {?} */

            var startIndex;
            /** @type {?} */

            var endIndex;

            if (this.isRemote) {
              startIndex = 0;
              endIndex = this.igxForOf.length;
            } else {
              startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);

              if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                startIndex = this.igxForOf.length - this.state.chunkSize;
              }

              this.state.startIndex = startIndex;
              endIndex = this.state.chunkSize + this.state.startIndex;
            }

            for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
              /** @type {?} */
              var input = this.igxForOf[i];
              /** @type {?} */

              var embView = embeddedViewCopy.shift();
              /** @type {?} */

              var cntx =
              /** @type {?} */
              embView.context;
              cntx.$implicit = input;
              cntx.index = this.getContextIndex(input);
              cntx.count = this.igxForOf.length;
            }

            if (prevChunkSize !== this.state.chunkSize) {
              this.onChunkLoad.emit(this.state);
            }
          }
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "_applyChanges",
        value: function _applyChanges() {
          /** @type {?} */
          var prevChunkSize = this.state.chunkSize;
          this.applyChunkSizeChange();

          this._recalcScrollBarSize();

          this._updateViews(prevChunkSize);
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "_calcMaxChunkSize",
        value: function _calcMaxChunkSize() {
          if (this.syncService.isMaster(this)) {
            return _get(_getPrototypeOf(IgxGridForOfDirective.prototype), "_calcMaxChunkSize", this).call(this);
          }

          return this.syncService.chunkSize(this.igxForScrollOrientation);
        }
      }, {
        key: "igxGridForOf",
        set: function set(value) {
          this.igxForOf = value;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.igxForOf;
        }
      }, {
        key: "sizesCache",
        get: function get() {
          if (this.syncService.isMaster(this)) {
            return this._sizesCache;
          }

          return this.syncService.sizesCache(this.igxForScrollOrientation);
        }
        /**
         * @hidden
         * \@internal
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._sizesCache = value;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "itemsDimension",
        get: function get() {
          return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
        }
      }]);

      return IgxGridForOfDirective;
    }(IgxForOfDirective);

    IgxGridForOfDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxGridFor][igxGridForOf]'
      }]
    }];
    /** @nocollapse */

    IgxGridForOfDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: IgxForOfScrollSyncService
      }, {
        type: IgxForOfSyncService
      }];
    };

    IgxGridForOfDirective.propDecorators = {
      igxGridForOf: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onDataChanging: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @hidden
     */

    var IgxForOfModule = function IgxForOfModule() {
      _classCallCheck(this, IgxForOfModule);
    };

    IgxForOfModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent, VirtualHelperBaseDirective],
        entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
        exports: [IgxForOfDirective, IgxGridForOfDirective],
        imports: [IgxScrollInertiaModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * **Ignite UI for Angular DropDown** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/drop_down.html)
     *
     * The Ignite UI for Angular Drop Down displays a scrollable list of items which may be visually grouped and
     * supports selection of a single item. Clicking or tapping an item selects it and closes the Drop Down
     *
     * Example:
     * ```html
     * <igx-drop-down>
     *   <igx-drop-down-item *ngFor="let item of items" disabled={{item.disabled}} isHeader={{item.header}}>
     *     {{ item.value }}
     *   </igx-drop-down-item>
     * </igx-drop-down>
     * ```
     */

    var IgxDropDownComponent =
    /*#__PURE__*/
    function (_IgxDropDownBase) {
      _inherits(IgxDropDownComponent, _IgxDropDownBase);

      /**
       * @param {?} elementRef
       * @param {?} cdr
       * @param {?} selection
       * @param {?} _displayDensityOptions
       */
      function IgxDropDownComponent(elementRef, cdr, selection, _displayDensityOptions) {
        var _this47;

        _classCallCheck(this, IgxDropDownComponent);

        _this47 = _possibleConstructorReturn(this, _getPrototypeOf(IgxDropDownComponent).call(this, elementRef, cdr, _displayDensityOptions));
        _this47.elementRef = elementRef;
        _this47.cdr = cdr;
        _this47.selection = selection;
        _this47._displayDensityOptions = _displayDensityOptions;
        _this47.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpening)='handleOpening()'></igx-drop-down>
         * ```
         */

        _this47.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpened)='handleOpened()'></igx-drop-down>
         * ```
         */

        _this47.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosing)='handleClosing()'></igx-drop-down>
         * ```
         */

        _this47.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosed)='handleClosed()'></igx-drop-down>
         * ```
         */

        _this47.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets/sets whether items take focus. Disabled by default.
         * When enabled, drop down items gain tab index and are focused when active -
         * this includes activating the selected item when opening the drop down and moving with keyboard navigation.
         *
         * Note: Keep that focus shift in mind when using the igxDropDownItemNavigation directive
         * and ensure it's placed either on each focusable item or a common ancestor to allow it to handle keyboard events.
         *
         * ```typescript
         * // get
         * let dropDownAllowsItemFocus = this.dropdown.allowItemsFocus;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-drop-down [allowItemsFocus]='true'></igx-drop-down>
         * ```
         */

        _this47.allowItemsFocus = false;
        return _this47;
      }
      /**
       * @hidden \@internal
       * @return {?}
       */


      _createClass(IgxDropDownComponent, [{
        key: "open",

        /**
         * Opens the dropdown
         *
         * ```typescript
         * this.dropdown.open();
         * ```
         * @param {?=} overlaySettings
         * @return {?}
         */
        value: function open(overlaySettings) {
          this.toggleDirective.open(overlaySettings);
          this.updateScrollPosition();
        }
        /**
         * Closes the dropdown
         *
         * ```typescript
         * this.dropdown.close();
         * ```
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          this.toggleDirective.close();
        }
        /**
         * Toggles the dropdown
         *
         * ```typescript
         * this.dropdown.toggle();
         * ```
         * @param {?=} overlaySettings
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle(overlaySettings) {
          if (this.collapsed || this.toggleDirective.isClosing) {
            this.open(overlaySettings);
          } else {
            this.close();
          }
        }
        /**
         * Select an item by index
         * @param {?} index of the item to select; If the drop down uses *igxFor, pass the index in data
         * @return {?}
         */

      }, {
        key: "setSelectedItem",
        value: function setSelectedItem(index) {
          if (index < 0 || index >= this.items.length) {
            return;
          }
          /** @type {?} */


          var newSelection;

          if (this.virtDir) {
            newSelection =
            /** @type {?} */
            {
              value: this.virtDir.igxForOf[index],
              index: index
            };
          } else {
            newSelection = this.items[index];
          }

          this.selectItem(newSelection);
        }
        /**
         * Navigates to the item on the specified index
         * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "navigateItem",
        value: function navigateItem(index) {
          var _this48 = this;

          if (this.virtDir) {
            if (index === -1 || index >= this.collectionLength) {
              return;
            }
            /** @type {?} */


            var direction = index > (this.focusedItem ? this.focusedItem.index : -1) ? Navigate.Down : Navigate.Up;
            /** @type {?} */

            var subRequired = this.isIndexOutOfBounds(index, direction);
            this.focusedItem =
            /** @type {?} */
            {
              value: this.virtDir.igxForOf[index],
              index: index
            };

            if (subRequired) {
              this.virtDir.scrollTo(index);
            }

            if (subRequired) {
              this.virtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["take"])(1)).subscribe(function () {
                _this48.skipHeader(direction);
              });
            } else {
              this.skipHeader(direction);
            }
          } else {
            _get(_getPrototypeOf(IgxDropDownComponent.prototype), "navigateItem", this).call(this, index);
          }

          if (this.allowItemsFocus && this.focusedItem) {
            this.focusedItem.element.nativeElement.focus();
            this.cdr.markForCheck();
          }
        }
        /**
         * @private
         * @param {?} index
         * @param {?} direction
         * @return {?}
         */

      }, {
        key: "isIndexOutOfBounds",
        value: function isIndexOutOfBounds(index, direction) {
          /** @type {?} */
          var virtState = this.virtDir.state;
          /** @type {?} */

          var currentPosition = this.virtDir.getScroll().scrollTop;
          /** @type {?} */

          var itemPosition = this.virtDir.getScrollForIndex(index, direction === Navigate.Down);
          /** @type {?} */

          var indexOutOfChunk = index < virtState.startIndex || index > virtState.chunkSize + virtState.startIndex;
          /** @type {?} */

          var scrollNeeded = direction === Navigate.Down ? currentPosition < itemPosition : currentPosition > itemPosition;
          /** @type {?} */

          var subRequired = indexOutOfChunk || scrollNeeded;
          return subRequired;
        }
        /**
         * @protected
         * @param {?} direction
         * @return {?}
         */

      }, {
        key: "skipHeader",
        value: function skipHeader(direction) {
          if (!this.focusedItem) {
            return;
          }

          if (this.focusedItem.isHeader || this.focusedItem.disabled) {
            if (direction === Navigate.Up) {
              this.navigatePrev();
            } else {
              this.navigateNext();
            }
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "updateScrollPosition",
        value: function updateScrollPosition() {
          if (!this.virtDir) {
            return;
          }

          if (!this.selectedItem) {
            this.virtDir.scrollTo(0);
            return;
          }
          /** @type {?} */


          var targetScroll = this.virtDir.getScrollForIndex(this.selectedItem.index);
          /** @type {?} */

          var itemsInView = this.virtDir.igxForContainerSize / this.virtDir.igxForItemSize;
          targetScroll -= (itemsInView / 2 - 1) * this.virtDir.igxForItemSize;
          this.virtDir.getScroll().scrollTop = targetScroll;
        }
        /**
         * @hidden \@internal
         * @param {?} e
         * @return {?}
         */

      }, {
        key: "onToggleOpening",
        value: function onToggleOpening(e) {
          this.onOpening.emit(e);

          if (e.cancel) {
            return;
          }

          if (!this.virtDir && this.selectedItem) {
            this.scrollToItem(this.selectedItem);
          }

          if (this.virtDir) {
            this.virtDir.scrollPosition = this._scrollPosition;
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onToggleOpened",
        value: function onToggleOpened() {
          if (this.selectedItem) {
            this.focusedItem = this.selectedItem;
            this._focusedItem.focused = true;
          } else if (this.allowItemsFocus) {
            this.navigateFirst();
          }

          this.onOpened.emit();
        }
        /**
         * @hidden \@internal
         * @param {?} e
         * @return {?}
         */

      }, {
        key: "onToggleClosing",
        value: function onToggleClosing(e) {
          this.onClosing.emit(e);

          if (this.virtDir) {
            this._scrollPosition = this.virtDir.scrollPosition;
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onToggleClosed",
        value: function onToggleClosed() {
          if (this._focusedItem) {
            this._focusedItem.focused = false;
          }

          this.onClosed.emit();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
          this.selection.clear(this.id);
          this.selection.clear("".concat(this.id, "-active"));
        }
        /**
         * @protected
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "scrollToItem",
        value: function scrollToItem(item) {
          var _this49 = this;

          /** @type {?} */
          var itemPosition = this.calculateScrollPosition(item); //  in IE11 setting sctrollTop is somehow slow and forces dropdown
          //  to appear on screen before animation start. As a result dropdown
          //  flickers badly. This is why we set scrollTop just a little later
          //  allowing animation to start and prevent dropdown flickering

          if (isIE()) {
            setTimeout(function () {
              _this49.scrollContainer.scrollTop = itemPosition;
            }, 1);
          } else {
            this.scrollContainer.scrollTop = itemPosition;
          }
        }
        /**
         * @hidden \@internal
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "calculateScrollPosition",
        value: function calculateScrollPosition(item) {
          if (!item) {
            return 0;
          }
          /** @type {?} */


          var elementRect = item.element.nativeElement.getBoundingClientRect();
          /** @type {?} */

          var parentRect = this.scrollContainer.getBoundingClientRect();
          /** @type {?} */

          var scrollDelta = parentRect.top - elementRect.top;
          /** @type {?} */

          var scrollPosition = this.scrollContainer.scrollTop - scrollDelta;
          /** @type {?} */

          var dropDownHeight = this.scrollContainer.clientHeight;
          scrollPosition -= dropDownHeight / 2;
          scrollPosition += item.elementHeight / 2;
          return Math.floor(scrollPosition);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this.toggleDirective.id = this.id;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          if (this.virtDir) {
            this.virtDir.igxForItemSize = 28;
          }
        }
        /**
         * Keydown Handler
         * @param {?} key
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "onItemActionKey",
        value: function onItemActionKey(key, event) {
          _get(_getPrototypeOf(IgxDropDownComponent.prototype), "onItemActionKey", this).call(this, key, event);

          this.close();
        }
        /**
         * Virtual scroll implementation
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "navigateFirst",
        value: function navigateFirst() {
          if (this.virtDir) {
            this.navigateItem(0);
          } else {
            _get(_getPrototypeOf(IgxDropDownComponent.prototype), "navigateFirst", this).call(this);
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "navigateLast",
        value: function navigateLast() {
          if (this.virtDir) {
            this.navigateItem(this.virtDir.totalItemCount ? this.virtDir.totalItemCount - 1 : this.virtDir.igxForOf.length - 1);
          } else {
            _get(_getPrototypeOf(IgxDropDownComponent.prototype), "navigateLast", this).call(this);
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "navigateNext",
        value: function navigateNext() {
          if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index + 1 : 0);
          } else {
            _get(_getPrototypeOf(IgxDropDownComponent.prototype), "navigateNext", this).call(this);
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "navigatePrev",
        value: function navigatePrev() {
          if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index - 1 : 0);
          } else {
            _get(_getPrototypeOf(IgxDropDownComponent.prototype), "navigatePrev", this).call(this);
          }
        }
        /**
         * Handles the `onSelection` emit and the drop down toggle when selection changes
         * @hidden
         * \@internal
         * @param {?=} newSelection
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "selectItem",
        value: function selectItem(newSelection, event) {
          /** @type {?} */
          var oldSelection = this.selectedItem;

          if (!newSelection) {
            newSelection = this.focusedItem;
          }

          if (newSelection === null) {
            return;
          }

          if (newSelection instanceof IgxDropDownItemBase && newSelection.isHeader) {
            return;
          }

          if (this.virtDir) {
            newSelection =
            /** @type {?} */
            {
              value: newSelection.value,
              index: newSelection.index
            };
          }
          /** @type {?} */


          var args = {
            oldSelection: oldSelection,
            newSelection: newSelection,
            cancel: false
          };
          this.onSelection.emit(args);

          if (!args.cancel) {
            if (this.isSelectionValid(args.newSelection)) {
              this.selection.set(this.id, new Set([args.newSelection]));

              if (!this.virtDir) {
                if (oldSelection) {
                  oldSelection.selected = false;
                }

                if (args.newSelection) {
                  args.newSelection.selected = true;
                }
              }

              if (event) {
                this.toggleDirective.close();
              }
            } else {
              throw new Error('Please provide a valid drop-down item for the selection!');
            }
          }
        }
        /**
         * Checks whether the selection is valid
         * `null` - the selection should be emptied
         * Virtual? - the selection should at least have and `index` and `value` property
         * Non-virtual? - the selection should be a valid drop-down item and **not** be a header
         * @protected
         * @param {?} selection
         * @return {?}
         */

      }, {
        key: "isSelectionValid",
        value: function isSelectionValid(selection) {
          return selection === null || this.virtDir && selection.hasOwnProperty('value') && selection.hasOwnProperty('index') || selection instanceof IgxDropDownItemComponent && !selection.isHeader;
        }
      }, {
        key: "focusedItem",
        get: function get() {
          var _this50 = this;

          if (this.virtDir) {
            return this._focusedItem && this._focusedItem.index !== -1 ? this.children.find(function (e) {
              return e.index === _this50._focusedItem.index;
            }) || null : null;
          }

          return this._focusedItem;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (!value) {
            this.selection.clear("".concat(this.id, "-active"));
            this._focusedItem = null;
            return;
          }

          this._focusedItem = value;

          if (this.virtDir) {
            this._focusedItem =
            /** @type {?} */
            {
              value: value.value,
              index: value.index
            };
          }

          this.selection.set("".concat(this.id, "-active"), new Set([this._focusedItem]));
        }
        /**
         * @return {?}
         */

      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.toggleDirective.id = value;
          this.selection.set(value, this.selection.get(this.id));
          this.selection.clear(this.id);
          this.selection.set(value, this.selection.get("".concat(this.id, "-active")));
          this.selection.clear("".concat(this.id, "-active"));
          this._id = value;
        }
        /**
         * Id of the internal listbox of the drop down
         * @return {?}
         */

      }, {
        key: "listId",
        get: function get() {
          return this.id + '-list';
        }
        /**
         * Get currently selected item
         *
         * ```typescript
         * let currentItem = this.dropdown.selectedItem;
         * ```
         * @return {?}
         */

      }, {
        key: "selectedItem",
        get: function get() {
          /** @type {?} */
          var selectedItem = this.selection.first_item(this.id);

          if (selectedItem) {
            return selectedItem;
          }

          return null;
        }
        /**
         * Gets if the dropdown is collapsed
         *
         * ```typescript
         * let isCollapsed = this.dropdown.collapsed;
         * ```
         * @return {?}
         */

      }, {
        key: "collapsed",
        get: function get() {
          return this.toggleDirective.collapsed;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "scrollContainer",
        get: function get() {
          return this.toggleDirective.element;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "collectionLength",
        get: function get() {
          if (this.virtDir) {
            return this.virtDir.totalItemCount || this.virtDir.igxForOf.length;
          }
        }
      }]);

      return IgxDropDownComponent;
    }(IgxDropDownBase);

    IgxDropDownComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-drop-down',
        template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\" [style.height]=\"height\"\n[style.maxHeight]=\"maxHeight\" [attr.id]=\"this.listId\" role=\"listbox\"\n    (onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n    (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <ng-container *ngIf=\"!collapsed\">\n        <ng-content></ng-content>\n    </ng-container>\n</div>\n",
        providers: [{
          provide: IGX_DROPDOWN_BASE,
          useExisting: IgxDropDownComponent
        }]
      }]
    }];
    /** @nocollapse */

    IgxDropDownComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxSelectionAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxDropDownComponent.propDecorators = {
      virtDir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxForOfDirective, {
          read: IgxForOfDirective,
          "static": false
        }]
      }],
      toggleDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxToggleDirective, {
          "static": true
        }]
      }],
      children: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxDropDownItemComponent;
        }), {
          descendants: true
        }]
      }],
      onOpening: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onOpened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      allowItemsFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Navigation Directive that handles keyboard events on its host and controls a targeted IgxDropDownBase component
     */

    var IgxDropDownItemNavigationDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} dropdown
       */
      function IgxDropDownItemNavigationDirective(dropdown) {
        _classCallCheck(this, IgxDropDownItemNavigationDirective);

        this.dropdown = dropdown;
        this._target = null;
      }
      /**
       * Gets the target of the navigation directive;
       *
       * ```typescript
       * // Get
       * export class MyComponent {
       *  ...
       * \@ContentChild(IgxDropDownNavigationDirective)
       *  navDirective: IgxDropDownNavigationDirective = null
       *  ...
       *  const navTarget: IgxDropDownBase = navDirective.navTarget
       * }
       * ```
       * @return {?}
       */


      _createClass(IgxDropDownItemNavigationDirective, [{
        key: "handleKeyDown",

        /**
         * Captures keydown events and calls the appropriate handlers on the target component
         * @param {?} event
         * @return {?}
         */
        value: function handleKeyDown(event) {
          if (event) {
            /** @type {?} */
            var key = event.key.toLowerCase();

            if (!this.target.collapsed) {
              // If dropdown is opened
              // If dropdown is opened

              /** @type {?} */
              var navKeys = ['esc', 'escape', 'enter', 'space', 'spacebar', ' ', 'arrowup', 'up', 'arrowdown', 'down', 'home', 'end'];

              if (navKeys.indexOf(key) === -1) {
                // If key has appropriate function in DD
                return;
              }

              event.preventDefault();
              event.stopPropagation();
            } else {
              // If dropdown is closed, do nothing
              return;
            }

            switch (key) {
              case 'esc':
              case 'escape':
                this.target.onItemActionKey(DropDownActionKey.ESCAPE, event);
                break;

              case 'enter':
                this.target.onItemActionKey(DropDownActionKey.ENTER, event);
                break;

              case 'space':
              case 'spacebar':
              case ' ':
                this.target.onItemActionKey(DropDownActionKey.SPACE, event);
                break;

              case 'arrowup':
              case 'up':
                this.onArrowUpKeyDown();
                break;

              case 'arrowdown':
              case 'down':
                this.onArrowDownKeyDown();
                break;

              case 'home':
                this.onHomeKeyDown();
                break;

              case 'end':
                this.onEndKeyDown();
                break;

              default:
                return;
            }
          }
        }
        /**
         * Navigates to previous item
         * @return {?}
         */

      }, {
        key: "onArrowDownKeyDown",
        value: function onArrowDownKeyDown() {
          this.target.navigateNext();
        }
        /**
         * Navigates to previous item
         * @return {?}
         */

      }, {
        key: "onArrowUpKeyDown",
        value: function onArrowUpKeyDown() {
          this.target.navigatePrev();
        }
        /**
         * Navigates to target's last item
         * @return {?}
         */

      }, {
        key: "onEndKeyDown",
        value: function onEndKeyDown() {
          this.target.navigateLast();
        }
        /**
         * Navigates to target's first item
         * @return {?}
         */

      }, {
        key: "onHomeKeyDown",
        value: function onHomeKeyDown() {
          this.target.navigateFirst();
        }
      }, {
        key: "target",
        get: function get() {
          return this._target;
        }
        /**
         * Sets the target of the navigation directive;
         * If no valid target is passed, it falls back to the drop down context
         *
         * ```html
         * <!-- Set -->
         * <input [igxDropDownItemNavigation]="dropdown" />
         * ...
         * <igx-drop-down #dropdown>
         * ...
         * </igx-drop-down>
         * ```
         * @param {?} target
         * @return {?}
         */
        ,
        set: function set(target) {
          this._target = target ? target : this.dropdown;
        }
      }]);

      return IgxDropDownItemNavigationDirective;
    }();

    IgxDropDownItemNavigationDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxDropDownItemNavigation]'
      }]
    }];
    /** @nocollapse */

    IgxDropDownItemNavigationDirective.ctorParameters = function () {
      return [{
        type: IgxDropDownBase,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_DROPDOWN_BASE]
        }]
      }];
    };

    IgxDropDownItemNavigationDirective.propDecorators = {
      target: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxDropDownItemNavigation']
      }],
      handleKeyDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxDropDownModule = function IgxDropDownModule() {
      _classCallCheck(this, IgxDropDownModule);
    };

    IgxDropDownModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxDropDownComponent, IgxDropDownItemComponent, IgxDropDownGroupComponent, IgxDropDownItemNavigationDirective],
        exports: [IgxDropDownComponent, IgxDropDownItemComponent, IgxDropDownGroupComponent, IgxDropDownItemNavigationDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxToggleModule],
        providers: [IgxSelectionAPIService]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var IgxHintPosition = {
      START: 0,
      END: 1
    };
    IgxHintPosition[IgxHintPosition.START] = 'START';
    IgxHintPosition[IgxHintPosition.END] = 'END';

    var IgxHintDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _element
       */
      function IgxHintDirective(_element) {
        _classCallCheck(this, IgxHintDirective);

        this._element = _element;
        this._position = IgxHintPosition.START;
        /**
         * Sets/gets whether the hint position is at the start.
         * Default value is `false`.
         * ```typescript
         * \@ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionStart = true;
         * ```
         * ```typescript
         * let isHintPositionStart = this.igxHint.isPositionStart;
         * ```
         * \@memberof IgxHintDirective
         */

        this.isPositionStart = false;
        /**
         * Sets/gets whether the hint position is at the end.
         * Default value is `false`.
         * ```typescript
         * \@ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionEnd = true;
         * ```
         * ```typescript
         * let isHintPositionEnd = this.igxHint.isPositionEnd;
         * ```
         * \@memberof IgxHintDirective
         */

        this.isPositionEnd = false;
      }
      /**
       * Sets the position of the hint.
       * ```html
       * <igx-input-group>
       *  <input igxInput type="text"/>
       *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
       * </igx-input-group>
       * ```
       * \@memberof IgxHintDirective
       * @param {?} value
       * @return {?}
       */


      _createClass(IgxHintDirective, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this._applyPosition(this._position);
        }
        /**
         * @private
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "_applyPosition",
        value: function _applyPosition(position) {
          this.isPositionStart = this.isPositionEnd = false;

          switch (position) {
            case IgxHintPosition.START:
              this.isPositionStart = true;
              break;

            case IgxHintPosition.END:
              this.isPositionEnd = true;
              break;

            default:
              break;
          }
        }
      }, {
        key: "position",
        set: function set(value) {
          /** @type {?} */
          var position =
          /** @type {?} */
          IgxHintPosition[value.toUpperCase()];

          if (position !== undefined) {
            this._position = position;

            this._applyPosition(this._position);
          }
        }
        /**
         * Gets the position of the hint.
         * ```typescript
         * \@ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * let hintPosition =  this.igxHint.position;
         * ```
         * \@memberof IgxHintDirective
         * @return {?}
         */
        ,
        get: function get() {
          return this._position.toString();
        }
      }]);

      return IgxHintDirective;
    }();

    IgxHintDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'igx-hint,[igxHint]'
      }]
    }];
    /** @nocollapse */

    IgxHintDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxHintDirective.propDecorators = {
      isPositionStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group__hint-item--start']
      }],
      isPositionEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group__hint-item--end']
      }],
      position: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['position']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @abstract
     */

    var IgxInputGroupBase = function IgxInputGroupBase() {
      _classCallCheck(this, IgxInputGroupBase);
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var nativeValidationAttributes = ['required', 'pattern', 'minlength', 'maxlength', 'min', 'max', 'step'];
    /** @enum {number} */

    var IgxInputState = {
      INITIAL: 0,
      VALID: 1,
      INVALID: 2
    };
    IgxInputState[IgxInputState.INITIAL] = 'INITIAL';
    IgxInputState[IgxInputState.VALID] = 'VALID';
    IgxInputState[IgxInputState.INVALID] = 'INVALID';

    var IgxInputDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} inputGroup
       * @param {?} ngModel
       * @param {?} formControl
       * @param {?} element
       * @param {?} cdr
       */
      function IgxInputDirective(inputGroup, ngModel, formControl, element, cdr) {
        _classCallCheck(this, IgxInputDirective);

        this.inputGroup = inputGroup;
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.element = element;
        this.cdr = cdr;
        this._valid = IgxInputState.INITIAL;
        /**
         * Sets/gets whether the `"igx-input-group__input"` class is added to the host element.
         * Default value is `false`.
         * ```typescript
         * this.igxInput.isInput = true;
         * ```
         * ```typescript
         * let isCLassAdded = this.igxInput.isInput;
         * ```
         * \@memberof IgxInputDirective
         */

        this.isInput = false;
        /**
         * Sets/gets whether the `"class.igx-input-group__textarea"` class is added to the host element.
         * Default value is `false`.
         * ```typescript
         * this.igxInput.isTextArea = true;
         * ```
         * ```typescript
         * let isCLassAdded = this.igxInput.isTextArea;
         * ```
         * \@memberof IgxInputDirective
         */

        this.isTextArea = false;
      }
      /**
       * @private
       * @return {?}
       */


      _createClass(IgxInputDirective, [{
        key: "onFocus",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function onFocus(event) {
          this.inputGroup.isFocused = true;
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur(event) {
          this.inputGroup.isFocused = false;
          this._valid = IgxInputState.INITIAL;

          if (this.ngControl) {
            if (!this.ngControl.valid) {
              this._valid = IgxInputState.INVALID;
            }
          } else if (this._hasValidators() && !this.nativeElement.checkValidity()) {
            this._valid = IgxInputState.INVALID;
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onInput",
        value: function onInput() {
          this.checkValidity();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.inputGroup.hasPlaceholder = this.nativeElement.hasAttribute('placeholder');
          this.inputGroup.disabled = this.inputGroup.disabled || this.nativeElement.hasAttribute('disabled');
          this.inputGroup.isRequired = this.nativeElement.hasAttribute('required'); // Make sure we do not invalidate the input on init

          if (!this.ngControl) {
            this._valid = IgxInputState.INITIAL;
          } // Also check the control's validators for required


          if (!this.inputGroup.isRequired && this.ngControl && this.ngControl.control.validator) {
            /** @type {?} */
            var validation = this.ngControl.control.validator(
            /** @type {?} */
            {});
            this.inputGroup.isRequired = validation && validation.required;
          }
          /** @type {?} */


          var elTag = this.nativeElement.tagName.toLowerCase();

          if (elTag === 'textarea') {
            this.isTextArea = true;
          } else {
            this.isInput = true;
          }

          if (this.ngControl) {
            this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
          }

          this.cdr.detectChanges();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
          }
        }
        /**
         * Sets a focus on the igxInput.
         * ```typescript
         * this.igxInput.focus();
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */

      }, {
        key: "focus",
        value: function focus() {
          this.nativeElement.focus();
        }
        /**
         * Gets the `nativeElement` of the igxInput.
         * ```typescript
         * let igxInputNativeElement = this.igxInput.nativeElement;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */

      }, {
        key: "onStatusChanged",

        /**
         * @hidden
         * @protected
         * @return {?}
         */
        value: function onStatusChanged() {
          if (this.ngControl.control.validator || this.ngControl.control.asyncValidator) {
            if (this.ngControl.control.touched || this.ngControl.control.dirty) {
              //  TODO: check the logic when control is touched or dirty
              if (this.inputGroup.isFocused) {
                // the user is still typing in the control
                this._valid = this.ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
              } else {
                // the user had touched the control previously but now the value is changing due to changes in the form
                this._valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
              }
            } else {
              //  if control is untouched and pristine its state is initial. This is when user did not interact
              //  with the input or when form/control is reset
              this._valid = IgxInputState.INITIAL;
            }
          }
        }
        /**
         * Gets whether the igxInput has a placeholder.
         * ```typescript
         * let hasPlaceholder = this.igxInput.hasPlaceholder;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */

      }, {
        key: "_hasValidators",

        /**
         * @private
         * @return {?}
         */
        value: function _hasValidators() {
          var _iteratorNormalCompletion19 = true;
          var _didIteratorError19 = false;
          var _iteratorError19 = undefined;

          try {
            for (var _iterator19 = nativeValidationAttributes[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
              var nativeValidationAttribute = _step19.value;

              if (this.nativeElement.hasAttribute(nativeValidationAttribute)) {
                return true;
              }
            }
          } catch (err) {
            _didIteratorError19 = true;
            _iteratorError19 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
                _iterator19["return"]();
              }
            } finally {
              if (_didIteratorError19) {
                throw _iteratorError19;
              }
            }
          }

          return !!this.ngControl && (!!this.ngControl.control.validator || !!this.ngControl.control.asyncValidator);
        }
        /**
         * Gets whether the igxInput is focused.
         * ```typescript
         * let isFocused = this.igxInput.focused;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */

      }, {
        key: "checkValidity",

        /**
         * @private
         * @return {?}
         */
        value: function checkValidity() {
          if (!this.ngControl && this._hasValidators()) {
            this._valid = this.nativeElement.checkValidity() ? IgxInputState.VALID : IgxInputState.INVALID;
          }
        }
      }, {
        key: "ngControl",
        get: function get() {
          return this.ngModel ? this.ngModel : this.formControl;
        }
        /**
         * Sets the `value` property.
         * ```html
         * <input-group>
         *  <input igxInput #igxInput [value]="'IgxInput Value'">
         * </input-group>
         * ```
         * \@memberof IgxInputDirective
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "value",
        set: function set(value) {
          this.nativeElement.value = value;
          this.checkValidity();
        }
        /**
         * Gets the `value` propery.
         * ```typescript
         * \@ViewChild('igxInput', {read: IgxInputDirective})
         *  public igxInput: IgxInputDirective;
         * let inputValue = this.igxInput.value;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        ,
        get: function get() {
          return this.nativeElement.value;
        }
        /**
         * Sets the `disabled` property.
         * ```html
         * <input-group>
         *  <input igxInput #igxInput [disabled]="true">
         * </input-group>
         * ```
         * \@memberof IgxInputDirective
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(value) {
          this.nativeElement.disabled = value;
          this.inputGroup.disabled = value;
        }
        /**
         * Gets the `disabled` property
         * ```typescript
         * \@ViewChild('igxInput', {read: IgxInputDirective})
         *  public igxInput: IgxInputDirective;
         * let isDisabled = this.igxInput.disabled;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        ,
        get: function get() {
          return this.nativeElement.hasAttribute('disabled');
        }
        /**
         * Sets the `required` property.
         * ```html
         * <input-group>
         *  <input igxInput #igxInput [required]="true">
         * </input-group>
         * ```
         * \@memberof IgxInputDirective
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "required",
        set: function set(value) {
          if (typeof value === 'boolean') {
            this.nativeElement.required = this.inputGroup.isRequired = value;

            if (value && !this.nativeElement.checkValidity()) {
              this._valid = IgxInputState.INVALID;
            } else {
              this._valid = IgxInputState.INITIAL;
            }
          }
        }
        /**
         * Gets whether the igxInput is required.
         * ```typescript
         * let isRequired = this.igxInput.required;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        ,
        get: function get() {
          return this.nativeElement.hasAttribute('required');
        }
      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
      }, {
        key: "hasPlaceholder",
        get: function get() {
          return this.nativeElement.hasAttribute('placeholder');
        }
        /**
         * Gets the placeholder element of the igxInput.
         * ```typescript
         * let igxInputPlaceholder = this.igxInput.placeholder;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */

      }, {
        key: "placeholder",
        get: function get() {
          return this.nativeElement.placeholder;
        }
      }, {
        key: "focused",
        get: function get() {
          return this.inputGroup.isFocused;
        }
        /**
         * Gets the state of the igxInput.
         * ```typescript
         * let igxInputState = this.igxInput.valid;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */

      }, {
        key: "valid",
        get: function get() {
          return this._valid;
        }
        /**
         * Gets whether the igxInput is valid.
         * ```typescript
         * let valid = this.igxInput.isValid;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        ,

        /**
         * Sets the state of the igxInput.
         * ```typescript
         * this.igxInput.valid = IgxInputState.INVALID;
         * ```
         * \@memberof IgxInputDirective
         * @param {?} value
         * @return {?}
         */
        set: function set(value) {
          this._valid = value;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.valid !== IgxInputState.INVALID;
        }
      }]);

      return IgxInputDirective;
    }();

    IgxInputDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxInput]',
        exportAs: 'igxInput'
      }]
    }];
    /** @nocollapse */

    IgxInputDirective.ctorParameters = function () {
      return [{
        type: IgxInputGroupBase
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"]]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlName"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlName"]]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxInputDirective.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['value']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group__input']
      }],
      isTextArea: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group__textarea']
      }],
      onFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus', ['$event']]
      }],
      onBlur: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['blur', ['$event']]
      }],
      onInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['input']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$3 = 0;

    var IgxLabelDirective = function IgxLabelDirective() {
      _classCallCheck(this, IgxLabelDirective);

      this.defaultClass = true;
      /**
       * @hidden
       */

      this.id = "igx-label-".concat(NEXT_ID$3++);
    };

    IgxLabelDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxLabel]'
      }]
    }];
    IgxLabelDirective.propDecorators = {
      defaultClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group__label']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxPrefixDirective = function IgxPrefixDirective() {
      _classCallCheck(this, IgxPrefixDirective);
    };

    IgxPrefixDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'igx-prefix,[igxPrefix]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxPrefixModule = function IgxPrefixModule() {
      _classCallCheck(this, IgxPrefixModule);
    };

    IgxPrefixModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxPrefixDirective],
        exports: [IgxPrefixDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxSuffixDirective = function IgxSuffixDirective() {
      _classCallCheck(this, IgxSuffixDirective);
    };

    IgxSuffixDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'igx-suffix,[igxSuffix]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxSuffixModule = function IgxSuffixModule() {
      _classCallCheck(this, IgxSuffixModule);
    };

    IgxSuffixModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxSuffixDirective],
        exports: [IgxSuffixDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$4 = 0;
    /** @enum {number} */

    var IgxInputGroupType = {
      LINE: 0,
      BOX: 1,
      BORDER: 2,
      FLUENT: 3,
      SEARCH: 4,
      FLUENT_SEARCH: 5
    };
    IgxInputGroupType[IgxInputGroupType.LINE] = 'LINE';
    IgxInputGroupType[IgxInputGroupType.BOX] = 'BOX';
    IgxInputGroupType[IgxInputGroupType.BORDER] = 'BORDER';
    IgxInputGroupType[IgxInputGroupType.FLUENT] = 'FLUENT';
    IgxInputGroupType[IgxInputGroupType.SEARCH] = 'SEARCH';
    IgxInputGroupType[IgxInputGroupType.FLUENT_SEARCH] = 'FLUENT_SEARCH';

    var IgxInputGroupComponent =
    /*#__PURE__*/
    function (_DisplayDensityBase2) {
      _inherits(IgxInputGroupComponent, _DisplayDensityBase2);

      /**
       * @param {?} _element
       * @param {?} _displayDensityOptions
       */
      function IgxInputGroupComponent(_element, _displayDensityOptions) {
        var _this51;

        _classCallCheck(this, IgxInputGroupComponent);

        _this51 = _possibleConstructorReturn(this, _getPrototypeOf(IgxInputGroupComponent).call(this, _displayDensityOptions));
        _this51._element = _element;
        _this51._displayDensityOptions = _displayDensityOptions;
        _this51._type = IgxInputGroupType.LINE;
        _this51._filled = false;
        _this51._supressInputAutofocus = false;
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-input-group [id]="'igx-input-group-55'"></igx-input-group>
         * ```
         */

        _this51.id = "igx-input-group-".concat(NEXT_ID$4++);
        /**
         * Property that enables/disables the autogenerated class of the `IgxInputGroupComponent`.
         * By default applied the class is applied.
         * ```typescript
         * \@ViewChild("MyInputGroup")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         * this.inputGroup.defaultClass = false;
         * ```
         * }
         */

        _this51.defaultClass = true;
        /**
         * @hidden
         */

        _this51.hasPlaceholder = false;
        /**
         * @hidden
         */

        _this51.isRequired = false;
        /**
         * @hidden
         */

        _this51.isFocused = false;
        /**
         * @hidden
         */

        _this51.isBox = false;
        /**
         * @hidden
         */

        _this51.isBorder = false;
        /**
         * @hidden
         */

        _this51.isSearch = false;
        /**
         * @hidden
         */

        _this51.isFluentSearch = false;
        /**
         * @hidden
         */

        _this51.isFluent = false;
        /**
         * An \@Input property that disables the `IgxInputGroupComponent`.
         * ```html
         * <igx-input-group [disabled]="'true'"></igx-input-group>
         * ```
         */

        _this51.disabled = false;
        /**
         * @hidden
         */

        _this51.hasWarning = false;
        _this51.element = _element;
        return _this51;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxInputGroupComponent, [{
        key: "onClick",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function onClick(event) {
          if (!this._supressInputAutofocus) {
            this.input.focus();
          }
        }
        /**
         * An \@Input property that sets how the input will be styled.
         * The allowed values are `line`, `box`, `border`, `fluent`, `search` and `fluentSearch`. The default is `line`.
         * ```html
         * <igx-input-group [type]="'search'">
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "validClass",
        get: function get() {
          return this.input.valid === IgxInputState.VALID;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "invalidClass",
        get: function get() {
          return this.input.valid === IgxInputState.INVALID;
        }
      }, {
        key: "type",
        set: function set(value) {
          /** @type {?} */
          var type =
          /** @type {?} */
          IgxInputGroupType[value.toUpperCase()];

          if (type !== undefined) {
            this.isBox = this.isFluent = this.isFluentSearch = this.isBorder = this.isSearch = false;

            switch (type) {
              case IgxInputGroupType.BOX:
                this.isBox = true;
                break;

              case IgxInputGroupType.BORDER:
                this.isBorder = true;
                break;

              case IgxInputGroupType.FLUENT:
                this.isFluent = true;
                break;

              case IgxInputGroupType.FLUENT_SEARCH:
                this.isFluentSearch = true;
                break;

              case IgxInputGroupType.SEARCH:
                this.isSearch = true;
                break;

              default:
                break;
            }

            this._type = type;
          }
        }
        /**
         * Returns whether the input element of the input group will be automatically focused on click.
         * ```typescript
         * let supressInputAutofocus = this.inputGroup.supressInputAutofocus;
         * ```
         * @return {?}
         */
        ,

        /**
         * Returns the type of the `IgxInputGroupComponent`. How the input is styled.
         * Values are `line` - 0, `box` - 1, `border` - 2,  `fluent` - 3 `fluentSearch` - 4 and `search` - 5. The default is `line`.
         * ```typescript
         * \@ViewChild("MyInputGroup")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let inputType = this.inputGroup.type;
         * }
         * ```
         * @return {?}
         */
        get: function get() {
          return this._type.toString();
        }
        /**
         * Returns whether the `IgxInputGroupComponent` has hints.
         * ```typescript
         * \@ViewChild("MyInputGroup")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let inputHints = this.inputGroup.hasHints;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "supressInputAutofocus",
        get: function get() {
          return this._supressInputAutofocus;
        }
        /**
         * Sets whether the input element of the input group will be automatically focused on click.
         * ```html
         * <igx-input-group [supressInputAutofocus]="true"></igx-input-group>
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._supressInputAutofocus = value;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isFilled",
        get: function get() {
          return this._filled || this.input && this.input.value;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isDisplayDensityCosy",
        get: function get() {
          return this.displayDensity === DisplayDensity.cosy;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isDisplayDensityComfortable",
        get: function get() {
          return this.displayDensity === DisplayDensity.comfortable;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isDisplayDensityCompact",
        get: function get() {
          return this.displayDensity === DisplayDensity.compact;
        }
      }, {
        key: "hasHints",
        get: function get() {
          return this.hints.length > 0;
        }
        /**
         * Returns whether the `IgxInputGroupComponent` has border.
         * ```typescript
         * \@ViewChild("MyInputGroup")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let inputBroder = this.inputGroup.hasBorder;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "hasBorder",
        get: function get() {
          return this._type === IgxInputGroupType.LINE || this._type === IgxInputGroupType.BOX;
        }
        /**
         * Returns whether the `IgxInputGroupComponent` type is line.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeLine = this.inputGroup.isTypeLine;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "isTypeLine",
        get: function get() {
          return this._type === IgxInputGroupType.LINE;
        }
        /**
         * Returns whether the `IgxInputGroupComponent` type is box.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeBox = this.inputGroup.isTypeBox;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "isTypeBox",
        get: function get() {
          return this._type === IgxInputGroupType.BOX;
        }
        /**
         * Returns whether the `IgxInputGroupComponent` type is border.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeBorder = this.inputGroup.isTypeBorder;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "isTypeBorder",
        get: function get() {
          return this._type === IgxInputGroupType.BORDER;
        }
        /**
         * Returns whether the `IgxInputGroupComponent` type is Fluent.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeFluent = this.inputGroup.isTypeFluent;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "isTypeFluent",
        get: function get() {
          return this._type === IgxInputGroupType.FLUENT;
        }
        /**
         * Returns whether the `IgxInputGroupComponent` type is search.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeSearch = this.inputGroup.isTypeSearch;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "isTypeSearch",
        get: function get() {
          return this._type === IgxInputGroupType.SEARCH;
        }
        /**
         * Returns whether the `IgxInputGroupComponent` type is fluentSearch.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeFluentSearch = this.inputGroup.isTypeFluentSearch;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "isTypeFluentSearch",
        get: function get() {
          return this._type === IgxInputGroupType.FLUENT_SEARCH;
        }
        /**
         * @return {?}
         */

      }, {
        key: "filled",
        get: function get() {
          return this._filled;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._filled = val;
        }
      }]);

      return IgxInputGroupComponent;
    }(DisplayDensityBase);

    IgxInputGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-input-group',
        template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__hint\">\n    <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n</div>\n\n<ng-template #material>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #bundle>\n\n<!--    <ng-content *ngIf=\"isTypeFluent\" select=\"[igxLabel]\"></ng-content>-->\n    <ng-container *ngIf=\"isTypeFluent\">\n        <ng-container *ngTemplateOutlet=\"material\"></ng-container>\n    </ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n        <div class=\"igx-input-group__bundle-main\">\n\n                <ng-container *ngIf=\"!isTypeFluent\">\n                    <ng-container *ngTemplateOutlet=\"material\"></ng-container>\n                </ng-container>\n<!--            <ng-content *ngIf=\"!isTypeFluent\" select=\"[igxLabel]\"></ng-content>-->\n\n            <ng-content select=\"[igxInput]\"></ng-content>\n        </div>\n        <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </div>\n    <div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n</ng-template>\n",
        providers: [{
          provide: IgxInputGroupBase,
          useExisting: IgxInputGroupComponent
        }]
      }]
    }];
    /** @nocollapse */

    IgxInputGroupComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxInputGroupComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      defaultClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group']
      }],
      hasPlaceholder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--placeholder']
      }],
      isRequired: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--required']
      }],
      isFocused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--focused']
      }],
      isBox: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--box']
      }],
      isBorder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--border']
      }],
      isSearch: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--search']
      }],
      isFluentSearch: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--fluent-search']
      }],
      isFluent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--fluent']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--disabled']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      validClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--valid']
      }],
      invalidClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--invalid']
      }],
      hasWarning: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--warning']
      }],
      hints: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxHintDirective, {
          read: IgxHintDirective
        }]
      }],
      input: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxInputDirective, {
          read: IgxInputDirective,
          "static": true
        }]
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['type']
      }],
      supressInputAutofocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isFilled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--filled']
      }],
      isDisplayDensityCosy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--cosy']
      }],
      isDisplayDensityComfortable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--comfortable']
      }],
      isDisplayDensityCompact: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-input-group--compact']
      }]
    };
    /**
     * @hidden
     */

    var IgxInputGroupModule = function IgxInputGroupModule() {
      _classCallCheck(this, IgxInputGroupModule);
    };

    IgxInputGroupModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxInputGroupComponent, IgxHintDirective, IgxInputDirective, IgxLabelDirective],
        exports: [IgxInputGroupComponent, IgxHintDirective, IgxInputDirective, IgxLabelDirective, IgxPrefixDirective, IgxSuffixDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxPrefixModule, IgxSuffixModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * **Ignite UI for Angular Autocomplete** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/autocomplete.html)
     *
     * The igxAutocomplete directive provides a way to enhance a text input
     * by showing a drop down of suggested options, provided by the developer.
     *
     * Example:
     * ```html
     * <input type="text" [igxAutocomplete]="townsPanel" />
     * <igx-drop-down #townsPanel>
     *     <igx-drop-down-item *ngFor="let town of towns | startsWith:townSelected" [value]="town">
     *         {{town}}
     *     </igx-drop-down-item>
     * </igx-drop-down>
     * ```
     */

    var IgxAutocompleteDirective =
    /*#__PURE__*/
    function (_IgxDropDownItemNavig) {
      _inherits(IgxAutocompleteDirective, _IgxDropDownItemNavig);

      /**
       * @param {?} ngModel
       * @param {?} formControl
       * @param {?} group
       * @param {?} elementRef
       * @param {?} cdr
       */
      function IgxAutocompleteDirective(ngModel, formControl, group, elementRef, cdr) {
        var _this52;

        _classCallCheck(this, IgxAutocompleteDirective);

        _this52 = _possibleConstructorReturn(this, _getPrototypeOf(IgxAutocompleteDirective).call(this, null));
        _this52.ngModel = ngModel;
        _this52.formControl = formControl;
        _this52.group = group;
        _this52.elementRef = elementRef;
        _this52.cdr = cdr;
        _this52.defaultSettings = {
          modal: false,
          scrollStrategy: new AbsoluteScrollStrategy(),
          positionStrategy: new AutoPositionStrategy({
            target: _this52.parentElement
          }),
          excludePositionTarget: true
        };
        _this52.dropDownOpened$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * Enables/disables autocomplete component
         *
         * ```typescript
         * // get
         * let disabled = this.autocomplete.disabled;
         * ```
         * ```html
         * <!--set-->
         * <input type="text" [igxAutocomplete]="townsPanel" [igxAutocompleteDisabled]="disabled"/>
         * ```
         * ```typescript
         * // set
         * public disabled = true;
         * ```
         */

        _this52.disabled = false;
        /**
         * Emitted after item from the drop down is selected
         *
         * ```html
         * <input igxInput [igxAutocomplete]="townsPanel" (onItemSelected)='itemSelected($event)' />
         * ```
         */

        _this52.onItemSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden \@internal
         */

        _this52.autofill = 'off';
        /**
         * @hidden \@internal
         */

        _this52.role = 'combobox';

        _this52.select = function (value) {
          if (!value.newSelection) {
            return;
          }

          value.cancel = true; // Disable selection in the drop down, because in autocomplete we do not save selection.
          // Disable selection in the drop down, because in autocomplete we do not save selection.

          /** @type {?} */

          var newValue = value.newSelection.value;
          /** @type {?} */

          var args = {
            value: newValue,
            cancel: false
          };

          _this52.onItemSelected.emit(args);

          if (args.cancel) {
            return;
          }

          _this52.close();

          _this52.nativeElement.focus(); // Update model after the input is re-focused, in order to have proper valid styling.
          // Otherwise when item is selected using mouse (and input is blurred), then valid style will be removed.


          _this52.model ? _this52.model.control.setValue(newValue) : _this52.nativeElement.value = newValue;
        };

        _this52.highlightFirstItem = function () {
          if (_this52.target.focusedItem) {
            _this52.target.focusedItem.focused = false;
            _this52.target.focusedItem = null;
          }

          _this52.target.navigateFirst();

          _this52.cdr.detectChanges();
        };

        return _this52;
      }
      /**
       * @protected
       * @return {?}
       */


      _createClass(IgxAutocompleteDirective, [{
        key: "onInput",

        /**
         * @hidden \@internal
         * @return {?}
         */
        value: function onInput() {
          this.open();
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onArrowDown",
        value: function onArrowDown(event) {
          event.preventDefault();
          this.open();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onTab",
        value: function onTab() {
          this.close();
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "handleKeyDown",
        value: function handleKeyDown(event) {
          if (!this.collapsed) {
            switch (event.key.toLowerCase()) {
              case 'space':
              case 'spacebar':
              case ' ':
              case 'home':
              case 'end':
                return;

              default:
                _get(_getPrototypeOf(IgxAutocompleteDirective.prototype), "handleKeyDown", this).call(this, event);

            }
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onArrowDownKeyDown",
        value: function onArrowDownKeyDown() {
          _get(_getPrototypeOf(IgxAutocompleteDirective.prototype), "onArrowDownKeyDown", this).call(this);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onArrowUpKeyDown",
        value: function onArrowUpKeyDown() {
          _get(_getPrototypeOf(IgxAutocompleteDirective.prototype), "onArrowUpKeyDown", this).call(this);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onEndKeyDown",
        value: function onEndKeyDown() {
          _get(_getPrototypeOf(IgxAutocompleteDirective.prototype), "onEndKeyDown", this).call(this);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onHomeKeyDown",
        value: function onHomeKeyDown() {
          _get(_getPrototypeOf(IgxAutocompleteDirective.prototype), "onHomeKeyDown", this).call(this);
        }
        /**
         * Closes autocomplete drop down
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          if (this.collapsed) {
            return;
          }

          this.target.close();
          this.dropDownOpened$.next();
        }
        /**
         * Opens autocomplete drop down
         * @return {?}
         */

      }, {
        key: "open",
        value: function open() {
          if (this.disabled || !this.collapsed) {
            return;
          }

          this.target.width = this.parentElement.clientWidth + 'px';
          this.target.open(this.settings);
          this.target.onSelection.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.dropDownOpened$)).subscribe(this.select);
          this.target.onOpened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(this.highlightFirstItem);
          this.target.children.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.dropDownOpened$)).subscribe(this.highlightFirstItem);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnDestroy() {
          this.dropDownOpened$.complete();
        }
      }, {
        key: "model",
        get: function get() {
          return this.ngModel || this.formControl;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.elementRef.nativeElement;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "parentElement",
        get: function get() {
          return this.group ? this.group.element.nativeElement : this.nativeElement;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "settings",
        get: function get() {
          /** @type {?} */
          var settings = Object.assign({}, this.defaultSettings, this.autocompleteSettings);

          if (!settings.positionStrategy.settings.target) {
            /** @type {?} */
            var positionStrategyClone = settings.positionStrategy.clone();
            positionStrategyClone.settings.target = this.parentElement;
            settings.positionStrategy = positionStrategyClone;
          }

          return settings;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ariaExpanded",
        get: function get() {
          return !this.collapsed;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "hasPopUp",
        get: function get() {
          return 'listbox';
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ariaOwns",
        get: function get() {
          return this.target.listId;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ariaActiveDescendant",
        get: function get() {
          return !this.target.collapsed && this.target.focusedItem ? this.target.focusedItem.id : null;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ariaAutocomplete",
        get: function get() {
          return 'list';
        }
      }, {
        key: "collapsed",
        get: function get() {
          return this.target ? this.target.collapsed : true;
        }
      }]);

      return IgxAutocompleteDirective;
    }(IgxDropDownItemNavigationDirective);

    IgxAutocompleteDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxAutocomplete]'
      }]
    }];
    /** @nocollapse */

    IgxAutocompleteDirective.ctorParameters = function () {
      return [{
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgModel"]]
        }]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlName"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControlName"]]
        }]
      }, {
        type: IgxInputGroupComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxAutocompleteDirective.propDecorators = {
      target: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxAutocomplete']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxAutocompleteDisabled']
      }],
      autocompleteSettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxAutocompleteSettings']
      }],
      onItemSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      autofill: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.autocomplete']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      ariaExpanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-expanded']
      }],
      hasPopUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-haspopup']
      }],
      ariaOwns: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-owns']
      }],
      ariaActiveDescendant: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-activedescendant']
      }],
      ariaAutocomplete: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-autocomplete']
      }],
      onInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['input']
      }],
      onArrowDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.ArrowDown', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Alt.ArrowDown', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.ArrowUp', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Alt.ArrowUp', ['$event']]
      }],
      onTab: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Tab']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Shift.Tab']
      }]
    };
    /**
     * @hidden
     */

    var IgxAutocompleteModule = function IgxAutocompleteModule() {
      _classCallCheck(this, IgxAutocompleteModule);
    };

    IgxAutocompleteModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        imports: [IgxDropDownModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]],
        declarations: [IgxAutocompleteDirective],
        exports: [IgxAutocompleteDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxButtonDirective =
    /*#__PURE__*/
    function (_DisplayDensityBase3) {
      _inherits(IgxButtonDirective, _DisplayDensityBase3);

      /**
       * @param {?} element
       * @param {?} _renderer
       * @param {?} _displayDensityOptions
       */
      function IgxButtonDirective(element, _renderer, _displayDensityOptions) {
        var _this53;

        _classCallCheck(this, IgxButtonDirective);

        _this53 = _possibleConstructorReturn(this, _getPrototypeOf(IgxButtonDirective).call(this, _displayDensityOptions));
        _this53.element = element;
        _this53._renderer = _renderer;
        _this53._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         */

        _this53._defaultType = 'flat';
        /**
         * @hidden
         */

        _this53._cssClassPrefix = 'igx-button';
        /**
         * Called when the button is clicked
         */

        _this53.buttonClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Sets/gets the `role` attribute.
         * ```typescript
         * this.button.role = 'navbutton';
         * ```
         * ```typescript
         * let buttonRole =  this.button.role;
         * ```
         * \@memberof IgxButtonDirective
         */

        _this53.role = 'button';
        /**
         * Gets or sets whether the button is selected.
         * Mainly used in the IgxButtonGroup component and it will have no effect if set separately.
         * ```html
         * <button igxButton="flat" [selected]="button.selected"></button>
         * ```
         * \@memberof IgxButtonDirective
         */

        _this53.selected = false;
        return _this53;
      }
      /**
       * Returns the underlying DOM element
       * @return {?}
       */


      _createClass(IgxButtonDirective, [{
        key: "onClick",

        /**
         * @hidden
         * @param {?} ev
         * @return {?}
         */
        value: function onClick(ev) {
          this.buttonClick.emit(ev);
        }
      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
        /**
         * Sets the type of the button.
         * ```html
         * <button  igxButton= "icon"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "type",
        set: function set(value) {
          /** @type {?} */
          var newValue = value ? value : this._defaultType;

          if (this._type !== newValue) {
            this._renderer.removeClass(this.nativeElement, "".concat(this._cssClassPrefix, "--").concat(this._type));

            this._type = newValue;

            this._renderer.addClass(this.nativeElement, "".concat(this._cssClassPrefix, "--").concat(this._type));
          }
        }
        /**
         * Sets the button text color.
         * ```html
         * <button igxButton="gradient" igxButtonColor="blue"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "color",
        set: function set(value) {
          this._color = value || this.nativeElement.style.color;

          this._renderer.setStyle(this.nativeElement, 'color', this._color);
        }
        /**
         * Sets the background color of the button.
         * ```html
         * <button igxButton="raised" igxButtonBackground="red"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "background",
        set: function set(value) {
          this._backgroundColor = value || this._backgroundColor;

          this._renderer.setStyle(this.nativeElement, 'background', this._backgroundColor);
        }
        /**
         * Sets the `aria-label` attribute.
         * ```html
         * <button igxButton= "flat" igxLabel="Label"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "label",
        set: function set(value) {
          this._label = value || this._label;

          this._renderer.setAttribute(this.nativeElement, "aria-label", this._label);
        }
        /**
         * Enables/disables the button.
         *  ```html
         * <button igxButton= "fab" [disabled]="true"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "disabled",
        set: function set(val) {
          val = !!val;
          this._disabled = val;

          if (val) {
            this._renderer.addClass(this.nativeElement, "".concat(this._cssClassPrefix, "--disabled"));
          } else {
            this._renderer.removeClass(this.nativeElement, "".concat(this._cssClassPrefix, "--disabled"));
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "cssClassCosy",
        get: function get() {
          return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') && this.displayDensity === DisplayDensity.cosy;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "cssClassCompact",
        get: function get() {
          return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') && this.displayDensity === DisplayDensity.compact;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "cssClassCosyFab",
        get: function get() {
          return this._type === 'fab' && this.displayDensity === DisplayDensity.cosy;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "cssClassCompactFab",
        get: function get() {
          return this._type === 'fab' && this.displayDensity === DisplayDensity.compact;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "disabledAttribute",
        get: function get() {
          return this._disabled ? this._disabled : null;
        }
      }]);

      return IgxButtonDirective;
    }(DisplayDensityBase);

    IgxButtonDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxButton]'
      }]
    }];
    /** @nocollapse */

    IgxButtonDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxButtonDirective.propDecorators = {
      buttonClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxButton']
      }],
      color: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxButtonColor']
      }],
      background: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxButtonBackground']
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxLabel']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cssClassCosy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-button--cosy']
      }],
      cssClassCompact: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-button--compact']
      }],
      cssClassCosyFab: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-button--fab-cosy']
      }],
      cssClassCompactFab: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-button--fab-compact']
      }],
      disabledAttribute: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.disabled']
      }],
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }]
    };
    /**
     * @hidden
     */

    var IgxButtonModule = function IgxButtonModule() {
      _classCallCheck(this, IgxButtonModule);
    };

    IgxButtonModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxButtonDirective],
        exports: [IgxButtonDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var IgxDividerType = {
      DEFAULT: 'default',
      DASHED: 'dashed'
    };
    /** @type {?} */

    var NEXT_ID$5 = 0;

    var IgxDividerDirective =
    /*#__PURE__*/
    function () {
      function IgxDividerDirective() {
        _classCallCheck(this, IgxDividerDirective);

        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = "igx-divider-".concat(NEXT_ID$5++);
        /**
         * An \@Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */

        this._inset = '0';
        /**
         * An \@Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */

        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */

        this.type = IgxDividerType.DEFAULT;
        /**
         * An \@Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */

        this.middle = false;
        /**
         * An \@Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */

        this.vertical = false;
      }
      /**
       * @return {?}
       */


      _createClass(IgxDividerDirective, [{
        key: "isDashed",
        get: function get() {
          return this.type === IgxDividerType.DASHED;
        }
        /**
         * A getter that returns `true` if the type of the divider is `default`;
         * ```typescript
         * const isDefault = this.divider.isDefault;
         * ```
         * @return {?}
         */

      }, {
        key: "isDefault",
        get: function get() {
          return this.type === IgxDividerType.DEFAULT;
        }
        /**
         * Sets the inset of the divider from the side(s).
         * If the divider attribute `middle` is set to `true`,
         * it will inset the divider on both sides.
         * ```typescript
         * this.divider.inset = '32px';
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "inset",
        set: function set(value) {
          this._inset = value;
        }
        /**
         * Gets the current divider inset in terms of
         * margin representation as applied to the divider.
         * ```typescript
         * const inset = this.divider.inset;
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          /** @type {?} */
          var baseMargin = '0';

          if (this.middle) {
            if (this.vertical) {
              return "".concat(this._inset, " ").concat(baseMargin);
            }

            return "".concat(baseMargin, " ").concat(this._inset);
          } else {
            if (this.vertical) {
              return "".concat(this._inset, " ").concat(baseMargin, " 0 ").concat(baseMargin);
            }

            return "".concat(baseMargin, " 0 ").concat(baseMargin, " ").concat(this._inset);
          }
        }
      }]);

      return IgxDividerDirective;
    }();

    IgxDividerDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-divider'
      }]
    }];
    IgxDividerDirective.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      _inset: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['inset']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-divider']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isDashed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-divider--dashed']
      }],
      middle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-divider--inset']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      vertical: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-divider--vertical']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      inset: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.margin']
      }]
    };

    var IgxDividerModule = function IgxDividerModule() {
      _classCallCheck(this, IgxDividerModule);
    };

    IgxDividerModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxDividerDirective],
        exports: [IgxDividerDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // @dynamic

    var IgxDefaultDropStrategy =
    /*#__PURE__*/
    function () {
      function IgxDefaultDropStrategy() {
        _classCallCheck(this, IgxDefaultDropStrategy);
      }

      _createClass(IgxDefaultDropStrategy, [{
        key: "dropAction",

        /**
         * @param {?} drag
         * @param {?} drop
         * @param {?} atIndex
         * @return {?}
         */
        value: function dropAction(drag, drop, atIndex) {}
      }]);

      return IgxDefaultDropStrategy;
    }(); // @dynamic


    var IgxAppendDropStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _renderer
       */
      function IgxAppendDropStrategy(_renderer) {
        _classCallCheck(this, IgxAppendDropStrategy);

        this._renderer = _renderer;
      }
      /**
       * @param {?} drag
       * @param {?} drop
       * @param {?} atIndex
       * @return {?}
       */


      _createClass(IgxAppendDropStrategy, [{
        key: "dropAction",
        value: function dropAction(drag, drop, atIndex) {
          /** @type {?} */
          var dragElement = drag.element.nativeElement;
          /** @type {?} */

          var dropAreaElement = drop.element.nativeElement;

          this._renderer.removeChild(dragElement.parentNode, dragElement);

          this._renderer.appendChild(dropAreaElement, dragElement);
        }
      }]);

      return IgxAppendDropStrategy;
    }(); // @dynamic


    var IgxPrependDropStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _renderer
       */
      function IgxPrependDropStrategy(_renderer) {
        _classCallCheck(this, IgxPrependDropStrategy);

        this._renderer = _renderer;
      }
      /**
       * @param {?} drag
       * @param {?} drop
       * @param {?} atIndex
       * @return {?}
       */


      _createClass(IgxPrependDropStrategy, [{
        key: "dropAction",
        value: function dropAction(drag, drop, atIndex) {
          /** @type {?} */
          var dragElement = drag.element.nativeElement;
          /** @type {?} */

          var dropAreaElement = drop.element.nativeElement;

          this._renderer.removeChild(dragElement.parentNode, dragElement);

          if (dropAreaElement.children.length) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[0]);
          } else {
            this._renderer.appendChild(dropAreaElement, dragElement);
          }
        }
      }]);

      return IgxPrependDropStrategy;
    }(); // @dynamic


    var IgxInsertDropStrategy =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _renderer
       */
      function IgxInsertDropStrategy(_renderer) {
        _classCallCheck(this, IgxInsertDropStrategy);

        this._renderer = _renderer;
      }
      /**
       * @param {?} drag
       * @param {?} drop
       * @param {?} atIndex
       * @return {?}
       */


      _createClass(IgxInsertDropStrategy, [{
        key: "dropAction",
        value: function dropAction(drag, drop, atIndex) {
          if (drag.element.nativeElement.parentElement === drop.element.nativeElement && atIndex === -1) {
            return;
          }
          /** @type {?} */


          var dragElement = drag.element.nativeElement;
          /** @type {?} */

          var dropAreaElement = drop.element.nativeElement;

          this._renderer.removeChild(dragElement.parentNode, dragElement);

          if (atIndex !== -1 && dropAreaElement.children.length > atIndex) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[atIndex]);
          } else {
            this._renderer.appendChild(dropAreaElement, dragElement);
          }
        }
      }]);

      return IgxInsertDropStrategy;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxDragHandleDirective =
    /**
     * @param {?} element
     */
    function IgxDragHandleDirective(element) {
      _classCallCheck(this, IgxDragHandleDirective);

      this.element = element;
      this.baseClass = true;
    };

    IgxDragHandleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxDragHandle]'
      }]
    }];
    /** @nocollapse */

    IgxDragHandleDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxDragHandleDirective.propDecorators = {
      baseClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drag__handle']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var RestrictDrag = {
      VERTICALLY: 0,
      HORIZONTALLY: 1,
      NONE: 2
    };
    RestrictDrag[RestrictDrag.VERTICALLY] = 'VERTICALLY';
    RestrictDrag[RestrictDrag.HORIZONTALLY] = 'HORIZONTALLY';
    RestrictDrag[RestrictDrag.NONE] = 'NONE';

    var IgxDragLocation =
    /**
     * @param {?} _pageX
     * @param {?} _pageY
     */
    function IgxDragLocation(_pageX, _pageY) {
      _classCallCheck(this, IgxDragLocation);

      this._pageX = _pageX;
      this._pageY = _pageY;
      this.pageX = parseFloat(_pageX);
      this.pageY = parseFloat(_pageY);
    };

    var IgxDragDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       * @param {?} element
       * @param {?} viewContainer
       * @param {?} zone
       * @param {?} renderer
       */
      function IgxDragDirective(cdr, element, viewContainer, zone, renderer) {
        _classCallCheck(this, IgxDragDirective);

        this.cdr = cdr;
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.ghostContext = null;
        /**
         * An \@Input property that indicates when the drag should start.
         * By default the drag starts after the draggable element is moved by 5px.
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */

        this.dragTolerance = 5;
        /**
         * An \@Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
         * By default it is set to `true`.
         * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
         * ```html
         * <div igxDrag [ghost]="false">
         *      <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */

        this.ghost = true;
        /**
         * Sets a custom class that will be added to the `ghostElement` element.
         * ```html
         * <div igxDrag [ghostClass]="'ghostElement'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */

        this.ghostClass = '';
        /**
         * @deprecated Please use custom base styling instead.
         * An \@Input property that hides the draggable element.
         * By default it's set to false.
         * ```html
         * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */

        this.hideBaseOnDrag = false;
        /**
         * @deprecated Please use provided transition functions in future.
         * An \@Input property that enables/disables the draggable element animation
         * when the element is released.
         * By default it's set to false.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */

        this.animateOnRelease = false;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */

        this.dragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the draggable element has been moved.
         * ```html
         * <div igxDrag  (dragMove)="onDragMove()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragMove(){
         *      alert("The element has moved!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */

        this.dragMove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */

        this.dragEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag (dragClick)="onDragClick()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragClick(){
         *      alert("The element has been clicked!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */

        this.dragClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostCreate)="ghostCreated()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostCreated(){
         *      alert("The ghost has been created!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */

        this.ghostCreate = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostDestroy)="ghostDestroyed()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostDestroyed(){
         *      alert("The ghost has been destroyed!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */

        this.ghostDestroy = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag (transitioned)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */

        this.transitioned = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        this._visibility = 'visible';
        /**
         * @hidden
         */

        this.baseClass = true;
        /**
         * @hidden
         */

        this.selectDisabled = false;
        /**
         * @hidden
         */

        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */

        this.animInProgress = false;
        this._baseMarginLeft = 0;
        this._baseMarginTop = 0;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this._dragStarted = false;
        this._ghostHostX = 0;
        this._ghostHostY = 0;
        this._pointerDownId = null;
        this._clicked = false;
        this._lastDropArea = null;
        this._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._removeOnDestroy = true;
      }
      /**
       * An \@Input property that specifies the offset of the dragged element relative to the mouse in pixels.
       * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
       * ```html
       * <div #hostDiv></div>
       * <div igxDrag [ghostOffsetX]="0">
       *         <span>Drag Me!</span>
       * </div>
       * ```
       * \@memberof IgxDragDirective
       * @param {?} value
       * @return {?}
       */


      _createClass(IgxDragDirective, [{
        key: "ngAfterContentInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this54 = this;

          if (!this.dragHandles || !this.dragHandles.length) {
            // Set user select none to the whole draggable element if no drag handles are defined.
            this.selectDisabled = true;
          } // Bind events


          this.zone.runOutsideAngular(function () {
            /** @type {?} */
            var targetElements = _this54.dragHandles && _this54.dragHandles.length ? _this54.dragHandles.map(function (item) {
              return item.element.nativeElement;
            }) : [_this54.element.nativeElement];
            targetElements.forEach(function (element) {
              if (_this54.pointerEventsEnabled) {
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'pointerdown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                  return _this54.onPointerDown(res);
                });
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'pointermove').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(function () {
                  return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"]);
                }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                  return _this54.onPointerMove(res);
                });
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'pointerup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                  return _this54.onPointerUp(res);
                });

                if (!_this54.ghost) {
                  // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                  Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'lostpointercapture').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                    return _this54.onPointerLost(res);
                  });
                }
              } else if (_this54.touchEventsEnabled) {
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'touchstart').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                  return _this54.onPointerDown(res);
                });
              } else {
                // We don't have pointer events and touch events. Use then mouse events.
                Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(element, 'mousedown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                  return _this54.onPointerDown(res);
                });
              }
            }); // We should bind to document events only once when there are no pointer events.

            if (!_this54.pointerEventsEnabled && _this54.touchEventsEnabled) {
              Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document.defaultView, 'touchmove').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(function () {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"]);
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                return _this54.onPointerMove(res);
              });
              Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document.defaultView, 'touchend').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                return _this54.onPointerUp(res);
              });
            } else if (!_this54.pointerEventsEnabled) {
              Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document.defaultView, 'mousemove').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(function () {
                return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"]);
              }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                return _this54.onPointerMove(res);
              });
              Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document.defaultView, 'mouseup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this54._destroy)).subscribe(function (res) {
                return _this54.onPointerUp(res);
              });
            }

            _this54.element.nativeElement.addEventListener('transitionend', function (args) {
              _this54.onTransitionEnd(args);
            });
          });
          this._baseMarginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
          this._baseMarginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
          this._baseOriginX = this.baseLeft;
          this._baseOriginY = this.baseTop;
          this._ghostStartX = this.baseLeft;
          this._ghostStartY = this.baseTop; // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.

          this.element.nativeElement.style.transitionDuration = '0.0s';
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroy.next(true);

          this._destroy.complete();

          if (this.ghost && this.ghostElement && this._removeOnDestroy) {
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
          }
        }
        /**
         * Sets desired location of the base element or ghost element if rended relative to the document.
         * @param {?} newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
         * @return {?}
         */

      }, {
        key: "setLocation",
        value: function setLocation(newLocation) {
          // We do not subtract marginLeft and marginTop here because here we calculate deltas.
          if (this.ghost && this.ghostElement) {
            /** @type {?} */
            var offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            /** @type {?} */

            var offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostLeft = newLocation.pageX - offsetHostX + this.getWindowScrollLeft();
            this.ghostTop = newLocation.pageY - offsetHostY + this.getWindowScrollTop();
          } else if (!this.ghost) {
            /** @type {?} */
            var deltaX = newLocation.pageX - this.pageX;
            /** @type {?} */

            var deltaY = newLocation.pageY - this.pageY;
            /** @type {?} */

            var transformX = this.getTransformX(this.element.nativeElement);
            /** @type {?} */

            var transformY = this.getTransformY(this.element.nativeElement);
            this.setTransformXY(transformX + deltaX, transformY + deltaY);
          }

          this._startX = this.baseLeft;
          this._startY = this.baseTop;
        }
        /**
         * Animates the base or ghost element depending on the `ghost` input to its initial location.
         * If `ghost` is true but there is not ghost rendered, it will be created and animated.
         * If the base element has changed its DOM position its initial location will be changed accordingly.
         * @param {?=} customAnimArgs Custom transition properties that will be applied when performing the transition.
         * @param {?=} startLocation Start location from where the transition should start.
         * @return {?}
         */

      }, {
        key: "transitionToOrigin",
        value: function transitionToOrigin(customAnimArgs, startLocation) {
          var _this55 = this;

          if (!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft || !startLocation && this.ghost && !this.ghostElement) {
            return;
          }

          if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
            if (this.ghost && !this.ghostElement) {
              this._startX = startLocation.pageX;
              this._startY = startLocation.pageY;
              this._ghostStartX = this._startX;
              this._ghostStartY = this._startY;
              this.createGhost(this._startX, this._startY);
            }

            this.setLocation(startLocation);
          }

          this.animInProgress = true; // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.

          setTimeout(function () {
            if (_this55.ghost) {
              _this55.ghostElement.style.transitionProperty = 'top, left';
              _this55.ghostElement.style.transitionDuration = customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this55.defaultReturnDuration;
              _this55.ghostElement.style.transitionTimingFunction = customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
              _this55.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';

              _this55.setLocation(new IgxDragLocation(_this55.baseLeft, _this55.baseTop));
            } else if (!_this55.ghost) {
              _this55.element.nativeElement.style.transitionProperty = 'transform';
              _this55.element.nativeElement.style.transitionDuration = customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this55.defaultReturnDuration;
              _this55.element.nativeElement.style.transitionTimingFunction = customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
              _this55.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
              _this55._startX = _this55.baseLeft;
              _this55._startY = _this55.baseTop;

              _this55.setTransformXY(0, 0);
            }
          }, 0);
        }
        /**
         * Animates the base or ghost element to a specific target location or other element using transition.
         * If `ghost` is true but there is not ghost rendered, it will be created and animated.
         * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
         * @param {?} target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
         * @param {?=} customAnimArgs Custom transition properties that will be applied when performing the transition.
         * @param {?=} startLocation Start location from where the transition should start.
         * @return {?}
         */

      }, {
        key: "transitionTo",
        value: function transitionTo(target, customAnimArgs, startLocation) {
          var _this56 = this;

          if (!!startLocation && this.ghost && !this.ghostElement) {
            this._startX = startLocation.pageX;
            this._startY = startLocation.pageY;
            this._ghostStartX = this._startX;
            this._ghostStartY = this._startY;
          } else if (!!startLocation && (!this.ghost || this.ghostElement)) {
            this.setLocation(startLocation);
          } else if (this.ghost && !this.ghostElement) {
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
            this._ghostStartX = this._startX + this.getWindowScrollLeft();
            this._ghostStartY = this._startY + this.getWindowScrollTop();
          }

          if (this.ghost && !this.ghostElement) {
            this.createGhost(this._startX, this._startY);
          }

          this.animInProgress = true; // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.

          setTimeout(function () {
            /** @type {?} */
            var movedElem = _this56.ghost ? _this56.ghostElement : _this56.element.nativeElement;
            movedElem.style.transitionProperty = _this56.ghost && _this56.ghostElement ? 'left, top' : 'transform';
            movedElem.style.transitionDuration = customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this56.defaultReturnDuration;
            movedElem.style.transitionTimingFunction = customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
            movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';

            if (target instanceof IgxDragLocation) {
              _this56.setLocation(new IgxDragLocation(target.pageX, target.pageY));
            } else {
              /** @type {?} */
              var targetRects = target.nativeElement.getBoundingClientRect();

              _this56.setLocation(new IgxDragLocation(targetRects.left - _this56.getWindowScrollLeft(), targetRects.top - _this56.getWindowScrollTop()));
            }
          }, 0);
        }
        /**
         * @hidden
         * Method bound to the PointerDown event of the base element igxDrag is initialized.
         * @param {?} event PointerDown event captured
         * @return {?}
         */

      }, {
        key: "onPointerDown",
        value: function onPointerDown(event) {
          this._clicked = true;
          this._pointerDownId = event.pointerId; // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.

          /** @type {?} */

          var handleFound = this.dragHandles.find(function (handle) {
            return handle.element.nativeElement === event.currentTarget;
          });
          /** @type {?} */

          var targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;

          if (this.pointerEventsEnabled) {
            targetElement.setPointerCapture(this._pointerDownId);
          } else {
            targetElement.focus();
            event.preventDefault();
          }

          if (!this._baseOriginX && !this._baseOriginY) {
            this._baseOriginX = this.baseLeft;
            this._baseOriginY = this.baseTop;
          }

          if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
          } else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
          }

          this._defaultOffsetX = this.baseLeft - this._startX + this.getWindowScrollLeft();
          this._defaultOffsetY = this.baseTop - this._startY + this.getWindowScrollTop();
          this._ghostStartX = this._startX + this.ghostOffsetX;
          this._ghostStartY = this._startY + this.ghostOffsetY;
          this._lastX = this._startX;
          this._lastY = this._startY;
        }
        /**
         * @hidden
         * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
         * This method is bound at first at the base element.
         * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
         * @param {?} event PointerMove event captured
         * @return {?}
         */

      }, {
        key: "onPointerMove",
        value: function onPointerMove(event) {
          var _this57 = this;

          if (this._clicked) {
            /** @type {?} */
            var pageX;
            /** @type {?} */

            var pageY;

            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
              // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
              pageX = event.pageX;
              pageY = event.pageY;
            } else if (this.touchEventsEnabled) {
              pageX = event.touches[0].pageX;
              pageY = event.touches[0].pageY; // Prevent scrolling on touch while dragging

              event.preventDefault();
            }
            /** @type {?} */


            var totalMovedX = pageX - this._startX;
            /** @type {?} */

            var totalMovedY = pageY - this._startY;

            if (!this._dragStarted && (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
              /** @type {?} */
              var dragStartArgs = {
                originalEvent: event,
                owner: this,
                startX: pageX - totalMovedX,
                startY: pageY - totalMovedY,
                pageX: pageX,
                pageY: pageY,
                cancel: false
              };
              this.zone.run(function () {
                _this57.dragStart.emit(dragStartArgs);
              });

              if (!dragStartArgs.cancel) {
                this._dragStarted = true;

                if (this.ghost) {
                  // We moved enough so ghostElement can be rendered and actual dragging to start.
                  // When creating it will take into account any offset set by the user by default.
                  this.createGhost(pageX, pageY);
                } else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                  // There is no need for ghost, but we will need to position initially the base element to reflect any offset.

                  /** @type {?} */
                  var transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) + this.getTransformX(this.element.nativeElement);
                  /** @type {?} */

                  var transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) + this.getTransformY(this.element.nativeElement);
                  this.setTransformXY(transformX, transformY);
                }
              } else {
                return;
              }
            } else if (!this._dragStarted) {
              return;
            }
            /** @type {?} */


            var moveArgs = {
              originalEvent: event,
              owner: this,
              startX: this._startX,
              startY: this._startY,
              pageX: this._lastX,
              pageY: this._lastY,
              nextPageX: pageX,
              nextPageY: pageY,
              cancel: false
            };
            this.dragMove.emit(moveArgs);
            /** @type {?} */

            var setPageX = moveArgs.nextPageX;
            /** @type {?} */

            var setPageY = moveArgs.nextPageY;
            /** @type {?} */

            var updatedMovedX = setPageX - this._startX;
            /** @type {?} */

            var updatedMovedY = setPageY - this._startY;

            if (!moveArgs.cancel) {
              if (this.ghost) {
                this.ghostLeft = this._ghostStartX + updatedMovedX;
                this.ghostTop = this._ghostStartY + updatedMovedY;
              } else {
                /** @type {?} */
                var lastMovedX = setPageX - this._lastX;
                /** @type {?} */

                var lastMovedY = setPageY - this._lastY;
                /** @type {?} */

                var translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                /** @type {?} */

                var translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                this.setTransformXY(translateX, translateY);
              }

              this.dispatchDragEvents(pageX, pageY, event);
            }

            this._lastX = setPageX;
            this._lastY = setPageY;
          }
        }
        /**
         * @hidden
         * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
         * This method is bound at first at the base element.
         * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
         * @param {?} event PointerUp event captured
         * @return {?}
         */

      }, {
        key: "onPointerUp",
        value: function onPointerUp(event) {
          var _this58 = this;

          if (!this._clicked) {
            return;
          }
          /** @type {?} */


          var pageX;
          /** @type {?} */

          var pageY;

          if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            pageX = event.pageX;
            pageY = event.pageY;
          } else if (this.touchEventsEnabled) {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY; // Prevent scrolling on touch while dragging

            event.preventDefault();
          }
          /** @type {?} */


          var eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY
          };
          this._pointerDownId = null;
          this._clicked = false;

          if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
              this.dispatchDropEvent(event.pageX, event.pageY, event);
            } else if (this.animateOnRelease) {
              this.transitionToOrigin();
            }

            this.zone.run(function () {
              _this58.dragEnd.emit(eventArgs);
            });

            if (!this.animInProgress) {
              this.onTransitionEnd(null);
            }
          } else {
            // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
            this.zone.run(function () {
              _this58.dragClick.emit(eventArgs);
            });
          }
        }
        /**
         * @hidden
         * Execute this method whe the pointer capture has been lost.
         * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
         * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
         * @param {?} event Event captured
         * @return {?}
         */

      }, {
        key: "onPointerLost",
        value: function onPointerLost(event) {
          var _this59 = this;

          if (!this._clicked) {
            return;
          }
          /** @type {?} */


          var eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: event.pageX,
            pageY: event.pageY
          };
          this._pointerDownId = null;
          this._clicked = false;

          if (this._dragStarted) {
            this.zone.run(function () {
              _this59.dragEnd.emit(eventArgs);
            });

            if (this.animateOnRelease) {
              this.transitionToOrigin();
            } else if (!this.animInProgress) {
              this.onTransitionEnd(null);
            }
          }
        }
        /**
         * @hidden
         * Create ghost element - if a Node object is provided it creates a clone of that node,
         * otherwise it clones the host element.
         * Bind all needed events.
         * @protected
         * @param {?} pageX Latest pointer position on the X axis relative to the page.
         * @param {?} pageY Latest pointer position on the Y axis relative to the page.
         * @param {?=} node The Node object to be cloned.
         * @return {?}
         */

      }, {
        key: "createGhost",
        value: function createGhost(pageX, pageY) {
          var _this60 = this;

          var node = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (!this.ghost) {
            return;
          }
          /** @type {?} */


          var dynamicGhostRef;

          if (this.ghostTemplate) {
            dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
            this.ghostElement = dynamicGhostRef.rootNodes[0];
          } else {
            this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
          }
          /** @type {?} */


          var totalMovedX = pageX - this._startX;
          /** @type {?} */

          var totalMovedY = pageY - this._startY;
          this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
          this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
          this.ghostElement.style.transitionDuration = '0.0s';
          this.ghostElement.style.position = 'absolute';

          if (this.ghostClass) {
            this.renderer.addClass(this.ghostElement, this.ghostClass);
          }
          /** @type {?} */


          var createEventArgs = {
            owner: this,
            ghostElement: this.ghostElement,
            cancel: false
          };
          this.ghostCreate.emit(createEventArgs);

          if (createEventArgs.cancel) {
            this.ghostElement = null;

            if (this.ghostTemplate && dynamicGhostRef) {
              dynamicGhostRef.destroy();
            }

            return;
          }

          if (this.ghostHost) {
            this.ghostHost.appendChild(this.ghostElement);
          } else {
            document.body.appendChild(this.ghostElement);
          }
          /** @type {?} */


          var ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
          /** @type {?} */

          var ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
          this.ghostElement.style.left = this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX + 'px';
          this.ghostElement.style.top = this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX + 'px';

          if (this.pointerEventsEnabled) {
            // The ghostElement takes control for moving and dragging after it has been rendered.
            if (this._pointerDownId !== null) {
              this.ghostElement.setPointerCapture(this._pointerDownId);
            }

            this.ghostElement.addEventListener('pointermove', function (args) {
              _this60.onPointerMove(args);
            });
            this.ghostElement.addEventListener('pointerup', function (args) {
              _this60.onPointerUp(args);
            });
            this.ghostElement.addEventListener('lostpointercapture', function (args) {
              _this60.onPointerLost(args);
            });
          } // Transition animation when the ghostElement is released and it returns to it's original position.


          this.ghostElement.addEventListener('transitionend', function (args) {
            _this60.onTransitionEnd(args);
          }); // Hide the base after the ghostElement is created, because otherwise the ghostElement will be not visible.

          if (this.hideBaseOnDrag) {
            this.visible = false;
          }

          this.cdr.detectChanges();
        }
        /**
         * @hidden
         * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
         * @protected
         * @param {?} pageX
         * @param {?} pageY
         * @param {?} originalEvent
         * @return {?}
         */

      }, {
        key: "dispatchDragEvents",
        value: function dispatchDragEvents(pageX, pageY, originalEvent) {
          /** @type {?} */
          var topDropArea;
          /** @type {?} */

          var customEventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
          };
          /** @type {?} */

          var elementsFromPoint = this.getElementsAtPoint(pageX, pageY);

          for (var i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' && elementsFromPoint[i] !== this.ghostElement && elementsFromPoint[i] !== this.element.nativeElement) {
              topDropArea = elementsFromPoint[i];
              break;
            }
          }

          if (topDropArea && (!this._lastDropArea || this._lastDropArea && this._lastDropArea !== topDropArea)) {
            if (this._lastDropArea) {
              this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            }

            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
          } else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            this._lastDropArea = null;
            return;
          }

          if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
          }
        }
        /**
         * @hidden
         * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
         * Last recorder drop area is updated in \@dispatchDragEvents method.
         * @protected
         * @param {?} pageX
         * @param {?} pageY
         * @param {?} originalEvent
         * @return {?}
         */

      }, {
        key: "dispatchDropEvent",
        value: function dispatchDropEvent(pageX, pageY, originalEvent) {
          /** @type {?} */
          var eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
          };
          this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
          this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
          this._lastDropArea = null;
        }
        /**
         * @hidden
         * Update relative positions
         * @return {?}
         */

      }, {
        key: "updateDragRelativePos",
        value: function updateDragRelativePos() {
          /** @type {?} */
          var newPosX;
          /** @type {?} */

          var newPosY;

          if (this.ghost && this.ghostElement) {
            // Calculate the new ghostElement position to remain where the mouse is, so it doesn't jump

            /** @type {?} */
            var totalDraggedX = this.ghostLeft - this._ghostStartX;
            /** @type {?} */

            var totalDraggedY = this.ghostTop - this._ghostStartY;
            newPosX = this.baseLeft;
            newPosY = this.baseTop;
            /** @type {?} */

            var diffStartX = this._ghostStartX - newPosX;
            /** @type {?} */

            var diffStartY = this._ghostStartY - newPosY;
            this.ghostTop = newPosX + totalDraggedX - diffStartX;
            this.ghostLeft = newPosY + totalDraggedY - diffStartY;
          } else if (!this.ghost) {
            /** @type {?} */
            var _totalDraggedX = this.getTransformX(this.element.nativeElement);
            /** @type {?} */


            var _totalDraggedY = this.getTransformY(this.element.nativeElement);

            newPosX = this.baseLeft - _totalDraggedX;
            newPosY = this.baseTop - _totalDraggedY;
            /** @type {?} */

            var deltaX = this._baseOriginX - newPosX;
            /** @type {?} */

            var deltaY = this._baseOriginY - newPosY;
            this.setTransformXY(_totalDraggedX + deltaX, _totalDraggedY + deltaY);
          }

          this._baseOriginX = newPosX !== undefined ? newPosX : this._baseOriginX;
          this._baseOriginY = newPosY !== undefined ? newPosY : this._baseOriginY;
        }
        /**
         * @deprecated This method will be removed in future major version. Please use `transitionToOrigin` or `transitionTo`.
         * Informs the `igxDrag` directive that it has been dropped/released.
         * This should usually be called when `animateOnRelease` is set to `true`.
         * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
         * animate correctly to the new position.
         * ```typescript
         * public onDropElem(event) {
         *     // Function bound to the igxDrop directive event `onDrop`
         *     // This cancels the default drop logic of the `igxDrop`
         *     event.cancel = true;
         *     event.drag.dropFinished();
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "dropFinished",
        value: function dropFinished() {
          this.updateDragRelativePos();

          if (this.animateOnRelease && this.ghostElement) {
            this.transitionToOrigin();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onTransitionEnd",
        value: function onTransitionEnd(event) {
          var _this61 = this;

          if (!this._dragStarted && !this.animInProgress || this._clicked) {
            // Return if no dragging started and there is no animation in progress.
            return;
          }

          if (this.ghost && this.ghostElement) {
            this._ghostStartX = this.baseLeft + this.getWindowScrollLeft();
            this._ghostStartY = this.baseTop + this.getWindowScrollTop();
            /** @type {?} */

            var ghostDestroyArgs = {
              owner: this,
              ghostElement: this.ghostElement,
              cancel: false
            };
            this.ghostDestroy.emit(ghostDestroyArgs);

            if (ghostDestroyArgs.cancel) {
              return;
            }

            if (this.hideBaseOnDrag) {
              this.visible = true;
            }

            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
          } else if (!this.ghost) {
            this.element.nativeElement.style.transitionProperty = '';
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this.element.nativeElement.style.transitionTimingFunction = '';
            this.element.nativeElement.style.transitionDelay = '';
          }

          this.animInProgress = false;
          this._dragStarted = false; // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.

          this.zone.run(function () {
            _this61.transitioned.emit({
              originalEvent: event,
              owner: _this61,
              startX: _this61._startX,
              startY: _this61._startY,
              pageX: _this61._startX,
              pageY: _this61._startY
            });
          });
        }
        /**
         * @hidden
         * @protected
         * @param {?} pageX
         * @param {?} pageY
         * @return {?}
         */

      }, {
        key: "getElementsAtPoint",
        value: function getElementsAtPoint(pageX, pageY) {
          // correct the coordinates with the current scroll position, because
          // document.elementsFromPoint consider position within the current viewport
          // window.pageXOffset == window.scrollX; // always true
          // using window.pageXOffset for IE9 compatibility

          /** @type {?} */
          var viewPortX = pageX - window.pageXOffset;
          /** @type {?} */

          var viewPortY = pageY - window.pageYOffset;

          if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes

            /** @type {?} */
            var elements = document['msElementsFromPoint'](viewPortX, viewPortY);
            return elements === null ? [] : elements;
          } else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
          }
        }
        /**
         * @hidden
         * @protected
         * @param {?} target
         * @param {?} eventName
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(target, eventName, eventArgs) {
          // This way is IE11 compatible.

          /** @type {?} */
          var dragLeaveEvent = document.createEvent('CustomEvent');
          dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
          target.dispatchEvent(dragLeaveEvent); // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
        }
        /**
         * @protected
         * @param {?} elem
         * @return {?}
         */

      }, {
        key: "getTransformX",
        value: function getTransformX(elem) {
          /** @type {?} */
          var posX = 0;

          if (elem.style.transform) {
            /** @type {?} */
            var matrix = elem.style.transform;
            /** @type {?} */

            var values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posX = values ? Number(values[1]) : 0;
          }

          return posX;
        }
        /**
         * @protected
         * @param {?} elem
         * @return {?}
         */

      }, {
        key: "getTransformY",
        value: function getTransformY(elem) {
          /** @type {?} */
          var posY = 0;

          if (elem.style.transform) {
            /** @type {?} */
            var matrix = elem.style.transform;
            /** @type {?} */

            var values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posY = values ? Number(values[2]) : 0;
          }

          return posY;
        }
        /**
         * Method setting transformation to the base draggable element.
         * @protected
         * @param {?} x
         * @param {?} y
         * @return {?}
         */

      }, {
        key: "setTransformXY",
        value: function setTransformXY(x, y) {
          this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "getWindowScrollTop",
        value: function getWindowScrollTop() {
          return window.scrollY ? window.scrollY : window.pageYOffset ? window.pageYOffset : 0;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "getWindowScrollLeft",
        value: function getWindowScrollLeft() {
          return window.scrollX ? window.scrollX : window.pageXOffset ? window.pageXOffset : 0;
        }
        /**
         * @protected
         * @param {?} ghostHost
         * @return {?}
         */

      }, {
        key: "ghostHostOffsetLeft",
        value: function ghostHostOffsetLeft(ghostHost) {
          /** @type {?} */
          var ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');

          if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
          } else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();
          }

          return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();
        }
        /**
         * @protected
         * @param {?} ghostHost
         * @return {?}
         */

      }, {
        key: "ghostHostOffsetTop",
        value: function ghostHostOffsetTop(ghostHost) {
          /** @type {?} */
          var ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');

          if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
          } else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();
          }

          return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();
        }
      }, {
        key: "ghostOffsetX",
        set: function set(value) {
          this._offsetX = parseInt(value, 10);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
        }
        /**
         * An \@Input property that specifies the offset of the dragged element relative to the mouse in pixels.
         * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
         * ```html
         * <div #hostDiv></div>
         * <div igxDrag [ghostOffsetY]="0">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "ghostOffsetY",
        set: function set(value) {
          this._offsetY = parseInt(value, 10);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
        }
        /**
         * @deprecated Please use native angular ways of hiding it using custom to the base element styling for future versions.
         * Sets the visibility of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     this.myDrag.visible = false;
         * }
         * ```
         * @param {?} bVisible
         * @return {?}
         */

      }, {
        key: "visible",
        set: function set(bVisible) {
          this._visibility = bVisible ? 'visible' : 'hidden';
          this.cdr.detectChanges();
        }
        /**
         * Returns the visibility state of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let dragVisibility = this.myDrag.visible;
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._visibility === 'visible';
        }
        /**
         * Gets the current location of the element relative to the page.
         * @return {?}
         */

      }, {
        key: "location",
        get: function get() {
          return new IgxDragLocation(this.pageX, this.pageY);
        }
        /**
         * Gets the original location of the element before dragging started.
         * @return {?}
         */

      }, {
        key: "originLocation",
        get: function get() {
          return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "pointerEventsEnabled",
        get: function get() {
          return typeof PointerEvent !== 'undefined';
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "touchEventsEnabled",
        get: function get() {
          return 'ontouchstart' in window;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "pageX",
        get: function get() {
          if (this.ghost && this.ghostElement) {
            return this.ghostLeft;
          }

          return this.baseLeft;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "pageY",
        get: function get() {
          if (this.ghost && this.ghostElement) {
            return this.ghostTop;
          }

          return this.baseTop;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "baseLeft",
        get: function get() {
          return this.element.nativeElement.getBoundingClientRect().left;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "baseTop",
        get: function get() {
          return this.element.nativeElement.getBoundingClientRect().top;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "baseOriginLeft",
        get: function get() {
          return this.baseLeft - this.getTransformX(this.element.nativeElement);
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "baseOriginTop",
        get: function get() {
          return this.baseTop - this.getTransformY(this.element.nativeElement);
        }
        /**
         * @protected
         * @param {?} pageX
         * @return {?}
         */

      }, {
        key: "ghostLeft",
        set: function set(pageX) {
          var _this62 = this;

          // To Do: Remove requestAnimationFrame when deprecated animations inputs are removed as well.
          // We use requestAnimationFrame for the old drop animations in combination with updateDragRelativePos.
          requestAnimationFrame(function () {
            if (_this62.ghostElement) {
              // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.

              /** @type {?} */
              var ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(_this62.ghostElement)['margin-left'], 10); // If ghost host is defined it needs to be taken into account.

              _this62.ghostElement.style.left = pageX - ghostMarginLeft - _this62._ghostHostX + 'px';
            }
          });
        }
        /**
         * @protected
         * @return {?}
         */
        ,
        get: function get() {
          return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
        }
        /**
         * @protected
         * @param {?} pageY
         * @return {?}
         */

      }, {
        key: "ghostTop",
        set: function set(pageY) {
          var _this63 = this;

          // To Do: Remove requestAnimationFrame when deprecated animations inputs are removed as well.
          // We use requestAnimationFrame for the old drop animations in combination with updateDragRelativePos.
          requestAnimationFrame(function () {
            if (_this63.ghostElement) {
              // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.

              /** @type {?} */
              var ghostMarginTop = parseInt(document.defaultView.getComputedStyle(_this63.ghostElement)['margin-top'], 10); // If ghost host is defined it needs to be taken into account.

              _this63.ghostElement.style.top = pageY - ghostMarginTop - _this63._ghostHostY + 'px';
            }
          });
        }
        /**
         * @protected
         * @return {?}
         */
        ,
        get: function get() {
          return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
        }
      }]);

      return IgxDragDirective;
    }();

    IgxDragDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'drag',
        selector: '[igxDrag]'
      }]
    }];
    /** @nocollapse */

    IgxDragDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }];
    };

    IgxDragDirective.propDecorators = {
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxDrag']
      }],
      dragTolerance: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dragChannel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ghost: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ghostClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hideBaseOnDrag: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      animateOnRelease: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ghostTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ghostHost: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ghostOffsetX: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ghostOffsetY: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dragStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      dragMove: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      dragEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      dragClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      ghostCreate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      ghostDestroy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      transitioned: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      dragHandles: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxDragHandleDirective]
      }],
      _visibility: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.visibility']
      }],
      baseClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drag']
      }],
      selectDisabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drag--select-disabled']
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("'hideBaseOnDrag' @Input property is deprecated and will be removed in future major versions.\n        Alternatives to it are using the new no ghost dragging and custom base styling."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxDragDirective.prototype, "hideBaseOnDrag", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("'animateOnRelease' @Input property is deprecated and will be removed in future major versions.\n        Please use 'transitionToOrigin' or 'transitionTo' methods instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxDragDirective.prototype, "animateOnRelease", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("'visible' @Input property is deprecated and will be removed in future major versions.\n        Please use native angular ways of hiding the base element using styling."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxDragDirective.prototype, "visible", null);

    var IgxDropDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?} _renderer
       * @param {?} _zone
       */
      function IgxDropDirective(element, _renderer, _zone) {
        _classCallCheck(this, IgxDropDirective);

        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */

        this.enter = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */

        this.over = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable element has left the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */

        this.leave = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable element has been dropped in the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */

        this.dropped = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        this.droppable = true;
        /**
         * @hidden
         */

        this.dragover = false;
        /**
         * @hidden
         */

        this._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._dropStrategy = new IgxDefaultDropStrategy();
      }
      /**
       * An \@Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
       *  the current drop area. The provided strategies are:
       *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
       *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
       *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
       *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
       *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
       * ```html
       * <div igxDrag>
       *      <span>DragMe</span>
       * </div>
       * <div igxDrop [dropStrategy]="myDropStrategy">
       *         <span>Numbers drop area!</span>
       * </div>
       * ```
       * ```typescript
       * import { IgxAppendDropStrategy } from 'igniteui-angular';
       *
       * export class App {
       *      public myDropStrategy = IgxAppendDropStrategy;
       * }
       * ```
       * \@memberof IgxDropDirective
       * @param {?} classRef
       * @return {?}
       */


      _createClass(IgxDropDirective, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          var _this64 = this;

          this._zone.runOutsideAngular(function () {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(_this64.element.nativeElement, 'igxDragEnter').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this64._destroy)).subscribe(function (res) {
              return _this64.onDragEnter(
              /** @type {?} */
              res);
            });
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(_this64.element.nativeElement, 'igxDragLeave').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this64._destroy)).subscribe(function (res) {
              return _this64.onDragLeave(res);
            });
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(_this64.element.nativeElement, 'igxDragOver').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this64._destroy)).subscribe(function (res) {
              return _this64.onDragOver(res);
            });
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroy.next(true);

          this._destroy.complete();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragOver",
        value: function onDragOver(event) {
          /** @type {?} */
          var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
          /** @type {?} */

          var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
          /** @type {?} */

          var offsetX = event.detail.pageX - elementPosX;
          /** @type {?} */

          var offsetY = event.detail.pageY - elementPosY;
          /** @type {?} */

          var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
          };
          this.over.emit(eventArgs);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragEnter",
        value: function onDragEnter(event) {
          var _this65 = this;

          if (!this.isDragLinked(event.detail.owner)) {
            return;
          }

          this.dragover = true;
          /** @type {?} */

          var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
          /** @type {?} */

          var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
          /** @type {?} */

          var offsetX = event.detail.pageX - elementPosX;
          /** @type {?} */

          var offsetY = event.detail.pageY - elementPosY;
          /** @type {?} */

          var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
          };

          this._zone.run(function () {
            _this65.enter.emit(eventArgs);
          });
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragLeave",
        value: function onDragLeave(event) {
          var _this66 = this;

          if (!this.isDragLinked(event.detail.owner)) {
            return;
          }

          this.dragover = false;
          /** @type {?} */

          var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
          /** @type {?} */

          var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
          /** @type {?} */

          var offsetX = event.detail.pageX - elementPosX;
          /** @type {?} */

          var offsetY = event.detail.pageY - elementPosY;
          /** @type {?} */

          var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
          };

          this._zone.run(function () {
            _this66.leave.emit(eventArgs);
          });
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragDrop",
        value: function onDragDrop(event) {
          var _this67 = this;

          if (!this.isDragLinked(event.detail.owner)) {
            return;
          }
          /** @type {?} */


          var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
          /** @type {?} */

          var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
          /** @type {?} */

          var offsetX = event.detail.pageX - elementPosX;
          /** @type {?} */

          var offsetY = event.detail.pageY - elementPosY;
          /** @type {?} */

          var args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY,
            cancel: false
          };

          this._zone.run(function () {
            _this67.dropped.emit(args);
          });

          if (this._dropStrategy && !args.cancel) {
            /** @type {?} */
            var elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
            /** @type {?} */

            var insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);

            this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
          }
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "getWindowScrollTop",
        value: function getWindowScrollTop() {
          return window.scrollY ? window.scrollY : window.pageYOffset ? window.pageYOffset : 0;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "getWindowScrollLeft",
        value: function getWindowScrollLeft() {
          return window.scrollX ? window.scrollX : window.pageXOffset ? window.pageXOffset : 0;
        }
        /**
         * @protected
         * @param {?} drag
         * @return {?}
         */

      }, {
        key: "isDragLinked",
        value: function isDragLinked(drag) {
          /** @type {?} */
          var dragLinkArray = drag.dragChannel instanceof Array;
          /** @type {?} */

          var dropLinkArray = this.dropChannel instanceof Array;

          if (!dragLinkArray && !dropLinkArray) {
            return this.dropChannel === drag.dragChannel;
          } else if (!dragLinkArray && dropLinkArray) {
            /** @type {?} */
            var dropLinks =
            /** @type {?} */
            this.dropChannel;

            for (var i = 0; i < dropLinks.length; i++) {
              if (dropLinks[i] === drag.dragChannel) {
                return true;
              }
            }
          } else if (dragLinkArray && !dropLinkArray) {
            /** @type {?} */
            var dragLinks =
            /** @type {?} */
            drag.dragChannel;

            for (var _i9 = 0; _i9 < dragLinks.length; _i9++) {
              if (dragLinks[_i9] === this.dropChannel) {
                return true;
              }
            }
          } else {
            /** @type {?} */
            var _dragLinks =
            /** @type {?} */
            drag.dragChannel;
            /** @type {?} */

            var _dropLinks =
            /** @type {?} */
            this.dropChannel;

            for (var _i10 = 0; _i10 < _dragLinks.length; _i10++) {
              for (var j = 0; j < _dropLinks.length; j++) {
                if (_dragLinks[_i10] === _dropLinks[j]) {
                  return true;
                }
              }
            }
          }

          return false;
        }
        /**
         * @protected
         * @param {?} draggedDir
         * @param {?} elementsAtPoint
         * @return {?}
         */

      }, {
        key: "getInsertIndexAt",
        value: function getInsertIndexAt(draggedDir, elementsAtPoint) {
          /** @type {?} */
          var insertIndex = -1;
          /** @type {?} */

          var dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);

          if (!dropChildren.length) {
            return insertIndex;
          }
          /** @type {?} */


          var i = 0;
          /** @type {?} */

          var childUnder = null;

          while (!childUnder && i < elementsAtPoint.length) {
            if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
              childUnder = elementsAtPoint[i];
            }

            i++;
          }
          /** @type {?} */


          var draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
          insertIndex = dropChildren.indexOf(childUnder);

          if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
            insertIndex++;
          }

          return insertIndex;
        }
      }, {
        key: "dropStrategy",
        set: function set(classRef) {
          this._dropStrategy = new classRef(this._renderer);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._dropStrategy;
        }
      }]);

      return IgxDropDirective;
    }();

    IgxDropDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'drop',
        selector: '[igxDrop]'
      }]
    }];
    /** @nocollapse */

    IgxDropDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };

    IgxDropDirective.propDecorators = {
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxDrop']
      }],
      dropChannel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dropStrategy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      enter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      over: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      leave: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      dropped: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      droppable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.droppable']
      }],
      dragover: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.dragOver']
      }],
      onDragDrop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['igxDrop', ['$event']]
      }]
    };
    /**
     * @hidden
     */

    var IgxDragDropModule = function IgxDragDropModule() {
      _classCallCheck(this, IgxDragDropModule);
    };

    IgxDragDropModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective],
        exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxFilterOptions =
    /*#__PURE__*/
    function () {
      function IgxFilterOptions() {
        _classCallCheck(this, IgxFilterOptions);

        // Input text value that will be used as a filtering pattern (matching condition is based on it)
        this.inputValue = '';
      } // Function - get value to be tested from the item
      // item - single item of the list to be filtered
      // key - property name of item, which value should be tested
      // Default behavior - returns "key"- named property value of item if key si provided,
      // otherwise textContent of the item's html element

      /**
       * @param {?} item
       * @param {?} key
       * @return {?}
       */


      _createClass(IgxFilterOptions, [{
        key: "get_value",
        value: function get_value(item, key) {
          /** @type {?} */
          var result = '';

          if (key && item[key]) {
            result = item[key].toString();
          } else if (item.element) {
            if (item.element.nativeElement) {
              result = item.element.nativeElement.textContent.trim(); // Check if element doesn't return the DOM element directly
            } else if (item.element.textContent) {
              result = item.element.textContent.trim();
            }
          }

          return result;
        } // Function - formats the original text before matching process
        // Default behavior - returns text to lower case

        /**
         * @param {?} valueToTest
         * @return {?}
         */

      }, {
        key: "formatter",
        value: function formatter(valueToTest) {
          return valueToTest.toLowerCase();
        } // Function - determines whether the item met the condition
        // valueToTest - text value that should be tested
        // inputValue - text value from input that condition is based on
        // Default behavior - "contains"

        /**
         * @param {?} valueToTest
         * @param {?} inputValue
         * @return {?}
         */

      }, {
        key: "matchFn",
        value: function matchFn(valueToTest, inputValue) {
          return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || '') > -1;
        } // Function - executed after matching test for every matched item
        // Default behavior - shows the item

        /**
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "metConditionFn",
        value: function metConditionFn(item) {
          if (item.hasOwnProperty('hidden')) {
            item.hidden = false;
          }
        } // Function - executed for every NOT matched item after matching test
        // Default behavior - hides the item

        /**
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "overdueConditionFn",
        value: function overdueConditionFn(item) {
          if (item.hasOwnProperty('hidden')) {
            item.hidden = true;
          }
        }
      }]);

      return IgxFilterOptions;
    }();

    var IgxFilterDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?} renderer
       */
      function IgxFilterDirective(element, renderer) {
        _classCallCheck(this, IgxFilterDirective);

        this.element = element;
        this.filtering = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"](false); // synchronous event emitter
        // synchronous event emitter

        this.filtered = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * @param {?} changes
       * @return {?}
       */


      _createClass(IgxFilterDirective, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          // Detect only changes of input value
          if (changes.filterOptions && changes.filterOptions.currentValue && changes.filterOptions.currentValue.inputValue !== undefined && changes.filterOptions.previousValue && changes.filterOptions.currentValue.inputValue !== changes.filterOptions.previousValue.inputValue) {
            this.filter();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "filter",
        value: function filter() {
          if (!this.filterOptions.items) {
            return;
          }
          /** @type {?} */


          var args = {
            cancel: false,
            items: this.filterOptions.items
          };
          this.filtering.emit(args);

          if (args.cancel) {
            return;
          }
          /** @type {?} */


          var pipe = new IgxFilterPipe();
          /** @type {?} */

          var filtered = pipe.transform(this.filterOptions.items, this.filterOptions);
          this.filtered.emit({
            filteredItems: filtered
          });
        }
      }]);

      return IgxFilterDirective;
    }();

    IgxFilterDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxFilter]'
      }]
    }];
    /** @nocollapse */

    IgxFilterDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }];
    };

    IgxFilterDirective.propDecorators = {
      filtering: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      filtered: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      filterOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxFilter']
      }]
    };

    var IgxFilterPipe =
    /*#__PURE__*/
    function () {
      function IgxFilterPipe() {
        _classCallCheck(this, IgxFilterPipe);
      }

      _createClass(IgxFilterPipe, [{
        key: "transform",

        /**
         * @param {?} items
         * @param {?} options
         * @return {?}
         */
        value: function transform(items, // options - initial settings of filter functionality
        options) {
          /** @type {?} */
          var result = [];

          if (!items || !items.length || !options) {
            return;
          }

          if (options.items) {
            items = options.items;
          }

          result = items.filter(function (item) {
            /** @type {?} */
            var match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);

            if (match) {
              if (options.metConditionFn) {
                options.metConditionFn(item);
              }
            } else {
              if (options.overdueConditionFn) {
                options.overdueConditionFn(item);
              }
            }

            return match;
          });
          return result;
        }
      }]);

      return IgxFilterPipe;
    }();

    IgxFilterPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'igxFilter',
        pure: false
      }]
    }];
    /**
     * @hidden
     */

    var IgxFilterModule = function IgxFilterModule() {
      _classCallCheck(this, IgxFilterModule);
    };

    IgxFilterModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxFilterDirective, IgxFilterPipe],
        exports: [IgxFilterDirective, IgxFilterPipe],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxFocusDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?=} comp
       */
      function IgxFocusDirective(element, comp) {
        _classCallCheck(this, IgxFocusDirective);

        this.element = element;
        this.comp = comp;
        this.focusState = true;
      }
      /**
       * Returns the state of the igxFocus.
       * ```typescript
       * \@ViewChild('focusContainer', {read: IgxFocusDirective})
       * public igxFocus: IgxFocusDirective;
       * let isFocusOn = this.igxFocus.focused;
       * ```
       * \@memberof IgxFocusDirective
       * @return {?}
       */


      _createClass(IgxFocusDirective, [{
        key: "trigger",

        /**
         * Triggers the igxFocus state.
         * ```typescript
         * \@ViewChild('focusContainer', {read: IgxFocusDirective})
         * public igxFocus: IgxFocusDirective;
         * this.igxFocus.trigger();
         * ```
         * \@memberof IgxFocusDirective
         * @return {?}
         */
        value: function trigger() {
          var _this68 = this;

          if (this.focusState) {
            requestAnimationFrame(function () {
              return _this68.nativeElement.focus();
            });
          }
        }
      }, {
        key: "focused",
        get: function get() {
          return this.focusState;
        }
        /**
         * Sets the state of the igxFocus.
         * ```html
         * <igx-input-group >
         *  <input #focusContainer igxInput [igxFocus]="true"/>
         * </igx-input-group>
         * ```
         * \@memberof IgxFocusDirective
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this.focusState = val;
          this.trigger();
        }
        /**
         * Gets the native element of the igxFocus.
         * ```typescript
         * \@ViewChild('focusContainer', {read: IgxFocusDirective})
         * public igxFocus: IgxFocusDirective;
         * let igxFocusNativeElement = this.igxFocus.nativeElement;
         * ```
         * \@memberof IgxFocusDirective
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          if (this.comp && this.comp[0] && this.comp[0].getEditElement) {
            return (
              /** @type {?} */
              this.comp[0].getEditElement()
            );
          }

          return this.element.nativeElement;
        }
      }]);

      return IgxFocusDirective;
    }();

    IgxFocusDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'igxFocus',
        selector: '[igxFocus]'
      }]
    }];
    /** @nocollapse */

    IgxFocusDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: Array,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"]]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Self"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    IgxFocusDirective.propDecorators = {
      focused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxFocus']
      }]
    };
    /**
     * @hidden
     */

    var IgxFocusModule = function IgxFocusModule() {
      _classCallCheck(this, IgxFocusModule);
    };

    IgxFocusModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxFocusDirective],
        exports: [IgxFocusDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxLayoutDirective =
    /*#__PURE__*/
    function () {
      function IgxLayoutDirective() {
        _classCallCheck(this, IgxLayoutDirective);

        /**
         * Sets the default flow direction of the container's children.
         *
         * Defaults to `rows`.
         *
         * ```html
         *  <div
         *   igxLayout
         *   igxLayoutDir="row">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         *  </div>
         * ```
         */
        this.dir = 'row';
        /**
         * Defines the direction flex children are placed in the flex container.
         *
         * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutReverse="true">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         * </div>
         * ```
         */

        this.reverse = false;
        /**
         * By default the immediate children will all try to fit onto one line.
         *
         * The default value `nowrap` sets this behavior.
         *
         * Other accepted values are `wrap` and `wrap-reverse`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="row"
         *   igxLayoutWrap="wrap">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */

        this.wrap = 'nowrap';
        /**
         * Defines the alignment along the main axis.
         *
         * Defaults to `flex-start` which packs the children toward the start line.
         *
         * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutJustify="space-between">
         *    <div>1</div>
         *    <div>2</div>
         *    <div>3</div>
         * </div>
         * ```
         */

        this.justify = 'flex-start';
        /**
         * Defines the default behavior for how children are laid out along the corss axis of the current line.
         *
         * Defaults to `flex-start`.
         *
         * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutItemAlign="start">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */

        this.itemAlign = 'stretch';
        /**
         * @hidden
         */

        this.display = 'flex';
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxLayoutDirective, [{
        key: "flexwrap",
        get: function get() {
          return this.wrap;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "justifycontent",
        get: function get() {
          return this.justify;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "align",
        get: function get() {
          return this.itemAlign;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "direction",
        get: function get() {
          if (this.reverse) {
            return this.dir === 'row' ? 'row-reverse' : 'column-reverse';
          }

          return this.dir === 'row' ? 'row' : 'column';
        }
      }]);

      return IgxLayoutDirective;
    }();

    IgxLayoutDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxLayout]'
      }]
    }];
    IgxLayoutDirective.propDecorators = {
      dir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxLayoutDir']
      }],
      reverse: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxLayoutReverse']
      }],
      wrap: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxLayoutWrap']
      }],
      justify: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxLayoutJustify']
      }],
      itemAlign: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxLayoutItemAlign']
      }],
      display: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.display']
      }],
      flexwrap: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.flex-wrap']
      }],
      justifycontent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.justify-content']
      }],
      align: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.align-items']
      }],
      direction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.flex-direction']
      }]
    };

    var IgxFlexDirective =
    /*#__PURE__*/
    function () {
      function IgxFlexDirective() {
        _classCallCheck(this, IgxFlexDirective);

        /**
         * Applies the `grow` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexGrow="0">Content1</div>
         *    <div igxFlex igxFlexGrow="1">Content2</div>
         *    <div igxFlex igxFlexGrow="0">Content3</div>
         * </div>
         * ```
         */
        this.grow = 1;
        /**
         * Applies the `shrink` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexShrink="1">Content1</div>
         *    <div igxFlex igxFlexShrink="0">Content2</div>
         *    <div igxFlex igxFlexShrink="1">Content3</div>
         * </div>
         * ```
         */

        this.shrink = 1;
        /**
         * Applies the directive to an element.
         *
         * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.
         *
         * ```html
         * <div igxFlex>Content</div>
         * ```
         */

        this.flex = '';
        /**
         * Applies the `order` attribute to an element that uses the directive.
         *
         * Default value is `0`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexOrder="1">Content1</div>
         *    <div igxFlex igxFlexOrder="0">Content2</div>
         *    <div igxFlex igxFlexOrder="2">Content3</div>
         * </div>
         * ```
         */

        this.order = 0;
        /**
         * Applies the `flex-basis` attribute to an element that uses the directive.
         *
         * Default value is `auto`.
         *
         * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.
         *
         * ```html
         * <div igxFlex igxFlexBasis="fit-content">Content</div>
         * ```
         */

        this.basis = 'auto';
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxFlexDirective, [{
        key: "style",
        get: function get() {
          if (this.flex) {
            return "".concat(this.flex);
          }

          return "".concat(this.grow, " ").concat(this.shrink, " ").concat(this.basis);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "itemorder",
        get: function get() {
          return this.order || 0;
        }
      }]);

      return IgxFlexDirective;
    }();

    IgxFlexDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxFlex]'
      }]
    }];
    IgxFlexDirective.propDecorators = {
      grow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxFlexGrow']
      }],
      shrink: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxFlexShrink']
      }],
      flex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxFlex']
      }],
      order: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxFlexOrder']
      }],
      basis: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxFlexBasis']
      }],
      style: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.flex']
      }],
      itemorder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.order']
      }]
    };
    /**
     * @hidden
     */

    var IgxLayoutModule = function IgxLayoutModule() {
      _classCallCheck(this, IgxLayoutModule);
    };

    IgxLayoutModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxFlexDirective, IgxLayoutDirective],
        exports: [IgxFlexDirective, IgxLayoutDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @type {?}
     */

    var MASK_FLAGS = ['C', '&', 'a', 'A', '?', 'L', '9', '0', '#'];
    /**
     * @hidden
     * @type {?}
     */

    var KEYS = {
      Ctrl: 17,
      Z: 90,
      Y: 89,
      X: 88,
      BACKSPACE: 8,
      DELETE: 46
    };
    /**
     * @hidden
     */

    var MaskHelper =
    /*#__PURE__*/
    function () {
      function MaskHelper() {
        _classCallCheck(this, MaskHelper);
      }

      _createClass(MaskHelper, [{
        key: "parseValueByMask",

        /**
         * @param {?} value
         * @param {?} maskOptions
         * @param {?} cursor
         * @return {?}
         */
        value: function parseValueByMask(value, maskOptions, cursor) {
          /** @type {?} */
          var inputValue = value;
          /** @type {?} */

          var mask = maskOptions.format;
          /** @type {?} */

          var literals = this.getMaskLiterals(mask);
          /** @type {?} */

          var literalKeys = Array.from(literals.keys());
          /** @type {?} */

          var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);

          if (inputValue.length < mask.length) {
            // BACKSPACE, DELETE
            if (inputValue === '' && cursor === -1) {
              this._cursor = 0;
              return this.parseValueByMaskOnInit(value, maskOptions);
            } // workaround for IE 'x' button


            if (nonLiteralIndeces.indexOf(cursor + 1) !== -1) {
              inputValue = this.insertCharAt(inputValue, cursor + 1, maskOptions.promptChar);
              this._cursor = cursor + 1;
            } else {
              inputValue = this.insertCharAt(inputValue, cursor + 1, mask[cursor + 1]);
              this._cursor = cursor + 1;

              for (var i = this._cursor; i < 0; i--) {
                if (literalKeys.indexOf(this._cursor) !== -1) {
                  this._cursor--;
                } else {
                  break;
                }
              }
            }
          } else {
            /** @type {?} */
            var _char2 = inputValue[cursor];
            /** @type {?} */

            var isCharValid = this.validateCharOnPostion(_char2, cursor, mask);

            if (nonLiteralIndeces.indexOf(cursor) !== -1) {
              inputValue = this.replaceCharAt(inputValue, cursor, '');

              if (isCharValid) {
                inputValue = this.replaceCharAt(inputValue, cursor, _char2);
                this._cursor = cursor + 1;
              } else {
                this._cursor = cursor;
              }
            } else {
              inputValue = this.replaceCharAt(inputValue, cursor, '');
              this._cursor = ++cursor;

              for (var _i11 = cursor; _i11 < mask.length; _i11++) {
                if (literalKeys.indexOf(this._cursor) !== -1) {
                  this._cursor = ++cursor;
                } else {
                  isCharValid = this.validateCharOnPostion(_char2, cursor, mask);

                  if (isCharValid) {
                    inputValue = this.replaceCharAt(inputValue, cursor, _char2);
                    this._cursor = ++cursor;
                    break;
                  } else {
                    break;
                  }
                }
              }
            }
          }

          return inputValue;
        }
        /**
         * @param {?} maskOptions
         * @return {?}
         */

      }, {
        key: "parseMask",
        value: function parseMask(maskOptions) {
          var _this69 = this;

          /** @type {?} */
          var outputVal = '';
          /** @type {?} */

          var mask = maskOptions.format;
          /** @type {?} */

          var literals = this.getMaskLiterals(mask);
          var _iteratorNormalCompletion20 = true;
          var _didIteratorError20 = false;
          var _iteratorError20 = undefined;

          try {
            for (var _iterator20 = mask[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
              var maskSym = _step20.value;
              outputVal += maskOptions.promptChar;
            }
          } catch (err) {
            _didIteratorError20 = true;
            _iteratorError20 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
                _iterator20["return"]();
              }
            } finally {
              if (_didIteratorError20) {
                throw _iteratorError20;
              }
            }
          }

          literals.forEach(function (val, key) {
            outputVal = _this69.replaceCharAt(outputVal, key, val);
          });
          return outputVal;
        }
        /**
         * @param {?} inputVal
         * @param {?} maskOptions
         * @return {?}
         */

      }, {
        key: "parseValueByMaskOnInit",
        value: function parseValueByMaskOnInit(inputVal, maskOptions) {
          var _this70 = this;

          /** @type {?} */
          var outputVal = '';
          /** @type {?} */

          var value = '';
          /** @type {?} */

          var mask = maskOptions.format;
          /** @type {?} */

          var literals = this.getMaskLiterals(mask);
          /** @type {?} */

          var literalKeys = Array.from(literals.keys());
          /** @type {?} */

          var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
          /** @type {?} */

          var literalValues = Array.from(literals.values());

          if (inputVal != null) {
            value = inputVal.toString();
          }

          var _iteratorNormalCompletion21 = true;
          var _didIteratorError21 = false;
          var _iteratorError21 = undefined;

          try {
            for (var _iterator21 = mask[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
              var maskSym = _step21.value;
              outputVal += maskOptions.promptChar;
            }
          } catch (err) {
            _didIteratorError21 = true;
            _iteratorError21 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
                _iterator21["return"]();
              }
            } finally {
              if (_didIteratorError21) {
                throw _iteratorError21;
              }
            }
          }

          literals.forEach(function (val, key) {
            outputVal = _this70.replaceCharAt(outputVal, key, val);
          });

          if (!value) {
            return outputVal;
          }
          /** @type {?} */


          var nonLiteralValues = this.getNonLiteralValues(value, literalValues);

          for (var i = 0; i < nonLiteralValues.length; i++) {
            /** @type {?} */
            var _char3 = nonLiteralValues[i];
            /** @type {?} */

            var isCharValid = this.validateCharOnPostion(_char3, nonLiteralIndeces[i], mask);

            if (!isCharValid && _char3 !== maskOptions.promptChar) {
              nonLiteralValues[i] = maskOptions.promptChar;
            }
          }

          if (nonLiteralValues.length > nonLiteralIndeces.length) {
            nonLiteralValues.splice(nonLiteralIndeces.length);
          }
          /** @type {?} */


          var pos = 0;
          var _iteratorNormalCompletion22 = true;
          var _didIteratorError22 = false;
          var _iteratorError22 = undefined;

          try {
            for (var _iterator22 = nonLiteralValues[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
              var nonLiteralValue = _step22.value;

              /** @type {?} */
              var _char4 = nonLiteralValue;
              outputVal = this.replaceCharAt(outputVal, nonLiteralIndeces[pos++], _char4);
            }
          } catch (err) {
            _didIteratorError22 = true;
            _iteratorError22 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
                _iterator22["return"]();
              }
            } finally {
              if (_didIteratorError22) {
                throw _iteratorError22;
              }
            }
          }

          return outputVal;
        }
        /**
         * @param {?} value
         * @param {?} maskOptions
         * @return {?}
         */

      }, {
        key: "restoreValueFromMask",
        value: function restoreValueFromMask(value, maskOptions) {
          /** @type {?} */
          var outputVal = '';
          /** @type {?} */

          var mask = maskOptions.format;
          /** @type {?} */

          var literals = this.getMaskLiterals(mask);
          /** @type {?} */

          var literalValues = Array.from(literals.values());
          var _iteratorNormalCompletion23 = true;
          var _didIteratorError23 = false;
          var _iteratorError23 = undefined;

          try {
            for (var _iterator23 = value[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
              var val = _step23.value;

              if (literalValues.indexOf(val) === -1) {
                if (val !== maskOptions.promptChar) {
                  outputVal += val;
                }
              }
            }
          } catch (err) {
            _didIteratorError23 = true;
            _iteratorError23 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
                _iterator23["return"]();
              }
            } finally {
              if (_didIteratorError23) {
                throw _iteratorError23;
              }
            }
          }

          return outputVal;
        }
        /**
         * @param {?} value
         * @param {?} maskOptions
         * @param {?} cursor
         * @param {?} selection
         * @return {?}
         */

      }, {
        key: "parseValueByMaskUponSelection",
        value: function parseValueByMaskUponSelection(value, maskOptions, cursor, selection) {
          /** @type {?} */
          var isCharValid;
          /** @type {?} */

          var inputValue = value;
          /** @type {?} */

          var _char5 = inputValue[cursor];
          /** @type {?} */

          var mask = maskOptions.format;
          /** @type {?} */

          var literals = this.getMaskLiterals(mask);
          /** @type {?} */

          var literalKeys = Array.from(literals.keys());
          /** @type {?} */

          var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);

          if (!this.data) {
            this._cursor = cursor < 0 ? ++cursor : cursor;

            if (nonLiteralIndeces.indexOf(this._cursor) !== -1) {
              isCharValid = this.validateCharOnPostion(_char5, this._cursor, mask);
              inputValue = isCharValid ? this.replaceCharAt(inputValue, this._cursor++, _char5) : inputValue = this.replaceCharAt(inputValue, this._cursor++, maskOptions.promptChar);
              selection--;

              if (selection > 0) {
                for (var i = 0; i < selection; i++) {
                  cursor++;
                  inputValue = nonLiteralIndeces.indexOf(cursor) !== -1 ? this.insertCharAt(inputValue, cursor, maskOptions.promptChar) : this.insertCharAt(inputValue, cursor, mask[cursor]);
                }
              }
            } else {
              inputValue = this.replaceCharAt(inputValue, this._cursor, mask[this._cursor]);
              this._cursor++;
              selection--;
              /** @type {?} */

              var isMarked = false;

              if (selection > 0) {
                cursor = this._cursor;

                for (var _i12 = 0; _i12 < selection; _i12++) {
                  if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                    isCharValid = this.validateCharOnPostion(_char5, cursor, mask);

                    if (isCharValid && !isMarked) {
                      inputValue = this.insertCharAt(inputValue, cursor, _char5);
                      cursor++;
                      this._cursor++;
                      isMarked = true;
                    } else {
                      inputValue = this.insertCharAt(inputValue, cursor, maskOptions.promptChar);
                      cursor++;
                    }
                  } else {
                    inputValue = this.insertCharAt(inputValue, cursor, mask[cursor]);

                    if (cursor === this._cursor) {
                      this._cursor++;
                    }

                    cursor++;
                  }
                }
              }
            }
          } else {
            if (inputValue === '' && cursor === -1) {
              this._cursor = 0;
              return this.parseValueByMaskOnInit(value, maskOptions);
            } // workaround for IE 'x' button


            if (this._cursor < 0) {
              this._cursor++;
              cursor++;
            }

            cursor++;
            this._cursor = cursor;

            for (var _i13 = 0; _i13 < selection; _i13++) {
              if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                inputValue = this.insertCharAt(inputValue, cursor, maskOptions.promptChar);
                cursor++;
              } else {
                inputValue = this.insertCharAt(inputValue, cursor, mask[cursor]);
                cursor++;
              }
            }
          }

          return inputValue;
        }
        /**
         * @param {?} value
         * @param {?} maskOptions
         * @param {?} cursor
         * @param {?} clipboardData
         * @param {?} selection
         * @return {?}
         */

      }, {
        key: "parseValueByMaskUponCopyPaste",
        value: function parseValueByMaskUponCopyPaste(value, maskOptions, cursor, clipboardData, selection) {
          /** @type {?} */
          var inputValue = value;
          /** @type {?} */

          var mask = maskOptions.format;
          /** @type {?} */

          var literals = this.getMaskLiterals(mask);
          /** @type {?} */

          var literalKeys = Array.from(literals.keys());
          /** @type {?} */

          var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
          /** @type {?} */

          var selectionEnd = cursor + selection;
          this._cursor = cursor;
          var _iteratorNormalCompletion24 = true;
          var _didIteratorError24 = false;
          var _iteratorError24 = undefined;

          try {
            for (var _iterator24 = clipboardData[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
              var clipboardSym = _step24.value;

              /** @type {?} */
              var _char6 = clipboardSym;

              if (this._cursor > mask.length) {
                return inputValue;
              }

              if (nonLiteralIndeces.indexOf(this._cursor) !== -1) {
                /** @type {?} */
                var isCharValid = this.validateCharOnPostion(_char6, this._cursor, mask);

                if (isCharValid) {
                  inputValue = this.replaceCharAt(inputValue, this._cursor++, _char6);
                }
              } else {
                for (var _i14 = cursor; _i14 < mask.length; _i14++) {
                  if (literalKeys.indexOf(this._cursor) !== -1) {
                    this._cursor++;
                  } else {
                    /** @type {?} */
                    var _isCharValid = this.validateCharOnPostion(_char6, this._cursor, mask);

                    if (_isCharValid) {
                      inputValue = this.replaceCharAt(inputValue, this._cursor++, _char6);
                    }

                    break;
                  }
                }
              }

              selection--;
            }
          } catch (err) {
            _didIteratorError24 = true;
            _iteratorError24 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion24 && _iterator24["return"] != null) {
                _iterator24["return"]();
              }
            } finally {
              if (_didIteratorError24) {
                throw _iteratorError24;
              }
            }
          }

          if (selection > 0) {
            for (var i = this._cursor; i < selectionEnd; i++) {
              if (literalKeys.indexOf(this._cursor) !== -1) {
                this._cursor++;
              } else {
                inputValue = this.replaceCharAt(inputValue, this._cursor++, maskOptions.promptChar);
              }
            }
          }

          return inputValue;
        }
        /**
         * @private
         * @param {?} inputChar
         * @param {?} position
         * @param {?} mask
         * @return {?}
         */

      }, {
        key: "validateCharOnPostion",
        value: function validateCharOnPostion(inputChar, position, mask) {
          /** @type {?} */
          var regex;
          /** @type {?} */

          var isValid;
          /** @type {?} */

          var letterOrDigitRegEx = "[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]";
          /** @type {?} */

          var letterDigitOrSpaceRegEx = "[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]";
          /** @type {?} */

          var letterRegEx = "[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]";
          /** @type {?} */

          var letteSpaceRegEx = "[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]";
          /** @type {?} */

          var digitRegEx = '[\\d]';
          /** @type {?} */

          var digitSpaceRegEx = "[\\d\\u0020]";
          /** @type {?} */

          var digitSpecialRegEx = '[\\d-\\+]';

          switch (mask.charAt(position)) {
            case 'C':
              isValid = inputChar !== '';
              break;

            case '&':
              regex = new RegExp("[\\u0020]");
              isValid = !regex.test(inputChar);
              break;

            case 'a':
              regex = new RegExp(letterDigitOrSpaceRegEx);
              isValid = regex.test(inputChar);
              break;

            case 'A':
              regex = new RegExp(letterOrDigitRegEx);
              isValid = regex.test(inputChar);
              break;

            case '?':
              regex = new RegExp(letteSpaceRegEx);
              isValid = regex.test(inputChar);
              break;

            case 'L':
              regex = new RegExp(letterRegEx);
              isValid = regex.test(inputChar);
              break;

            case '0':
              regex = new RegExp(digitRegEx);
              isValid = regex.test(inputChar);
              break;

            case '9':
              regex = new RegExp(digitSpaceRegEx);
              isValid = regex.test(inputChar);
              break;

            case '#':
              regex = new RegExp(digitSpecialRegEx);
              isValid = regex.test(inputChar);
              break;

            default:
              {
                isValid = null;
              }
          }

          return isValid;
        }
        /**
         * @private
         * @param {?} strValue
         * @param {?} index
         * @param {?} char
         * @return {?}
         */

      }, {
        key: "replaceCharAt",
        value: function replaceCharAt(strValue, index, _char7) {
          if (strValue !== undefined) {
            return strValue.substring(0, index) + _char7 + strValue.substring(index + 1);
          }
        }
        /**
         * @private
         * @param {?} strValue
         * @param {?} index
         * @param {?} char
         * @return {?}
         */

      }, {
        key: "insertCharAt",
        value: function insertCharAt(strValue, index, _char8) {
          if (strValue !== undefined) {
            return strValue.substring(0, index) + _char8 + strValue.substring(index);
          }
        }
        /**
         * @private
         * @param {?} mask
         * @return {?}
         */

      }, {
        key: "getMaskLiterals",
        value: function getMaskLiterals(mask) {
          /** @type {?} */
          var literals = new Map();

          for (var i = 0; i < mask.length; i++) {
            /** @type {?} */
            var _char9 = mask.charAt(i);

            if (MASK_FLAGS.indexOf(_char9) === -1) {
              literals.set(i, _char9);
            }
          }

          return literals;
        }
        /**
         * @private
         * @param {?} mask
         * @param {?} literalKeys
         * @return {?}
         */

      }, {
        key: "getNonLiteralIndeces",
        value: function getNonLiteralIndeces(mask, literalKeys) {
          /** @type {?} */
          var nonLiteralsIndeces = new Array();

          for (var i = 0; i < mask.length; i++) {
            if (literalKeys.indexOf(i) === -1) {
              nonLiteralsIndeces.push(i);
            }
          }

          return nonLiteralsIndeces;
        }
        /**
         * @private
         * @param {?} value
         * @param {?} literalValues
         * @return {?}
         */

      }, {
        key: "getNonLiteralValues",
        value: function getNonLiteralValues(value, literalValues) {
          /** @type {?} */
          var nonLiteralValues = new Array();
          var _iteratorNormalCompletion25 = true;
          var _didIteratorError25 = false;
          var _iteratorError25 = undefined;

          try {
            for (var _iterator25 = value[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
              var val = _step25.value;

              if (literalValues.indexOf(val) === -1) {
                nonLiteralValues.push(val);
              }
            }
          } catch (err) {
            _didIteratorError25 = true;
            _iteratorError25 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion25 && _iterator25["return"] != null) {
                _iterator25["return"]();
              }
            } finally {
              if (_didIteratorError25) {
                throw _iteratorError25;
              }
            }
          }

          return nonLiteralValues;
        }
      }, {
        key: "cursor",

        /**
         * @return {?}
         */
        get: function get() {
          return this._cursor;
        }
      }]);

      return MaskHelper;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var noop = function noop() {};

    var IgxMaskDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       */
      function IgxMaskDirective(elementRef) {
        _classCallCheck(this, IgxMaskDirective);

        this.elementRef = elementRef;
        /**
         * Emits an event each time the value changes.
         * Provides `rawValue: string` and `formattedValue: string` as event arguments.
         * ```html
         * <input (onValueChange) = "onValueChange(rawValue: string, formattedValue: string)">
         * ```
         */

        this.onValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        this._maskOptions = {
          format: '',
          promptChar: ''
        };
        /**
         * @hidden
         */

        this._onTouchedCallback = noop;
        /**
         * @hidden
         */

        this._onChangeCallback = noop;
        this.maskHelper = new MaskHelper();
      }
      /**
       * Specifies a placeholder.
       * ```html
       * <input placeholder = "enter text...">
       * ```
       * \@memberof IgxMaskDirective
       * @param {?} val
       * @return {?}
       */


      _createClass(IgxMaskDirective, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          if (this.promptChar && this.promptChar.length > 1) {
            this._maskOptions.promptChar = this.promptChar = this.promptChar.substring(0, 1);
          }

          this._maskOptions.format = this.mask ? this.mask : 'CCCCCCCCCC';
          this._maskOptions.promptChar = this.promptChar ? this.promptChar : '_';
          this.nativeElement.setAttribute('placeholder', this.placeholder ? this.placeholder : this._maskOptions.format);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydown",
        value: function onKeydown(event) {
          /** @type {?} */
          var key = event.keyCode || event.charCode;

          if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
          }

          if (key === KEYS.Ctrl) {
            this._ctrlDown = true;
          }

          if (this._ctrlDown && key === KEYS.Z || this._ctrlDown && key === KEYS.Y) {
            event.preventDefault();
          }

          this._key = key;
          this._selection = Math.abs(this.selectionEnd - this.selectionStart);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeyup",
        value: function onKeyup(event) {
          /** @type {?} */
          var key = event.keyCode || event.charCode;

          if (key === KEYS.Ctrl) {
            this._ctrlDown = false;
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onPaste",
        value: function onPaste(event) {
          this._paste = true;
          this._valOnPaste = this.value;
          this._cursorOnPaste = this.getCursorPosition();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onInputChanged",
        value: function onInputChanged(event) {
          if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
            return;
          }

          if (this._paste) {
            this._paste = false;
            /** @type {?} */

            var clipboardData = this.value.substring(this._cursorOnPaste, this.getCursorPosition());
            this.value = this.maskHelper.parseValueByMaskUponCopyPaste(this._valOnPaste, this._maskOptions, this._cursorOnPaste, clipboardData, this._selection);
            this.setCursorPosition(this.maskHelper.cursor);
          } else {
            /** @type {?} */
            var currentCursorPos = this.getCursorPosition();
            this.maskHelper.data = this._key === KEYS.BACKSPACE || this._key === KEYS.DELETE;
            this.value = this._selection && this._selection !== 0 ? this.maskHelper.parseValueByMaskUponSelection(this.value, this._maskOptions, currentCursorPos - 1, this._selection) : this.maskHelper.parseValueByMask(this.value, this._maskOptions, currentCursorPos - 1);
            this.setCursorPosition(this.maskHelper.cursor);
          }
          /** @type {?} */


          var rawVal = this.maskHelper.restoreValueFromMask(this.value, this._maskOptions);
          this.dataValue = this.includeLiterals ? this.value : rawVal;

          this._onChangeCallback(this.dataValue);

          this.onValueChange.emit({
            rawValue: rawVal,
            formattedValue: this.value
          });
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus(value) {
          if (this.focusedValuePipe) {
            if (isIE()) {
              this._stopPropagation = true;
            }

            this.value = this.focusedValuePipe.transform(value);
          } else {
            this.value = this.maskHelper.parseValueByMaskOnInit(this.value, this._maskOptions);
          }
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur(value) {
          if (this.displayValuePipe) {
            this.value = this.displayValuePipe.transform(value);
          } else if (value === this.maskHelper.parseMask(this._maskOptions)) {
            this.value = '';
          }
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "getCursorPosition",
        value: function getCursorPosition() {
          return this.nativeElement.selectionStart;
        }
        /**
         * @hidden
         * @private
         * @param {?} start
         * @param {?=} end
         * @return {?}
         */

      }, {
        key: "setCursorPosition",
        value: function setCursorPosition(start) {
          var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;
          this.nativeElement.setSelectionRange(start, end);
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (this.promptChar && this.promptChar.length > 1) {
            this._maskOptions.promptChar = this.promptChar.substring(0, 1);
          }

          this.value = value ? this.maskHelper.parseValueByMaskOnInit(value, this._maskOptions) : '';

          if (this.displayValuePipe) {
            this.value = this.displayValuePipe.transform(this.value);
          }

          this.dataValue = this.includeLiterals ? this.value : value;

          this._onChangeCallback(this.dataValue);

          this.onValueChange.emit({
            rawValue: value,
            formattedValue: this.value
          });
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
      }, {
        key: "placeholder",
        set: function set(val) {
          this._placeholder = val;
          this.nativeElement.setAttribute('placeholder', this._placeholder);
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._placeholder;
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this.nativeElement.value;
        }
        /**
         * @hidden
         * @private
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this.nativeElement.value = val;
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.elementRef.nativeElement;
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "selectionStart",
        get: function get() {
          return this.nativeElement.selectionStart;
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "selectionEnd",
        get: function get() {
          return this.nativeElement.selectionEnd;
        }
      }]);

      return IgxMaskDirective;
    }();

    IgxMaskDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxMaskDirective,
          multi: true
        }],
        selector: '[igxMask]'
      }]
    }];
    /** @nocollapse */

    IgxMaskDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxMaskDirective.propDecorators = {
      mask: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxMask']
      }],
      promptChar: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      includeLiterals: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      placeholder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      displayValuePipe: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      focusedValuePipe: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dataValue: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onValueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onKeydown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown', ['$event']]
      }],
      onKeyup: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keyup', ['$event']]
      }],
      onPaste: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['paste', ['$event']]
      }],
      onInputChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['input', ['$event']]
      }],
      onFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus', ['$event.target.value']]
      }],
      onBlur: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['blur', ['$event.target.value']]
      }]
    };
    /**
     * @hidden
     */

    var IgxMaskModule = function IgxMaskModule() {
      _classCallCheck(this, IgxMaskModule);
    };

    IgxMaskModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxMaskDirective],
        exports: [IgxMaskDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var RadioLabelPosition = {
      BEFORE: 'before',
      AFTER: 'after'
    };
    /** @type {?} */

    var nextId = 0;
    /** @type {?} */

    var noop$1 = function noop$1() {};
    /**
     * **Ignite UI for Angular Radio Button** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
     *
     * The Ignite UI Radio Button allows the user to select a single option from an available set of options that are listed side by side.
     *
     * Example:
     * ```html
     * <igx-radio>
     *   Simple radio button
     * </igx-radio>
     * ```
     */


    var IgxRadioComponent =
    /*#__PURE__*/
    function () {
      function IgxRadioComponent() {
        _classCallCheck(this, IgxRadioComponent);

        /**
         * Sets/gets the `id` of the radio component.
         * If not set, the `id` of the first radio component will be `"igx-radio-0"`.
         * ```html
         * <igx-radio id = "my-first-radio"></igx-radio>
         * ```
         * ```typescript
         * let radioId =  this.radio.id;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.id = "igx-radio-".concat(nextId++);
        /**
         * Sets/gets the id of the `label` element in the radio component.
         * If not set, the id of the `label` in the first radio component will be `"igx-radio-0-label"`.
         * ```html
         * <igx-radio labelId = "Label1"></igx-radio>
         * ```
         * ```typescript
         * let labelId =  this.radio.labelId;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.labelId = "".concat(this.id, "-label");
        /**
         * Sets/gets the position of the `label` in the radio component.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-radio labelPosition = "before"></igx-radio>
         * ```
         * ```typescript
         * let labelPosition =  this.radio.labelPosition;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.labelPosition = 'after';
        /**
         * Sets the value of the `tabindex` attribute.
         * ```html
         * <igx-radio [tabindex] = "1"></igx-radio>
         * ```
         * ```typescript
         * let tabIndex =  this.radio.tabindex;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.tabindex = null;
        /**
         * Enables/disables the ripple effect on the radio button..
         * If not set, the `disableRipple` will have value `false`.
         * ```html
         * <igx-radio [disableRipple] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabledRipple =  this.radio.disableRipple;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.disableRipple = false;
        /**
         * Sets/gets whether the radio button is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-radio [required] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isRequired =  this.radio.required;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute of the radio component.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-radio aria-labelledby = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabelledBy = this.radio.ariaLabelledBy;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the `aria-label` attribute of the radio component.
         * ```html
         * <igx-radio aria-label = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabel =  this.radio.ariaLabel;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.ariaLabel = null;
        /**
         * An event that is emitted after the radio `value` is changed.
         * Provides references to the `IgxRadioComponent` and the `value` property as event arguments.
         * \@memberof IgxRadioComponent
         */

        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Returns the class of the radio component.
         * ```typescript
         * let radioClass = this.radio.cssClass;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.cssClass = 'igx-radio';
        /**
         * Sets/gets  the `checked` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [checked] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isChecked =  this.radio.checked;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.checked = false;
        /**
         * Sets/gets  the `disabled` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [disabled] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabled =  this.radio.disabled;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.disabled = false;
        /**
         * Sets/gets whether the radio component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.radio.focus = true;
         * ```
         * ```typescript
         * let isFocused =  this.radio.focused;
         * ```
         * \@memberof IgxRadioComponent
         */

        this.focused = false;
        /**
         * @hidden
         */

        this.inputId = "".concat(this.id, "-input");
        /**
         * @hidden
         */

        this._value = null;
        /**
         * @hidden
         */

        this._onTouchedCallback = noop$1;
        /**
         * @hidden
         */

        this._onChangeCallback = noop$1;
      }
      /**
       * @hidden
       * @param {?} event
       * @return {?}
       */


      _createClass(IgxRadioComponent, [{
        key: "_onRadioChange",
        value: function _onRadioChange(event) {
          event.stopPropagation();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onRadioClick",
        value: function _onRadioClick(event) {
          event.stopPropagation();
          this.select();

          if (isIE()) {
            this.nativeRadio.nativeElement.blur();
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "_onLabelClick",
        value: function _onLabelClick() {
          this.select();
        }
        /**
         * Selects the current radio button.
         * ```typescript
         * this.radio.select();
         * ```
         * \@memberof IgxRadioComponent
         * @return {?}
         */

      }, {
        key: "select",
        value: function select() {
          if (this.disabled) {
            return;
          }

          this.checked = true;
          this.focused = false;
          this.change.emit({
            value: this.value,
            radio: this
          });

          this._onChangeCallback(this.value);
        }
        /**
         * Checks whether the provided value is consistent to the current radio button.
         * If it is, the checked attribute will have value `true`;
         * ```typescript
         * this.radio.writeValue('radioButtonValue');
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this._value = value;
          this.checked = this._value === this.value;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getEditElement",
        value: function getEditElement() {
          return this.nativeRadio.nativeElement;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onFocus",

        /**
         * @hidden
         * @return {?}
         */
        value: function onFocus() {
          this.focused = true;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur() {
          this.focused = false;

          this._onTouchedCallback();
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
      }, {
        key: "labelClass",
        get: function get() {
          switch (this.labelPosition) {
            case RadioLabelPosition.BEFORE:
              return "".concat(this.cssClass, "__label--before");

            case RadioLabelPosition.AFTER:
            default:
              return "".concat(this.cssClass, "__label");
          }
        }
      }]);

      return IgxRadioComponent;
    }();

    IgxRadioComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxRadioComponent,
          multi: true
        }],
        selector: 'igx-radio',
        template: "<input #radio class=\"igx-radio__input\" type=\"radio\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (click)=\"_onRadioClick($event)\"\n    (change)=\"_onRadioChange($event)\"\n    (focus)=\"onFocus()\"\n    (blur)=\"onBlur()\" />\n\n<label #nativeLabel class=\"igx-radio__composite\" igxRipple\n    igxRippleTarget=\".igx-radio__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    [for]=\"inputId\">\n    <div class=\"igx-radio__ripple\"></div>\n</label>\n\n<span #placeholderLabel role=\"label\"\n    [id]=\"labelId\"\n    [class]=\"labelClass\"\n    (click)=\"_onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
      }]
    }];
    /** @nocollapse */

    IgxRadioComponent.ctorParameters = function () {
      return [];
    };

    IgxRadioComponent.propDecorators = {
      nativeRadio: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['radio', {
          "static": true
        }]
      }],
      nativeLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['nativeLabel', {
          "static": true
        }]
      }],
      placeholderLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['placeholderLabel', {
          "static": true
        }]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      labelId: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      labelPosition: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disableRipple: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ariaLabelledBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['aria-labelledby']
      }],
      ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['aria-label']
      }],
      change: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-radio']
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-radio--checked']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-radio--disabled']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      focused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-radio--focused']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxRippleDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} builder
       * @param {?} elementRef
       * @param {?} renderer
       * @param {?} zone
       */
      function IgxRippleDirective(builder, elementRef, renderer, zone) {
        _classCallCheck(this, IgxRippleDirective);

        this.builder = builder;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        /**
         * Sets/gets the ripple target.
         * ```html
         * <div  #rippleContainer class="div-1" igxRipple [igxRippleTarget] = "'.div-1'"></div>
         * ```
         * ```typescript
         * \@ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleTarget = this.ripple.rippleTarget;
         * ```
         * Can set the ripple to activate on a child element inside the parent where igxRipple is defined.
         * ```html
         * <div #rippleContainer [igxRippleTarget] = "'#child"'>
         *  <button id="child">Click</button>
         * </div>
         * ```
         * \@memberof IgxRippleDirective
         */

        this.rippleTarget = '';
        /**
         * Sets/gets the ripple duration(in milliseconds).
         * Default value is `600`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDuration] = "800"></button>
         * ```
         * ```typescript
         * \@ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleDuration = this.ripple.rippleDuration;
         * ```
         * \@memberof IgxRippleDirective
         */

        this.rippleDuration = 600;
        /**
         * Sets/gets whether the ripple is disabled.
         * Default value is `false`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDisabled] = "true"></button>
         * ```
         * ```typescript
         * \@ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let isRippleDisabled = this.ripple.rippleDisabled;
         * ```
         * \@memberof IgxRippleDirective
         */

        this.rippleDisabled = false;
        this.rippleElementClass = 'igx-ripple__inner';
        this.rippleHostClass = 'igx-ripple';
        this._centered = false;
        this.animationQueue = [];
      }
      /**
       * Enables/disables the ripple to be centered.
       * ```html
       * <button #rippleContainer igxRipple [igxRippleCentered] = "true"></button>
       * ```
       * \@memberof IgxRippleDirective
       * @param {?} value
       * @return {?}
       */


      _createClass(IgxRippleDirective, [{
        key: "onMouseDown",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function onMouseDown(event) {
          var _this71 = this;

          this.zone.runOutsideAngular(function () {
            return _this71._ripple(event);
          });
        }
        /**
         * @private
         * @param {?} rippleElement
         * @param {?} styleParams
         * @return {?}
         */

      }, {
        key: "setStyles",
        value: function setStyles(rippleElement, styleParams) {
          this.renderer.addClass(rippleElement, this.rippleElementClass);
          this.renderer.setStyle(rippleElement, 'width', "".concat(styleParams.radius, "px"));
          this.renderer.setStyle(rippleElement, 'height', "".concat(styleParams.radius, "px"));
          this.renderer.setStyle(rippleElement, 'top', "".concat(styleParams.top, "px"));
          this.renderer.setStyle(rippleElement, 'left', "".concat(styleParams.left, "px"));

          if (this.rippleColor) {
            this.renderer.setStyle(rippleElement, 'background', this.rippleColor);
          }
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_ripple",
        value: function _ripple(event) {
          var _this72 = this;

          if (this.rippleDisabled) {
            return;
          }
          /** @type {?} */


          var target = this.rippleTarget ? this.nativeElement.querySelector(this.rippleTarget) || this.nativeElement : this.nativeElement;
          /** @type {?} */

          var rectBounds = target.getBoundingClientRect();
          /** @type {?} */

          var radius = Math.max(rectBounds.width, rectBounds.height);
          /** @type {?} */

          var left = event.clientX - rectBounds.left - radius / 2;
          /** @type {?} */

          var top = event.clientY - rectBounds.top - radius / 2;

          if (this._centered) {
            left = top = 0;
          }
          /** @type {?} */


          var dimensions = {
            radius: radius,
            top: top,
            left: left
          };
          /** @type {?} */

          var rippleElement = this.renderer.createElement('span');
          this.setStyles(rippleElement, dimensions);
          this.renderer.addClass(target, this.rippleHostClass);
          this.renderer.appendChild(target, rippleElement);
          /** @type {?} */

          var animation = this.builder.build([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            opacity: 0.5,
            transform: 'scale(.3)'
          }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(this.rippleDuration, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
            opacity: 0,
            transform: 'scale(2)'
          }))]).create(rippleElement);
          this.animationQueue.push(animation);
          animation.onDone(function () {
            _this72.animationQueue.splice(_this72.animationQueue.indexOf(animation), 1);

            target.removeChild(rippleElement);

            if (_this72.animationQueue.length < 1) {
              _this72.renderer.removeClass(target, _this72.rippleHostClass);
            }
          });
          animation.play();
        }
      }, {
        key: "centered",
        set: function set(value) {
          this._centered = value || this.centered;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.elementRef.nativeElement;
        }
      }]);

      return IgxRippleDirective;
    }();

    IgxRippleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRipple]'
      }]
    }];
    /** @nocollapse */

    IgxRippleDirective.ctorParameters = function () {
      return [{
        type: _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };

    IgxRippleDirective.propDecorators = {
      rippleTarget: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxRippleTarget']
      }],
      rippleColor: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxRipple']
      }],
      rippleDuration: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxRippleDuration']
      }],
      centered: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxRippleCentered']
      }],
      rippleDisabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxRippleDisabled']
      }],
      onMouseDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['mousedown', ['$event']]
      }]
    };
    /**
     * @hidden
     */

    var IgxRippleModule = function IgxRippleModule() {
      _classCallCheck(this, IgxRippleModule);
    };

    IgxRippleModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxRippleDirective],
        exports: [IgxRippleDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var noop$2 = function noop$2() {};
    /** @type {?} */


    var nextId$1 = 0;
    /**
     * **Ignite UI for Angular Radio Group** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
     *
     * The Ignite UI Radio Group allows the user to select a single option from an available set of options that are listed side by side.
     *
     * Example:
     * ```html
     * <igx-radio-group name="radioGroup">
     *   <igx-radio *ngFor="let item of ['Foo', 'Bar', 'Baz']" value="{{item}}">
     *      {{item}}
     *   </igx-radio>
     * </igx-radio-group>
     * ```
     */

    var IgxRadioGroupDirective =
    /*#__PURE__*/
    function () {
      function IgxRadioGroupDirective() {
        _classCallCheck(this, IgxRadioGroupDirective);

        /**
         * An event that is emitted after the radio group `value` is changed.
         * Provides references to the selected `IgxRadioComponent` and the `value` property as event arguments.
         * \@memberof IgxRadioGroupDirective
         */
        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        this.cssClass = 'igx-radio-group';
        /**
         * @hidden
         */

        this._onChangeCallback = noop$2;
        /**
         * @hidden
         */

        this._name = "igx-radio-group-".concat(nextId$1++);
        /**
         * @hidden
         */

        this._value = null;
        /**
         * @hidden
         */

        this._selected = null;
        /**
         * @hidden
         */

        this._isInitialized = false;
        /**
         * @hidden
         */

        this._labelPosition = 'after';
        /**
         * @hidden
         */

        this._disabled = false;
        /**
         * @hidden
         */

        this._required = false;
        /**
         * @hidden
         */

        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
      }
      /**
       * Sets/gets the `value` attribute.
       * ```html
       * <igx-radio-group [value] = "'radioButtonValue'"></igx-radio-group>
       * ```
       * ```typescript
       * let value =  this.radioGroup.value;
       * ```
       * \@memberof IgxRadioGroupDirective
       * @return {?}
       */


      _createClass(IgxRadioGroupDirective, [{
        key: "ngAfterContentInit",

        /**
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this73 = this;

          // The initial value can possibly be set by NgModel and it is possible that
          // the OnInit of the NgModel occurs after the OnInit of this class.
          this._isInitialized = true;
          setTimeout(function () {
            _this73._initRadioButtons();
          });
        }
        /**
         * Checks whether the provided value is consistent to the current radio button.
         * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
         * ```typescript
         * this.radioGroup.writeValue('radioButtonValue');
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this.value = value;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
              button.registerOnTouched(fn);
            });
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "_initRadioButtons",
        value: function _initRadioButtons() {
          var _this74 = this;

          if (this.radioButtons) {
            /** @type {?} */
            var props = {
              name: this._name,
              labelPosition: this._labelPosition,
              disabled: this._disabled,
              required: this._required
            };
            this.radioButtons.forEach(function (button) {
              Object.assign(button, props);

              if (button.value === _this74._value) {
                button.checked = true;
                _this74._selected = button;
              }

              button.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this74.destroy$)).subscribe(function (ev) {
                return _this74._selectedRadioButtonChanged(ev);
              });
            });
          }
        }
        /**
         * @hidden
         * @private
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "_selectedRadioButtonChanged",
        value: function _selectedRadioButtonChanged(args) {
          if (this._selected !== args.radio) {
            if (this._selected) {
              this._selected.checked = false;
            }

            this._selected = args.radio;
          }

          this._value = args.value;

          if (this._isInitialized) {
            this.change.emit(args);

            this._onChangeCallback(this.value);
          }
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "_setRadioButtonNames",
        value: function _setRadioButtonNames() {
          var _this75 = this;

          if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
              button.name = _this75._name;
            });
          }
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "_selectRadioButton",
        value: function _selectRadioButton() {
          var _this76 = this;

          if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
              if (!_this76._value) {
                // no value - uncheck all radio buttons
                if (button.checked) {
                  button.checked = false;
                }
              } else {
                if (_this76._value === button.value) {
                  // selected button
                  if (_this76._selected !== button) {
                    _this76._selected = button;
                  }

                  if (!button.checked) {
                    button.select();
                  }
                } else {
                  // non-selected button
                  if (button.checked) {
                    button.checked = false;
                  }
                }
              }
            });
          }
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "_setRadioButtonLabelPosition",
        value: function _setRadioButtonLabelPosition() {
          var _this77 = this;

          if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
              button.labelPosition = _this77._labelPosition;
            });
          }
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "_disableRadioButtons",
        value: function _disableRadioButtons() {
          var _this78 = this;

          if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
              button.disabled = _this78._disabled;
            });
          }
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "_setRadioButtonsRequired",
        value: function _setRadioButtonsRequired() {
          var _this79 = this;

          if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
              button.required = _this79._required;
            });
          }
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._value !== newValue) {
            this._value = newValue;

            this._selectRadioButton();
          }
        }
        /**
         * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.
         * ```html
         * <igx-radio-group name = "Radio1"></igx-radio-group>
         *  ```
         * ```typescript
         * let name =  this.radioGroup.name;
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */

      }, {
        key: "name",
        get: function get() {
          return this._name;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._name !== newValue) {
            this._name = newValue;

            this._setRadioButtonNames();
          }
        }
        /**
         * Sets/gets whether the radio group is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-radio-group [required] = "true"></igx-radio-group>
         * ```
         * ```typescript
         * let isRequired =  this.radioGroup.required;
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */

      }, {
        key: "required",
        get: function get() {
          return this._required;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._required !== newValue) {
            this._required = newValue;

            this._setRadioButtonsRequired();
          }
        }
        /**
         * An \@Input property that allows you to disable the radio group. By default it's false.
         * ```html
         * <igx-radio-group [disabled]="true"></igx-radio-group>
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._disabled !== newValue) {
            this._disabled = newValue;

            this._disableRadioButtons();
          }
        }
        /**
         * Sets/gets the position of the `label` in the child radio buttons.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-radio-group labelPosition = "before"></igx-radio-group>
         * ```
         * ```typescript
         * let labelPosition =  this.radioGroup.labelPosition;
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */

      }, {
        key: "labelPosition",
        get: function get() {
          return this._labelPosition;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._labelPosition !== newValue) {
            this._labelPosition = newValue === RadioLabelPosition.BEFORE ? RadioLabelPosition.BEFORE : RadioLabelPosition.AFTER;

            this._setRadioButtonLabelPosition();
          }
        }
        /**
         * Sets/gets the selected child radio button.
         * ```typescript
         * let selectedButton = this.radioGroup.selected;
         * this.radioGroup.selected = selectedButton;
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this._selected;
        }
        /**
         * @param {?} selected
         * @return {?}
         */
        ,
        set: function set(selected) {
          if (this._selected !== selected) {
            this._selected = selected;
            this.value = selected ? selected.value : null;
          }
        }
      }]);

      return IgxRadioGroupDirective;
    }();

    IgxRadioGroupDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'igxRadioGroup',
        selector: 'igx-radio-group, [igxRadioGroup]',
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxRadioGroupDirective,
          multi: true
        }]
      }]
    }];
    IgxRadioGroupDirective.propDecorators = {
      radioButtons: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxRadioComponent, {
          descendants: true
        }]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      labelPosition: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      change: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-radio-group']
      }]
    };
    /**
     * @hidden
     */

    var IgxRadioModule = function IgxRadioModule() {
      _classCallCheck(this, IgxRadioModule);
    };

    IgxRadioModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxRadioGroupDirective, IgxRadioComponent],
        exports: [IgxRadioGroupDirective, IgxRadioComponent],
        imports: [IgxRippleModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxTextHighlightDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?} renderer
       */
      function IgxTextHighlightDirective(element, renderer) {
        var _this80 = this;

        _classCallCheck(this, IgxTextHighlightDirective);

        this.element = element;
        this.renderer = renderer;
        this._div = null;
        this._observer = null;
        this._nodeWasRemoved = false;
        this._forceEvaluation = false;
        this._activeElementIndex = -1;
        this._defaultCssClass = 'igx-highlight';
        this._defaultActiveCssClass = 'igx-highlight--active';
        /**
         * Identifies the highlight within a unique group.
         * This allows it to have several different highlight groups,
         * with each of them having their own active highlight.
         *
         * ```html
         * <div
         *   igxTextHighlight
         *   [groupName]="myGroupName">
         * </div>
         * ```
         */

        this.groupName = '';
        this._value = '';
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        IgxTextHighlightDirective.onActiveElementChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (groupName) {
          if (_this80.groupName === groupName) {
            if (_this80._activeElementIndex !== -1) {
              _this80.deactivate();
            }

            _this80.activateIfNecessary();
          }
        });
      }
      /**
       * The underlying value of the element that will be highlighted.
       *
       * ```typescript
       * // get
       * const elementValue = this.textHighlight.value;
       * ```
       *
       * ```html
       * <!--set-->
       * <div
       *   igxTextHighlight
       *   [value]="newValue">
       * </div>
       * ```
       * @return {?}
       */


      _createClass(IgxTextHighlightDirective, [{
        key: "ngOnDestroy",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnDestroy() {
          this.clearHighlight();

          if (this._observer !== null) {
            this._observer.disconnect();
          }

          this.destroy$.next(true);
          this.destroy$.complete();
        }
        /**
         * @hidden
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          if (changes.value && !changes.value.firstChange) {
            this._valueChanged = true;
          } else if (changes.row !== undefined && !changes.row.firstChange || changes.column !== undefined && !changes.column.firstChange || changes.page !== undefined && !changes.page.firstChange) {
            if (this._activeElementIndex !== -1) {
              this.deactivate();
            }

            this.activateIfNecessary();
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.parentElement = this.renderer.parentNode(this.element.nativeElement);

          if (IgxTextHighlightDirective.highlightGroupsMap.has(this.groupName) === false) {
            IgxTextHighlightDirective.highlightGroupsMap.set(this.groupName, {
              index: -1
            });
          }

          this._lastSearchInfo = {
            searchedText: '',
            content: this.value,
            matchCount: 0,
            caseSensitive: false,
            exactMatch: false
          };
          this._container = this.parentElement.firstElementChild;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewChecked",
        value: function ngAfterViewChecked() {
          if (this._valueChanged) {
            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
            this.activateIfNecessary();
            this._valueChanged = false;
          }
        }
        /**
         * Clears the existing highlight and highlights the searched text.
         * Returns how many times the element contains the searched text.
         * @param {?} text
         * @param {?=} caseSensitive
         * @param {?=} exactMatch
         * @return {?}
         */

      }, {
        key: "highlight",
        value: function highlight(text, caseSensitive, exactMatch) {
          /** @type {?} */
          var caseSensitiveResolved = caseSensitive ? true : false;
          /** @type {?} */

          var exactMatchResolved = exactMatch ? true : false;

          if (this.searchNeedsEvaluation(text, caseSensitiveResolved, exactMatchResolved)) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
            this._lastSearchInfo.content = this.value;

            if (text === '' || text === undefined || text === null) {
              this.clearHighlight();
            } else {
              this.clearChildElements(true);
              this._lastSearchInfo.matchCount = this.getHighlightedText(text, caseSensitive, exactMatch);
            }
          } else if (this._nodeWasRemoved) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
          }

          return this._lastSearchInfo.matchCount;
        }
        /**
         * Clears any existing highlight.
         * @return {?}
         */

      }, {
        key: "clearHighlight",
        value: function clearHighlight() {
          this.clearChildElements(false);
          this._lastSearchInfo.searchedText = '';
          this._lastSearchInfo.matchCount = 0;
        }
        /**
         * Activates the highlight if it is on the currently active row, column and page.
         * @return {?}
         */

      }, {
        key: "activateIfNecessary",
        value: function activateIfNecessary() {
          /** @type {?} */
          var group = IgxTextHighlightDirective.highlightGroupsMap.get(this.groupName);
          /** @type {?} */

          var column = group.columnIndex === undefined ? group.column : group.columnIndex;
          /** @type {?} */

          var row = group.rowIndex === undefined ? group.row : group.rowIndex;

          if (column === this.column && row === this.row && group.page === this.page) {
            this.activate(group.index);
          }
        }
        /**
         * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
         * Should be used only when necessary as using many observers may lead to performance degradation.
         * @return {?}
         */

      }, {
        key: "observe",
        value: function observe() {
          var _this81 = this;

          if (this._observer === null) {
            /** @type {?} */
            var callback = function callback(mutationList) {
              mutationList.forEach(function (mutation) {
                /** @type {?} */
                var removedNodes = Array.from(mutation.removedNodes);
                removedNodes.forEach(function (n) {
                  if (n === _this81._container) {
                    _this81._nodeWasRemoved = true;

                    _this81.clearChildElements(false);
                  }
                });
                /** @type {?} */

                var addedNodes = Array.from(mutation.addedNodes);
                addedNodes.forEach(function (n) {
                  if (n === _this81.parentElement.firstElementChild && _this81._nodeWasRemoved) {
                    _this81._container = _this81.parentElement.firstElementChild;
                    _this81._nodeWasRemoved = false;
                    _this81._forceEvaluation = true;

                    _this81.highlight(_this81._lastSearchInfo.searchedText, _this81._lastSearchInfo.caseSensitive, _this81._lastSearchInfo.exactMatch);

                    _this81._forceEvaluation = false;

                    _this81.activateIfNecessary();

                    _this81._observer.disconnect();

                    _this81._observer = null;
                  }
                });
              });
            };

            this._observer = new MutationObserver(callback);

            this._observer.observe(this.parentElement, {
              childList: true
            });
          }
        }
        /**
         * @private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "activate",
        value: function activate(index) {
          this.deactivate();

          if (this._div !== null) {
            /** @type {?} */
            var spans = this._div.querySelectorAll('span');

            this._activeElementIndex = index;

            if (spans.length <= index) {
              return;
            }
            /** @type {?} */


            var elementToActivate = spans[index];
            this.renderer.addClass(elementToActivate, this._defaultActiveCssClass);
            this.renderer.addClass(elementToActivate, this.activeCssClass);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          if (this._activeElementIndex === -1) {
            return;
          }
          /** @type {?} */


          var spans = this._div.querySelectorAll('span');

          if (spans.length <= this._activeElementIndex) {
            this._activeElementIndex = -1;
            return;
          }
          /** @type {?} */


          var elementToDeactivate = spans[this._activeElementIndex];
          this.renderer.removeClass(elementToDeactivate, this._defaultActiveCssClass);
          this.renderer.removeClass(elementToDeactivate, this.activeCssClass);
          this._activeElementIndex = -1;
        }
        /**
         * @private
         * @param {?} originalContentHidden
         * @return {?}
         */

      }, {
        key: "clearChildElements",
        value: function clearChildElements(originalContentHidden) {
          this.renderer.setProperty(this.element.nativeElement, 'hidden', originalContentHidden);

          if (this._div !== null) {
            this.renderer.removeChild(this.parentElement, this._div);
            this._div = null;
            this._activeElementIndex = -1;
          }
        }
        /**
         * @private
         * @param {?} searchText
         * @param {?} caseSensitive
         * @param {?} exactMatch
         * @return {?}
         */

      }, {
        key: "getHighlightedText",
        value: function getHighlightedText(searchText, caseSensitive, exactMatch) {
          this.appendDiv();
          /** @type {?} */

          var stringValue = String(this.value);
          /** @type {?} */

          var contentStringResolved = !caseSensitive ? stringValue.toLowerCase() : stringValue;
          /** @type {?} */

          var searchTextResolved = !caseSensitive ? searchText.toLowerCase() : searchText;
          /** @type {?} */

          var matchCount = 0;

          if (exactMatch) {
            if (contentStringResolved === searchTextResolved) {
              // tslint:disable-next-line:max-line-length
              this.appendSpan("<span class=\"".concat(this._defaultCssClass, " ").concat(this.cssClass ? this.cssClass : '', "\">").concat(stringValue, "</span>"));
              matchCount++;
            } else {
              this.appendText(stringValue);
            }
          } else {
            /** @type {?} */
            var foundIndex = contentStringResolved.indexOf(searchTextResolved, 0);
            /** @type {?} */

            var previousMatchEnd = 0;

            while (foundIndex !== -1) {
              /** @type {?} */
              var _start = foundIndex;
              /** @type {?} */

              var end = foundIndex + searchTextResolved.length;
              this.appendText(stringValue.substring(previousMatchEnd, _start)); // tslint:disable-next-line:max-line-length

              this.appendSpan("<span class=\"".concat(this._defaultCssClass, " ").concat(this.cssClass ? this.cssClass : '', "\">").concat(stringValue.substring(_start, end), "</span>"));
              previousMatchEnd = end;
              matchCount++;
              foundIndex = contentStringResolved.indexOf(searchTextResolved, end);
            }

            this.appendText(stringValue.substring(previousMatchEnd, stringValue.length));
          }

          return matchCount;
        }
        /**
         * @private
         * @param {?} text
         * @return {?}
         */

      }, {
        key: "appendText",
        value: function appendText(text) {
          /** @type {?} */
          var textElement = this.renderer.createText(text);
          this.renderer.appendChild(this._div, textElement);
        }
        /**
         * @private
         * @param {?} outerHTML
         * @return {?}
         */

      }, {
        key: "appendSpan",
        value: function appendSpan(outerHTML) {
          /** @type {?} */
          var span = this.renderer.createElement('span');
          this.renderer.appendChild(this._div, span);
          this.renderer.setProperty(span, 'outerHTML', outerHTML);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "appendDiv",
        value: function appendDiv() {
          this._div = this.renderer.createElement('div');

          if (this.containerClass) {
            this.renderer.addClass(this._div, this.containerClass);
          }

          this.renderer.appendChild(this.parentElement, this._div);
        }
        /**
         * @private
         * @param {?} text
         * @param {?} caseSensitive
         * @param {?} exactMatch
         * @return {?}
         */

      }, {
        key: "searchNeedsEvaluation",
        value: function searchNeedsEvaluation(text, caseSensitive, exactMatch) {
          /** @type {?} */
          var searchedText = this._lastSearchInfo.searchedText;
          return !this._nodeWasRemoved && (searchedText === null || searchedText !== text || this._lastSearchInfo.content !== this.value || this._lastSearchInfo.caseSensitive !== caseSensitive || this._lastSearchInfo.exactMatch !== exactMatch || this._forceEvaluation);
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value === undefined || value === null) {
            this._value = '';
          } else {
            this._value = value;
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "lastSearchInfo",
        get: function get() {
          return this._lastSearchInfo;
        }
        /**
         * Activates the highlight at a given index.
         * (if such index exists)
         * @param {?} groupName
         * @param {?} highlight
         * @return {?}
         */

      }], [{
        key: "setActiveHighlight",
        value: function setActiveHighlight(groupName, highlight) {
          IgxTextHighlightDirective.highlightGroupsMap.set(groupName, highlight);
          IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
        }
        /**
         * Clears any existing highlight.
         * @param {?} groupName
         * @return {?}
         */

      }, {
        key: "clearActiveHighlight",
        value: function clearActiveHighlight(groupName) {
          IgxTextHighlightDirective.highlightGroupsMap.set(groupName, {
            index: -1
          });
          IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
        }
      }]);

      return IgxTextHighlightDirective;
    }();

    IgxTextHighlightDirective.onActiveElementChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    IgxTextHighlightDirective.highlightGroupsMap = new Map();
    IgxTextHighlightDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxTextHighlight]'
      }]
    }];
    /** @nocollapse */

    IgxTextHighlightDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }];
    };

    IgxTextHighlightDirective.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['cssClass']
      }],
      activeCssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['activeCssClass']
      }],
      containerClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['containerClass']
      }],
      groupName: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['groupName']
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['value']
      }],
      row: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['row']
      }],
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['column']
      }],
      page: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['page']
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("IgxTextHighlightDirective 'page' input property is deprecated."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Number)], IgxTextHighlightDirective.prototype, "page", void 0);
    /**
     * @hidden
     */

    var IgxTextHighlightModule = function IgxTextHighlightModule() {
      _classCallCheck(this, IgxTextHighlightModule);
    };

    IgxTextHighlightModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxTextHighlightDirective],
        exports: [IgxTextHighlightDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxTextSelectionDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       */
      function IgxTextSelectionDirective(element) {
        _classCallCheck(this, IgxTextSelectionDirective);

        this.element = element;
        this.selectionState = true;
      }
      /**
       * Returns whether the input element is selectable through the directive.
       *
       * ```typescript
       * // get
       * \@ViewChild('firstName',
       *  {read: IgxTextSelectionDirective})
       * public firstName: IgxTextSelectionDirective;
       *
       * public getFirstNameSelectionStatus() {
       *  return this.firstName.selected;
       * }
       * ```
       * @return {?}
       */


      _createClass(IgxTextSelectionDirective, [{
        key: "onFocus",

        /**
         * @hidden
         * @return {?}
         */
        value: function onFocus() {
          this.trigger();
        }
        /**
         * Triggers the selection of the element if it is marked as selectable.
         *
         * ```html
         * <input
         *   type="text"
         *   id="firstName"
         *   igxTextSelection>
         * </input>
         * ```
         *
         * ```typescript
         * \@ViewChild('firstName',
         *  {read: IgxTextSelectionDirective})
         * public inputElement: IgxTextSelectionDirective;
         *
         * public triggerElementSelection() {
         *  this.inputElement.trigger();
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "trigger",
        value: function trigger() {
          var _this82 = this;

          if (this.selected && this.nativeElement.value.length) {
            requestAnimationFrame(function () {
              return _this82.nativeElement.setSelectionRange(0, _this82.nativeElement.value.length);
            });
          }
        }
      }, {
        key: "selected",
        get: function get() {
          return this.selectionState;
        }
        /**
         *  Determines whether the input element could be selected through the directive.
         *
         * ```html
         * <!--set-->
         * <input
         *   type="text"
         *   id="firstName"
         *   [igxTextSelection]="true">
         * </input>
         *
         * <input
         *   type="text"
         *   id="lastName"
         *   igxTextSelection
         *   [selected]="true">
         * </input>
         * ```
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this.selectionState = val;
        }
        /**
         * Returns the nativeElement of the element where the directive was applied.
         *
         * ```html
         * <input
         *   type="text"
         *    id="firstName"
         *   igxTextSelection>
         * </input>
         * ```
         *
         * ```typescript
         * \@ViewChild('firstName',
         *  {read: IgxTextSelectionDirective})
         * public inputElement: IgxTextSelectionDirective;
         *
         * public getNativeElement() {
         *  return this.inputElement.nativeElement;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
      }]);

      return IgxTextSelectionDirective;
    }();

    IgxTextSelectionDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'igxTextSelection',
        selector: '[igxTextSelection]'
      }]
    }];
    /** @nocollapse */

    IgxTextSelectionDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxTextSelectionDirective.propDecorators = {
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxTextSelection']
      }],
      onFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus']
      }]
    };
    /**
     * @hidden
     */

    var IgxTextSelectionModule = function IgxTextSelectionModule() {
      _classCallCheck(this, IgxTextSelectionModule);
    };

    IgxTextSelectionModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxTextSelectionDirective],
        exports: [IgxTextSelectionDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * **Ignite UI for Angular Tooltip Target** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
     *
     * The Ignite UI for Angular Tooltip Target directive is used to mark an HTML element in the markup as one that has a tooltip.
     * The tooltip target is used in combination with the Ignite UI for Angular Tooltip by assigning the exported tooltip reference to the
     * target's selector property.
     *
     * Example:
     * ```html
     * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
     * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
     * ```
     */

    var IgxTooltipTargetDirective =
    /*#__PURE__*/
    function (_IgxToggleActionDirec) {
      _inherits(IgxTooltipTargetDirective, _IgxToggleActionDirec);

      /**
       * @param {?} _element
       * @param {?} _navigationService
       */
      function IgxTooltipTargetDirective(_element, _navigationService) {
        var _this83;

        _classCallCheck(this, IgxTooltipTargetDirective);

        _this83 = _possibleConstructorReturn(this, _getPrototypeOf(IgxTooltipTargetDirective).call(this, _element, _navigationService));
        _this83._element = _element;
        _this83._navigationService = _navigationService;
        /**
         * Gets/sets the amount of milliseconds that should pass before showing the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipShowDelay = this.tooltipTarget.showDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" showDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */

        _this83.showDelay = 500;
        /**
         * Gets/sets the amount of milliseconds that should pass before hiding the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipHideDelay = this.tooltipTarget.hideDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" hideDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */

        _this83.hideDelay = 500;
        /**
         * Specifies if the tooltip should not show when hovering its target with the mouse. (defaults to false)
         * While setting this property to 'true' will disable the user interactions that shows/hides the tooltip,
         * the developer will still be able to show/hide the tooltip through the API.
         *
         * ```typescript
         * // get
         * let tooltipDisabledValue = this.tooltipTarget.tooltipDisabled;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" [tooltipDisabled]="true">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */

        _this83.tooltipDisabled = false;
        /**
         * Emits an event when the tooltip that is associated with this target starts showing.
         * This event is fired before the start of the countdown to showing the tooltip.
         *
         * ```typescript
         * tooltipShowing(args: ITooltipShowEventArgs) {
         *    alert("Tooltip started showing!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipShow)='tooltipShowing($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */

        _this83.onTooltipShow = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the tooltip that is associated with this target starts hiding.
         * This event is fired before the start of the countdown to hiding the tooltip.
         *
         * ```typescript
         * tooltipHiding(args: ITooltipHideEventArgs) {
         *    alert("Tooltip started hiding!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipHide)='tooltipHiding($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */

        _this83.onTooltipHide = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this83;
      }
      /**
       * @hidden
       * @param {?} target
       * @return {?}
       */


      _createClass(IgxTooltipTargetDirective, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          _get(_getPrototypeOf(IgxTooltipTargetDirective.prototype), "ngOnInit", this).call(this);
          /** @type {?} */


          var positionSettings = {
            target: this.nativeElement,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            openAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(scaleInCenter, {
              params: {
                duration: '150ms'
              }
            }),
            closeAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeOut, {
              params: {
                duration: '75ms'
              }
            })
          };
          this._overlayDefaults.positionStrategy = new AutoPositionStrategy(positionSettings);
          this._overlayDefaults.closeOnOutsideClick = false;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "checkOutletAndOutsideClick",
        value: function checkOutletAndOutsideClick() {
          if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "preMouseEnterCheck",
        // Return true if the execution in onMouseEnter should be terminated after this method

        /**
         * @private
         * @return {?}
         */
        value: function preMouseEnterCheck() {
          // If tooltip is about to be opened
          if (this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
            this.target.toBeShown = false;
          } // If Tooltip is opened or about to be hidden


          if (!this.target.collapsed || this.target.toBeHidden) {
            clearTimeout(this.target.timeoutId);
            /** @type {?} */

            var hidingArgs = {
              target: this,
              tooltip: this.target,
              cancel: false
            };
            this.onTooltipHide.emit(hidingArgs);

            if (hidingArgs.cancel) {
              return true;
            } //  if close animation has started finish it, or close the tooltip with no animation


            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
          }

          return false;
        } // Return true if the execution in onMouseLeave should be terminated after this method

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "preMouseLeaveCheck",
        value: function preMouseLeaveCheck() {
          clearTimeout(this.target.timeoutId); // If tooltip is about to be opened

          if (this.target.toBeShown) {
            this.target.toBeShown = false;
            this.target.toBeHidden = false;
            return true;
          }

          return false;
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownEscape",
        value: function onKeydownEscape(event) {
          /** @type {?} */
          var hidingArgs = {
            target: this,
            tooltip: this.target,
            cancel: false
          };
          this.onTooltipHide.emit(hidingArgs);

          if (hidingArgs.cancel) {
            return;
          }

          this.target.toBeHidden = true;
          this.target.close();
          this.target.toBeHidden = false;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onClick",
        value: function onClick() {
          if (!this.target.collapsed) {
            /** @type {?} */
            var hidingArgs = {
              target: this,
              tooltip: this.target,
              cancel: false
            };
            this.onTooltipHide.emit(hidingArgs);

            if (hidingArgs.cancel) {
              return;
            }

            this.target.forceClose(this.mergedOverlaySettings);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onMouseEnter",
        value: function onMouseEnter() {
          var _this84 = this;

          if (this.tooltipDisabled) {
            return;
          }

          this.checkOutletAndOutsideClick();
          /** @type {?} */

          var shouldReturn = this.preMouseEnterCheck();

          if (shouldReturn) {
            return;
          }
          /** @type {?} */


          var showingArgs = {
            target: this,
            tooltip: this.target,
            cancel: false
          };
          this.onTooltipShow.emit(showingArgs);

          if (showingArgs.cancel) {
            return;
          }

          this.target.toBeShown = true;
          this.target.timeoutId = setTimeout(function () {
            _this84.target.open(_this84.mergedOverlaySettings); // Call open() of IgxTooltipDirective


            _this84.target.toBeShown = false;
          }, this.showDelay);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onMouseLeave",
        value: function onMouseLeave() {
          var _this85 = this;

          if (this.tooltipDisabled) {
            return;
          }

          this.checkOutletAndOutsideClick();
          /** @type {?} */

          var shouldReturn = this.preMouseLeaveCheck();

          if (shouldReturn || this.target.collapsed) {
            return;
          }
          /** @type {?} */


          var hidingArgs = {
            target: this,
            tooltip: this.target,
            cancel: false
          };
          this.onTooltipHide.emit(hidingArgs);

          if (hidingArgs.cancel) {
            return;
          }

          this.target.toBeHidden = true;
          this.target.timeoutId = setTimeout(function () {
            _this85.target.close(); // Call close() of IgxTooltipDirective


            _this85.target.toBeHidden = false;
          }, this.hideDelay);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onTouchStart",
        value: function onTouchStart(event) {
          if (this.tooltipDisabled) {
            return;
          }

          this.showTooltip();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDocumentTouchStart",
        value: function onDocumentTouchStart(event) {
          if (this.tooltipDisabled) {
            return;
          }

          if (this.nativeElement !== event.target && !this.nativeElement.contains(event.target)) {
            this.hideTooltip();
          }
        }
        /**
         * Shows the tooltip by respecting the 'showDelay' property.
         *
         * ```typescript
         * this.tooltipTarget.showTooltip();
         * ```
         * @return {?}
         */

      }, {
        key: "showTooltip",
        value: function showTooltip() {
          var _this86 = this;

          clearTimeout(this.target.timeoutId);

          if (!this.target.collapsed) {
            /** @type {?} */
            var hidingArgs = {
              target: this,
              tooltip: this.target,
              cancel: false
            };
            this.onTooltipHide.emit(hidingArgs);

            if (hidingArgs.cancel) {
              return;
            } //  if close animation has started finish it, or close the tooltip with no animation


            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
          }
          /** @type {?} */


          var showingArgs = {
            target: this,
            tooltip: this.target,
            cancel: false
          };
          this.onTooltipShow.emit(showingArgs);

          if (showingArgs.cancel) {
            return;
          }

          this.target.toBeShown = true;
          this.target.timeoutId = setTimeout(function () {
            _this86.target.open(_this86.mergedOverlaySettings); // Call open() of IgxTooltipDirective


            _this86.target.toBeShown = false;
          }, this.showDelay);
        }
        /**
         * Hides the tooltip by respecting the 'hideDelay' property.
         *
         * ```typescript
         * this.tooltipTarget.hideTooltip();
         * ```
         * @return {?}
         */

      }, {
        key: "hideTooltip",
        value: function hideTooltip() {
          var _this87 = this;

          if (this.target.collapsed && this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
          }

          if (this.target.collapsed || this.target.toBeHidden) {
            return;
          }
          /** @type {?} */


          var hidingArgs = {
            target: this,
            tooltip: this.target,
            cancel: false
          };
          this.onTooltipHide.emit(hidingArgs);

          if (hidingArgs.cancel) {
            return;
          }

          this.target.toBeHidden = true;
          this.target.timeoutId = setTimeout(function () {
            _this87.target.close(); // Call close() of IgxTooltipDirective


            _this87.target.toBeHidden = false;
          }, this.hideDelay);
        }
      }, {
        key: "target",
        set: function set(target) {
          if (target !== null && target !== '') {
            this._target = target;
          }
        }
        /**
         * @hidden
         * @return {?}
         */
        ,
        get: function get() {
          if (typeof this._target === 'string') {
            return this._navigationService.get(this._target);
          }

          return this._target;
        }
        /**
         * Gets the respective native element of the directive.
         *
         * ```typescript
         * let tooltipTargetElement = this.tooltipTarget.nativeElement;
         * ```
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this._element.nativeElement;
        }
        /**
         * Indicates if the tooltip that is is associated with this target is currently hidden.
         *
         * ```typescript
         * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;
         * ```
         * @return {?}
         */

      }, {
        key: "tooltipHidden",
        get: function get() {
          return !this.target || this.target.collapsed;
        }
      }, {
        key: "mergedOverlaySettings",
        get: function get() {
          return Object.assign({}, this._overlayDefaults, this.overlaySettings);
        }
      }]);

      return IgxTooltipTargetDirective;
    }(IgxToggleActionDirective);

    IgxTooltipTargetDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'tooltipTarget',
        selector: '[igxTooltipTarget]'
      }]
    }];
    /** @nocollapse */

    IgxTooltipTargetDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: IgxNavigationService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    IgxTooltipTargetDirective.propDecorators = {
      showDelay: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['showDelay']
      }],
      hideDelay: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['hideDelay']
      }],
      tooltipDisabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['tooltipDisabled']
      }],
      target: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxTooltipTarget']
      }],
      onTooltipShow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onTooltipHide: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onKeydownEscape: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['document:keydown.escape', ['$event']]
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click']
      }],
      onMouseEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['mouseenter']
      }],
      onMouseLeave: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['mouseleave']
      }],
      onTouchStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['touchstart', ['$event']]
      }],
      onDocumentTouchStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['document:touchstart', ['$event']]
      }]
    };
    /** @type {?} */

    var NEXT_ID$6 = 0;
    /**
     * **Ignite UI for Angular Tooltip** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
     *
     * The Ignite UI for Angular Tooltip directive is used to mark an HTML element in the markup as one that should behave as a tooltip.
     * The tooltip is used in combination with the Ignite UI for Angular Tooltip Target by assigning the exported tooltip reference to the
     * respective target's selector property.
     *
     * Example:
     * ```html
     * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
     * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
     * ```
     */

    var IgxTooltipDirective =
    /*#__PURE__*/
    function (_IgxToggleDirective) {
      _inherits(IgxTooltipDirective, _IgxToggleDirective);

      /**
       * @hidden
       * @param {?} elementRef
       * @param {?} cdr
       * @param {?} overlayService
       * @param {?} navigationService
       */
      function IgxTooltipDirective(elementRef, cdr, overlayService, navigationService) {
        var _this88;

        _classCallCheck(this, IgxTooltipDirective);

        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        _this88 = _possibleConstructorReturn(this, _getPrototypeOf(IgxTooltipDirective).call(this, elementRef, cdr, overlayService, navigationService));
        /**
         * @hidden
         * Returns whether close time out has started
         */

        _this88.toBeHidden = false;
        /**
         * @hidden
         * Returns whether open time out has started
         */

        _this88.toBeShown = false;
        /**
         * Identifier for the tooltip.
         * If this is property is not explicitly set, it will be automatically generated.
         *
         * ```typescript
         * let tooltipId = this.tooltip.id;
         * ```
         */

        _this88.id = "igx-tooltip-".concat(NEXT_ID$6++);
        return _this88;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxTooltipDirective, [{
        key: "forceOpen",

        /**
         * If there is open animation in progress this method will finish is.
         * If there is no open animation in progress this method will open the toggle with no animation.
         * @protected
         * @param {?=} overlaySettings setting to use for opening the toggle
         * @return {?}
         */
        value: function forceOpen(overlaySettings) {
          /** @type {?} */
          var info = this.overlayService.getOverlayById(this._overlayId);
          /** @type {?} */

          var hasOpenAnimation = info ? info.openAnimationPlayer : false;

          if (hasOpenAnimation) {
            info.openAnimationPlayer.finish();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
          } else if (this.collapsed) {
            /** @type {?} */
            var animation = overlaySettings.positionStrategy.settings.openAnimation;
            overlaySettings.positionStrategy.settings.openAnimation = null;
            this.open(overlaySettings);
            overlaySettings.positionStrategy.settings.openAnimation = animation;
          }
        }
        /**
         * If there is close animation in progress this method will finish is.
         * If there is no close animation in progress this method will close the toggle with no animation.
         * @protected
         * @param {?=} overlaySettings settings to use for closing the toggle
         * @return {?}
         */

      }, {
        key: "forceClose",
        value: function forceClose(overlaySettings) {
          /** @type {?} */
          var info = this.overlayService.getOverlayById(this._overlayId);
          /** @type {?} */

          var hasCloseAnimation = info ? info.closeAnimationPlayer : false;

          if (hasCloseAnimation) {
            info.closeAnimationPlayer.finish();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
          } else if (!this.collapsed) {
            /** @type {?} */
            var animation = overlaySettings.positionStrategy.settings.closeAnimation;
            overlaySettings.positionStrategy.settings.closeAnimation = null;
            this.close();
            overlaySettings.positionStrategy.settings.closeAnimation = animation;
          }
        }
      }, {
        key: "hiddenClass",
        get: function get() {
          return this.collapsed;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "defaultClass",
        get: function get() {
          return !this.collapsed;
        }
        /**
         * Get the role attribute of the tooltip.
         *
         * ```typescript
         * let tooltipRole = this.tooltip.role;
         * ```
         * @return {?}
         */

      }, {
        key: "role",
        get: function get() {
          return 'tooltip';
        }
      }]);

      return IgxTooltipDirective;
    }(IgxToggleDirective);

    IgxTooltipDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        exportAs: 'tooltip',
        selector: '[igxTooltip]'
      }]
    }];
    /** @nocollapse */

    IgxTooltipDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxOverlayService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxOverlayService]
        }]
      }, {
        type: IgxNavigationService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    IgxTooltipDirective.propDecorators = {
      hiddenClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tooltip--hidden']
      }],
      defaultClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tooltip--desktop']
      }],
      context: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['context']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }]
    };
    /**
     * @hidden
     */

    var IgxTooltipModule = function IgxTooltipModule() {
      _classCallCheck(this, IgxTooltipModule);
    };

    IgxTooltipModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxTooltipDirective, IgxTooltipTargetDirective],
        exports: [IgxTooltipDirective, IgxTooltipTargetDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]],
        providers: [IgxOverlayService]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Provides base filtering operations
     * Implementations should be Singleton
     *
     * @export
     */

    var IgxFilteringOperand =
    /*#__PURE__*/
    function () {
      function IgxFilteringOperand() {
        var _this89 = this;

        _classCallCheck(this, IgxFilteringOperand);

        this.operations = [{
          name: 'null',
          isUnary: true,
          iconName: 'is_null',
          logic: function logic(target) {
            return target === null;
          }
        }, {
          name: 'notNull',
          isUnary: true,
          iconName: 'is_not_null',
          logic: function logic(target) {
            return target !== null;
          }
        }, {
          name: 'in',
          isUnary: false,
          iconName: 'is_in',
          hidden: true,
          logic: function logic(target, searchVal) {
            return _this89.findValueInSet(target, searchVal);
          }
        }];
      }
      /**
       * @return {?}
       */


      _createClass(IgxFilteringOperand, [{
        key: "findValueInSet",

        /**
         * @hidden
         * @protected
         * @param {?} target
         * @param {?} searchVal
         * @return {?}
         */
        value: function findValueInSet(target, searchVal) {
          return searchVal.has(target);
        }
        /**
         * Returns an array of names of the conditions which are visible in the UI
         * @return {?}
         */

      }, {
        key: "conditionList",
        value: function conditionList() {
          return this.operations.filter(function (f) {
            return !f.hidden;
          }).map(function (element) {
            return element.name;
          });
        }
        /**
         * Returns an instance of the condition with the specified name.
         * @param {?} name The name of the condition.
         * @return {?}
         */

      }, {
        key: "condition",
        value: function condition(name) {
          return this.operations.find(function (element) {
            return element.name === name;
          });
        }
        /**
         * Adds a new condition to the filtering operations.
         * @param {?} operation The filtering operation.
         * @return {?}
         */

      }, {
        key: "append",
        value: function append(operation) {
          this.operations.push(operation);
        }
      }], [{
        key: "instance",
        value: function instance() {
          return this._instance || (this._instance = new this());
        }
      }]);

      return IgxFilteringOperand;
    }();

    IgxFilteringOperand._instance = null;
    /**
     * Provides filtering operations for booleans
     *
     * @export
     */

    var IgxBooleanFilteringOperand =
    /*#__PURE__*/
    function (_IgxFilteringOperand) {
      _inherits(IgxBooleanFilteringOperand, _IgxFilteringOperand);

      /**
       * @protected
       */
      function IgxBooleanFilteringOperand() {
        var _this90;

        _classCallCheck(this, IgxBooleanFilteringOperand);

        _this90 = _possibleConstructorReturn(this, _getPrototypeOf(IgxBooleanFilteringOperand).call(this));
        _this90.operations = [{
          name: 'all',
          isUnary: true,
          iconName: 'all',
          logic: function logic(target) {
            return true;
          }
        }, {
          name: 'true',
          isUnary: true,
          iconName: 'is_true',
          logic: function logic(target) {
            return !!(target && target !== null && target !== undefined);
          }
        }, {
          name: 'false',
          isUnary: true,
          iconName: 'is_false',
          logic: function logic(target) {
            return !target && target !== null && target !== undefined;
          }
        }, {
          name: 'empty',
          isUnary: true,
          iconName: 'empty',
          logic: function logic(target) {
            return target === null || target === undefined;
          }
        }, {
          name: 'notEmpty',
          isUnary: true,
          iconName: 'not_empty',
          logic: function logic(target) {
            return target !== null && target !== undefined;
          }
        }].concat(_this90.operations);
        return _this90;
      }

      return IgxBooleanFilteringOperand;
    }(IgxFilteringOperand);
    /**
     * Provides filtering operations for Dates
     *
     * @export
     */


    var IgxDateFilteringOperand =
    /*#__PURE__*/
    function (_IgxFilteringOperand2) {
      _inherits(IgxDateFilteringOperand, _IgxFilteringOperand2);

      /**
       * @protected
       */
      function IgxDateFilteringOperand() {
        var _this91;

        _classCallCheck(this, IgxDateFilteringOperand);

        _this91 = _possibleConstructorReturn(this, _getPrototypeOf(IgxDateFilteringOperand).call(this));
        _this91.operations = [{
          name: 'equals',
          isUnary: false,
          iconName: 'equals',
          logic: function logic(target, searchVal) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
            /** @type {?} */

            var searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
            return targetp.year === searchp.year && targetp.month === searchp.month && targetp.day === searchp.day;
          }
        }, {
          name: 'doesNotEqual',
          isUnary: false,
          iconName: 'not_equal',
          logic: function logic(target, searchVal) {
            if (!target) {
              return true;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
            /** @type {?} */

            var searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
            return targetp.year !== searchp.year || targetp.month !== searchp.month || targetp.day !== searchp.day;
          }
        }, {
          name: 'before',
          isUnary: false,
          iconName: 'is_before',
          logic: function logic(target, searchVal) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);

            return target < searchVal;
          }
        }, {
          name: 'after',
          isUnary: false,
          iconName: 'is_after',
          logic: function logic(target, searchVal) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);

            return target > searchVal;
          }
        }, {
          name: 'today',
          isUnary: true,
          iconName: 'today',
          logic: function logic(target) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var d = IgxDateFilteringOperand.getDateParts(target, 'yMd');
            /** @type {?} */

            var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yMd');
            return d.year === now.year && d.month === now.month && d.day === now.day;
          }
        }, {
          name: 'yesterday',
          isUnary: true,
          iconName: 'yesterday',
          logic: function logic(target) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var td = IgxDateFilteringOperand.getDateParts(target, 'yMd');
            /** @type {?} */

            var y = function (d) {
              return new Date(d.setDate(d.getDate() - 1));
            }(new Date());
            /** @type {?} */


            var yesterday = IgxDateFilteringOperand.getDateParts(y, 'yMd');
            return td.year === yesterday.year && td.month === yesterday.month && td.day === yesterday.day;
          }
        }, {
          name: 'thisMonth',
          isUnary: true,
          iconName: 'this_month',
          logic: function logic(target) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
            /** @type {?} */

            var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
            return d.year === now.year && d.month === now.month;
          }
        }, {
          name: 'lastMonth',
          isUnary: true,
          iconName: 'last_month',
          logic: function logic(target) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
            /** @type {?} */

            var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');

            if (!now.month) {
              now.month = 11;
              now.year -= 1;
            } else {
              now.month--;
            }

            return d.year === now.year && d.month === now.month;
          }
        }, {
          name: 'nextMonth',
          isUnary: true,
          iconName: 'next_month',
          logic: function logic(target) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
            /** @type {?} */

            var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');

            if (now.month === 11) {
              now.month = 0;
              now.year += 1;
            } else {
              now.month++;
            }

            return d.year === now.year && d.month === now.month;
          }
        }, {
          name: 'thisYear',
          isUnary: true,
          iconName: 'this_year',
          logic: function logic(target) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var d = IgxDateFilteringOperand.getDateParts(target, 'y');
            /** @type {?} */

            var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
            return d.year === now.year;
          }
        }, {
          name: 'lastYear',
          isUnary: true,
          iconName: 'last_year',
          logic: function logic(target) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var d = IgxDateFilteringOperand.getDateParts(target, 'y');
            /** @type {?} */

            var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
            return d.year === now.year - 1;
          }
        }, {
          name: 'nextYear',
          isUnary: true,
          iconName: 'next_year',
          logic: function logic(target) {
            if (!target) {
              return false;
            }

            _this91.validateInputData(target);
            /** @type {?} */


            var d = IgxDateFilteringOperand.getDateParts(target, 'y');
            /** @type {?} */

            var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
            return d.year === now.year + 1;
          }
        }, {
          name: 'empty',
          isUnary: true,
          iconName: 'empty',
          logic: function logic(target) {
            return target === null || target === undefined;
          }
        }, {
          name: 'notEmpty',
          isUnary: true,
          iconName: 'not_empty',
          logic: function logic(target) {
            return target !== null && target !== undefined;
          }
        }].concat(_this91.operations);
        return _this91;
      }
      /**
       * Splits a Date object into parts
       *
       * \@memberof IgxDateFilteringOperand
       * @param {?} date
       * @param {?=} dateFormat
       * @return {?}
       */


      _createClass(IgxDateFilteringOperand, [{
        key: "validateInputData",

        /**
         * @private
         * @param {?} target
         * @return {?}
         */
        value: function validateInputData(target) {
          if (!(target instanceof Date)) {
            throw new Error('Could not perform filtering on \'date\' column because the datasource object type is not \'Date\'.');
          }
        }
        /**
         * @protected
         * @param {?} target
         * @param {?} searchVal
         * @return {?}
         */

      }, {
        key: "findValueInSet",
        value: function findValueInSet(target, searchVal) {
          if (!target) {
            return false;
          }

          return searchVal.has(new Date(target.getFullYear(), target.getMonth(), target.getDate()).toISOString());
        }
      }], [{
        key: "getDateParts",
        value: function getDateParts(date, dateFormat) {
          /** @type {?} */
          var res = {
            day: null,
            hours: null,
            milliseconds: null,
            minutes: null,
            month: null,
            seconds: null,
            year: null
          };

          if (!date || !dateFormat) {
            return res;
          }

          if (dateFormat.indexOf('y') >= 0) {
            res.year = date.getFullYear();
          }

          if (dateFormat.indexOf('M') >= 0) {
            res.month = date.getMonth();
          }

          if (dateFormat.indexOf('d') >= 0) {
            res.day = date.getDate();
          }

          if (dateFormat.indexOf('h') >= 0) {
            res.hours = date.getHours();
          }

          if (dateFormat.indexOf('m') >= 0) {
            res.minutes = date.getMinutes();
          }

          if (dateFormat.indexOf('s') >= 0) {
            res.seconds = date.getSeconds();
          }

          if (dateFormat.indexOf('f') >= 0) {
            res.milliseconds = date.getMilliseconds();
          }

          return res;
        }
      }]);

      return IgxDateFilteringOperand;
    }(IgxFilteringOperand);
    /**
     * Provides filtering operations for numbers
     *
     * @export
     */


    var IgxNumberFilteringOperand =
    /*#__PURE__*/
    function (_IgxFilteringOperand3) {
      _inherits(IgxNumberFilteringOperand, _IgxFilteringOperand3);

      /**
       * @protected
       */
      function IgxNumberFilteringOperand() {
        var _this92;

        _classCallCheck(this, IgxNumberFilteringOperand);

        _this92 = _possibleConstructorReturn(this, _getPrototypeOf(IgxNumberFilteringOperand).call(this));
        _this92.operations = [{
          name: 'equals',
          isUnary: false,
          iconName: 'equals',
          logic: function logic(target, searchVal) {
            return target === searchVal;
          }
        }, {
          name: 'doesNotEqual',
          isUnary: false,
          iconName: 'not_equal',
          logic: function logic(target, searchVal) {
            return target !== searchVal;
          }
        }, {
          name: 'greaterThan',
          isUnary: false,
          iconName: 'greater_than',
          logic: function logic(target, searchVal) {
            return target > searchVal;
          }
        }, {
          name: 'lessThan',
          isUnary: false,
          iconName: 'less_than',
          logic: function logic(target, searchVal) {
            return target < searchVal;
          }
        }, {
          name: 'greaterThanOrEqualTo',
          isUnary: false,
          iconName: 'greater_than_or_equal',
          logic: function logic(target, searchVal) {
            return target >= searchVal;
          }
        }, {
          name: 'lessThanOrEqualTo',
          isUnary: false,
          iconName: 'less_than_or_equal',
          logic: function logic(target, searchVal) {
            return target <= searchVal;
          }
        }, {
          name: 'empty',
          isUnary: true,
          iconName: 'empty',
          logic: function logic(target) {
            return target === null || target === undefined || isNaN(target);
          }
        }, {
          name: 'notEmpty',
          isUnary: true,
          iconName: 'not_empty',
          logic: function logic(target) {
            return target !== null && target !== undefined && !isNaN(target);
          }
        }].concat(_this92.operations);
        return _this92;
      }

      return IgxNumberFilteringOperand;
    }(IgxFilteringOperand);
    /**
     * Provides filtering operations for strings
     *
     * @export
     */


    var IgxStringFilteringOperand =
    /*#__PURE__*/
    function (_IgxFilteringOperand4) {
      _inherits(IgxStringFilteringOperand, _IgxFilteringOperand4);

      /**
       * @protected
       */
      function IgxStringFilteringOperand() {
        var _this93;

        _classCallCheck(this, IgxStringFilteringOperand);

        _this93 = _possibleConstructorReturn(this, _getPrototypeOf(IgxStringFilteringOperand).call(this));
        _this93.operations = [{
          name: 'contains',
          isUnary: false,
          iconName: 'contains',
          logic: function logic(target, searchVal, ignoreCase) {
            /** @type {?} */
            var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
            target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
            return target.indexOf(search) !== -1;
          }
        }, {
          name: 'doesNotContain',
          isUnary: false,
          iconName: 'does_not_contain',
          logic: function logic(target, searchVal, ignoreCase) {
            /** @type {?} */
            var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
            target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
            return target.indexOf(search) === -1;
          }
        }, {
          name: 'startsWith',
          isUnary: false,
          iconName: 'starts_with',
          logic: function logic(target, searchVal, ignoreCase) {
            /** @type {?} */
            var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
            target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
            return target.startsWith(search);
          }
        }, {
          name: 'endsWith',
          isUnary: false,
          iconName: 'ends_with',
          logic: function logic(target, searchVal, ignoreCase) {
            /** @type {?} */
            var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
            target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
            return target.endsWith(search);
          }
        }, {
          name: 'equals',
          isUnary: false,
          iconName: 'equals',
          logic: function logic(target, searchVal, ignoreCase) {
            /** @type {?} */
            var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
            target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
            return target === search;
          }
        }, {
          name: 'doesNotEqual',
          isUnary: false,
          iconName: 'not_equal',
          logic: function logic(target, searchVal, ignoreCase) {
            /** @type {?} */
            var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
            target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
            return target !== search;
          }
        }, {
          name: 'empty',
          isUnary: true,
          iconName: 'empty',
          logic: function logic(target) {
            return target === null || target === undefined || target.length === 0;
          }
        }, {
          name: 'notEmpty',
          isUnary: true,
          iconName: 'not_empty',
          logic: function logic(target) {
            return target !== null && target !== undefined && target.length > 0;
          }
        }].concat(_this93.operations);
        return _this93;
      }
      /**
       * Applies case sensitivity on strings if provided
       *
       * \@memberof IgxStringFilteringOperand
       * @param {?} a
       * @param {?} ignoreCase
       * @return {?}
       */


      _createClass(IgxStringFilteringOperand, null, [{
        key: "applyIgnoreCase",
        value: function applyIgnoreCase(a, ignoreCase) {
          a = a || ''; // bulletproof

          return ignoreCase ? ('' + a).toLowerCase() : a;
        }
      }]);

      return IgxStringFilteringOperand;
    }(IgxFilteringOperand);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var filteringStateDefaults = {
      strategy: new FilteringStrategy()
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var GroupedRecords =
    /*#__PURE__*/
    function (_Array) {
      _inherits(GroupedRecords, _Array);

      function GroupedRecords() {
        _classCallCheck(this, GroupedRecords);

        return _possibleConstructorReturn(this, _getPrototypeOf(GroupedRecords).apply(this, arguments));
      }

      return GroupedRecords;
    }(_wrapNativeSuper(Array));
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * **Ignite UI for Angular Icon Service** -
     *
     * The Ignite UI Icon Service makes it easy for developers to include custom SVG images and use them with IgxIconComponent.
     * In addition it could be used to associate a custom class to be applied on IgxIconComponent according to given fontSet.
     *
     * Example:
     * ```typescript
     * this.iconService.registerFontSetAlias('material', 'material-icons');
     * this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     */


    var IgxIconService =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _sanitizer
       * @param {?} _document
       */
      function IgxIconService(_sanitizer, _document) {
        _classCallCheck(this, IgxIconService);

        this._sanitizer = _sanitizer;
        this._document = _document;
        this._fontSet = 'material-icons';
        this._fontSetAliases = new Map();
        this._cachedSvgIcons = new Set();
      }
      /**
       *  Returns the default font set.
       * ```typescript
       *   const defaultFontSet = this.iconService.defaultFontSet;
       * ```
       * @return {?}
       */


      _createClass(IgxIconService, [{
        key: "registerFontSetAlias",

        /**
         *  Registers a custom class to be applied to IgxIconComponent for a given fontSet.
         * ```typescript
         *   this.iconService.registerFontSetAlias('material', 'material-icons');
         * ```
         * @template THIS
         * @this {THIS}
         * @param {?} alias
         * @param {?=} className
         * @return {THIS}
         */
        value: function registerFontSetAlias(alias) {
          var className = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : alias;

          /** @type {?} */
          this._fontSetAliases.set(alias, className);

          return (
            /** @type {?} */
            this
          );
        }
        /**
         *  Returns the custom class, if any, associated to a given fontSet.
         * ```typescript
         *   const fontSetClass = this.iconService.fontSetClassName('material');
         * ```
         * @param {?} alias
         * @return {?}
         */

      }, {
        key: "fontSetClassName",
        value: function fontSetClassName(alias) {
          return this._fontSetAliases.get(alias) || alias;
        }
        /**
         *  Adds an SVG image to the cache. SVG source is an url.
         * ```typescript
         *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
         * ```
         * @param {?} iconName
         * @param {?} url
         * @param {?=} fontSet
         * @return {?}
         */

      }, {
        key: "addSvgIcon",
        value: function addSvgIcon(iconName, url) {
          var fontSet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

          if (iconName && url) {
            /** @type {?} */
            var safeUrl = this._sanitizer.bypassSecurityTrustResourceUrl(url);

            if (!safeUrl) {
              throw new Error("The provided URL could not be processed as trusted resource URL by Angular's DomSanitizer: \"".concat(url, "\"."));
            }
            /** @type {?} */


            var sanitizedUrl = this._sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_1__["SecurityContext"].RESOURCE_URL, safeUrl);

            if (!sanitizedUrl) {
              throw new Error("The URL provided was not trusted as a resource URL: \"".concat(url, "\"."));
            }

            this.fetchSvg(iconName, url, fontSet);
          } else {
            throw new Error('You should provide at least `iconName` and `url` to register an svg icon.');
          }
        }
        /**
         *  Adds an SVG image to the cache. SVG source is its text.
         * ```typescript
         *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
         *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
         * ```
         * @param {?} iconName
         * @param {?} iconText
         * @param {?=} fontSet
         * @return {?}
         */

      }, {
        key: "addSvgIconFromText",
        value: function addSvgIconFromText(iconName, iconText) {
          var fontSet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

          if (iconName && iconText) {
            this.cacheSvgIcon(iconName, iconText, fontSet);
          } else {
            throw new Error('You should provide at least `iconName` and `iconText` to register an svg icon.');
          }
        }
        /**
         *  Returns whether a given SVG image is present in the cache.
         * ```typescript
         *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
         * ```
         * @param {?} iconName
         * @param {?=} fontSet
         * @return {?}
         */

      }, {
        key: "isSvgIconCached",
        value: function isSvgIconCached(iconName) {
          var fontSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

          /** @type {?} */
          var iconKey = this.getSvgIconKey(iconName, fontSet);
          return this._cachedSvgIcons.has(iconKey);
        }
        /**
         *  Returns the key of a cached SVG image.
         * ```typescript
         *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
         * ```
         * @param {?} iconName
         * @param {?=} fontSet
         * @return {?}
         */

      }, {
        key: "getSvgIconKey",
        value: function getSvgIconKey(iconName) {
          var fontSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          return fontSet + '_' + iconName;
        }
        /**
         * @hidden
         * @private
         * @param {?} iconName
         * @param {?} url
         * @param {?=} fontSet
         * @return {?}
         */

      }, {
        key: "fetchSvg",
        value: function fetchSvg(iconName, url) {
          var fontSet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

          /** @type {?} */
          var instance = this;
          /** @type {?} */

          var httpRequest = new XMLHttpRequest();
          httpRequest.open('GET', url, true);
          httpRequest.responseType = 'text'; // load – when the result is ready, that includes HTTP errors like 404.

          httpRequest.onload = function (event) {
            if (event) {
              /** @type {?} */
              var request =
              /** @type {?} */
              event.target;

              if (request.status === 200) {
                instance.cacheSvgIcon(iconName, request.responseText, fontSet);
              } else {
                throw new Error("Could not fetch SVG from url: ".concat(url, "; error: ").concat(request.status, " (").concat(request.statusText, ")"));
              }
            } else {
              throw new Error("Could not fetch SVG from url: ".concat(url, ";"));
            }
          }; // error – when the request couldn’t be made, e.g.network down or invalid URL.


          httpRequest.onerror = function (event) {
            if (event) {
              /** @type {?} */
              var request =
              /** @type {?} */
              event.target;
              throw new Error("Could not fetch SVG from url: ".concat(url, "; error status code: ").concat(request.status, " (").concat(request.statusText, ")"));
            }

            throw new Error("Could not fetch SVG from url: ".concat(url, ";"));
          };

          httpRequest.send();
        }
        /**
         * @hidden
         * @private
         * @param {?} iconName
         * @param {?} value
         * @param {?=} fontSet
         * @return {?}
         */

      }, {
        key: "cacheSvgIcon",
        value: function cacheSvgIcon(iconName, value) {
          var fontSet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

          if (iconName && value) {
            this.ensureSvgContainerCreated();
            /** @type {?} */

            var div = this._document.createElement('DIV');

            div.innerHTML = value;
            /** @type {?} */

            var svg =
            /** @type {?} */
            div.querySelector('svg');

            if (svg) {
              /** @type {?} */
              var iconKey = this.getSvgIconKey(iconName, fontSet);
              svg.setAttribute('id', iconKey);
              svg.setAttribute('fit', '');
              svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
              svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.

              if (this._cachedSvgIcons.has(iconKey)) {
                /** @type {?} */
                var oldChild = this._svgContainer.querySelector("svg[id='".concat(iconKey, "']"));

                this._svgContainer.removeChild(oldChild);
              }

              this._svgContainer.appendChild(svg);

              this._cachedSvgIcons.add(iconKey);
            }
          }
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "ensureSvgContainerCreated",
        value: function ensureSvgContainerCreated() {
          if (!this._svgContainer) {
            this._svgContainer = this._document.documentElement.querySelector('.igx-svg-container');

            if (!this._svgContainer) {
              this._svgContainer = this._document.createElement('DIV');

              this._svgContainer.classList.add('igx-svg-container');

              this._document.documentElement.appendChild(this._svgContainer);
            }
          }
        }
      }, {
        key: "defaultFontSet",
        get: function get() {
          return this._fontSet;
        }
        /**
         *  Sets the default font set.
         * ```typescript
         *   this.iconService.defaultFontSet = 'svg-flags';
         * ```
         * @param {?} className
         * @return {?}
         */
        ,
        set: function set(className) {
          this._fontSet = className;
        }
      }]);

      return IgxIconService;
    }();

    IgxIconService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    IgxIconService.ctorParameters = function () {
      return [{
        type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["DomSanitizer"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
        }]
      }];
    };
    /** @nocollapse */


    IgxIconService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function IgxIconService_Factory() {
        return new IgxIconService(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["DomSanitizer"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]));
      },
      token: IgxIconService,
      providedIn: "root"
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * **Ignite UI for Angular Icon** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/icon.html)
     *
     * The Ignite UI Icon makes it easy for developers to include material design icons directly in their markup. The icons
     * support custom colors and can be marked as active or disabled using the `isActive` property. This will change the appearance
     * of the icon.
     *
     * Example:
     * ```html
     * <igx-icon color="#00ff00" isActive="true">home</igx-icon>
     * ```
     * @type {?}
     */

    var NEXT_ID$7 = 0;

    var IgxIconComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _el
       * @param {?} iconService
       */
      function IgxIconComponent(_el, iconService) {
        _classCallCheck(this, IgxIconComponent);

        this._el = _el;
        this.iconService = iconService;
        /**
         *  This allows you to change the value of `class.igx-icon`. By default it's `igx-icon`.
         * ```typescript
         * \@ViewChild("MyIcon") public icon: IgxIconComponent;
         * constructor(private cdRef:ChangeDetectorRef) {}
         * ngAfterViewInit() {
         *    this.icon.cssClass = "";
         *    this.cdRef.detectChanges();
         * }
         * ```
         */

        this.cssClass = 'igx-icon';
        /**
         *  This allows you to disable the `aria-hidden` attribute. By default it's applied.
         * ```typescript
         * \@ViewChild("MyIcon") public icon: IgxIconComponent;
         * constructor(private cdRef:ChangeDetectorRef) {}
         * ngAfterViewInit() {
         *    this.icon.ariaHidden = false;
         *    this.cdRef.detectChanges();
         * }
         * ```
         */

        this.ariaHidden = true;
        /**
         *  An \@Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-icon id="igx-icon-1" fontSet="material" color="blue" [isActive]="false">settings</igx-icon>
         * ```
         */

        this.id = "igx-icon-".concat(NEXT_ID$7++);
        /**
         *  An \@Input property that allows you to disable the `active` property. By default it's applied.
         * ```html
         * <igx-icon [isActive]="false" fontSet="material" color="blue">settings</igx-icon>
         * ```
         */

        this.active = true;
        this.el = _el;
        this.font = this.iconService.defaultFontSet;
        this.iconService.registerFontSetAlias('material', 'material-icons');
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxIconComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          this.updateIconClass();
        }
        /**
         *  An accessor that returns the value of the font property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconFont = this.icon.getFontSet;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "updateIconClass",

        /**
         * @hidden
         * @private
         * @return {?}
         */
        value: function updateIconClass() {
          /** @type {?} */
          var className = this.iconService.fontSetClassName(this.font);
          this.el.nativeElement.classList.add(className);

          if (this.iconName && !this.iconService.isSvgIconCached(this.iconName, this.font)) {
            this.el.nativeElement.classList.add(this.iconName);
          }
        }
      }, {
        key: "getFontSet",
        get: function get() {
          return this.font;
        }
        /**
         *  An accessor that returns the value of the active property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconActive = this.icon.getActive;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "getActive",
        get: function get() {
          return this.active;
        }
        /**
         *  An accessor that returns inactive property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconActive = this.icon.getInactive;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "getInactive",
        get: function get() {
          return !this.active;
        }
        /**
         *  An accessor that returns the opposite value of the `iconColor` property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconColor = this.icon.getIconColor;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "getIconColor",
        get: function get() {
          return this.iconColor;
        }
        /**
         *  An accessor that returns the value of the iconName property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconName = this.icon.getIconName;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "getIconName",
        get: function get() {
          return this.iconName;
        }
        /**
         *  An accessor that returns the key of the SVG image.
         *  The key consists of the fontSet and the iconName separated by underscore.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let svgKey = this.icon.getSvgKey;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "getSvgKey",
        get: function get() {
          if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
            return '#' + this.iconService.getSvgIconKey(this.iconName, this.font);
          }

          return null;
        }
        /**
         *   An accessor that returns a TemplateRef to explicit, svg or no ligature.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconTemplate = this.icon.template;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "template",
        get: function get() {
          if (this.iconName) {
            if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
              return this.svgImage;
            }

            return this.noLigature;
          }

          return this.explicitLigature;
        }
      }]);

      return IgxIconComponent;
    }();

    IgxIconComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-icon',
        template: "<ng-template #noLigature></ng-template>\n\n<ng-template #explicitLigature>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #svgImage>\n    <svg>\n        <use [attr.href]=\"getSvgKey\"></use>\n    </svg>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
      }]
    }];
    /** @nocollapse */

    IgxIconComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: IgxIconService
      }];
    };

    IgxIconComponent.propDecorators = {
      noLigature: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['noLigature', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      explicitLigature: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['explicitLigature', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      svgImage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['svgImage', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-icon']
      }],
      ariaHidden: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-hidden']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      font: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['fontSet']
      }],
      active: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['isActive']
      }],
      iconColor: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['color']
      }],
      iconName: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['name']
      }],
      getInactive: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-icon--inactive']
      }],
      getIconColor: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.color']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxIconModule =
    /*#__PURE__*/
    function () {
      function IgxIconModule() {
        _classCallCheck(this, IgxIconModule);
      }

      _createClass(IgxIconModule, null, [{
        key: "forRoot",

        /**
         * @return {?}
         */
        value: function forRoot() {
          return {
            ngModule: IgxIconModule
          };
        }
      }]);

      return IgxIconModule;
    }();

    IgxIconModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxIconComponent],
        exports: [IgxIconComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateMethod('IgxIconModule.forRoot method is deprecated. Use IgxIconModule instead.'), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", []), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:returntype", void 0)], IgxIconModule, "forRoot", null);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$8 = 0;
    /** @enum {string} */

    var Size = {
      SMALL: 'small',
      MEDIUM: 'medium',
      LARGE: 'large'
    };
    /** @enum {string} */

    var AvatarType = {
      DEFAULT: 'default',
      INITIALS: 'initials',
      IMAGE: 'image',
      ICON: 'icon'
    };
    /**
     * **Ignite UI for Angular Avatar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/avatar.html)
     *
     * The Ignite UI Avatar provides an easy way to add an avatar icon to your application.  This icon can be an
     * image, someone's initials or a material icon from the google material icon set.
     *
     * Example:
     * ```html
     * <igx-avatar initials="MS" roundShape="true" size="large">
     * </igx-avatar>
     * ```
     */

    var IgxAvatarComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       */
      function IgxAvatarComponent(elementRef) {
        _classCallCheck(this, IgxAvatarComponent);

        this.elementRef = elementRef;
        /**
         * Returns the `aria-label` of the avatar.
         *
         * ```typescript
         * let ariaLabel = this.avatar.ariaLabel;
         * ```
         *
         */

        this.ariaLabel = 'avatar';
        /**
         * Returns the `role` attribute of the avatar.
         *
         * ```typescript
         * let avatarRole = this.avatar.role;
         * ```
         *
         * \@memberof IgxAvatarComponent
         */

        this.role = 'img';
        /**
         * Returns the class of the avatar.
         *
         * ```typescript
         * let avatarCLass =  this.avatar.cssClass;
         * ```
         *
         * \@memberof IgxAvatarComponent
         */

        this.cssClass = 'igx-avatar';
        /**
         * @hidden
         */

        this._size = 'small';
        /**
         * Sets the `id` of the avatar. If not set, the first avatar component will have `id` = `"igx-avatar-0"`.
         *
         * ```html
         * <igx-avatar id="my-first-avatar"></igx-avatar>
         * ```
         *
         * \@memberof IgxAvatarComponent
         */

        this.id = "igx-avatar-".concat(NEXT_ID$8++);
        /**
         * Sets a round shape to the avatar if `roundShape` is `"true"`.
         * By default the shape of the avatar is a square.
         *
         * ```html
         * <igx-avatar roundShape = "true" ></igx-avatar>
         * ```
         *
         * \@memberof IgxAvatarComponent
         */

        this.roundShape = false;
      }
      /**
       * Returns the `size` of the avatar.
       *
       * ```typescript
       * let avatarSize =  this.avatar.size;
       * ```
       *
       * \@memberof IgxAvatarComponent
       * @return {?}
       */


      _createClass(IgxAvatarComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this.roleDescription = this.getRole();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.elementRef.nativeElement.classList.add("igx-avatar--".concat(this._size), "igx-avatar--".concat(this.type));
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "getRole",
        value: function getRole() {
          switch (this.type) {
            case AvatarType.IMAGE:
              return 'image avatar';

            case AvatarType.ICON:
              return 'icon avatar';

            case AvatarType.INITIALS:
              return 'initials avatar';

            default:
              return 'custom avatar';
          }
        }
        /**
         * Returns the url of the `image`.
         *
         * ```typescript
         * let imageSourceUrl = this.avatar.getSrcUrl();
         * ```
         *
         * \@memberof IgxAvatarComponent
         * @return {?}
         */

      }, {
        key: "getSrcUrl",
        value: function getSrcUrl() {
          return "url(".concat(this.src, ")");
        }
      }, {
        key: "size",
        get: function get() {
          return this._size;
        }
        /**
         * Sets the `size`  of the avatar.
         * By default the `size` is `"small"`. It can be set to `"medium"` or `"large"`.
         *
         * ```
         * <igx-avatar size="large"></igx-avatar>
         * ```
         *
         * \@memberof IgxAvatarComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          switch (value) {
            case 'small':
            case 'medium':
            case 'large':
              this._size = value;
              break;

            default:
              this._size = 'small';
          }
        }
        /**
         * Returns the type of the avatar.
         *
         * ```typescript
         * let avatarType = this.avatar.type;
         * ```
         *
         * \@memberof IgxAvatarComponent
         * @return {?}
         */

      }, {
        key: "type",
        get: function get() {
          if (this.src) {
            return AvatarType.IMAGE;
          }

          if (this.icon) {
            return AvatarType.ICON;
          }

          if (this.initials) {
            return AvatarType.INITIALS;
          }

          return AvatarType.DEFAULT;
        }
        /**
         * Returns the template of the avatar.
         *
         * ```typescript
         * let template = this.avatar.template;
         * ```
         *
         * \@memberof IgxAvatarComponent
         * @return {?}
         */

      }, {
        key: "template",
        get: function get() {
          switch (this.type) {
            case AvatarType.IMAGE:
              return this.imageTemplate;

            case AvatarType.INITIALS:
              return this.initialsTemplate;

            case AvatarType.ICON:
              return this.iconTemplate;

            default:
              return this.defaultTemplate;
          }
        }
      }]);

      return IgxAvatarComponent;
    }();

    IgxAvatarComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-avatar',
        template: "<ng-template #defaultTemplate>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #imageTemplate>\n    <div #image class=\"igx-avatar__image\" [style.backgroundImage]=\"getSrcUrl()\"></div>\n</ng-template>\n\n<ng-template #initialsTemplate>\n    <span>{{initials.substring(0, 2)}}</span>\n</ng-template>\n\n<ng-template #iconTemplate>\n     <igx-icon>{{icon}}</igx-icon>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
      }]
    }];
    /** @nocollapse */

    IgxAvatarComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxAvatarComponent.propDecorators = {
      image: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['image', {
          "static": false
        }]
      }],
      defaultTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      imageTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['imageTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      initialsTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['initialsTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      iconTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['iconTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-label']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-avatar']
      }],
      roleDescription: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-roledescription']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      roundShape: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-avatar--rounded']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      color: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.color']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      bgColor: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.background']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      initials: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      icon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      src: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      size: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @hidden
     */

    var IgxAvatarModule = function IgxAvatarModule() {
      _classCallCheck(this, IgxAvatarModule);
    };

    IgxAvatarModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxAvatarComponent],
        exports: [IgxAvatarComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxIconModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$9 = 0;
    /** @enum {string} */

    var Type = {
      DEFAULT: 'default',
      INFO: 'info',
      SUCCESS: 'success',
      WARNING: 'warning',
      ERROR: 'error'
    };
    /**
     * **Ignite UI for Angular Badge** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/badge.html)
     *
     * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
     * application when visual notification is needed. They are usually designed as icons with a predefined
     * style to communicate information, success, warnings, or errors.
     *
     * Example:
     * ```html
     * <igx-avatar icon="person" roundShape="true" size="small">
     *   <igx-badge icon="check" type="success" class="badge-style">
     *   </igx-badge>
     * </igx-avatar>
     * ```
     * The `badge-style` class is used to position the badge:
     * ```css
     * .badge-style {
     *   position: absolute;
     *   bottom: -6px;
     *   right:-50px;
     * }
     * ```
     */

    var IgxBadgeComponent =
    /*#__PURE__*/
    function () {
      function IgxBadgeComponent() {
        _classCallCheck(this, IgxBadgeComponent);

        /**
         * An \@Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-badge id="igx-badge-2" icon="check" type="success" class="badge-style"></igx-badge>
         * ```
         */
        this.id = "igx-badge-".concat(NEXT_ID$9++);
        /**
         * An \@Input property controlling the type of the badge.
         * Allowed values are `default`, `info`, `success`, `warning`, `error`.
         * Providing an invalid value won't display a badge.
         * ```html
         * <igx-badge type="success" icon="check" class="badge-style"></igx-badge>
         * ```
         */

        this.type = 'default';
        /**
         * An \@Input property that sets the value to be displayed inside the badge.
         * If an `icon` property is already set the `icon` will be displayed.
         * If neither a `value` nor an `icon` is set the contentent of the badge will be empty.
         * ```html
         * <igx-badge value="11" type="success" class="badge-style"></igx-badge>
         * ```
         */

        this.value = '';
        /**
         * This allows you to set value to role attribute.
         * ```html
         * \@ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         * //...
         * badge.label = "badge-status";
         * ```
         */

        this.role = 'status';
        /**
         * This allows you to disable igx-badge class. The default it's applied.
         * ```html
         * \@ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         * //...
         * badge.cssClass = false;
         * ```
         */

        this.cssClass = 'igx-badge';
        /**
         * This allows you to set value to aria-label attribute.
         * ```html
         * \@ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         * //...
         * badge.label = "icon-badge";
         * ```
         */

        this.label = 'badge';
      }
      /**
       * @hidden
       * Defines a human-readable, accessor, author-localized description for the `type` and the `icon` or `value` of the element.
       * @return {?}
       */


      _createClass(IgxBadgeComponent, [{
        key: "setClasses",

        /**
         * @hidden
         * Method which makes the name of the class more descriptive.
         * This helps the styling of the badges.
         * @return {?}
         */
        value: function setClasses() {
          /** @type {?} */
          var classes = {};

          switch (Type[this.type.toUpperCase()]) {
            case Type.DEFAULT:
              classes = _defineProperty({}, "".concat(this.cssClass, "__circle--default"), true);
              break;

            case Type.INFO:
              classes = _defineProperty({}, "".concat(this.cssClass, "__circle--info"), true);
              break;

            case Type.SUCCESS:
              classes = _defineProperty({}, "".concat(this.cssClass, "__circle--success"), true);
              break;

            case Type.WARNING:
              classes = _defineProperty({}, "".concat(this.cssClass, "__circle--warning"), true);
              break;

            case Type.ERROR:
              classes = _defineProperty({}, "".concat(this.cssClass, "__circle--error"), true);
              break;
          }

          return classes;
        }
      }, {
        key: "roleDescription",
        get: function get() {
          /** @type {?} */
          var message; // tslint:disable-next-line:prefer-conditional-expression

          if (this.icon) {
            message = this.type + ' type badge with icon type ' + this.icon;
          } else if (this.value) {
            message = this.type + ' badge type with value ' + this.value;
          } else {
            message = this.type + ' badge type without value';
          }

          return message;
        }
      }]);

      return IgxBadgeComponent;
    }();

    IgxBadgeComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-badge',
        template: "<div class=\"igx-badge__circle\" [ngClass]=\"setClasses()\" [attr.aria-roledescription]=\"roleDescription\">\n    <span *ngIf=\"!icon\" class=\"igx-badge__circle-value\">{{value}}</span>\n    <igx-icon *ngIf=\"icon\" fontSet=\"material\">{{icon}}</igx-icon>\n</div>\n"
      }]
    }];
    IgxBadgeComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      icon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-badge']
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-label']
      }]
    };
    /**
     * @hidden
     */

    var IgxBadgeModule = function IgxBadgeModule() {
      _classCallCheck(this, IgxBadgeModule);
    };

    IgxBadgeModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxBadgeComponent],
        exports: [IgxBadgeComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxIconModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @type {?}
     */

    var IGX_EXPANSION_PANEL_COMPONENT = 'IgxExpansionPanelToken';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxExpansionPanelBodyComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} panel
       * @param {?} element
       * @param {?} cdr
       */
      function IgxExpansionPanelBodyComponent(panel, element, cdr) {
        _classCallCheck(this, IgxExpansionPanelBodyComponent);

        this.panel = panel;
        this.element = element;
        this.cdr = cdr;
        this._labelledBy = '';
        this._label = '';
        /**
         * @hidden
         */

        this.cssClass = "igx-expansion-panel__body";
        /**
         * Gets/sets the `role` attribute of the panel body
         * Default is 'region';
         * Get
         * ```typescript
         *  const currentRole = this.panel.body.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.body.role = 'content';
         * ```
         * ```html
         *  <igx-expansion-panel-body [role]="'custom'"></igx-expansion-panel-body>
         * ```
         */

        this.role = 'region';
      }
      /**
       * Gets the `aria-label` attribute of the panel body
       * Defaults to the panel id with '-region' in the end;
       * Get
       * ```typescript
       *  const currentLabel = this.panel.body.label;
       * ```
       * @return {?}
       */


      _createClass(IgxExpansionPanelBodyComponent, [{
        key: "label",
        get: function get() {
          return this._label || this.panel.id + '-region';
        }
        /**
         * Sets the `aria-label` attribute of the panel body
         * ```typescript
         *  this.panel.body.label = 'my-custom-label';
         * ```
         * ```html
         *  <igx-expansion-panel-body [label]="'my-custom-label'"></igx-expansion-panel-body>
         * ```
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._label = val;
        }
        /**
         * Gets the `aria-labelledby` attribute of the panel body
         * Defaults to the panel header id;
         * Get
         * ```typescript
         *  const currentLabel = this.panel.body.labelledBy;
         * ```
         * @return {?}
         */

      }, {
        key: "labelledBy",
        get: function get() {
          return this._labelledBy;
        }
        /**
         * Sets the `aria-labelledby` attribute of the panel body
         * ```typescript
         *  this.panel.body.labelledBy = 'my-custom-id';
         * ```
         * ```html
         *  <igx-expansion-panel-body [labelledBy]="'my-custom-id'"></igx-expansion-panel-body>
         * ```
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._labelledBy = val;
        }
      }]);

      return IgxExpansionPanelBodyComponent;
    }();

    IgxExpansionPanelBodyComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-expansion-panel-body',
        template: "<ng-content></ng-content>"
      }]
    }];
    /** @nocollapse */

    IgxExpansionPanelBodyComponent.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_EXPANSION_PANEL_COMPONENT]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxExpansionPanelBodyComponent.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-expansion-panel__body']
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-label']
      }],
      labelledBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-labelledby']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxExpansionPanelTitleDirective = function IgxExpansionPanelTitleDirective() {
      _classCallCheck(this, IgxExpansionPanelTitleDirective);

      this.cssClass = "igx-expansion-panel__header-title";
    };

    IgxExpansionPanelTitleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-expansion-panel-title'
      }]
    }];
    IgxExpansionPanelTitleDirective.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-expansion-panel__header-title']
      }]
    };
    /**
     * @hidden
     */

    var IgxExpansionPanelDescriptionDirective = function IgxExpansionPanelDescriptionDirective() {
      _classCallCheck(this, IgxExpansionPanelDescriptionDirective);

      this.cssClass = "igx-expansion-panel__header-description";
    };

    IgxExpansionPanelDescriptionDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-expansion-panel-description'
      }]
    }];
    IgxExpansionPanelDescriptionDirective.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-expansion-panel__header-description']
      }]
    };
    /**
     * @hidden
     */

    var IgxExpansionPanelIconDirective = function IgxExpansionPanelIconDirective() {
      _classCallCheck(this, IgxExpansionPanelIconDirective);
    };

    IgxExpansionPanelIconDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-expansion-panel-icon'
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var ICON_POSITION = {
      LEFT: 'left',
      NONE: 'none',
      RIGHT: 'right'
    };

    var IgxExpansionPanelHeaderComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} panel
       * @param {?} cdr
       * @param {?} elementRef
       */
      function IgxExpansionPanelHeaderComponent(panel, cdr, elementRef) {
        _classCallCheck(this, IgxExpansionPanelHeaderComponent);

        this.panel = panel;
        this.cdr = cdr;
        this.elementRef = elementRef; // properties section

        this._iconTemplate = false;
        /**
         * Sets/gets the `id` of the expansion panel header.
         * ```typescript
         * let panelHeaderId =  this.panel.header.id;
         * ```
         * \@memberof IgxExpansionPanelComponent
         */

        this.id = '';
        /**
         * Gets/sets the `aria-level` attribute of the header
         * Get
         * ```typescript
         *  const currentAriaLevel = this.panel.header.lv;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.lv = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [lv]="myCustomLevel"></igx-expansion-panel-header>
         * ```
         */

        this.lv = '3';
        /**
         * Gets/sets the `role` attribute of the header
         * Get
         * ```typescript
         *  const currentRole = this.panel.header.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.role = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [role]="'custom'"></igx-expansion-panel-header>
         * ```
         */

        this.role = 'heading';
        /**
         * Gets/sets the position of the expansion-panel-header expand/collapse icon
         * Accepts `left`, `right` or `none`
         * ```typescript
         *  const currentIconPosition = this.panel.header.iconPosition;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.iconPosition = 'left';
         * ```
         * ```html
         *  <igx-expansion-panel-header [iconPosition]="'right'"></igx-expansion-panel-header>
         * ```
         */

        this.iconPosition = ICON_POSITION.LEFT;
        /**
         * Emitted whenever a user interacts with the header host
         * ```typescript
         *  handleInteraction(event: IExpansionPanelEventArgs) {
         *  ...
         * }
         * ```
         * ```html
         *  <igx-expansion-panel-header (onInteraction)="handleInteraction($event)">
         *      ...
         *  </igx-expansion-panel-header>
         * ```
         */

        this.onInteraction = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        this.cssClass = 'igx-expansion-panel__header';
        /**
         * Gets/sets the whether the header is disabled
         * When disabled, the header will not handle user events and will stop their propagation
         *
         * ```typescript
         *  const isDisabled = this.panel.header.disabled;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.disabled = true;
         * ```
         * ```html
         *  <igx-expansion-panel-header [disabled]="true">
         *     ...
         *  </igx-expansion-panel-header>
         * ```
         */

        this.disabled = false;
        this.id = "".concat(this.panel.id, "-header");
      }
      /**
       * @hidden
       * @param {?} val
       * @return {?}
       */


      _createClass(IgxExpansionPanelHeaderComponent, [{
        key: "onAction",

        /**
         * @hidden
         * @param {?=} evt
         * @return {?}
         */
        value: function onAction(evt) {
          if (this.disabled) {
            evt.stopPropagation();
            return;
          }

          this.onInteraction.emit({
            event: evt,
            panel: this.panel
          });
          this.panel.toggle(evt);
          evt.preventDefault();
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "openPanel",
        value: function openPanel(event) {
          if (event.altKey) {
            this.panel.expand(event);
            this.onInteraction.emit({
              event: event,
              panel: this.panel
            });
          }
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "closePanel",
        value: function closePanel(event) {
          if (event.altKey) {
            this.panel.collapse(event);
            this.onInteraction.emit({
              event: event,
              panel: this.panel
            });
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "iconTemplate",
        set: function set(val) {
          this._iconTemplate =
          /** @type {?} */
          val;
        }
        /**
         * @hidden
         * @return {?}
         */
        ,
        get: function get() {
          return this._iconTemplate;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "controls",
        get: function get() {
          return this.panel.id;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isExpanded",
        get: function get() {
          return !this.panel.collapsed;
        }
      }, {
        key: "iconPositionClass",
        get: function get() {
          switch (this.iconPosition) {
            case ICON_POSITION.LEFT:
              return "igx-expansion-panel__header-icon--start";

            case ICON_POSITION.RIGHT:
              return "igx-expansion-panel__header-icon--end";

            case ICON_POSITION.NONE:
              return "igx-expansion-panel__header-icon--none";

            default:
              return '';
          }
        }
      }]);

      return IgxExpansionPanelHeaderComponent;
    }();

    IgxExpansionPanelHeaderComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-expansion-panel-header',
        template: "<div class=\"igx-expansion-panel__header-inner\" tabindex=\"0\" role=\"button\" [attr.id]=\"id\"\n[attr.aria-disabled]=\"disabled\" [attr.aria-expanded]=\"isExpanded\" [attr.aria-controls]=\"controls\">\n    <div class=\"igx-expansion-panel__title-wrapper\">\n        <ng-content select=\"igx-expansion-panel-title\"></ng-content>\n        <ng-content select=\"igx-expansion-panel-description\"></ng-content>\n    </div>\n    <ng-content></ng-content>\n    <div [class]=\"iconPositionClass\">\n        <ng-content *ngIf=\"iconTemplate\" select=\"igx-expansion-panel-icon\"></ng-content>\n        <igx-icon *ngIf=\"!iconTemplate\" fontSet=\"material\">\n            {{panel.collapsed? 'expand_more':'expand_less'}}\n        </igx-icon>\n    </div>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxExpansionPanelHeaderComponent.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Host"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_EXPANSION_PANEL_COMPONENT]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxExpansionPanelHeaderComponent.propDecorators = {
      iconTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxExpansionPanelIconDirective, {
          "static": false
        }]
      }],
      lv: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-level']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      iconPosition: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onInteraction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-expansion-panel__header']
      }],
      isExpanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-expansion-panel__header--expanded']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-expansion-panel--disabled']
      }],
      onAction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Enter', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Space', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Spacebar', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }],
      openPanel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Alt.ArrowDown', ['$event']]
      }],
      closePanel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Alt.ArrowUp', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$a = 0;

    var IgxExpansionPanelComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       * @param {?} builder
       */
      function IgxExpansionPanelComponent(cdr, builder) {
        _classCallCheck(this, IgxExpansionPanelComponent);

        this.cdr = cdr;
        this.builder = builder;
        this._collapsed = true;
        /**
         * Sets/gets the animation settings of the expansion panel component
         * Open and Close animation should be passed
         *
         * Get
         * ```typescript
         *  const currentAnimations = this.panel.animationSettings;
         * ```
         * Set
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  this.panel.animationsSettings = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```
         * or via template
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  myCustomAnimationObject = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```html
         *  <igx-expansion-panel [animationSettings]='myCustomAnimationObject'>
         *  ...
         *  </igx-expansion-panel>
         * ```
         */

        this.animationSettings = {
          openAnimation: growVerIn,
          closeAnimation: growVerOut
        };
        /**
         * Sets/gets the `id` of the expansion panel component.
         * If not set, `id` will have value `"igx-expansion-panel-0"`;
         * ```html
         * <igx-expansion-panel id = "my-first-expansion-panel"></igx-expansion-panel>
         * ```
         * ```typescript
         * let panelId =  this.panel.id;
         * ```
         * \@memberof IgxExpansionPanelComponent
         */

        this.id = "igx-expansion-panel-".concat(NEXT_ID$a++);
        /**
         * @hidden
         */

        this.cssClass = 'igx-expansion-panel';
        /**
         * @hidden
         */

        this.collapsedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when the expansion panel finishes collapsing
         * ```typescript
         *  handleCollapsed(event: {
         *  panel: IgxExpansionPanelComponent,
         *  event: Event
         * })
         * ```
         * ```html
         *  <igx-expansion-panel (onCollapsed)="handleCollapsed($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */

        this.onCollapsed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when the expansion panel finishes expanding
         * ```typescript
         *  handleExpanded(event: {
         *  panel: IgxExpansionPanelComponent,
         *  event: Event
         * })
         * ```
         * ```html
         *  <igx-expansion-panel (onExpanded)="handleExpanded($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */

        this.onExpanded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * Gets/sets whether the component is collapsed (its content is hidden)
       * Get
       * ```typescript
       *  const myPanelState: boolean = this.panel.collapsed;
       * ```
       * Set
       * ```html
       *  this.panel.collapsed = true;
       * ```
       *
       * Two-way data binding:
       * ```html
       * <igx-expansion-panel [(collapsed)]="model.isCollapsed"></igx-expansion-panel>
       * ```
       * @return {?}
       */


      _createClass(IgxExpansionPanelComponent, [{
        key: "ngAfterContentInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this94 = this;

          if (this.body && this.header) {
            // schedule at end of turn:
            Promise.resolve().then(function () {
              _this94.body.labelledBy = _this94.body.labelledBy || _this94.headerId;
              _this94.body.label = _this94.body.label || _this94.id + '-region';
            });
          }
        }
        /**
         * @private
         * @param {?} cb
         * @return {?}
         */

      }, {
        key: "playOpenAnimation",
        value: function playOpenAnimation(cb) {
          if (!this.body) {
            // if not body element is passed, there is nothing to animate
            return;
          }
          /** @type {?} */


          var animation = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(this.animationSettings.openAnimation);
          /** @type {?} */

          var animationBuilder = this.builder.build(animation);
          /** @type {?} */

          var openAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
          openAnimationPlayer.onDone(function () {
            cb();
            openAnimationPlayer.reset();
          });
          openAnimationPlayer.play();
        }
        /**
         * @private
         * @param {?} cb
         * @return {?}
         */

      }, {
        key: "playCloseAnimation",
        value: function playCloseAnimation(cb) {
          if (!this.body) {
            // if not body element is passed, there is nothing to animate
            return;
          }
          /** @type {?} */


          var animation = Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(this.animationSettings.closeAnimation);
          /** @type {?} */

          var animationBuilder = this.builder.build(animation);
          /** @type {?} */

          var closeAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
          closeAnimationPlayer.onDone(function () {
            cb();
            closeAnimationPlayer.reset();
          });
          closeAnimationPlayer.play();
        }
        /**
         * Collapses the panel
         *
         * ```html
         *  <igx-expansion-panel #myPanel>
         *      ...
         *  </igx-expansion-panel>
         *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
         * ```
         * @param {?=} evt
         * @return {?}
         */

      }, {
        key: "collapse",
        value: function collapse(evt) {
          var _this95 = this;

          if (this.collapsed) {
            // If expansion panel is already collapsed, do nothing
            return;
          }

          this.playCloseAnimation(function () {
            _this95.onCollapsed.emit({
              event: evt,
              panel: _this95
            });

            _this95.collapsed = true;
          });
        }
        /**
         * Expands the panel
         *
         * ```html
         *  <igx-expansion-panel #myPanel>
         *      ...
         *  </igx-expansion-panel>
         *  <button (click)="myPanel.expand($event)">Expand Panel</button>
         * ```
         * @param {?=} evt
         * @return {?}
         */

      }, {
        key: "expand",
        value: function expand(evt) {
          var _this96 = this;

          if (!this.collapsed) {
            // If the panel is already opened, do nothing
            return;
          }

          this.collapsed = false;
          this.cdr.detectChanges();
          this.playOpenAnimation(function () {
            _this96.onExpanded.emit({
              event: evt,
              panel: _this96
            });
          });
        }
        /**
         * Toggles the panel
         *
         * ```html
         *  <igx-expansion-panel #myPanel>
         *      ...
         *  </igx-expansion-panel>
         *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
         * ```
         * @param {?=} evt
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle(evt) {
          if (this.collapsed) {
            this.open(evt);
          } else {
            this.close(evt);
          }
        }
        /**
         * @param {?=} evt
         * @return {?}
         */

      }, {
        key: "open",
        value: function open(evt) {
          this.expand(evt);
        }
        /**
         * @param {?=} evt
         * @return {?}
         */

      }, {
        key: "close",
        value: function close(evt) {
          this.collapse(evt);
        }
      }, {
        key: "collapsed",
        get: function get() {
          return this._collapsed;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._collapsed = value;
          this.collapsedChange.emit(this._collapsed);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "headerId",
        get: function get() {
          return this.header ? "".concat(this.id, "-header") : '';
        }
      }]);

      return IgxExpansionPanelComponent;
    }();

    IgxExpansionPanelComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-expansion-panel',
        template: "<ng-content select=\"igx-expansion-panel-header\"></ng-content>\n<ng-content *ngIf=\"!collapsed\" select=\"igx-expansion-panel-body\"></ng-content>\n",
        providers: [{
          provide: IGX_EXPANSION_PANEL_COMPONENT,
          useExisting: IgxExpansionPanelComponent
        }]
      }]
    }];
    /** @nocollapse */

    IgxExpansionPanelComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"]
      }];
    };

    IgxExpansionPanelComponent.propDecorators = {
      animationSettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-expansion-panel']
      }],
      collapsed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      collapsedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onCollapsed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onExpanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      body: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxExpansionPanelBodyComponent;
        }), {
          read: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxExpansionPanelBodyComponent;
          }),
          "static": false
        }]
      }],
      header: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxExpansionPanelHeaderComponent;
        }), {
          read: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxExpansionPanelHeaderComponent;
          }),
          "static": false
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxExpansionPanelModule = function IgxExpansionPanelModule() {
      _classCallCheck(this, IgxExpansionPanelModule);
    };

    IgxExpansionPanelModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelBodyComponent, IgxExpansionPanelDescriptionDirective, IgxExpansionPanelTitleDirective, IgxExpansionPanelIconDirective],
        entryComponents: [],
        exports: [IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelBodyComponent, IgxExpansionPanelDescriptionDirective, IgxExpansionPanelTitleDirective, IgxExpansionPanelIconDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxRippleModule, IgxIconModule, IgxButtonModule, IgxAvatarModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable:directive-selector

    var IgxBannerActionsDirective = function IgxBannerActionsDirective() {
      _classCallCheck(this, IgxBannerActionsDirective);
    };

    IgxBannerActionsDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'igx-banner-actions'
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * **Ignite UI for Angular Banner** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/banner.html)
     *
     * The Ignite UI Banner provides a highly templateable and easy to use banner that can be shown in your application.
     *
     * Usage:
     *
     * ```html
     * <igx-banner #banner>
     *   Our privacy settings have changed.
     *  <igx-banner-actions>
     *      <button igxButton="raised">Read More</button>
     *      <button igxButton="raised">Accept and Continue</button>
     *  </igx-banner-actions>
     * </igx-banner>
     * ```
     */

    var IgxBannerComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       */
      function IgxBannerComponent(elementRef) {
        _classCallCheck(this, IgxBannerComponent);

        this.elementRef = elementRef;
        /**
         * Fires after the banner shows up
         * ```typescript
         * public handleOpened(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpened)="handleOpened($event)"></igx-banner>
         * ```
         */

        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Fires before the banner shows up
         * ```typescript
         * public handleOpening(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpening)="handleOpening($event)"></igx-banner>
         * ```
         */

        this.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Fires after the banner hides
         * ```typescript
         * public handleClosed(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosed)="handleClosed($event)"></igx-banner>
         * ```
         */

        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Fires before the banner hides
         * ```typescript
         * public handleClosing(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosing)="handleClosing($event)"></igx-banner>
         * ```
         */

        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxBannerComponent, [{
        key: "open",

        /**
         * Opens the banner
         *
         * ```typescript
         *  myBanner.open();
         * ```
         *
         * ```html
         * <igx-banner #banner>
         * ...
         * </igx-banner>
         * <button (click)="banner.open()">Open Banner</button>
         * ```
         * @param {?=} event
         * @return {?}
         */
        value: function open(event) {
          this._bannerEvent = {
            banner: this,
            event: event
          };
          /** @type {?} */

          var openingArgs = {
            banner: this,
            event: event,
            cancel: false
          };
          this.onOpening.emit(openingArgs);

          if (openingArgs.cancel) {
            return;
          }

          this._expansionPanel.open(event);
        }
        /**
         * Closes the banner
         *
         * ```typescript
         *  myBanner.close();
         * ```
         *
         * ```html
         * <igx-banner #banner>
         * ...
         * </igx-banner>
         * <button (click)="banner.close()">Close Banner</button>
         * ```
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "close",
        value: function close(event) {
          this._bannerEvent = {
            banner: this,
            event: event
          };
          /** @type {?} */

          var closingArgs = {
            banner: this,
            event: event,
            cancel: false
          };
          this.onClosing.emit(closingArgs);

          if (closingArgs.cancel) {
            return;
          }

          this._expansionPanel.close(event);
        }
        /**
         * Toggles the banner
         *
         * ```typescript
         *  myBanner.toggle();
         * ```
         *
         * ```html
         * <igx-banner #banner>
         * ...
         * </igx-banner>
         * <button (click)="banner.toggle()">Toggle Banner</button>
         * ```
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle(event) {
          if (this.collapsed) {
            this.open(event);
          } else {
            this.close(event);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onExpansionPanelOpen",
        value: function onExpansionPanelOpen() {
          this.onOpened.emit(this._bannerEvent);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onExpansionPanelClose",
        value: function onExpansionPanelClose() {
          this.onClosed.emit(this._bannerEvent);
        }
      }, {
        key: "useDefaultTemplate",
        get: function get() {
          return !this._bannerActionTemplate;
        }
        /**
         * Get the animation settings used by the banner open/close methods
         * ```typescript
         * let currentAnimations: AnimationSettings = banner.animationSettings
         * ```
         * @return {?}
         */

      }, {
        key: "animationSettings",
        get: function get() {
          return this._animationSettings ? this._animationSettings : this._expansionPanel.animationSettings;
        }
        /**
         * Set the animation settings used by the banner open/close methods
         * ```typescript
         * import { slideInLeft, slideOutRight } from 'igniteui-angular';
         * ...
         * banner.animationSettings: AnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };
         * ```
         * @param {?} settings
         * @return {?}
         */
        ,
        set: function set(settings) {
          this._animationSettings = settings;
        }
        /**
         * Gets whether banner is collapsed
         *
         * ```typescript
         * const isCollapsed: boolean = banner.collapsed;
         * ```
         * @return {?}
         */

      }, {
        key: "collapsed",
        get: function get() {
          return this._expansionPanel.collapsed;
        }
        /**
         * Returns the native element of the banner component
         * ```typescript
         *  const myBannerElement: HTMLElement = banner.element;
         * ```
         * @return {?}
         */

      }, {
        key: "element",
        get: function get() {
          return this.elementRef.nativeElement;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "displayStyle",
        get: function get() {
          return this.collapsed ? '' : 'block';
        }
      }]);

      return IgxBannerComponent;
    }();

    IgxBannerComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-banner',
        template: "<igx-expansion-panel #expansionPanel [animationSettings]=\"animationSettings\" (onCollapsed)=\"onExpansionPanelClose()\" (onExpanded)=\"onExpansionPanelOpen()\"\n    [collapsed]=\"collapsed\" aria-live=\"polite\" [attr.aria-hidden]=\"collapsed\">\n    <igx-expansion-panel-body>\n        <div class=\"igx-banner\">\n            <div class=\"igx-banner__message\">\n                <div *ngIf=\"bannerIcon\" class=\"igx-banner__illustration\">\n                    <ng-content select=\"igx-icon\"></ng-content>\n                </div>\n                <span class=\"igx-banner__text\">\n                    <ng-content></ng-content>\n                </span>\n            </div>\n            <div class=\"igx-banner__actions\">\n                <div class=\"igx-banner__row\">\n                    <ng-container *ngIf=\"useDefaultTemplate\">\n                        <button igxButton=\"flat\" igxRipple (click)=\"close()\">\n                            Dismiss\n                        </button>\n                    </ng-container>\n                    <ng-container *ngIf=\"!useDefaultTemplate\">\n                        <ng-content select=\"igx-banner-actions\"></ng-content>\n                    </ng-container>\n                </div>\n            </div>\n        </div>\n    </igx-expansion-panel-body>\n</igx-expansion-panel>"
      }]
    }];
    /** @nocollapse */

    IgxBannerComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxBannerComponent.propDecorators = {
      _expansionPanel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['expansionPanel', {
          "static": true
        }]
      }],
      _bannerActionTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxBannerActionsDirective, {
          "static": false
        }]
      }],
      bannerIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxIconComponent, {
          "static": false
        }]
      }],
      onOpened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onOpening: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      animationSettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      displayStyle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.display']
      }]
    };
    /**
     * @hidden
     */

    var IgxBannerModule = function IgxBannerModule() {
      _classCallCheck(this, IgxBannerModule);
    };

    IgxBannerModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxBannerComponent, IgxBannerActionsDirective],
        exports: [IgxBannerComponent, IgxBannerActionsDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var ButtonGroupAlignment = {
      horizontal: 0,
      vertical: 1
    };
    ButtonGroupAlignment[ButtonGroupAlignment.horizontal] = 'horizontal';
    ButtonGroupAlignment[ButtonGroupAlignment.vertical] = 'vertical';
    /** @type {?} */

    var NEXT_ID$b = 0;
    /**
     * **Ignite UI for Angular Button Group** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/buttongroup.html)
     *
     * The Ignite UI Button Group displays a group of buttons either vertically or horizontally.  The group supports
     * single, multiple and toggle selection.
     *
     * Example:
     * ```html
     * <igx-buttongroup multiSelection="true" [values]="fontOptions">
     * </igx-buttongroup>
     * ```
     * The `fontOptions` value shown above is defined as:
     * ```typescript
     * this.fontOptions = [
     *   { icon: 'format_bold', selected: false },
     *   { icon: 'format_italic', selected: false },
     *   { icon: 'format_underlined', selected: false }];
     * ```
     */

    var IgxButtonGroupComponent =
    /*#__PURE__*/
    function (_DisplayDensityBase4) {
      _inherits(IgxButtonGroupComponent, _DisplayDensityBase4);

      /**
       * @param {?} _cdr
       * @param {?} _renderer
       * @param {?} _displayDensityOptions
       */
      function IgxButtonGroupComponent(_cdr, _renderer, _displayDensityOptions) {
        var _this97;

        _classCallCheck(this, IgxButtonGroupComponent);

        _this97 = _possibleConstructorReturn(this, _getPrototypeOf(IgxButtonGroupComponent).call(this, _displayDensityOptions));
        _this97._cdr = _cdr;
        _this97._renderer = _renderer;
        _this97._displayDensityOptions = _displayDensityOptions;
        _this97._disabled = false;
        _this97.buttonClickNotifier$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        _this97.queryListNotifier$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * An \@Input property that sets the value of the `id` attribute. If not set it will be automatically generated.
         * ```html
         *  <igx-buttongroup [id]="'igx-dialog-56'" [multiSelection]="!multi" [values]="alignOptions">
         * ```
         */

        _this97.id = "igx-buttongroup-".concat(NEXT_ID$b++);
        /**
         * @hidden
         */

        _this97.zIndex = 0;
        /**
         * An \@Input property that enables selecting multiple buttons. By default, multi-selection is false.
         * ```html
         * <igx-buttongroup [multiSelection]="false" [alignment]="alignment"></igx-buttongroup>
         * ```
         */

        _this97.multiSelection = false;
        /**
         * @hidden
         */

        _this97.selectedIndexes = [];
        /**
         * An \@Ouput property that emits an event when a button is selected.
         * ```typescript
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onSelect(buttongroup){
         *    this.toast.show()
         * }
         * //...
         * ```
         * ```html
         * <igx-buttongroup #MyChild [multiSelection]="!multi" (onSelect)="onSelect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have made a selection!"></igx-toast>
         * ```
         */

        _this97.onSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Ouput property that emits an event when a button is deselected.
         * ```typescript
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onUnselect(buttongroup){
         *    this.toast.show()
         * }
         * //...
         * ```
         * ```html
         * igx-buttongroup #MyChild [multiSelection]="multi" (onUnselect)="onUnselect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have deselected a button!"></igx-toast>
         * ```
         */

        _this97.onUnselect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this97;
      }
      /**
       * A collection containing all buttons inside the button group.
       * @return {?}
       */


      _createClass(IgxButtonGroupComponent, [{
        key: "selectButton",

        /**
         * Selects a button by its index.
         * ```typescript
         * \@ViewChild("MyChild")
         * private buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    this.buttonG.selectButton(2);
         *    this.cdr.detectChanges();
         * }
         * ```
         * \@memberOf {\@link IgxButtonGroupComponent}
         * @param {?} index
         * @return {?}
         */
        value: function selectButton(index) {
          var _this98 = this;

          if (index >= this.buttons.length || index < 0) {
            return;
          }
          /** @type {?} */


          var button = this.buttons[index];
          /** @type {?} */

          var buttonElement = button.nativeElement;
          this.selectedIndexes.push(index);
          button.selected = true;

          this._renderer.setAttribute(buttonElement, 'aria-pressed', 'true');

          this._renderer.addClass(buttonElement, 'igx-button-group__item--selected');

          this.onSelect.emit({
            button: button,
            index: index
          });
          /** @type {?} */

          var indexInViewButtons = this.viewButtons.toArray().indexOf(button);

          if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = true;
          } // deselect other buttons if multiSelection is not enabled


          if (!this.multiSelection && this.selectedIndexes.length > 1) {
            this.buttons.forEach(function (b, i) {
              if (i !== index && _this98.selectedIndexes.indexOf(i) !== -1) {
                _this98.deselectButton(i);
              }
            });
          }
        }
        /**
         * Deselects a button by its index.
         * ```typescript
         * \@ViewChild("MyChild")
         * private buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    this.buttonG.deselectButton(2);
         *    this.cdr.detectChanges();
         * }
         * ```
         * \@memberOf {\@link IgxButtonGroupComponent}
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "deselectButton",
        value: function deselectButton(index) {
          if (index >= this.buttons.length || index < 0) {
            return;
          }
          /** @type {?} */


          var button = this.buttons[index];
          /** @type {?} */

          var buttonElement = button.nativeElement;
          this.selectedIndexes.splice(this.selectedIndexes.indexOf(index), 1);
          button.selected = false;

          this._renderer.setAttribute(buttonElement, 'aria-pressed', 'false');

          this._renderer.removeClass(buttonElement, 'igx-button-group__item--selected');

          this.onUnselect.emit({
            button: button,
            index: index
          });
          /** @type {?} */

          var indexInViewButtons = this.viewButtons.toArray().indexOf(button);

          if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = false;
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this99 = this;

          this.templateButtons.forEach(function (button) {
            if (!button.initialDensity) {
              button.displayDensity = _this99.displayDensity;
            }
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this100 = this;

          /** @type {?} */
          var initButtons = function initButtons() {
            // Cancel any existing buttonClick subscriptions
            _this100.buttonClickNotifier$.next();

            _this100.selectedIndexes.splice(0, _this100.selectedIndexes.length); // initial configuration


            _this100.buttons.forEach(function (button, index) {
              /** @type {?} */
              var buttonElement = button.nativeElement;

              if (_this100.disabled) {
                button.disabled = true;
              }

              if (button.selected) {
                _this100.selectButton(index);
              }

              button.buttonClick.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this100.buttonClickNotifier$)).subscribe(function (ev) {
                return _this100._clickHandler(ev, index);
              });

              _this100._renderer.addClass(buttonElement, 'igx-button-group__item');
            });
          };

          this.viewButtons.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.queryListNotifier$)).subscribe(function () {
            return initButtons();
          });
          this.templateButtons.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.queryListNotifier$)).subscribe(function () {
            return initButtons();
          });
          initButtons();

          this._cdr.detectChanges();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.buttonClickNotifier$.next();
          this.buttonClickNotifier$.complete();
          this.queryListNotifier$.next();
          this.queryListNotifier$.complete();
        }
        /**
         * @hidden
         * @param {?} event
         * @param {?} i
         * @return {?}
         */

      }, {
        key: "_clickHandler",
        value: function _clickHandler(event, i) {
          if (this.selectedIndexes.indexOf(i) !== -1) {
            this.deselectButton(i);
          } else {
            this.selectButton(i);
          }
        }
      }, {
        key: "buttons",
        get: function get() {
          return [].concat(_toConsumableArray(this.viewButtons.toArray()), _toConsumableArray(this.templateButtons.toArray()));
        }
        /**
         * Allows you to set a style using the `itemContentCssClass` input.
         * The value should be the CSS class name that will be applied to the button group.
         * ```typescript
         * public style1 = "styleClass";
         * //..
         * ```
         * ```html
         * <igx-buttongroup [itemContentCssClass]="style1" [multiSelection]="!multi" [values]="alignOptions">
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "itemContentCssClass",
        set: function set(value) {
          this._itemContentCssClass = value || this._itemContentCssClass;
        }
        /**
         * Returns the CSS class of the item content of the `IgxButtonGroup`.
         * ```typescript
         * \@ViewChild("MyChild")
         * public buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *   let buttonSelect = this.buttonG.itemContentCssClass;
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._itemContentCssClass;
        }
        /**
         * An \@Input property that allows you to disable the `igx-buttongroup` component. By default it's false.
         * ```html
         * <igx-buttongroup [disabled]="true" [multiSelection]="multi" [values]="fontOptions"></igx-buttongroup>
         * ```
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          var _this101 = this;

          if (this._disabled !== value) {
            this._disabled = value;

            if (this.viewButtons && this.templateButtons) {
              this.buttons.forEach(function (b) {
                return b.disabled = _this101._disabled;
              });
            }
          }
        }
        /**
         * Allows you to set the button group alignment.
         * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.
         * ```typescript
         * public alignment = ButtonGroupAlignment.vertical;
         * //..
         * ```
         * ```html
         * <igx-buttongroup [multiSelection]="false" [values]="cities" [alignment]="alignment"></igx-buttongroup>
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "alignment",
        set: function set(value) {
          this._isVertical = value === ButtonGroupAlignment.vertical;
        }
        /**
         * Returns the alignment of the `igx-buttongroup`.
         * ```typescript
         * \@ViewChild("MyChild")
         * public buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    let buttonAlignment = this.buttonG.alignment;
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._isVertical ? ButtonGroupAlignment.vertical : ButtonGroupAlignment.horizontal;
        }
        /**
         * Returns true if the `igx-buttongroup` alignment is vertical.
         * Note that in order for the accessor to work correctly the property should be set explicitly.
         * ```html
         * <igx-buttongroup #MyChild [alignment]="alignment" [values]="alignOptions">
         * ```
         * ```typescript
         * //...
         * \@ViewChild("MyChild")
         * private buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    let orientation = this.buttonG.isVertical;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "isVertical",
        get: function get() {
          return this._isVertical;
        }
        /**
         * Gets the selected button/buttons.
         * ```typescript
         * \@ViewChild("MyChild")
         * private buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    let selectedButton = this.buttonG.selectedButtons;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "selectedButtons",
        get: function get() {
          var _this102 = this;

          return this.buttons.filter(function (b, i) {
            return _this102.selectedIndexes.indexOf(i) !== -1;
          });
        }
      }]);

      return IgxButtonGroupComponent;
    }(DisplayDensityBase);

    IgxButtonGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-buttongroup',
        template: "<div class=\"igx-button-group\" role=\"group\" [class.igx-button-group--vertical]=\"isVertical\">\n    <button *ngFor=\"let button of values; let i = 'index'\"\n        type=\"button\"\n        igxButton=\"flat\"\n        [displayDensity]=\"displayDensity\"\n        [selected]=\"button.selected\"\n        [attr.data-togglable]=\"button.togglable\"\n        [disabled]=\"disabled || button.disabled\"\n        [igxButtonColor]=\"button.color\"\n        [igxButtonBackground]=\"button.bgcolor\"\n        [igxLabel]=\"button.label\"\n        [igxRipple]=\"button.ripple\"\n    >\n        <div class=\"igx-button-group__item-content {{ itemContentCssClass }}\">\n            <igx-icon *ngIf=\"button.icon\" fontSet=\"material\">{{button.icon}}</igx-icon>\n            <span *ngIf=\"button.label\">{{button.label}}</span>\n        </div>\n    </button>\n    <ng-content></ng-content>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxButtonGroupComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxButtonGroupComponent.propDecorators = {
      viewButtons: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxButtonDirective]
      }],
      templateButtons: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxButtonDirective]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      zIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.zIndex']
      }],
      itemContentCssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      multiSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      values: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      alignment: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onUnselect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @hidden
     */

    var IgxButtonGroupModule = function IgxButtonGroupModule() {
      _classCallCheck(this, IgxButtonGroupModule);
    };

    IgxButtonGroupModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxButtonGroupComponent],
        exports: [IgxButtonGroupComponent],
        imports: [IgxButtonModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxRippleModule, IgxIconModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var DateRangeType = {
      After: 0,
      Before: 1,
      Between: 2,
      Specific: 3,
      Weekdays: 4,
      Weekends: 5
    };
    DateRangeType[DateRangeType.After] = 'After';
    DateRangeType[DateRangeType.Before] = 'Before';
    DateRangeType[DateRangeType.Between] = 'Between';
    DateRangeType[DateRangeType.Specific] = 'Specific';
    DateRangeType[DateRangeType.Weekdays] = 'Weekdays';
    DateRangeType[DateRangeType.Weekends] = 'Weekends';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var TimeDeltaInterval = {
      Month: 'month',
      Year: 'year'
    };
    /** @type {?} */

    var MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    /** @type {?} */

    var FEBRUARY = 1;
    /**
     * @param {?=} start
     * @param {?=} stop
     * @param {?=} step
     * @return {?}
     */

    function range() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var stop = arguments.length > 1 ? arguments[1] : undefined;
      var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      /** @type {?} */
      var res = [];
      /** @type {?} */

      var cur = stop === undefined ? 0 : start;
      /** @type {?} */

      var max = stop === undefined ? start : stop;

      for (var i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
      }

      return res;
    }
    /**
     * Returns true for leap years, false for non-leap years.
     *
     * @export
     * @param {?} year
     * @return {?}
     */


    function isLeap(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} day
     * @return {?}
     */


    function weekDay(year, month, day) {
      return new Date(year, month, day).getDay();
    }
    /**
     * Return weekday and number of days for year, month.
     *
     * @export
     * @param {?} year
     * @param {?} month
     * @return {?}
     */


    function monthRange(year, month) {
      if (month < 0 || month > 11) {
        throw new Error('Invalid month specified');
      }
      /** @type {?} */


      var day = weekDay(year, month, 1);
      /** @type {?} */

      var nDays = MDAYS[month];

      if (month === FEBRUARY && isLeap(year)) {
        nDays++;
      }

      return [day, nDays];
    }
    /**
     * @param {?} date
     * @param {?} ranges
     * @return {?}
     */


    function isDateInRanges(date, ranges) {
      date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      /** @type {?} */

      var dateInMs = date.getTime();

      if (!ranges) {
        return false;
      }

      var _iteratorNormalCompletion26 = true;
      var _didIteratorError26 = false;
      var _iteratorError26 = undefined;

      try {
        for (var _iterator26 = ranges[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
          var descriptor = _step26.value;

          /** @type {?} */
          var dRanges = descriptor.dateRange ? descriptor.dateRange.map(function (r) {
            return new Date(r.getFullYear(), r.getMonth(), r.getDate());
          }) : undefined;

          switch (descriptor.type) {
            case DateRangeType.After:
              if (dateInMs > dRanges[0].getTime()) {
                return true;
              }

              break;

            case DateRangeType.Before:
              if (dateInMs < dRanges[0].getTime()) {
                return true;
              }

              break;

            case DateRangeType.Between:
              /** @type {?} */
              var dRange = dRanges.map(function (d) {
                return d.getTime();
              });
              /** @type {?} */

              var min = Math.min(dRange[0], dRange[1]);
              /** @type {?} */

              var max = Math.max(dRange[0], dRange[1]);

              if (dateInMs >= min && dateInMs <= max) {
                return true;
              }

              break;

            case DateRangeType.Specific:
              /** @type {?} */
              var datesInMs = dRanges.map(function (d) {
                return d.getTime();
              });
              var _iteratorNormalCompletion27 = true;
              var _didIteratorError27 = false;
              var _iteratorError27 = undefined;

              try {
                for (var _iterator27 = datesInMs[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                  var specificDateInMs = _step27.value;

                  if (dateInMs === specificDateInMs) {
                    return true;
                  }
                }
              } catch (err) {
                _didIteratorError27 = true;
                _iteratorError27 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion27 && _iterator27["return"] != null) {
                    _iterator27["return"]();
                  }
                } finally {
                  if (_didIteratorError27) {
                    throw _iteratorError27;
                  }
                }
              }

              break;

            case DateRangeType.Weekdays:
              /** @type {?} */
              var day = date.getDay();

              if (day % 6 !== 0) {
                return true;
              }

              break;

            case DateRangeType.Weekends:
              /** @type {?} */
              var weekday = date.getDay();

              if (weekday % 6 === 0) {
                return true;
              }

              break;

            default:
              return false;
          }
        }
      } catch (err) {
        _didIteratorError26 = true;
        _iteratorError26 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion26 && _iterator26["return"] != null) {
            _iterator26["return"]();
          }
        } finally {
          if (_didIteratorError26) {
            throw _iteratorError26;
          }
        }
      }

      return false;
    }
    /** @enum {number} */


    var WEEKDAYS = {
      SUNDAY: 0,
      MONDAY: 1,
      TUESDAY: 2,
      WEDNESDAY: 3,
      THURSDAY: 4,
      FRIDAY: 5,
      SATURDAY: 6
    };
    WEEKDAYS[WEEKDAYS.SUNDAY] = 'SUNDAY';
    WEEKDAYS[WEEKDAYS.MONDAY] = 'MONDAY';
    WEEKDAYS[WEEKDAYS.TUESDAY] = 'TUESDAY';
    WEEKDAYS[WEEKDAYS.WEDNESDAY] = 'WEDNESDAY';
    WEEKDAYS[WEEKDAYS.THURSDAY] = 'THURSDAY';
    WEEKDAYS[WEEKDAYS.FRIDAY] = 'FRIDAY';
    WEEKDAYS[WEEKDAYS.SATURDAY] = 'SATURDAY';

    var Calendar =
    /*#__PURE__*/
    function () {
      /**
       * @param {?=} firstWeekDay
       */
      function Calendar() {
        var firstWeekDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : WEEKDAYS.SUNDAY;

        _classCallCheck(this, Calendar);

        this._firstWeekDay = firstWeekDay;
      }
      /**
       * @return {?}
       */


      _createClass(Calendar, [{
        key: "weekdays",

        /**
         * Returns an array of weekdays for one week starting
         * with the currently set `firstWeekDay`
         *
         * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
         * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
         *
         * \@memberof Calendar
         * @return {?}
         *
         */
        value: function weekdays() {
          /** @type {?} */
          var res = [];
          var _iteratorNormalCompletion28 = true;
          var _didIteratorError28 = false;
          var _iteratorError28 = undefined;

          try {
            for (var _iterator28 = range(this.firstWeekDay, this.firstWeekDay + 7)[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
              var i = _step28.value;
              res.push(i % 7);
            }
          } catch (err) {
            _didIteratorError28 = true;
            _iteratorError28 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion28 && _iterator28["return"] != null) {
                _iterator28["return"]();
              }
            } finally {
              if (_didIteratorError28) {
                throw _iteratorError28;
              }
            }
          }

          return res;
        }
        /**
         * Returns the date values for one month. It will always iterate throught
         * complete weeks, so it will contain dates outside the specified month.
         *
         * \@memberof Calendar
         * @param {?} year
         * @param {?} month
         * @param {?=} extraWeek
         * @return {?}
         *
         */

      }, {
        key: "monthdates",
        value: function monthdates(year, month) {
          var extraWeek = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          /** @type {?} */
          var date = new Date(year, month, 1);
          /** @type {?} */

          var days = (date.getDay() - this.firstWeekDay) % 7;

          if (days < 0) {
            days = 7 - Math.abs(days);
          }

          date = this.timedelta(date, 'day', -days);
          /** @type {?} */

          var res = [];
          /** @type {?} */

          var value;

          while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);

            if (date.getMonth() !== month && date.getDay() === this.firstWeekDay) {
              if (extraWeek && res.length <= 35) {
                var _iteratorNormalCompletion29 = true;
                var _didIteratorError29 = false;
                var _iteratorError29 = undefined;

                try {
                  for (var _iterator29 = range(0, 7)[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
                    var _ = _step29.value;
                    value = this.generateICalendarDate(date, year, month);
                    res.push(value);
                    date = this.timedelta(date, 'day', 1);
                  }
                } catch (err) {
                  _didIteratorError29 = true;
                  _iteratorError29 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion29 && _iterator29["return"] != null) {
                      _iterator29["return"]();
                    }
                  } finally {
                    if (_didIteratorError29) {
                      throw _iteratorError29;
                    }
                  }
                }
              }

              break;
            }
          }

          return res;
        }
        /**
         * Returns a matrix (array of arrays) representing a month's calendar.
         * Each row represents a full week; week entries are ICalendarDate objects.
         *
         * \@memberof Calendar
         * @param {?} year
         * @param {?} month
         * @param {?=} extraWeek
         * @return {?}
         *
         */

      }, {
        key: "monthdatescalendar",
        value: function monthdatescalendar(year, month) {
          var extraWeek = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          /** @type {?} */
          var dates = this.monthdates(year, month, extraWeek);
          /** @type {?} */

          var res = [];
          var _iteratorNormalCompletion30 = true;
          var _didIteratorError30 = false;
          var _iteratorError30 = undefined;

          try {
            for (var _iterator30 = range(0, dates.length, 7)[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
              var i = _step30.value;
              res.push(dates.slice(i, i + 7));
            }
          } catch (err) {
            _didIteratorError30 = true;
            _iteratorError30 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion30 && _iterator30["return"] != null) {
                _iterator30["return"]();
              }
            } finally {
              if (_didIteratorError30) {
                throw _iteratorError30;
              }
            }
          }

          return res;
        }
        /**
         * @param {?} date
         * @param {?} interval
         * @param {?} units
         * @return {?}
         */

      }, {
        key: "timedelta",
        value: function timedelta(date, interval, units) {
          /** @type {?} */
          var ret = new Date(date);
          /** @type {?} */

          var checkRollover = function checkRollover() {
            if (ret.getDate() !== date.getDate()) {
              ret.setDate(0);
            }
          };

          switch (interval.toLowerCase()) {
            case 'year':
              ret.setFullYear(ret.getFullYear() + units);
              checkRollover();
              break;

            case 'quarter':
              ret.setMonth(ret.getMonth() + 3 * units);
              checkRollover();
              break;

            case 'month':
              ret.setMonth(ret.getMonth() + units);
              checkRollover();
              break;

            case 'week':
              ret.setDate(ret.getDate() + 7 * units);
              break;

            case 'day':
              ret.setDate(ret.getDate() + units);
              break;

            case 'hour':
              ret.setTime(ret.getTime() + units * 3600000);
              break;

            case 'minute':
              ret.setTime(ret.getTime() + units * 60000);
              break;

            case 'second':
              ret.setTime(ret.getTime() + units * 1000);
              break;

            default:
              throw new Error('Invalid interval specifier');
          }

          return ret;
        }
        /**
         * @param {?} date
         * @param {?} locale
         * @param {?} options
         * @param {?} parts
         * @return {?}
         */

      }, {
        key: "formatToParts",
        value: function formatToParts(date, locale, options, parts) {
          /** @type {?} */
          var formatter = new Intl.DateTimeFormat(locale, options);
          /** @type {?} */

          var result = {
            date: date,
            full: formatter.format(date)
          };

          if (
          /** @type {?} */
          formatter.formatToParts) {
            /** @type {?} */
            var formattedParts =
            /** @type {?} */
            formatter.formatToParts(date);
            /** @type {?} */

            var toType = function toType(partType) {
              /** @type {?} */
              var index = formattedParts.findIndex(function (_ref) {
                var type = _ref.type;
                return type === partType;
              });
              /** @type {?} */

              var o = {
                value: '',
                literal: '',
                combined: ''
              };

              if (partType === 'era' && index > -1) {
                o.value = formattedParts[index].value;
                return o;
              } else if (partType === 'era' && index === -1) {
                return o;
              }

              o.value = formattedParts[index].value;
              o.literal = formattedParts[index + 1] ? formattedParts[index + 1].value : '';
              o.combined = [o.value, o.literal].join('');
              return o;
            };

            var _iteratorNormalCompletion31 = true;
            var _didIteratorError31 = false;
            var _iteratorError31 = undefined;

            try {
              for (var _iterator31 = parts[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
                var each = _step31.value;
                result[each] = toType(each);
              }
            } catch (err) {
              _didIteratorError31 = true;
              _iteratorError31 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion31 && _iterator31["return"] != null) {
                  _iterator31["return"]();
                }
              } finally {
                if (_didIteratorError31) {
                  throw _iteratorError31;
                }
              }
            }
          } else {
            var _iteratorNormalCompletion32 = true;
            var _didIteratorError32 = false;
            var _iteratorError32 = undefined;

            try {
              for (var _iterator32 = parts[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
                var _each = _step32.value;
                result[_each] = {
                  value: '',
                  literal: '',
                  combined: ''
                };
              }
            } catch (err) {
              _didIteratorError32 = true;
              _iteratorError32 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion32 && _iterator32["return"] != null) {
                  _iterator32["return"]();
                }
              } finally {
                if (_didIteratorError32) {
                  throw _iteratorError32;
                }
              }
            }
          }

          return result;
        }
        /**
         * @param {?} date
         * @param {?} interval
         * @param {?} activeViewIdx
         * @return {?}
         */

      }, {
        key: "getFirstViewDate",
        value: function getFirstViewDate(date, interval, activeViewIdx) {
          return this.timedelta(date, interval, -activeViewIdx);
        }
        /**
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "getNextMonth",
        value: function getNextMonth(date) {
          return this.timedelta(date, TimeDeltaInterval.Month, 1);
        }
        /**
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "getPrevMonth",
        value: function getPrevMonth(date) {
          return this.timedelta(date, TimeDeltaInterval.Month, -1);
        }
        /**
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "getNextYear",
        value: function getNextYear(date) {
          return this.timedelta(date, TimeDeltaInterval.Year, 1);
        }
        /**
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "getPrevYear",
        value: function getPrevYear(date) {
          return this.timedelta(date, TimeDeltaInterval.Year, -1);
        }
        /**
         * @private
         * @param {?} date
         * @param {?} year
         * @param {?} month
         * @return {?}
         */

      }, {
        key: "generateICalendarDate",
        value: function generateICalendarDate(date, year, month) {
          return {
            date: date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
          };
        }
        /**
         * @private
         * @param {?} date
         * @param {?} year
         * @param {?} month
         * @return {?}
         */

      }, {
        key: "isPreviousMonth",
        value: function isPreviousMonth(date, year, month) {
          if (date.getFullYear() === year) {
            return date.getMonth() < month;
          }

          return date.getFullYear() < year;
        }
        /**
         * @private
         * @param {?} date
         * @param {?} year
         * @param {?} month
         * @return {?}
         */

      }, {
        key: "isNextMonth",
        value: function isNextMonth(date, year, month) {
          if (date.getFullYear() === year) {
            return date.getMonth() > month;
          }

          return date.getFullYear() > year;
        }
      }, {
        key: "firstWeekDay",
        get: function get() {
          return this._firstWeekDay % 7;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._firstWeekDay = value;
        }
      }]);

      return Calendar;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var IgxCalendarYearDirective =
    /*#__PURE__*/
    function () {
      function IgxCalendarYearDirective() {
        _classCallCheck(this, IgxCalendarYearDirective);

        this.onYearSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * @return {?}
       */


      _createClass(IgxCalendarYearDirective, [{
        key: "onClick",

        /**
         * @return {?}
         */
        value: function onClick() {
          this.onYearSelection.emit(this.value);
        }
      }, {
        key: "defaultCSS",
        get: function get() {
          return !this.isCurrentYear;
        }
        /**
         * @return {?}
         */

      }, {
        key: "currentCSS",
        get: function get() {
          return this.isCurrentYear;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isCurrentYear",
        get: function get() {
          return this.date.getFullYear() === this.value.getFullYear();
        }
      }]);

      return IgxCalendarYearDirective;
    }();

    IgxCalendarYearDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCalendarYear]'
      }]
    }];
    IgxCalendarYearDirective.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxCalendarYear']
      }],
      date: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onYearSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      defaultCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__year']
      }],
      currentCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__year--current']
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click']
      }]
    };

    var IgxCalendarMonthDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       */
      function IgxCalendarMonthDirective(elementRef) {
        _classCallCheck(this, IgxCalendarMonthDirective);

        this.elementRef = elementRef;
        this.onMonthSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.tabindex = 0;
      }
      /**
       * @return {?}
       */


      _createClass(IgxCalendarMonthDirective, [{
        key: "onClick",

        /**
         * @return {?}
         */
        value: function onClick() {
          /** @type {?} */
          var date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
          this.onMonthSelection.emit(date);
        }
      }, {
        key: "defaultCSS",
        get: function get() {
          return !this.isCurrentMonth;
        }
        /**
         * @return {?}
         */

      }, {
        key: "currentCSS",
        get: function get() {
          return this.isCurrentMonth;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isCurrentMonth",
        get: function get() {
          return this.date.getMonth() === this.value.getMonth();
        }
        /**
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.elementRef.nativeElement;
        }
      }]);

      return IgxCalendarMonthDirective;
    }();

    IgxCalendarMonthDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCalendarMonth]'
      }]
    }];
    /** @nocollapse */

    IgxCalendarMonthDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxCalendarMonthDirective.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxCalendarMonth']
      }],
      date: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      index: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onMonthSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      defaultCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__month']
      }],
      currentCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__month--current']
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click']
      }]
    };
    /**
     * @hidden
     */

    var IgxCalendarHeaderTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxCalendarHeaderTemplateDirective(template) {
      _classCallCheck(this, IgxCalendarHeaderTemplateDirective);

      this.template = template;
    };

    IgxCalendarHeaderTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCalendarHeader]'
      }]
    }];
    /** @nocollapse */

    IgxCalendarHeaderTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxCalendarSubheaderTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxCalendarSubheaderTemplateDirective(template) {
      _classCallCheck(this, IgxCalendarSubheaderTemplateDirective);

      this.template = template;
    };

    IgxCalendarSubheaderTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCalendarSubheader]'
      }]
    }];
    /** @nocollapse */

    IgxCalendarSubheaderTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxCalendarScrollMonthDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?} zone
       */
      function IgxCalendarScrollMonthDirective(element, zone) {
        _classCallCheck(this, IgxCalendarScrollMonthDirective);

        this.element = element;
        this.zone = zone;
        /**
         * @hidden
         */

        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxCalendarScrollMonthDirective, [{
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this103 = this;

          Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.element.nativeElement, 'keyup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounce"])(function () {
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(100);
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (event) {
            _this103.stopScroll(event);
          });
          this.zone.runOutsideAngular(function () {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(_this103.element.nativeElement, 'keydown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["tap"])(function (event) {
              if (event.key === " "
              /* SPACE */
              || event.key === "Spacebar"
              /* SPACE_IE */
              || event.key === "Enter"
              /* ENTER */
              ) {
                  event.preventDefault();
                  event.stopPropagation();
                }
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounce"])(function () {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(100);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this103.destroy$)).subscribe(function (event) {
              if (event.key === " "
              /* SPACE */
              || event.key === "Spacebar"
              /* SPACE_IE */
              || event.key === "Enter"
              /* ENTER */
              ) {
                  _this103.zone.run(function () {
                    return _this103.startScroll(true);
                  });
                }
            });
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onMouseDown",
        value: function onMouseDown() {
          this.startScroll();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onMouseUp",
        value: function onMouseUp(event) {
          this.stopScroll(event);
        }
      }]);

      return IgxCalendarScrollMonthDirective;
    }();

    IgxCalendarScrollMonthDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCalendarScrollMonth]'
      }]
    }];
    /** @nocollapse */

    IgxCalendarScrollMonthDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };

    IgxCalendarScrollMonthDirective.propDecorators = {
      startScroll: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      stopScroll: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onMouseDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['mousedown']
      }],
      onMouseUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['mouseup', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var CalendarSelection = {
      SINGLE: 'single',
      MULTI: 'multi',
      RANGE: 'range'
    };
    /** @enum {string} */

    var ScrollMonth = {
      PREV: 'prev',
      NEXT: 'next',
      NONE: 'none'
    };

    var IgxCalendarBase =
    /*#__PURE__*/
    function () {
      /**
       * @hidden
       */
      function IgxCalendarBase() {
        _classCallCheck(this, IgxCalendarBase);

        /**
         * Sets/gets whether the outside dates (dates that are out of the current month) will be hidden.
         * Default value is `false`.
         * ```html
         * <igx-calendar [hideOutsideDays] = "true"></igx-calendar>
         * ```
         * ```typescript
         * let hideOutsideDays = this.calendar.hideOutsideDays;
         * ```
         */
        this.hideOutsideDays = false;
        /**
         * Emits an event when a date is selected.
         * Provides reference the `selectedDates` property.
         */

        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        this._selection = CalendarSelection.SINGLE;
        /**
         * @hidden
         */

        this.rangeStarted = false;
        /**
         * @hidden
         */

        this._locale = 'en';
        /**
         * @hidden
         */

        this._disabledDates = null;
        /**
         * @hidden
         */

        this._specialDates = null;
        /**
         * @hidden
         */

        this._formatOptions = {
          day: 'numeric',
          month: 'short',
          weekday: 'short',
          year: 'numeric'
        };
        /**
         * @hidden
         */

        this._formatViews = {
          day: false,
          month: true,
          year: false
        };
        /**
         * @hidden
         */

        this.monthScrollDirection = ScrollMonth.NONE;
        /**
         * @hidden
         */

        this.scrollMonth$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */

        this.stopMonthScroll$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */

        this.startMonthScroll$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */

        this._onTouchedCallback = function () {};
        /**
         * @hidden
         */


        this._onChangeCallback = function () {};

        this.calendarModel = new Calendar();
        this.viewDate = this.viewDate ? this.viewDate : new Date();
        this.calendarModel.firstWeekDay = this.weekStart;
        this.initFormatters();
      }
      /**
       * Gets the start day of the week.
       * Can return a numeric or an enum representation of the week day.
       * Defaults to `Sunday` / `0`.
       * @return {?}
       */


      _createClass(IgxCalendarBase, [{
        key: "getDateOnlyInMs",

        /**
         * @hidden
         * @private
         * @param {?} date
         * @return {?}
         */
        value: function getDateOnlyInMs(date) {
          return this.getDateOnly(date).getTime();
        }
        /**
         * @hidden
         * @private
         * @param {?} start
         * @param {?} end
         * @return {?}
         */

      }, {
        key: "generateDateRange",
        value: function generateDateRange(start, end) {
          /** @type {?} */
          var result = [];
          start = this.getDateOnly(start);
          end = this.getDateOnly(end);

          while (start.getTime() !== end.getTime()) {
            start = this.calendarModel.timedelta(start, 'day', 1);
            result.push(start);
          }

          return result;
        }
        /**
         * Performs a single selection.
         * @hidden
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "selectSingle",
        value: function selectSingle(value) {
          this.selectedDates = this.getDateOnly(value);

          this._onChangeCallback(this.selectedDates);
        }
        /**
         * Performs a multiple selection
         * @hidden
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "selectMultiple",
        value: function selectMultiple(value) {
          var _this104 = this;

          if (Array.isArray(value)) {
            /** @type {?} */
            var newDates = value.map(function (v) {
              return _this104.getDateOnly(v).getTime();
            });
            /** @type {?} */

            var selDates = this.selectedDates.map(function (v) {
              return _this104.getDateOnly(v).getTime();
            });

            if (JSON.stringify(newDates) === JSON.stringify(selDates)) {
              return;
            }

            this.selectedDates = Array.from(new Set([].concat(_toConsumableArray(newDates), _toConsumableArray(selDates)))).map(function (v) {
              return new Date(v);
            });
          } else {
            /** @type {?} */
            var valueDateOnly = this.getDateOnly(value);
            /** @type {?} */

            var newSelection = [];

            if (this.selectedDates.every(function (date) {
              return date.getTime() !== valueDateOnly.getTime();
            })) {
              newSelection.push(valueDateOnly);
            } else {
              this.selectedDates = this.selectedDates.filter(function (date) {
                return date.getTime() !== valueDateOnly.getTime();
              });
            }

            if (newSelection.length > 0) {
              this.selectedDates = this.selectedDates.concat(newSelection);
            }
          }

          this.selectedDates = this.selectedDates.filter(function (d) {
            return !_this104.isDateDisabled(d);
          });
          this.selectedDates.sort(function (a, b) {
            return a.valueOf() - b.valueOf();
          });

          this._onChangeCallback(this.selectedDates);
        }
        /**
         * @hidden
         * @private
         * @param {?} value
         * @param {?=} excludeDisabledDates
         * @return {?}
         */

      }, {
        key: "selectRange",
        value: function selectRange(value) {
          var _this105 = this;

          var excludeDisabledDates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          /** @type {?} */
          var start;
          /** @type {?} */

          var end;

          if (Array.isArray(value)) {
            // this.rangeStarted = false;
            value.sort(function (a, b) {
              return a.valueOf() - b.valueOf();
            });
            start = this.getDateOnly(value[0]);
            end = this.getDateOnly(value[value.length - 1]);
            this.selectedDates = [start].concat(_toConsumableArray(this.generateDateRange(start, end)));
          } else {
            if (!this.rangeStarted) {
              this.rangeStarted = true;
              this.selectedDates = [value];
            } else {
              this.rangeStarted = false;

              if (this.selectedDates[0].getTime() === value.getTime()) {
                this.selectedDates = [];

                this._onChangeCallback(this.selectedDates);

                return;
              }

              this.selectedDates.push(value);
              this.selectedDates.sort(function (a, b) {
                return a.valueOf() - b.valueOf();
              });
              start = this.selectedDates.shift();
              end = this.selectedDates.pop();
              this.selectedDates = [start].concat(_toConsumableArray(this.generateDateRange(start, end)));
            }
          }

          if (excludeDisabledDates) {
            this.selectedDates = this.selectedDates.filter(function (d) {
              return !_this105.isDateDisabled(d);
            });
          }

          this._onChangeCallback(this.selectedDates);
        }
        /**
         * Performs a single deselection.
         * @hidden
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "deselectSingle",
        value: function deselectSingle(value) {
          if (this.selectedDates !== null && this.getDateOnlyInMs(
          /** @type {?} */
          value) === this.getDateOnlyInMs(this.selectedDates)) {
            this.selectedDates = null;

            this._onChangeCallback(this.selectedDates);
          }
        }
        /**
         * Performs a multiple deselection.
         * @hidden
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "deselectMultiple",
        value: function deselectMultiple(value) {
          var _this106 = this;

          value = value.filter(function (v) {
            return v !== null;
          });
          /** @type {?} */

          var selectedDatesCount = this.selectedDates.length;
          /** @type {?} */

          var datesInMsToDeselect = new Set(value.map(function (v) {
            return _this106.getDateOnlyInMs(v);
          }));

          for (var i = this.selectedDates.length - 1; i >= 0; i--) {
            if (datesInMsToDeselect.has(this.getDateOnlyInMs(this.selectedDates[i]))) {
              this.selectedDates.splice(i, 1);
            }
          }

          if (this.selectedDates.length !== selectedDatesCount) {
            this._onChangeCallback(this.selectedDates);
          }
        }
        /**
         * Performs deselection of a single value, when selection is multi
         * Usually performed by the selectMultiple method, but leads to bug when multiple months are in view
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "deselectMultipleInMonth",
        value: function deselectMultipleInMonth(value) {
          /** @type {?} */
          var valueDateOnly = this.getDateOnly(value);
          this.selectedDates = this.selectedDates.filter(function (date) {
            return date.getTime() !== valueDateOnly.getTime();
          });
        }
        /**
         * Performs a range deselection.
         * @hidden
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "deselectRange",
        value: function deselectRange(value) {
          value = value.filter(function (v) {
            return v !== null;
          });

          if (value.length < 1) {
            return;
          }

          value.sort(function (a, b) {
            return a.valueOf() - b.valueOf();
          });
          /** @type {?} */

          var valueStart = this.getDateOnlyInMs(value[0]);
          /** @type {?} */

          var valueEnd = this.getDateOnlyInMs(value[value.length - 1]);
          this.selectedDates.sort(function (a, b) {
            return a.valueOf() - b.valueOf();
          });
          /** @type {?} */

          var selectedDatesStart = this.getDateOnlyInMs(this.selectedDates[0]);
          /** @type {?} */

          var selectedDatesEnd = this.getDateOnlyInMs(this.selectedDates[this.selectedDates.length - 1]);

          if (!(valueEnd < selectedDatesStart) && !(valueStart > selectedDatesEnd)) {
            this.selectedDates = [];
            this.rangeStarted = false;

            this._onChangeCallback(this.selectedDates);
          }
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "initFormatters",
        value: function initFormatters() {
          this.formatterDay = new Intl.DateTimeFormat(this._locale, {
            day: this._formatOptions.day
          });
          this.formatterWeekday = new Intl.DateTimeFormat(this._locale, {
            weekday: this._formatOptions.weekday
          });
          this.formatterMonth = new Intl.DateTimeFormat(this._locale, {
            month: this._formatOptions.month
          });
          this.formatterYear = new Intl.DateTimeFormat(this._locale, {
            year: this._formatOptions.year
          });
          this.formatterMonthday = new Intl.DateTimeFormat(this._locale, {
            month: this._formatOptions.month,
            day: this._formatOptions.day
          });
        }
        /**
         * @hidden
         * @protected
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "getDateOnly",
        value: function getDateOnly(date) {
          return new Date(date.getFullYear(), date.getMonth(), date.getDate());
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this.selectDate(
          /** @type {?} */
          value);
        }
        /**
         * Checks whether a date is disabled.
         * @hidden
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "isDateDisabled",
        value: function isDateDisabled(date) {
          if (this.disabledDates === null) {
            return false;
          }

          return isDateInRanges(date, this.disabledDates);
        }
        /**
         * Selects date(s) (based on the selection type).
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "selectDate",
        value: function selectDate(value) {
          if (value === null || value === undefined || Array.isArray(value) && value.length === 0) {
            return;
          }

          switch (this.selection) {
            case CalendarSelection.SINGLE:
              if (isDate(value) && !this.isDateDisabled(
              /** @type {?} */
              value)) {
                this.selectSingle(
                /** @type {?} */
                value);
              }

              break;

            case CalendarSelection.MULTI:
              this.selectMultiple(value);
              break;

            case CalendarSelection.RANGE:
              this.selectRange(value, true);
              break;
          }
        }
        /**
         * Deselects date(s) (based on the selection type).
         * @param {?=} value
         * @return {?}
         */

      }, {
        key: "deselectDate",
        value: function deselectDate(value) {
          if (this.selectedDates === null || this.selectedDates.length === 0) {
            return;
          }

          if (value === null || value === undefined) {
            this.selectedDates = this.selection === CalendarSelection.SINGLE ? null : [];
            this.rangeStarted = false;

            this._onChangeCallback(this.selectedDates);

            return;
          }

          switch (this.selection) {
            case CalendarSelection.SINGLE:
              this.deselectSingle(
              /** @type {?} */
              value);
              break;

            case CalendarSelection.MULTI:
              this.deselectMultiple(
              /** @type {?} */
              value);
              break;

            case CalendarSelection.RANGE:
              this.deselectRange(
              /** @type {?} */
              value);
              break;
          }
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "selectDateFromClient",
        value: function selectDateFromClient(value) {
          switch (this.selection) {
            case CalendarSelection.SINGLE:
            case CalendarSelection.MULTI:
              this.selectDate(value);
              break;

            case CalendarSelection.RANGE:
              this.selectRange(value, true);
              break;
          }
        }
      }, {
        key: "weekStart",
        get: function get() {
          return this.calendarModel.firstWeekDay;
        }
        /**
         * Sets the start day of the week.
         * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.calendarModel.firstWeekDay = value;
        }
        /**
         * Gets the `locale` of the calendar.
         * Default value is `"en"`.
         * @return {?}
         */

      }, {
        key: "locale",
        get: function get() {
          return this._locale;
        }
        /**
         * Sets the `locale` of the calendar.
         * Expects a valid BCP 47 language tag.
         * Default value is `"en"`.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._locale = value;
          this.initFormatters();
        }
        /**
         * Gets the date format options of the days view.
         * @return {?}
         */

      }, {
        key: "formatOptions",
        get: function get() {
          return this._formatOptions;
        }
        /**
         * Sets the date format options of the days view.
         * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
         * @param {?} formatOptions
         * @return {?}
         */
        ,
        set: function set(formatOptions) {
          this._formatOptions = Object.assign(this._formatOptions, formatOptions);
          this.initFormatters();
        }
        /**
         * Gets whether the `day`, `month` and `year` should be rendered
         * according to the locale and formatOptions, if any.
         * @return {?}
         */

      }, {
        key: "formatViews",
        get: function get() {
          return this._formatViews;
        }
        /**
         * Gets whether the `day`, `month` and `year` should be rendered
         * according to the locale and formatOptions, if any.
         * @param {?} formatViews
         * @return {?}
         */
        ,
        set: function set(formatViews) {
          this._formatViews = Object.assign(this._formatViews, formatViews);
        }
        /**
         *
         * Gets the selection type.
         * Default value is `"single"`.
         * Changing the type of selection resets the currently
         * selected values if any.
         * @return {?}
         */

      }, {
        key: "selection",
        get: function get() {
          return this._selection;
        }
        /**
         * Sets the selection.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          switch (value) {
            case CalendarSelection.SINGLE:
              this.selectedDates = null;
              break;

            case CalendarSelection.MULTI:
            case CalendarSelection.RANGE:
              this.selectedDates = [];
              break;

            default:
              throw new Error('Invalid selection value');
          }

          this._onChangeCallback(this.selectedDates);

          this.rangeStarted = false;
          this._selection = value;
        }
        /**
         * Gets the selected date(s).
         *
         * When selection is set to `single`, it returns
         * a single `Date` object.
         * Otherwise it is an array of `Date` objects.
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this.selectedDates;
        }
        /**
         * Sets the selected date(s).
         *
         * When selection is set to `single`, it accepts
         * a single `Date` object.
         * Otherwise it is an array of `Date` objects.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (!value || !!value &&
          /** @type {?} */
          value.length === 0) {
            return;
          }

          this.selectDate(value);
        }
        /**
         * Gets the date that is presented.
         * By default it is the current date.
         * @return {?}
         */

      }, {
        key: "viewDate",
        get: function get() {
          return this._viewDate;
        }
        /**
         * Sets the date that will be presented in the default view when the component renders.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._viewDate = this.getDateOnly(value);
        }
        /**
         * Gets the disabled dates descriptors.
         * @return {?}
         */

      }, {
        key: "disabledDates",
        get: function get() {
          return this._disabledDates;
        }
        /**
         * Sets the disabled dates' descriptors.
         * ```typescript
         * \@ViewChild("MyCalendar")
         * public calendar: IgxCalendarComponent;
         * ngOnInit(){
         *    this.calendar.disabledDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._disabledDates = value;
        }
        /**
         * Gets the special dates descriptors.
         * @return {?}
         */

      }, {
        key: "specialDates",
        get: function get() {
          return this._specialDates;
        }
        /**
         * Sets the special dates' descriptors.
         * ```typescript
         * \@ViewChild("MyCalendar")
         * public calendar: IgxCalendarComponent;
         * ngOnInit(){
         *    this.calendar.specialDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._specialDates = value;
        }
      }]);

      return IgxCalendarBase;
    }();

    IgxCalendarBase.propDecorators = {
      weekStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      locale: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      formatOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      formatViews: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      viewDate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabledDates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      specialDates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hideOutsideDays: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var CalendarView = {
      DEFAULT: 0,
      YEAR: 1,
      DECADE: 2
    };
    CalendarView[CalendarView.DEFAULT] = 'DEFAULT';
    CalendarView[CalendarView.YEAR] = 'YEAR';
    CalendarView[CalendarView.DECADE] = 'DECADE';

    var IgxMonthPickerBase =
    /*#__PURE__*/
    function (_IgxCalendarBase) {
      _inherits(IgxMonthPickerBase, _IgxCalendarBase);

      function IgxMonthPickerBase() {
        var _this107;

        _classCallCheck(this, IgxMonthPickerBase);

        _this107 = _possibleConstructorReturn(this, _getPrototypeOf(IgxMonthPickerBase).apply(this, arguments));
        /**
         * Holds month view index we are operating on.
         */

        _this107.activeViewIdx = 0;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */

        _this107.tabindex = 0;
        /**
         * @hidden
         */

        _this107._activeView = CalendarView.DEFAULT;
        return _this107;
      }
      /**
       * Gets the current active view.
       * @return {?}
       */


      _createClass(IgxMonthPickerBase, [{
        key: "changeYear",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function changeYear(event) {
          var _this108 = this;

          this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
          this.activeView = CalendarView.DEFAULT;
          requestAnimationFrame(function () {
            if (_this108.yearsBtns && _this108.yearsBtns.length) {
              _this108.yearsBtns.find(function (e, idx) {
                return idx === _this108.activeViewIdx;
              }).nativeElement.focus();
            }
          });
        }
        /**
         * @hidden
         * @param {?=} activeViewIdx
         * @return {?}
         */

      }, {
        key: "activeViewDecade",
        value: function activeViewDecade() {
          var activeViewIdx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          this._activeView = CalendarView.DECADE;
          this.activeViewIdx = activeViewIdx;
        }
        /**
         * @hidden
         * @param {?} event
         * @param {?=} activeViewIdx
         * @return {?}
         */

      }, {
        key: "activeViewDecadeKB",
        value: function activeViewDecadeKB(event) {
          var activeViewIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          if (event.key === " "
          /* SPACE */
          || event.key === "Spacebar"
          /* SPACE_IE */
          || event.key === "Enter"
          /* ENTER */
          ) {
              event.preventDefault();
              this.activeViewDecade(activeViewIdx);
            }
        }
        /**
         * Returns the locale representation of the year in the year view if enabled,
         * otherwise returns the default `Date.getFullYear()` value.
         *
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "formattedYear",
        value: function formattedYear(value) {
          if (this.formatViews.year) {
            return this.formatterYear.format(value);
          }

          return "".concat(value.getFullYear());
        }
      }, {
        key: "activeView",
        get: function get() {
          return this._activeView;
        }
        /**
         * Sets the current active view.
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._activeView = val;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isDefaultView",
        get: function get() {
          return this._activeView === CalendarView.DEFAULT;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isDecadeView",
        get: function get() {
          return this._activeView === CalendarView.DECADE;
        }
      }]);

      return IgxMonthPickerBase;
    }(IgxCalendarBase);

    IgxMonthPickerBase.propDecorators = {
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      yearsBtns: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: ['yearsBtn']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$c = 0;

    var IgxMonthsViewComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} el
       */
      function IgxMonthsViewComponent(el) {
        _classCallCheck(this, IgxMonthsViewComponent);

        this.el = el;
        /**
         * Sets/gets the `id` of the months view.
         * If not set, the `id` will have value `"igx-months-view-0"`.
         * ```html
         * <igx-months-view id="my-months-view"></igx-months-view>
         * ```
         * ```typescript
         * let monthsViewId =  this.monthsView.id;
         * ```
         * \@memberof IgxMonthsViewComponent
         */

        this.id = "igx-months-view-".concat(NEXT_ID$c++);
        /**
         * Gets/sets the selected date of the months view.
         * By default it is the current date.
         * ```html
         * <igx-months-view [date]="myDate"></igx-months-view>
         * ```
         * ```typescript
         * let date =  this.monthsView.date;
         * ```
         * \@memberof IgxMonthsViewComponent
         */

        this.date = new Date();
        /**
         * Gets/sets whether the view should be rendered
         * according to the locale and monthFormat, if any.
         */

        this.formatView = true;
        /**
         * Emits an event when a selection is made in the months view.
         * Provides reference the `date` property in the `IgxMonthsViewComponent`.
         * ```html
         * <igx-months-view (onSelection)="onSelection($event)"></igx-months-view>
         * ```
         * \@memberof IgxMonthsViewComponent
         */

        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */

        this.styleClass = true;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */

        this.tabindex = 0;
        /**
         * @hidden
         */

        this._locale = 'en';
        /**
         * @hidden
         */

        this._monthFormat = 'short';
        /**
         * @hidden
         */

        this._onTouchedCallback = function () {};
        /**
         * @hidden
         */


        this._onChangeCallback = function () {};

        this.initMonthFormatter();
        this._calendarModel = new Calendar();
      }
      /**
       * Gets the month format option of the months view.
       * ```typescript
       * let monthFormat = this.monthsView.monthFormat.
       * ```
       * @return {?}
       */


      _createClass(IgxMonthsViewComponent, [{
        key: "formattedMonth",

        /**
         * Returns the locale representation of the month in the months view.
         *
         * @hidden
         * @param {?} value
         * @return {?}
         */
        value: function formattedMonth(value) {
          if (this.formatView) {
            return this._formatterMonth.format(value);
          }

          return "".concat(value.getMonth());
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "selectMonth",
        value: function selectMonth(event) {
          this.onSelection.emit(event);
          this.date = event;

          this._onChangeCallback(this.date);
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (value) {
            this.date = value;
          }
        }
        /**
         * @hidden
         * @param {?} index
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "monthTracker",
        value: function monthTracker(index, item) {
          return "".concat(item.getMonth(), "}");
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "initMonthFormatter",
        value: function initMonthFormatter() {
          this._formatterMonth = new Intl.DateTimeFormat(this._locale, {
            month: this.monthFormat
          });
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowUp",
        value: function onKeydownArrowUp(event) {
          event.preventDefault();
          event.stopPropagation();
          /** @type {?} */

          var node = this.monthsRef.find(function (date) {
            return date.nativeElement === event.target;
          });

          if (!node) {
            return;
          }
          /** @type {?} */


          var months = this.monthsRef.toArray();
          /** @type {?} */

          var nodeRect = node.nativeElement.getBoundingClientRect();

          for (var index = months.indexOf(node) - 1; index >= 0; index--) {
            /** @type {?} */
            var nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            /** @type {?} */

            var tolerance = 6;

            if (nodeRect.top !== nextNodeRect.top && nextNodeRect.left - nodeRect.left < tolerance) {
              months[index].nativeElement.focus();
              break;
            }
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowDown",
        value: function onKeydownArrowDown(event) {
          event.preventDefault();
          event.stopPropagation();
          /** @type {?} */

          var node = this.monthsRef.find(function (date) {
            return date.nativeElement === event.target;
          });

          if (!node) {
            return;
          }
          /** @type {?} */


          var months = this.monthsRef.toArray();
          /** @type {?} */

          var nodeRect = node.nativeElement.getBoundingClientRect();

          for (var index = months.indexOf(node) + 1; index < months.length; index++) {
            /** @type {?} */
            var nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            /** @type {?} */

            var tolerance = 6;

            if (nextNodeRect.top !== nodeRect.top && nodeRect.left - nextNodeRect.left < tolerance) {
              months[index].nativeElement.focus();
              break;
            }
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowRight",
        value: function onKeydownArrowRight(event) {
          event.preventDefault();
          event.stopPropagation();
          /** @type {?} */

          var node = this.monthsRef.find(function (date) {
            return date.nativeElement === event.target;
          });

          if (!node) {
            return;
          }
          /** @type {?} */


          var months = this.monthsRef.toArray();

          if (months.indexOf(node) + 1 < months.length) {
            /** @type {?} */
            var month = months[months.indexOf(node) + 1];
            month.nativeElement.focus();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowLeft",
        value: function onKeydownArrowLeft(event) {
          event.preventDefault();
          event.stopPropagation();
          /** @type {?} */

          var node = this.monthsRef.find(function (date) {
            return date.nativeElement === event.target;
          });

          if (!node) {
            return;
          }
          /** @type {?} */


          var months = this.monthsRef.toArray();

          if (months.indexOf(node) - 1 >= 0) {
            /** @type {?} */
            var month = months[months.indexOf(node) - 1];
            month.nativeElement.focus();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownHome",
        value: function onKeydownHome(event) {
          event.preventDefault();
          event.stopPropagation();
          /** @type {?} */

          var month = this.monthsRef.toArray()[0];
          month.nativeElement.focus();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownEnd",
        value: function onKeydownEnd(event) {
          event.preventDefault();
          event.stopPropagation();
          /** @type {?} */

          var months = this.monthsRef.toArray();
          /** @type {?} */

          var month = months[months.length - 1];
          month.nativeElement.focus();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownEnter",
        value: function onKeydownEnter(event) {
          /** @type {?} */
          var value = this.monthsRef.find(function (date) {
            return date.nativeElement === event.target;
          }).value;
          this.date = new Date(value.getFullYear(), value.getMonth(), this.date.getDate());
          this.onSelection.emit(this.date);

          this._onChangeCallback(this.date);
        }
      }, {
        key: "monthFormat",
        get: function get() {
          return this._monthFormat;
        }
        /**
         * Sets the month format option of the months view.
         * ```html
         * <igx-months-view> [monthFormat] = "short'"</igx-months-view>
         * ```
         * \@memberof IgxMonthsViewComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._monthFormat = value;
          this.initMonthFormatter();
        }
        /**
         * Gets the `locale` of the months view.
         * Default value is `"en"`.
         * ```typescript
         * let locale =  this.monthsView.locale;
         * ```
         * \@memberof IgxMonthsViewComponent
         * @return {?}
         */

      }, {
        key: "locale",
        get: function get() {
          return this._locale;
        }
        /**
         * Sets the `locale` of the months view.
         * Expects a valid BCP 47 language tag.
         * Default value is `"en"`.
         * ```html
         * <igx-months-view [locale]="de"></igx-months-view>
         * ```
         * \@memberof IgxMonthsViewComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._locale = value;
          this.initMonthFormatter();
        }
        /**
         * Returns an array of date objects which are then used to
         * properly render the month names.
         *
         * Used in the template of the component
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "months",
        get: function get() {
          /** @type {?} */
          var start = new Date(this.date.getFullYear(), 0, 1);
          /** @type {?} */

          var result = [];

          for (var i = 0; i < 12; i++) {
            result.push(start);
            start = this._calendarModel.timedelta(start, 'month', 1);
          }

          return result;
        }
      }]);

      return IgxMonthsViewComponent;
    }();

    IgxMonthsViewComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxMonthsViewComponent,
          multi: true
        }],
        selector: 'igx-months-view',
        template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-row--wrap\">\n        <div [igxCalendarMonth]=\"month\" [date]=\"date\" (onMonthSelection)=\"selectMonth($event)\" [index]=\"i\" *ngFor=\"let month of months; index as i; trackBy: monthTracker\">\n            {{ formattedMonth(month) | titlecase }}\n        </div>\n    </div>\n</div>\n\n"
      }]
    }];
    /** @nocollapse */

    IgxMonthsViewComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxMonthsViewComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      date: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      monthFormat: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      locale: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      formatView: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      styleClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar']
      }],
      monthsRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxCalendarMonthDirective, {
          read: IgxCalendarMonthDirective
        }]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      onKeydownArrowUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowup', ['$event']]
      }],
      onKeydownArrowDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowdown', ['$event']]
      }],
      onKeydownArrowRight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowright', ['$event']]
      }],
      onKeydownArrowLeft: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowleft', ['$event']]
      }],
      onKeydownHome: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.home', ['$event']]
      }],
      onKeydownEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.end', ['$event']]
      }],
      onKeydownEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.enter', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$d = 0;

    var CalendarHammerConfig =
    /*#__PURE__*/
    function (_angular_platform_bro) {
      _inherits(CalendarHammerConfig, _angular_platform_bro);

      function CalendarHammerConfig() {
        var _this109;

        _classCallCheck(this, CalendarHammerConfig);

        _this109 = _possibleConstructorReturn(this, _getPrototypeOf(CalendarHammerConfig).apply(this, arguments));
        _this109.overrides = {
          pan: {
            direction: Hammer.DIRECTION_VERTICAL,
            threshold: 1
          }
        };
        return _this109;
      }

      return CalendarHammerConfig;
    }(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HammerGestureConfig"]);

    CalendarHammerConfig.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];

    var IgxYearsViewComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} el
       */
      function IgxYearsViewComponent(el) {
        _classCallCheck(this, IgxYearsViewComponent);

        this.el = el;
        /**
         * Sets/gets the `id` of the years view.
         * If not set, the `id` will have value `"igx-years-view-0"`.
         * ```html
         * <igx-years-view id = "my-years-view"></igx-years-view>
         * ```
         * ```typescript
         * let yearsViewId =  this.yearsView.id;
         * ```
         * \@memberof IgxCalendarComponent
         */

        this.id = "igx-years-view-".concat(NEXT_ID$d++);
        /**
         * Gets/sets the selected date of the years view.
         * By default it is the current date.
         * ```html
         * <igx-years-view [date]="myDate"></igx-years-view>
         * ```
         * ```typescript
         * let date =  this.yearsView.date;
         * ```
         * \@memberof IgxYearsViewComponent
         */

        this.date = new Date();
        /**
         * Emits an event when a selection is made in the years view.
         * Provides reference the `date` property in the `IgxYearsViewComponent`.
         * ```html
         * <igx-years-view (onSelection)="onSelection($event)"></igx-years-view>
         * ```
         * \@memberof IgxYearsViewComponent
         */

        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */

        this.styleClass = true;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */

        this.tabindex = 0;
        /**
         * @hidden
         */

        this._locale = 'en';
        /**
         * @hidden
         */

        this._yearFormat = 'numeric';
        /**
         * @hidden
         */

        this._onTouchedCallback = function () {};
        /**
         * @hidden
         */


        this._onChangeCallback = function () {};

        this.initYearFormatter();
        this._calendarModel = new Calendar();
      }
      /**
       * Gets the year format option of the years view.
       * ```typescript
       * let yearFormat = this.yearsView.yearFormat.
       * ```
       * @return {?}
       */


      _createClass(IgxYearsViewComponent, [{
        key: "formattedYear",

        /**
         * Returns the locale representation of the year in the years view.
         *
         * @hidden
         * @param {?} value
         * @return {?}
         */
        value: function formattedYear(value) {
          if (this.formatView) {
            return this._formatterYear.format(value);
          }

          return "".concat(value.getFullYear());
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "selectYear",
        value: function selectYear(event) {
          this.date = event;
          this.onSelection.emit(this.date);

          this._onChangeCallback(this.date);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "scroll",
        value: function scroll(event) {
          event.preventDefault();
          event.stopPropagation();
          /** @type {?} */

          var delta = event.deltaY < 0 ? -1 : 1;
          this.generateYearRange(delta);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "pan",
        value: function pan(event) {
          /** @type {?} */
          var delta = event.deltaY < 0 ? 1 : -1;
          this.generateYearRange(delta);
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
        /**
         * @hidden
         * @param {?} index
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "yearTracker",
        value: function yearTracker(index, item) {
          return "".concat(item.getFullYear(), "}");
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (value) {
            this.date = value;
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowDown",
        value: function onKeydownArrowDown(event) {
          event.preventDefault();
          event.stopPropagation();
          this.generateYearRange(1);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowUp",
        value: function onKeydownArrowUp(event) {
          event.preventDefault();
          event.stopPropagation();
          this.generateYearRange(-1);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onKeydownEnter",
        value: function onKeydownEnter() {
          this.onSelection.emit(this.date);

          this._onChangeCallback(this.date);
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "initYearFormatter",
        value: function initYearFormatter() {
          this._formatterYear = new Intl.DateTimeFormat(this._locale, {
            year: this.yearFormat
          });
        }
        /**
         * @hidden
         * @private
         * @param {?} delta
         * @return {?}
         */

      }, {
        key: "generateYearRange",
        value: function generateYearRange(delta) {
          /** @type {?} */
          var currentYear = new Date().getFullYear();

          if (delta > 0 && this.date.getFullYear() - currentYear >= 95 || delta < 0 && currentYear - this.date.getFullYear() >= 95) {
            return;
          }

          this.date = this._calendarModel.timedelta(this.date, 'year', delta);
        }
      }, {
        key: "yearFormat",
        get: function get() {
          return this._yearFormat;
        }
        /**
         * Sets the year format option of the years view.
         * ```html
         * <igx-years-view [yearFormat]="numeric"></igx-years-view>
         * ```
         * \@memberof IgxYearsViewComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._yearFormat = value;
          this.initYearFormatter();
        }
        /**
         * Gets the `locale` of the years view.
         * Default value is `"en"`.
         * ```typescript
         * let locale =  this.yearsView.locale;
         * ```
         * \@memberof IgxYearsViewComponent
         * @return {?}
         */

      }, {
        key: "locale",
        get: function get() {
          return this._locale;
        }
        /**
         * Sets the `locale` of the years view.
         * Expects a valid BCP 47 language tag.
         * Default value is `"en"`.
         * ```html
         * <igx-years-view [locale]="de"></igx-years-view>
         * ```
         * \@memberof IgxYearsViewComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._locale = value;
          this.initYearFormatter();
        }
        /**
         * Returns an array of date objects which are then used to properly
         * render the years.
         *
         * Used in the template of the component.
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "decade",
        get: function get() {
          /** @type {?} */
          var result = [];
          /** @type {?} */

          var start = this.date.getFullYear() - 3;
          /** @type {?} */

          var end = this.date.getFullYear() + 4;
          var _iteratorNormalCompletion33 = true;
          var _didIteratorError33 = false;
          var _iteratorError33 = undefined;

          try {
            for (var _iterator33 = range(start, end)[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
              var year = _step33.value;
              result.push(new Date(year, this.date.getMonth(), this.date.getDate()));
            }
          } catch (err) {
            _didIteratorError33 = true;
            _iteratorError33 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion33 && _iterator33["return"] != null) {
                _iterator33["return"]();
              }
            } finally {
              if (_didIteratorError33) {
                throw _iteratorError33;
              }
            }
          }

          return result;
        }
      }]);

      return IgxYearsViewComponent;
    }();

    IgxYearsViewComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxYearsViewComponent,
          multi: true
        }, {
          provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HAMMER_GESTURE_CONFIG"],
          useClass: CalendarHammerConfig
        }],
        selector: 'igx-years-view',
        template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span [igxCalendarYear]=\"year\" [date]=\"date\" (onYearSelection)=\"selectYear($event)\" *ngFor=\"let year of decade; trackBy: yearTracker\">\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxYearsViewComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxYearsViewComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      date: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      yearFormat: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      locale: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      formatView: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      styleClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar']
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      onKeydownArrowDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowdown', ['$event']]
      }],
      onKeydownArrowUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowup', ['$event']]
      }],
      onKeydownEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.enter']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxDayItemComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       */
      function IgxDayItemComponent(elementRef) {
        _classCallCheck(this, IgxDayItemComponent);

        this.elementRef = elementRef;
        this.hideOutsideDays = false;
        this.isLastInRange = false;
        this.isFirstInRange = false;
        this.isWithinRange = false;
        this.onDateSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._selected = false;
      }
      /**
       * Returns boolean indicating if the day is selected
       *
       * @return {?}
       */


      _createClass(IgxDayItemComponent, [{
        key: "onSelect",

        /**
         * @return {?}
         */
        value: function onSelect() {
          this.onDateSelection.emit(this.date);
        }
      }, {
        key: "selected",
        get: function get() {
          return this._selected;
        }
        /**
         * Selects the day
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._selected = value;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isCurrentMonth",
        get: function get() {
          return this.date.isCurrentMonth;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isPreviousMonth",
        get: function get() {
          return this.date.isPrevMonth;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isNextMonth",
        get: function get() {
          return this.date.isNextMonth;
        }
        /**
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.elementRef.nativeElement;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isSelectedCSS",
        get: function get() {
          return !this.isDisabled && this.selected;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isInactive",
        get: function get() {
          return this.date.isNextMonth || this.date.isPrevMonth;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isHidden",
        get: function get() {
          return this.hideOutsideDays && this.isInactive;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isToday",
        get: function get() {
          /** @type {?} */
          var today = new Date(Date.now());
          /** @type {?} */

          var date = this.date.date;
          return date.getFullYear() === today.getFullYear() && date.getMonth() === today.getMonth() && date.getDate() === today.getDate();
        }
        /**
         * @return {?}
         */

      }, {
        key: "isWeekend",
        get: function get() {
          /** @type {?} */
          var day = this.date.date.getDay();
          return day === 0 || day === 6;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isDisabled",
        get: function get() {
          if (this.disabledDates === null) {
            return false;
          }

          return isDateInRanges(this.date.date, this.disabledDates);
        }
        /**
         * @return {?}
         */

      }, {
        key: "isOutOfRange",
        get: function get() {
          if (!this.outOfRangeDates) {
            return false;
          }

          return isDateInRanges(this.date.date, this.outOfRangeDates);
        }
        /**
         * @return {?}
         */

      }, {
        key: "isFocusable",
        get: function get() {
          return this.isCurrentMonth && !this.isHidden && !this.isDisabled && !this.isOutOfRange;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isWithinRangeCSS",
        get: function get() {
          return !this.isSingleSelection && this.isWithinRange;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isSpecial",
        get: function get() {
          if (this.specialDates === null) {
            return false;
          }

          return isDateInRanges(this.date.date, this.specialDates);
        }
        /**
         * @return {?}
         */

      }, {
        key: "defaultCSS",
        get: function get() {
          return this.date.isCurrentMonth && !(this.isWeekend && this.selected);
        }
        /**
         * @return {?}
         */

      }, {
        key: "isDisabledCSS",
        get: function get() {
          return this.isHidden || this.isDisabled || this.isOutOfRange;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isSingleSelection",
        get: function get() {
          return this.selection !== CalendarSelection.RANGE;
        }
        /**
         * @return {?}
         */

      }, {
        key: "tabindex",
        get: function get() {
          return this.isDisabled || this.isHidden ? -1 : 0;
        }
      }]);

      return IgxDayItemComponent;
    }();

    IgxDayItemComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-day-item',
        template: "<span class=\"igx-calendar__date-content\">\n    <ng-content></ng-content>\n</span>\n"
      }]
    }];
    /** @nocollapse */

    IgxDayItemComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxDayItemComponent.propDecorators = {
      date: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabledDates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      outOfRangeDates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      specialDates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hideOutsideDays: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isLastInRange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--last']
      }],
      isFirstInRange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--first']
      }],
      isWithinRange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onDateSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      isSelectedCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--selected']
      }],
      isInactive: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--inactive']
      }],
      isHidden: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--hidden']
      }],
      isToday: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--current']
      }],
      isWeekend: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--weekend']
      }],
      isWithinRangeCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--range']
      }],
      isSpecial: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--special']
      }],
      defaultCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date']
      }],
      isDisabledCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--disabled']
      }],
      isSingleSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar__date--single']
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      onSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.enter']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var Direction = {
      Up: 'ArrowUp',
      Down: 'ArrowDown',
      Left: 'ArrowLeft',
      Right: 'ArrowRight'
    };
    /** @type {?} */

    var ARROW = 'Arrow';
    /**
     * @hidden
     */

    var IgxDaysViewNavigationService =
    /*#__PURE__*/
    function () {
      function IgxDaysViewNavigationService() {
        _classCallCheck(this, IgxDaysViewNavigationService);
      }

      _createClass(IgxDaysViewNavigationService, [{
        key: "focusNextDate",

        /**
         * Implements kb navigation in all MoveDirections. nextDate and nextMonthView naming convention is used for both previous/next
         * @hidden
         * @param {?} target
         * @param {?} key
         * @param {?=} nextView
         * @return {?}
         */
        value: function focusNextDate(target, key) {
          var nextView = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (target.childElementCount === 0) {
            target = target.parentElement;
          }

          if (key.indexOf('Arrow') === -1) {
            key = ARROW.concat(key);
          }
          /** @type {?} */


          var monthView = this.monthView;
          /** @type {?} */

          var node = monthView.dates.find(function (date) {
            return date.nativeElement === target;
          });
          /** @type {?} */

          var dates = monthView.dates.toArray();
          /** @type {?} */

          var day;
          /** @type {?} */

          var step;
          /** @type {?} */

          var i;
          /** @type {?} */

          var nextDate;
          /** @type {?} */

          var index = dates.indexOf(node);

          if (!node) {
            return;
          } // focus item in current month


          switch (key) {
            case Direction.Left:
              {
                step = -1;
                nextDate = this.timedelta(node.date.date, step);

                for (i = index; i > 0; i--) {
                  day = nextView ? dates[i] : dates[i - 1];
                  nextDate = day.date.date;

                  if (day.date.isPrevMonth) {
                    break;
                  }

                  if (day && day.isFocusable) {
                    day.nativeElement.focus();
                    return;
                  }
                }

                break;
              }

            case Direction.Right:
              {
                step = 1;
                nextDate = this.timedelta(node.date.date, step);

                for (i = index; i < dates.length - 1; i++) {
                  day = nextView ? dates[i] : dates[i + 1];
                  nextDate = day.date.date;

                  if (day.date.isNextMonth) {
                    break;
                  }

                  if (day && day.isFocusable) {
                    day.nativeElement.focus();
                    return;
                  }
                }

                break;
              }

            case Direction.Up:
              {
                step = -7;
                nextDate = this.timedelta(node.date.date, step);

                for (i = index; i - 7 > -1; i -= 7) {
                  day = nextView ? dates[i] : dates[i - 7];
                  nextDate = day.date.date;

                  if (day.date.isPrevMonth) {
                    break;
                  }

                  if (day && day.isFocusable) {
                    day.nativeElement.focus();
                    return;
                  }
                }

                break;
              }

            case Direction.Down:
              {
                step = 7;
                nextDate = this.timedelta(node.date.date, step);

                for (i = index; i + 7 < 42; i += 7) {
                  day = nextView ? dates[i] : dates[i + 7];
                  nextDate = day.date.date;

                  if (day.date.isNextMonth) {
                    break;
                  }

                  if (day && day.isFocusable) {
                    day.nativeElement.focus();
                    return;
                  }
                }

                break;
              }
          } // focus item in prev/next visible month

          /** @type {?} */


          var nextMonthView = step > 0 ? monthView.nextMonthView : monthView.prevMonthView;

          if (nextMonthView) {
            dates = nextMonthView.dates.toArray();
            day = dates.find(function (item) {
              return item.date.date.getTime() === nextDate.getTime();
            });

            if (day && day.isFocusable) {
              day.nativeElement.focus();
              return;
            }

            nextMonthView.daysNavService.focusNextDate(day.nativeElement, key);
          } // if iterating in the visible prev/next moths above found a day that is not focusable, ie is disabled, hidden, etc
          // then it is needed to recalculate the next day, which is going to be part of the prev/next months


          if (day && !day.isFocusable) {
            day = dates[i + step];

            if (!day) {
              nextDate = this.timedelta(node.date.date, step + i - index);
            }
          } // focus item in prev/next month, which is currently out of view

          /** @type {?} */


          var dayIsNextMonth;

          if (day) {
            dayIsNextMonth = step > 0 ? day.date.isNextMonth : day.date.isPrevMonth;
          }

          if (monthView.changeDaysView && !nextMonthView && (day && dayIsNextMonth || !day)) {
            /** @type {?} */
            var monthAction = step > 0 ? ScrollMonth.NEXT : ScrollMonth.PREV;
            monthView.onViewChanging.emit({
              monthAction: monthAction,
              key: key,
              nextDate: nextDate
            });
          }
        }
        /**
         * Focuses first focusable day in the month. Will go to next visible month, if no day in the first month is focusable
         * @hidden
         * @return {?}
         */

      }, {
        key: "focusHomeDate",
        value: function focusHomeDate() {
          /** @type {?} */
          var monthView = this.monthView;

          while (!this.focusFirstDay(monthView) && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
          }
        }
        /**
         * Focuses last focusable day in the month. Will go to previous visible month, if no day in the first month is focusable
         * @hidden
         * @return {?}
         */

      }, {
        key: "focusEndDate",
        value: function focusEndDate() {
          /** @type {?} */
          var monthView = this.monthView;

          while (!this.focusLastDay(monthView) && monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
          }
        }
        /**
         * @private
         * @param {?} date
         * @param {?} units
         * @return {?}
         */

      }, {
        key: "timedelta",
        value: function timedelta(date, units) {
          /** @type {?} */
          var ret = new Date(date);
          ret.setDate(ret.getDate() + units);
          return ret;
        }
        /**
         * @private
         * @param {?} monthView
         * @return {?}
         */

      }, {
        key: "focusFirstDay",
        value: function focusFirstDay(monthView) {
          /** @type {?} */
          var dates = monthView.dates.filter(function (d) {
            return d.isCurrentMonth;
          });

          for (var i = 0; i < dates.length; i++) {
            if (dates[i].isFocusable) {
              dates[i].nativeElement.focus();
              return true;
            }
          }

          return false;
        }
        /**
         * @private
         * @param {?} monthView
         * @return {?}
         */

      }, {
        key: "focusLastDay",
        value: function focusLastDay(monthView) {
          /** @type {?} */
          var dates = monthView.dates.filter(function (d) {
            return d.isCurrentMonth;
          });

          for (var i = dates.length - 1; i >= 0; i--) {
            if (dates[i].isFocusable) {
              dates[i].nativeElement.focus();
              return true;
            }
          }

          return false;
        }
      }]);

      return IgxDaysViewNavigationService;
    }();

    IgxDaysViewNavigationService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$e = 0;

    var IgxDaysViewComponent =
    /*#__PURE__*/
    function (_IgxCalendarBase2) {
      _inherits(IgxDaysViewComponent, _IgxCalendarBase2);

      /**
       * @hidden
       * @param {?} daysNavService
       */
      function IgxDaysViewComponent(daysNavService) {
        var _this110;

        _classCallCheck(this, IgxDaysViewComponent);

        _this110 = _possibleConstructorReturn(this, _getPrototypeOf(IgxDaysViewComponent).call(this));
        _this110.daysNavService = daysNavService;
        /**
         * Sets/gets the `id` of the days view.
         * If not set, the `id` will have value `"igx-days-view-0"`.
         * ```html
         * <igx-days-view id="my-days-view"></igx-days-view>
         * ```
         * ```typescript
         * let daysViewId =  this.daysView.id;
         * ```
         */

        _this110.id = "igx-days-view-".concat(NEXT_ID$e++);
        /**
         * @hidden
         */

        _this110.changeDaysView = false;
        /**
         * @hidden
         */

        _this110.onDateSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this110.onViewChanging = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */

        _this110.styleClass = true;
        return _this110;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxDaysViewComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this.daysNavService.monthView = this;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (!this.changeDaysView && this.dates) {
            this.disableOutOfRangeDates();
          }
        }
        /**
         * Returns the locale representation of the date in the days view.
         *
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "formattedDate",
        value: function formattedDate(value) {
          if (this.formatViews.day) {
            return this.formatterDay.format(value);
          }

          return "".concat(value.getDate());
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "generateWeekHeader",
        value: function generateWeekHeader() {
          /** @type {?} */
          var dayNames = [];
          /** @type {?} */

          var rv = this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth())[0];
          var _iteratorNormalCompletion34 = true;
          var _didIteratorError34 = false;
          var _iteratorError34 = undefined;

          try {
            for (var _iterator34 = rv[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
              var day = _step34.value;
              dayNames.push(this.formatterWeekday.format(day.date));
            }
          } catch (err) {
            _didIteratorError34 = true;
            _iteratorError34 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion34 && _iterator34["return"] != null) {
                _iterator34["return"]();
              }
            } finally {
              if (_didIteratorError34) {
                throw _iteratorError34;
              }
            }
          }

          return dayNames;
        }
        /**
         * @hidden
         * @param {?} index
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "rowTracker",
        value: function rowTracker(index, item) {
          return "".concat(item[index].date.getMonth()).concat(item[index].date.getDate());
        }
        /**
         * @hidden
         * @param {?} index
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "dateTracker",
        value: function dateTracker(index, item) {
          return "".concat(item.date.getMonth(), "--").concat(item.date.getDate());
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isCurrentMonth",
        value: function isCurrentMonth(value) {
          return this.viewDate.getMonth() === value.getMonth();
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isCurrentYear",
        value: function isCurrentYear(value) {
          return this.viewDate.getFullYear() === value.getFullYear();
        }
        /**
         * @hidden
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "isSelected",
        value: function isSelected(date) {
          /** @type {?} */
          var selectedDates;

          if (this.isDateDisabled(date.date) || !this.value || Array.isArray(this.value) && this.value.length === 0) {
            return false;
          }

          if (this.selection === CalendarSelection.SINGLE) {
            selectedDates =
            /** @type {?} */
            this.value;
            return this.getDateOnly(selectedDates).getTime() === date.date.getTime();
          }

          selectedDates =
          /** @type {?} */
          this.value;

          if (this.selection === CalendarSelection.RANGE && selectedDates.length === 1) {
            return this.getDateOnly(selectedDates[0]).getTime() === date.date.getTime();
          }

          if (this.selection === CalendarSelection.MULTI) {
            /** @type {?} */
            var _start2 = this.getDateOnly(selectedDates[0]);
            /** @type {?} */


            var end = this.getDateOnly(selectedDates[selectedDates.length - 1]);

            if (this.isWithinRange(date.date, false, _start2, end)) {
              /** @type {?} */
              var currentDate = selectedDates.find(function (element) {
                return element.getTime() === date.date.getTime();
              });
              return !!currentDate;
            } else {
              return false;
            }
          } else {
            return this.isWithinRange(date.date, true);
          }
        }
        /**
         * @hidden
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "isLastInRange",
        value: function isLastInRange(date) {
          if (this.isSingleSelection || !this.value) {
            return false;
          }
          /** @type {?} */


          var dates =
          /** @type {?} */
          this.value;
          /** @type {?} */

          var lastDate = dates[dates.length - 1];
          return isEqual(lastDate, date.date);
        }
        /**
         * @hidden
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "isFirstInRange",
        value: function isFirstInRange(date) {
          if (this.isSingleSelection || !this.value) {
            return false;
          }

          return isEqual(
          /** @type {?} */
          this.value[0], date.date);
        }
        /**
         * @hidden
         * @param {?} date
         * @param {?} checkForRange
         * @param {?=} min
         * @param {?=} max
         * @return {?}
         */

      }, {
        key: "isWithinRange",
        value: function isWithinRange(date, checkForRange, min, max) {
          if (checkForRange && !(Array.isArray(this.value) && this.value.length > 1)) {
            return false;
          }

          min = min ? min : this.value[0];
          max = max ? max : this.value[
          /** @type {?} */
          this.value.length - 1];
          return isDateInRanges(date, [{
            type: DateRangeType.Between,
            dateRange: [min, max]
          }]);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "focusActiveDate",
        value: function focusActiveDate() {
          /** @type {?} */
          var date = this.dates.find(function (d) {
            return d.selected;
          });

          if (!date) {
            date = this.dates.find(function (d) {
              return d.isToday;
            });
          }

          if (date.isFocusable) {
            date.nativeElement.focus();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "selectDay",
        value: function selectDay(event) {
          this.selectDateFromClient(event.date);
          this.onDateSelection.emit(event);
          this.onSelection.emit(this.selectedDates);
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "disableOutOfRangeDates",
        value: function disableOutOfRangeDates() {
          /** @type {?} */
          var dateRange = [];
          this.dates.toArray().forEach(function (date) {
            if (!date.isCurrentMonth) {
              dateRange.push(date.date.date);
            }
          });
          this.outOfRangeDates = [{
            type: DateRangeType.Specific,
            dateRange: dateRange
          }];
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getFirstMonthView",
        value: function getFirstMonthView() {
          /** @type {?} */
          var monthView =
          /** @type {?} */
          this;

          while (monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
          }

          return monthView;
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "getLastMonthView",
        value: function getLastMonthView() {
          /** @type {?} */
          var monthView =
          /** @type {?} */
          this;

          while (monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
          }

          return monthView;
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "onKeydownArrow",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function onKeydownArrow(event) {
          event.preventDefault();
          event.stopPropagation();
          this.daysNavService.focusNextDate(
          /** @type {?} */
          event.target, event.key);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownHome",
        value: function onKeydownHome(event) {
          event.preventDefault();
          event.stopPropagation();
          this.getFirstMonthView().daysNavService.focusHomeDate();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownEnd",
        value: function onKeydownEnd(event) {
          event.preventDefault();
          event.stopPropagation();
          this.getLastMonthView().daysNavService.focusEndDate();
        }
      }, {
        key: "getCalendarMonth",
        get: function get() {
          return this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth(), true);
        }
      }, {
        key: "isSingleSelection",
        get: function get() {
          return this.selection !== CalendarSelection.RANGE;
        }
      }]);

      return IgxDaysViewComponent;
    }(IgxCalendarBase);

    IgxDaysViewComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          multi: true,
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxDaysViewComponent
        }, {
          provide: IgxDaysViewNavigationService,
          useClass: IgxDaysViewNavigationService
        }],
        selector: 'igx-days-view',
        template: "<div class=\"igx-calendar__body-row\">\n    <span *ngFor=\"let dayName of generateWeekHeader()\" class=\"igx-calendar__label\">\n        {{ dayName | titlecase }}\n    </span>\n</div>\n\n<div *ngFor=\"let week of getCalendarMonth; last as isLast; index as i; trackBy: rowTracker\"\n    class=\"igx-calendar__body-row\">\n    <igx-day-item\n        *ngFor=\"let day of week; trackBy: dateTracker\"\n        [date]=\"day\"\n        [selection]=\"selection\"\n        [selected]=\"isSelected(day)\"\n        [isLastInRange]=\"isLastInRange(day)\"\n        [isFirstInRange]=\"isFirstInRange(day)\"\n        [isWithinRange]=\"isWithinRange(day.date, true)\"\n        [disabledDates]=\"disabledDates\"\n        [specialDates]=\"specialDates\"\n        [outOfRangeDates]=\"outOfRangeDates\"\n        [hideOutsideDays]=\"hideOutsideDays\"\n        (onDateSelection)=\"selectDay($event)\">\n        {{ formattedDate(day.date) }}\n    </igx-day-item>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxDaysViewComponent.ctorParameters = function () {
      return [{
        type: IgxDaysViewNavigationService
      }];
    };

    IgxDaysViewComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      changeDaysView: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onDateSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onViewChanging: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      dates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxDayItemComponent, {
          read: IgxDayItemComponent
        }]
      }],
      styleClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar']
      }],
      onKeydownArrow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowleft', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowright', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowup', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowdown', ['$event']]
      }],
      onKeydownHome: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.home', ['$event']]
      }],
      onKeydownEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.end', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$f = 0;
    /**
     * Calendar provides a way to display date information.
     *
     * \@igxModule IgxCalendarModule
     *
     * \@igxTheme igx-calendar-theme, igx-icon-theme
     *
     * \@igxKeywords calendar, datepicker, schedule, date
     *
     * \@igxGroup Scheduling
     *
     * \@remarks
     * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
     * or range selection.
     *
     * \@example:
     * ```html
     * <igx-calendar selection="range"></igx-calendar>
     * ```
     */

    var IgxCalendarComponent =
    /*#__PURE__*/
    function (_IgxMonthPickerBase) {
      _inherits(IgxCalendarComponent, _IgxMonthPickerBase);

      function IgxCalendarComponent() {
        var _this111;

        _classCallCheck(this, IgxCalendarComponent);

        _this111 = _possibleConstructorReturn(this, _getPrototypeOf(IgxCalendarComponent).apply(this, arguments));
        /**
         * Sets/gets the `id` of the calendar.
         *
         * \@remarks
         * If not set, the `id` will have value `"igx-calendar-0"`.
         *
         * \@example
         * ```html
         * <igx-calendar id="my-first-calendar"></igx-calendar>
         * ```
         * \@memberof IgxCalendarComponent
         */

        _this111.id = "igx-calendar-".concat(NEXT_ID$f++);
        /**
         * Sets/gets whether the calendar has header.
         * Default value is `true`.
         *
         * \@example
         * ```html
         * <igx-calendar [hasHeader]="false"></igx-calendar>
         * ```
         */

        _this111.hasHeader = true;
        /**
         * Sets/gets whether the calendar header will be in vertical position.
         * Default value is `false`.
         *
         * \@example
         * ```html
         * <igx-calendar [vertical] = "true"></igx-calendar>
         * ```
         */

        _this111.vertical = false;
        /**
         * Apply the different states for the transitions of animateChange
         * @hidden
         * \@internal
         */

        _this111.animationAction = '';
        /**
         * Denote if the calendar view was changed with the keyboard
         *
         * @hidden
         * \@internal
         */

        _this111.isKeydownTrigger = false;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         * \@internal
         */

        _this111.tabindex = 0;
        /**
         * The default aria role attribute for the component.
         *
         * @hidden
         * \@internal
         */

        _this111.role = 'grid';
        /**
         * The default aria lebelled by attribute for the component.
         *
         * @hidden
         * \@internal
         */

        _this111.ariaLabelledBy = 'calendar';
        /**
         * The default css class applied to the component.
         *
         * @hidden
         * \@internal
         */

        _this111.styleClass = true;
        /**
         * @hidden
         * \@internal
         */

        _this111._monthsViewNumber = 1;
        /**
         * Continious navigation through the previous months
         * @hidden
         * \@internal
         */

        _this111.startPrevMonthScroll = function () {
          var isKeydownTrigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          _this111.startMonthScroll$.next();

          _this111.monthScrollDirection = ScrollMonth.PREV;

          _this111.previousMonth(isKeydownTrigger);
        };
        /**
         * Continious navigation through the next months
         * @hidden
         * \@internal
         */


        _this111.startNextMonthScroll = function () {
          var isKeydownTrigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          _this111.startMonthScroll$.next();

          _this111.monthScrollDirection = ScrollMonth.NEXT;

          _this111.nextMonth(isKeydownTrigger);
        };
        /**
         * Stop continuous navigation
         * @hidden
         * \@internal
         */


        _this111.stopMonthScroll = function (event) {
          event.stopPropagation(); // generally the scrolling is built on the calendar component
          // and all start/stop scrolling methods are called on the calendar
          // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,
          // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen

          _this111.daysView.stopMonthScroll$.next(true);

          _this111.daysView.stopMonthScroll$.complete();

          if (_this111.monthScrollDirection === ScrollMonth.PREV) {
            _this111.prevMonthBtn.nativeElement.focus();
          } else if (_this111.monthScrollDirection === ScrollMonth.NEXT) {
            _this111.nextMonthBtn.nativeElement.focus();
          }

          _this111.monthScrollDirection = ScrollMonth.NONE;
        };

        return _this111;
      }
      /**
       * Sets/gets the number of month views displayed.
       * Default value is `1`.
       *
       * \@example
       * ```html
       * <igx-calendar [monthsViewNumber]="2"></igx-calendar>
       * ```
       * @return {?}
       */


      _createClass(IgxCalendarComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          var _this112 = this;

          this.setSiblingMonths(this.monthViews);
          this._monthViewsChanges$ = this.monthViews.changes.subscribe(function (c) {
            _this112.setSiblingMonths(c);
          });
          this.startMonthScroll$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.stopMonthScroll$), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["switchMap"])(function () {
            return _this112.scrollMonth$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["skipLast"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounce"])(function () {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(300);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this112.stopMonthScroll$));
          })).subscribe(function () {
            switch (_this112.monthScrollDirection) {
              case ScrollMonth.PREV:
                _this112.previousMonth();

                break;

              case ScrollMonth.NEXT:
                _this112.nextMonth();

                break;

              case ScrollMonth.NONE:
              default:
                break;
            }
          });
        }
        /**
         * Returns the locale representation of the month in the month view if enabled,
         * otherwise returns the default `Date.getMonth()` value.
         *
         * @hidden
         * \@internal
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "formattedMonth",
        value: function formattedMonth(value) {
          if (this.formatViews.month) {
            return this.formatterMonth.format(value);
          }

          return "".concat(value.getMonth());
        }
        /**
         * Change to previous month
         *
         * @hidden
         * \@internal
         * @param {?=} isKeydownTrigger
         * @return {?}
         */

      }, {
        key: "previousMonth",
        value: function previousMonth() {
          var isKeydownTrigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          this.viewDate = this.calendarModel.getPrevMonth(this.viewDate);
          this.animationAction = ScrollMonth.PREV;
          this.isKeydownTrigger = isKeydownTrigger;
        }
        /**
         * Change to next month
         *
         * @hidden
         * \@internal
         * @param {?=} isKeydownTrigger
         * @return {?}
         */

      }, {
        key: "nextMonth",
        value: function nextMonth() {
          var isKeydownTrigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          this.viewDate = this.calendarModel.getNextMonth(this.viewDate);
          this.animationAction = ScrollMonth.NEXT;
          this.isKeydownTrigger = isKeydownTrigger;
        }
        /**
         * @hidden
         * \@internal
         * @param {?} args
         * @param {?} activeViewIdx
         * @return {?}
         */

      }, {
        key: "onActiveViewDecade",
        value: function onActiveViewDecade(args, activeViewIdx) {
          var _this113 = this;

          _get(_getPrototypeOf(IgxCalendarComponent.prototype), "activeViewDecade", this).call(this, activeViewIdx);

          requestAnimationFrame(function () {
            if (_this113.dacadeView) {
              _this113.dacadeView.date = args;

              _this113.dacadeView.el.nativeElement.focus();
            }
          });
        }
        /**
         * @hidden
         * \@internal
         * @param {?} event
         * @param {?} args
         * @param {?} activeViewIdx
         * @return {?}
         */

      }, {
        key: "onActiveViewDecadeKB",
        value: function onActiveViewDecadeKB(event, args, activeViewIdx) {
          var _this114 = this;

          _get(_getPrototypeOf(IgxCalendarComponent.prototype), "activeViewDecadeKB", this).call(this, event, activeViewIdx);

          requestAnimationFrame(function () {
            if (_this114.dacadeView) {
              _this114.dacadeView.date = args;

              _this114.dacadeView.el.nativeElement.focus();
            }
          });
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "getFormattedDate",
        value: function getFormattedDate() {
          /** @type {?} */
          var date = this.headerDate;
          return {
            monthday: this.formatterMonthday.format(date),
            weekday: this.formatterWeekday.format(date)
          };
        }
        /**
         * Handles invoked on date selection
         * @hidden
         * \@internal
         * @param {?} instance
         * @return {?}
         */

      }, {
        key: "childClicked",
        value: function childClicked(instance) {
          if (instance.isPrevMonth) {
            this.previousMonth();
          }

          if (instance.isNextMonth) {
            this.nextMonth();
          }

          this.selectDateFromClient(instance.date);

          if (this.selection === 'multi') {
            this.deselectDateInMonthViews(instance.date);
          }

          this.onSelection.emit(this.selectedDates);
        }
        /**
         * @hidden
         * \@internal
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "viewChanging",
        value: function viewChanging(args) {
          var _this115 = this;

          this.animationAction = args.monthAction;
          this.isKeydownTrigger = true;
          this.nextDate = args.nextDate;

          this.callback = function (next) {
            /** @type {?} */
            var day = _this115.daysView.dates.find(function (item) {
              return item.date.date.getTime() === next.getTime();
            });

            if (day) {
              _this115.daysView.daysNavService.focusNextDate(day.nativeElement, args.key, true);
            }
          };

          this.viewDate = this.nextDate;
        }
        /**
         * @hidden
         * \@intenal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "changeMonth",
        value: function changeMonth(event) {
          var _this116 = this;

          this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
          this.activeView = CalendarView.DEFAULT;
          requestAnimationFrame(function () {
            /** @type {?} */
            var elem = _this116.monthsBtns.find(function (e, idx) {
              return idx === _this116.activeViewIdx;
            });

            if (elem) {
              elem.nativeElement.focus();
            }
          });
        }
        /**
         * @hidden
         * \@internal
         * @param {?} args
         * @param {?} activeViewIdx
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "onActiveViewYear",
        value: function onActiveViewYear(args, activeViewIdx, event) {
          var _this117 = this;

          this.activeView = CalendarView.YEAR;
          this.activeViewIdx = activeViewIdx;
          requestAnimationFrame(function () {
            _this117.monthsView.date = args;

            _this117.focusMonth(event.target);
          });
        }
        /**
         * @private
         * @param {?} target
         * @return {?}
         */

      }, {
        key: "focusMonth",
        value: function focusMonth(target) {
          /** @type {?} */
          var month = this.monthsView.monthsRef.find(function (e) {
            return e.index === parseInt(target.parentElement.attributes['data-month'].value, 10);
          });

          if (month) {
            month.nativeElement.focus();
          }
        }
        /**
         * @hidden
         * \@internal
         * @param {?} args
         * @param {?} event
         * @param {?} activeViewIdx
         * @return {?}
         */

      }, {
        key: "onActiveViewYearKB",
        value: function onActiveViewYearKB(args, event, activeViewIdx) {
          if (event.key === " "
          /* SPACE */
          || event.key === "Spacebar"
          /* SPACE_IE */
          || event.key === "Enter"
          /* ENTER */
          ) {
              event.preventDefault();
              this.onActiveViewYear(args, activeViewIdx, event);
            }
        }
        /**
         * Deselects date(s) (based on the selection type).
         *
         * \@example
         * ```typescript
         * this.calendar.deselectDate(new Date(`2018-06-12`));
         * ````
         * @param {?=} value
         * @return {?}
         */

      }, {
        key: "deselectDate",
        value: function deselectDate(value) {
          var _this118 = this;

          _get(_getPrototypeOf(IgxCalendarComponent.prototype), "deselectDate", this).call(this, value);

          this.monthViews.forEach(function (view) {
            view.selectedDates = _this118.selectedDates;
            view.rangeStarted = false;
          });

          this._onChangeCallback(this.selectedDates);
        }
        /**
         * Helper method that does deselection for all month views when selection is "multi"
         * If not called, selection in other month views stays
         * @hidden
         * \@internal
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "deselectDateInMonthViews",
        value: function deselectDateInMonthViews(value) {
          this.monthViews.forEach(function (m) {
            m.deselectMultipleInMonth(value);
          });
        }
        /**
         * @hidden
         * \@internal
         * @param {?} i
         * @return {?}
         */

      }, {
        key: "getViewDate",
        value: function getViewDate(i) {
          /** @type {?} */
          var date = this.calendarModel.timedelta(this.viewDate, 'month', i);
          return date;
        }
        /**
         * Getter for the context object inside the calendar templates.
         * @hidden
         * \@internal
         * @param {?} i
         * @return {?}
         */

      }, {
        key: "getContext",
        value: function getContext(i) {
          /** @type {?} */
          var date = this.getViewDate(i);
          return this.generateContext(date, i);
        }
        /**
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "animationDone",
        value: function animationDone(event) {
          if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.scrollMonth$.next();
          }

          if (this.activeView !== CalendarView.DEFAULT) {
            return;
          }
          /** @type {?} */


          var monthView =
          /** @type {?} */
          this.daysView;
          /** @type {?} */

          var date = monthView.dates.find(function (d) {
            return d.selected;
          });

          while (!date && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
            date = monthView.dates.find(function (d) {
              return d.selected;
            });
          }

          if (date && date.isFocusable && !this.isKeydownTrigger) {
            setTimeout(function () {
              date.nativeElement.focus();
            }, parseInt(slideInRight.options.params.duration, 10));
          } else if (this.callback && (event.toState === ScrollMonth.NEXT || event.toState === ScrollMonth.PREV)) {
            this.callback(this.nextDate);
          }

          this.animationAction = ScrollMonth.NONE;
        }
        /**
         * Keyboard navigation of the calendar
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownPageDown",
        value: function onKeydownPageDown(event) {
          var _this119 = this;

          event.preventDefault();

          if (this.activeView !== CalendarView.DEFAULT) {
            return;
          }
          /** @type {?} */


          var isPageDown = event.key === 'PageDown';
          /** @type {?} */

          var step = isPageDown ? 1 : -1;
          /** @type {?} */

          var monthView =
          /** @type {?} */
          this.daysView;
          /** @type {?} */

          var activeDate;

          while (!activeDate && monthView) {
            activeDate = monthView.dates.find(function (date) {
              return date.nativeElement === document.activeElement;
            });
            monthView = monthView.nextMonthView;
          }

          if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            /** @type {?} */

            var year = this.nextDate.getFullYear();
            /** @type {?} */

            var month = this.nextDate.getMonth() + step;

            if (isPageDown) {
              if (month > 11) {
                month = 0;
                year += step;
              }
            } else {
              if (month < 0) {
                month = 11;
                year += step;
              }
            }
            /** @type {?} */


            var _range = monthRange(this.nextDate.getFullYear(), month);
            /** @type {?} */


            var day = this.nextDate.getDate();

            if (day > _range[1]) {
              day = _range[1];
            }

            this.nextDate.setDate(day);
            this.nextDate.setMonth(month);
            this.nextDate.setFullYear(year);

            this.callback = function (next) {
              monthView =
              /** @type {?} */
              _this119.daysView;
              /** @type {?} */

              var dayItem;

              while (!dayItem && monthView || dayItem && !dayItem.isCurrentMonth) {
                dayItem = monthView.dates.find(function (d) {
                  return d.date.date.getTime() === next.getTime();
                });
                monthView = monthView.nextMonthView;
              }

              if (dayItem && dayItem.isFocusable) {
                dayItem.nativeElement.focus();
              }
            };
          }

          if (isPageDown) {
            this.nextMonth(true);
          } else {
            this.previousMonth(true);
          }
        }
        /**
         * Keyboard navigation of the calendar
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownShiftPageUp",
        value: function onKeydownShiftPageUp(event) {
          var _this120 = this;

          event.preventDefault();

          if (this.activeView !== CalendarView.DEFAULT) {
            return;
          }
          /** @type {?} */


          var isPageDown = event.key === 'PageDown';
          /** @type {?} */

          var step = isPageDown ? 1 : -1;
          this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);
          this.animationAction = isPageDown ? ScrollMonth.NEXT : ScrollMonth.PREV;
          this.isKeydownTrigger = true;
          /** @type {?} */

          var monthView =
          /** @type {?} */
          this.daysView;
          /** @type {?} */

          var activeDate;

          while (!activeDate && monthView) {
            activeDate = monthView.dates.find(function (date) {
              return date.nativeElement === document.activeElement;
            });
            monthView = monthView.nextMonthView;
          }

          if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            /** @type {?} */

            var year = this.nextDate.getFullYear() + step;
            /** @type {?} */

            var _range2 = monthRange(year, this.nextDate.getMonth());
            /** @type {?} */


            var day = this.nextDate.getDate();

            if (day > _range2[1]) {
              day = _range2[1];
            }

            this.nextDate.setDate(day);
            this.nextDate.setFullYear(year);

            this.callback = function (next) {
              monthView =
              /** @type {?} */
              _this120.daysView;
              /** @type {?} */

              var dayItem;

              while (!dayItem && monthView || dayItem && !dayItem.isCurrentMonth) {
                dayItem = monthView.dates.find(function (d) {
                  return d.date.date.getTime() === next.getTime();
                });
                monthView = monthView.nextMonthView;
              }

              if (dayItem && dayItem.isFocusable) {
                dayItem.nativeElement.focus();
              }
            };
          }
        }
        /**
         * Keyboard navigation of the calendar
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownHome",
        value: function onKeydownHome(event) {
          if (this.daysView) {
            this.daysView.onKeydownHome(event);
          }
        }
        /**
         * Keyboard navigation of the calendar
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownEnd",
        value: function onKeydownEnd(event) {
          if (this.daysView) {
            this.daysView.onKeydownEnd(event);
          }
        }
        /**
         * Stop continuous navigation on mouseup event
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onMouseUp",
        value: function onMouseUp(event) {
          if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.stopMonthScroll(event);
          }
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._monthViewsChanges$) {
            this._monthViewsChanges$.unsubscribe();
          }
        }
        /**
         * Helper method building and returning the context object inside
         * the calendar templates.
         * @hidden
         * \@internal
         * @private
         * @param {?} value
         * @param {?=} i
         * @return {?}
         */

      }, {
        key: "generateContext",
        value: function generateContext(value, i) {
          var _this121 = this;

          /** @type {?} */
          var formatObject = Object.assign({
            index: i,
            monthView: function monthView() {
              return _this121.onActiveViewYear(value, i);
            },
            yearView: function yearView() {
              return _this121.onActiveViewDecade(value, i);
            }
          }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));
          return {
            $implicit: formatObject
          };
        }
        /**
         * Helper method that sets references for prev/next months for each month in the view
         * @hidden
         * \@internal
         * @private
         * @param {?} monthViews
         * @return {?}
         */

      }, {
        key: "setSiblingMonths",
        value: function setSiblingMonths(monthViews) {
          var _this122 = this;

          monthViews.forEach(function (item, index) {
            /** @type {?} */
            var prevMonthView = _this122.getMonthView(index - 1);
            /** @type {?} */


            var nextMonthView = _this122.getMonthView(index + 1);

            item.nextMonthView = nextMonthView;
            item.prevMonthView = prevMonthView;
          });
        }
        /**
         * Helper method returning previous/next day views
         * @hidden
         * \@internal
         * @private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "getMonthView",
        value: function getMonthView(index) {
          if (index === -1 || index === this.monthViews.length) {
            return null;
          } else {
            return this.monthViews.toArray()[index];
          }
        }
      }, {
        key: "monthsViewNumber",
        get: function get() {
          return this._monthsViewNumber;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (val < 1) {
            return;
          }

          this._monthsViewNumber = val;
        }
        /**
         * The default css class applied to the component.
         *
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "styleVerticalClass",
        get: function get() {
          return this.vertical;
        }
        /**
         * Denote if the year view is active.
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "isYearView",
        get: function get() {
          return this.activeView === CalendarView.YEAR;
        }
        /**
         * Gets the header template.
         *
         * \@example
         * ```typescript
         * let headerTemplate =  this.calendar.headerTeamplate;
         * ```
         * \@memberof IgxCalendarComponent
         * @return {?}
         */

      }, {
        key: "headerTemplate",
        get: function get() {
          if (this.headerTemplateDirective) {
            return this.headerTemplateDirective.template;
          }

          return null;
        }
        /**
         * Sets the header template.
         *
         * \@example
         * ```html
         * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
         * ```
         * \@memberof IgxCalendarComponent
         * @param {?} directive
         * @return {?}
         */
        ,
        set: function set(directive) {
          this.headerTemplateDirective = directive;
        }
        /**
         * Gets the subheader template.
         *
         * \@example
         * ```typescript
         * let subheaderTemplate = this.calendar.subheaderTemplate;
         * ```
         * @return {?}
         */

      }, {
        key: "subheaderTemplate",
        get: function get() {
          if (this.subheaderTemplateDirective) {
            return this.subheaderTemplateDirective.template;
          }

          return null;
        }
        /**
         * Sets the subheader template.
         *
         * \@example
         * ```html
         * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
         * ```
         * \@memberof IgxCalendarComponent
         * @param {?} directive
         * @return {?}
         */
        ,
        set: function set(directive) {
          this.subheaderTemplateDirective = directive;
        }
        /**
         * Gets the context for the template marked with the `igxCalendarHeader` directive.
         *
         * \@example
         * ```typescript
         * let headerContext =  this.calendar.headerContext;
         * ```
         * @return {?}
         */

      }, {
        key: "headerContext",
        get: function get() {
          /** @type {?} */
          var date = this.headerDate;
          return this.generateContext(date);
        }
        /**
         * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
         * or `igxCalendarSubHeaderYear` directive.
         *
         * \@example
         * ```typescript
         * let context =  this.calendar.context;
         * ```
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          /** @type {?} */
          var date = this.viewDate;
          return this.generateContext(date);
        }
        /**
         * Date displayed in header
         *
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "headerDate",
        get: function get() {
          return this.selectedDates ? this.selectedDates : new Date();
        }
      }]);

      return IgxCalendarComponent;
    }(IgxMonthPickerBase);

    IgxCalendarComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          multi: true,
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxCalendarComponent
        }],
        animations: [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animateView', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => 0', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeIn)), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(scaleInCenter, {
          params: {
            duration: '.2s',
            fromScale: .9
          }
        }))]), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animateChange', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => prev', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInLeft, {
          params: {
            fromPosition: 'translateX(-30%)'
          }
        })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInRight, {
          params: {
            fromPosition: 'translateX(30%)'
          }
        }))])],
        selector: 'igx-calendar',
        template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n    <span tabindex=\"0\" #monthsBtn (keydown)=\"onActiveViewYearKB(getViewDate(obj.index), $event, obj.index)\" (click)=\"onActiveViewYear(getViewDate(obj.index), obj.index, $event)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedMonth(getViewDate(obj.index)) }}\n    </span>\n    <span tabindex=\"0\" #yearsBtn (keydown)=\"onActiveViewDecadeKB($event, getViewDate(obj.index), obj.index)\" (click)=\"onActiveViewDecade(getViewDate(obj.index), obj.index)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedYear(getViewDate(obj.index)) }}\n    </span>\n</ng-template>\n\n<div *ngIf=\"selection === 'single' && hasHeader\" class=\"igx-calendar__header\">\n    <h5 class=\"igx-calendar__header-year\">{{ formattedYear(headerDate) }}</h5>\n    <h2 class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</div>\n\n<div *ngIf=\"isDefaultView\" class=\"igx-calendar__body\" [@animateView]=\"activeView\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" #prevMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startPrevMonthScroll\" [stopScroll]=\"stopMonthScroll\"  [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\" *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [style.width.%]=\"100/monthsViewNumber\" [attr.data-month]=\"i | IgxGetViewDate:viewDate:false\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" #nextMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startNextMonthScroll\" [stopScroll]=\"stopMonthScroll\" [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <div style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [changeDaysView]=\"true\" #days\n                [selection]=\"selection\"\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [viewDate]=\"i | IgxGetViewDate:viewDate\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                (onViewChanging)=\"viewChanging($event)\"\n                (onDateSelection)=\"childClicked($event)\">\n        </igx-days-view>\n    </div>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\" [@animateView]=\"activeView\" #months\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (onSelection)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"changeYear($event)\">\n</igx-years-view>\n"
      }]
    }];
    IgxCalendarComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hasHeader: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      vertical: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      monthsViewNumber: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      animationAction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      ariaLabelledBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-labelledby']
      }],
      styleVerticalClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar--vertical']
      }],
      styleClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar']
      }],
      monthsView: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['months', {
          read: IgxMonthsViewComponent,
          "static": false
        }]
      }],
      monthsBtns: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: ['monthsBtn']
      }],
      dacadeView: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['decade', {
          read: IgxYearsViewComponent,
          "static": false
        }]
      }],
      daysView: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['days', {
          read: IgxDaysViewComponent,
          "static": false
        }]
      }],
      monthViews: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: ['days', {
          read: IgxDaysViewComponent
        }]
      }],
      prevMonthBtn: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['prevMonthBtn', {
          "static": false
        }]
      }],
      nextMonthBtn: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['nextMonthBtn', {
          "static": false
        }]
      }],
      headerTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxCalendarHeaderTemplateDirective;
        }), {
          read: IgxCalendarHeaderTemplateDirective,
          "static": true
        }]
      }],
      subheaderTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxCalendarSubheaderTemplateDirective;
        }), {
          read: IgxCalendarSubheaderTemplateDirective,
          "static": true
        }]
      }],
      onKeydownPageDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.pagedown', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.pageup', ['$event']]
      }],
      onKeydownShiftPageUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.shift.pageup', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.shift.pagedown', ['$event']]
      }],
      onKeydownHome: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.home', ['$event']]
      }],
      onKeydownEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.end', ['$event']]
      }],
      onMouseUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['document:mouseup', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$g = 0;

    var IgxMonthPickerComponent =
    /*#__PURE__*/
    function (_IgxMonthPickerBase2) {
      _inherits(IgxMonthPickerComponent, _IgxMonthPickerBase2);

      function IgxMonthPickerComponent() {
        var _this123;

        _classCallCheck(this, IgxMonthPickerComponent);

        _this123 = _possibleConstructorReturn(this, _getPrototypeOf(IgxMonthPickerComponent).apply(this, arguments));
        /**
         * Sets/gets the `id` of the month picker.
         * If not set, the `id` will have value `"igx-month-picker-0"`.
         */

        _this123.id = "igx-month-picker-".concat(NEXT_ID$g++);
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */

        _this123.styleClass = true;
        /**
         * @hidden
         */

        _this123.yearAction = '';
        return _this123;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxMonthPickerComponent, [{
        key: "animationDone",
        value: function animationDone() {
          this.yearAction = '';
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "activeViewDecadeKB",
        value: function activeViewDecadeKB(event) {
          var _this124 = this;

          _get(_getPrototypeOf(IgxMonthPickerComponent.prototype), "activeViewDecadeKB", this).call(this, event);

          if (event.key === "ArrowRight"
          /* RIGHT_ARROW */
          || event.key === "Right"
          /* RIGHT_ARROW_IE */
          ) {
              event.preventDefault();
              this.nextYear();
            }

          if (event.key === "ArrowLeft"
          /* LEFT_ARROW */
          || event.key === "Left"
          /* LEFT_ARROW_IE */
          ) {
              event.preventDefault();
              this.previousYear();
            }

          requestAnimationFrame(function () {
            if (_this124.dacadeView) {
              _this124.dacadeView.el.nativeElement.focus();
            }
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "activeViewDecade",
        value: function activeViewDecade() {
          var _this125 = this;

          _get(_getPrototypeOf(IgxMonthPickerComponent.prototype), "activeViewDecade", this).call(this);

          requestAnimationFrame(function () {
            _this125.dacadeView.el.nativeElement.focus();
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "nextYear",
        value: function nextYear() {
          this.yearAction = 'next';
          this.viewDate = this.calendarModel.getNextYear(this.viewDate);
          this.selectDate(this.viewDate);
          this.onSelection.emit(this.selectedDates);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "nextYearKB",
        value: function nextYearKB(event) {
          if (event.key === " "
          /* SPACE */
          || event.key === "Spacebar"
          /* SPACE_IE */
          || event.key === "Enter"
          /* ENTER */
          ) {
              event.preventDefault();
              event.stopPropagation();
              this.nextYear();
            }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "previousYear",
        value: function previousYear() {
          this.yearAction = 'prev';
          this.viewDate = this.calendarModel.getPrevYear(this.viewDate);
          this.selectDate(this.viewDate);
          this.onSelection.emit(this.selectedDates);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "previousYearKB",
        value: function previousYearKB(event) {
          if (event.key === " "
          /* SPACE */
          || event.key === "Spacebar"
          /* SPACE_IE */
          || event.key === "Enter"
          /* ENTER */
          ) {
              event.preventDefault();
              event.stopPropagation();
              this.previousYear();
            }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "selectYear",
        value: function selectYear(event) {
          var _this126 = this;

          this.viewDate = new Date(event.getFullYear(), event.getMonth(), event.getDate());
          this.activeView = CalendarView.DEFAULT;
          this.selectDate(event);
          this.onSelection.emit(this.selectedDates);
          requestAnimationFrame(function () {
            if (_this126.yearsBtn) {
              _this126.yearsBtn.nativeElement.focus();
            }
          });
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "selectMonth",
        value: function selectMonth(event) {
          this.selectDate(event);
          this.onSelection.emit(this.selectedDates);
        }
        /**
         * Selects a date.
         * ```typescript
         * this.monPicker.selectDate(new Date(`2018-06-12`));
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "selectDate",
        value: function selectDate(value) {
          if (!value) {
            return new Date();
          } // TO DO: to be refactored after discussion on the desired behavior


          _get(_getPrototypeOf(IgxMonthPickerComponent.prototype), "selectDate", this).call(this, value);

          this.viewDate = value;
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          // TO DO: to be refactored after discussion on the desired behavior
          if (value) {
            this.viewDate = this.selectedDates = value;
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownPageUp",
        value: function onKeydownPageUp(event) {
          event.preventDefault();
          this.yearAction = 'prev';
          this.viewDate = this.calendarModel.getPrevYear(this.viewDate);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownPageDown",
        value: function onKeydownPageDown(event) {
          event.preventDefault();
          this.yearAction = 'next';
          this.viewDate = this.calendarModel.getNextYear(this.viewDate);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownHome",
        value: function onKeydownHome(event) {
          if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownHome(event);
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownEnd",
        value: function onKeydownEnd(event) {
          if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownEnd(event);
          }
        }
      }]);

      return IgxMonthPickerComponent;
    }(IgxMonthPickerBase);

    IgxMonthPickerComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          multi: true,
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxMonthPickerComponent
        }],
        animations: [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animateView', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => 0', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeIn)), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(scaleInCenter, {
          params: {
            duration: '.2s',
            fromScale: .9
          }
        }))]), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animateChange', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => prev', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInLeft, {
          params: {
            fromPosition: 'translateX(-30%)'
          }
        })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInRight, {
          params: {
            fromPosition: 'translateX(30%)'
          }
        }))])],
        selector: 'igx-month-picker',
        template: "<div *ngIf=\"isDefaultView\" [@animateView]=\"activeView\" class=\"igx-calendar__body\" (swiperight)=\"previousYear()\" (swipeleft)=\"nextYear()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" (click)=\"previousYear()\" (keydown)=\"previousYearKB($event)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'left': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div [style.width.%]=\"100\">\n            <span tabindex=\"0\" #yearsBtn (keydown)=\"activeViewDecadeKB($event)\" (click)=\"activeViewDecade()\" class=\"igx-calendar-picker__date\">\n                {{ formattedYear(viewDate) }}\n            </span>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" (click)=\"nextYear()\" (keydown)=\"nextYearKB($event)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'right': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <igx-months-view [@animateChange]=\"yearAction\" #months\n                     (@animateChange.done)=\"animationDone()\"\n                     [date]=\"viewDate\"\n                     [locale]=\"locale\"\n                     [formatView]=\"formatViews.month\"\n                     [monthFormat]=\"formatOptions.month\"\n                     (onSelection)=\"selectMonth($event)\">\n    </igx-months-view>\n</div>\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"selectYear($event)\">\n</igx-years-view>\n"
      }]
    }];
    IgxMonthPickerComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      styleClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-calendar']
      }],
      monthsView: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['months', {
          read: IgxMonthsViewComponent,
          "static": false
        }]
      }],
      dacadeView: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['decade', {
          read: IgxYearsViewComponent,
          "static": false
        }]
      }],
      daysView: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['days', {
          read: IgxDaysViewComponent,
          "static": false
        }]
      }],
      yearsBtn: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['yearsBtn', {
          "static": false
        }]
      }],
      onKeydownPageUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.pageup', ['$event']]
      }],
      onKeydownPageDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.pagedown', ['$event']]
      }],
      onKeydownHome: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.home', ['$event']]
      }],
      onKeydownEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.end', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxMonthViewSlotsCalendar =
    /*#__PURE__*/
    function () {
      function IgxMonthViewSlotsCalendar() {
        _classCallCheck(this, IgxMonthViewSlotsCalendar);
      }

      _createClass(IgxMonthViewSlotsCalendar, [{
        key: "transform",

        /**
         * @param {?} monthViews
         * @return {?}
         */
        value: function transform(monthViews) {
          return new Array(monthViews);
        }
      }]);

      return IgxMonthViewSlotsCalendar;
    }();

    IgxMonthViewSlotsCalendar.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'IgxMonthViewSlots'
      }]
    }];

    var IgxGetViewDateCalendar =
    /*#__PURE__*/
    function () {
      function IgxGetViewDateCalendar() {
        _classCallCheck(this, IgxGetViewDateCalendar);

        this.calendar = new Calendar();
      }
      /**
       * @param {?} index
       * @param {?} viewDate
       * @param {?=} wholeDate
       * @return {?}
       */


      _createClass(IgxGetViewDateCalendar, [{
        key: "transform",
        value: function transform(index, viewDate) {
          var wholeDate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          /** @type {?} */
          var date = this.calendar.timedelta(viewDate, 'month', index);
          return wholeDate ? date : date.getMonth();
        }
      }]);

      return IgxGetViewDateCalendar;
    }();

    IgxGetViewDateCalendar.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'IgxGetViewDate'
      }]
    }];
    /** @nocollapse */

    IgxGetViewDateCalendar.ctorParameters = function () {
      return [];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var IgxCalendarModule = function IgxCalendarModule() {
      _classCallCheck(this, IgxCalendarModule);
    };

    IgxCalendarModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxDayItemComponent, IgxDaysViewComponent, IgxCalendarComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarMonthDirective, IgxCalendarYearDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarScrollMonthDirective, IgxMonthsViewComponent, IgxYearsViewComponent, IgxMonthPickerComponent, IgxMonthViewSlotsCalendar, IgxGetViewDateCalendar],
        exports: [IgxCalendarComponent, IgxDaysViewComponent, IgxMonthsViewComponent, IgxYearsViewComponent, IgxMonthPickerComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarMonthDirective, IgxCalendarYearDirective, IgxCalendarSubheaderTemplateDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], IgxIconModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$h = 0;
    /**
     * IgxCardMedia is container for the card media section.
     * Use it to wrap images and videos.
     */

    var IgxCardMediaDirective = function IgxCardMediaDirective() {
      _classCallCheck(this, IgxCardMediaDirective);

      /**
       * @hidden
       */
      this.cssClass = 'igx-card__media';
      /**
       * An \@Input property that sets the `width` and `min-width` style property
       * of the media container. If not provided it will be set to `auto`.
       * ```html
       * <igx-card-media width="300px"></igx-card-media>
       * ```
       */

      this.width = 'auto';
      /**
       * An \@Input property that sets the `height` style property of the media container.
       * If not provided it will be set to `auto`.
       * ```html
       * <igx-card-media height="50%"></igx-card-media>
       * ```
       */

      this.height = 'auto';
      /**
       * An \@Input property that sets the `role` attribute of the media container.
       */

      this.role = 'img';
    };

    IgxCardMediaDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-card-media'
      }]
    }];
    IgxCardMediaDirective.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card__media']
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.width']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.min-width']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      height: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.height']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * IgxCardHeader is container for the card header
     */

    var IgxCardHeaderComponent = function IgxCardHeaderComponent() {
      _classCallCheck(this, IgxCardHeaderComponent);

      /**
       * @hidden
       */
      this.cssClass = 'igx-card-header';
      /**
       * An \@Input property that sets the layout style of the header.
       * By default the header elements(thumbnail and title/subtitle) are aligned horizontally.
       * ```html
       * <igx-card-header [vertical]="true"></igx-card-header>
       * ```
       */

      this.vertical = false;
      /**
       * An \@Input property that sets the value of the `role` attribute of the card header.
       * By default the value is set to `header`.
       * ```html
       * <igx-card-header role="header"></igx-card-header>
       * ```
       */

      this.role = 'header';
    };

    IgxCardHeaderComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-card-header',
        template: "<div class=\"igx-card-header__thumbnail\">\n    <ng-content select=\"igx-avatar, igx-card-media, [igxCardThumbnail]\"></ng-content>\n</div>\n\n<div class=\"igx-card-header__titles\">\n    <ng-content select=\"\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle\">\n    </ng-content>\n</div>\n\n<ng-content></ng-content>\n"
      }]
    }];
    IgxCardHeaderComponent.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card-header']
      }],
      vertical: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card-header--vertical']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }]
    };
    /**
     * IgxCardThumbnail is container for the card thumbnail section.
     * Use it to wrap anything you want to be used as a thumbnail.
     */

    var IgxCardThumbnailDirective = function IgxCardThumbnailDirective() {
      _classCallCheck(this, IgxCardThumbnailDirective);
    };

    IgxCardThumbnailDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCardThumbnail]'
      }]
    }];
    /**
     * igxCardHeaderTitle is used to denote the header title in a card.
     * Use it to tag text nodes.
     */

    var IgxCardHeaderTitleDirective = function IgxCardHeaderTitleDirective() {
      _classCallCheck(this, IgxCardHeaderTitleDirective);

      /**
       * @hidden
       */
      this.cssClass = 'igx-card__header__title';
    };

    IgxCardHeaderTitleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCardHeaderTitle]'
      }]
    }];
    IgxCardHeaderTitleDirective.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card-header__title']
      }]
    };
    /**
     * igxCardHeaderSubtitle is used to denote the header subtitle in a card.
     * Use it to tag text nodes.
     */

    var IgxCardHeaderSubtitleDirective = function IgxCardHeaderSubtitleDirective() {
      _classCallCheck(this, IgxCardHeaderSubtitleDirective);

      /**
       * @hidden
       */
      this.cssClass = 'igx-card-header__subtitle';
    };

    IgxCardHeaderSubtitleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCardHeaderSubtitle]'
      }]
    }];
    IgxCardHeaderSubtitleDirective.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card-header__subtitle']
      }]
    };
    /**
     * IgxCardContent is container for the card content.
     */

    var IgxCardContentDirective = function IgxCardContentDirective() {
      _classCallCheck(this, IgxCardContentDirective);

      /**
       * @hidden
       */
      this.cssClass = 'igx-card-content';
    };

    IgxCardContentDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-card-content'
      }]
    }];
    IgxCardContentDirective.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card-content']
      }]
    };
    /**
     * IgxCardFooter is container for the card footer
     */

    var IgxCardFooterDirective = function IgxCardFooterDirective() {
      _classCallCheck(this, IgxCardFooterDirective);

      /**
       * An \@Input property that sets the value of the `role` attribute of the card footer.
       * By default the value is set to `footer`.
       * ```html
       * <igx-card-footer role="footer"></igx-card-footer>
       * ```
       */
      this.role = 'footer';
    };

    IgxCardFooterDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-card-footer'
      }]
    }];
    IgxCardFooterDirective.propDecorators = {
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /** @enum {string} */

    var IgxCardType = {
      DEFAULT: 'default',
      OUTLINED: 'outlined'
    };

    var IgxCardComponent =
    /*#__PURE__*/
    function () {
      function IgxCardComponent() {
        _classCallCheck(this, IgxCardComponent);

        /**
         * Sets/gets the `id` of the card.
         * If not set, `id` will have value `"igx-card-0"`;
         * ```html
         * <igx-card id = "my-first-card"></igx-card>
         * ```
         * ```typescript
         * let cardId =  this.card.id;
         * ```
         * \@memberof IgxCardComponent
         */
        this.id = "igx-card-".concat(NEXT_ID$h++);
        /**
         * An \@Input property that sets the value of the `role` attribute of the card.
         * By default the value is set to `group`.
         * ```html
         * <igx-card role="group"></igx-card>
         * ```
         */

        this.role = 'group';
        /**
         * An \@Input property that sets the value of the `type` attribute of the card.
         * By default the value is set to `default`. You can make the card use the
         * outlined style by setting the value to `outlined`.
         * ```html
         * <igx-card type="outlined"></igx-card>
         * ```
         */

        this.type = IgxCardType.DEFAULT;
        /**
         * An \@Input property that sets the value of the `horizontal` attribute of the card.
         * Setting this to `true` will make the different card sections align horizontally,
         * essentially flipping the card to the side.
         * ```html
         * <igx-card [horizontal]="true"></igx-card>
         * ```
         */

        this.horizontal = false;
      }
      /**
       * A getter which will return true if the card type is `outlined`.
       * @return {?}
       */


      _createClass(IgxCardComponent, [{
        key: "isOutlinedCard",
        get: function get() {
          return this.type === IgxCardType.OUTLINED;
        }
      }]);

      return IgxCardComponent;
    }();

    IgxCardComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-card',
        template: "<ng-container select='igx-card-media'></ng-container>\n\n<ng-container select='igx-card-header'></ng-container>\n<ng-container select='igx-card-content'>\n    <ng-content></ng-content>\n</ng-container>\n\n<ng-container select='igx-card-actions'></ng-container>\n"
      }]
    }];
    IgxCardComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isOutlinedCard: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card--outlined']
      }],
      horizontal: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card--horizontal']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /** @enum {string} */

    var IgxCardActionsLayout = {
      DEFAULT: 'default',
      JUSTIFY: 'justify'
    };
    /**
     * IgxCardActions is container for the card actions.
     */

    var IgxCardActionsComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} card
       */
      function IgxCardActionsComponent(card) {
        _classCallCheck(this, IgxCardActionsComponent);

        this.card = card;
        this.isVerticalSet = false;
        /**
         * An \@Input property that sets the layout style of the actions.
         * By default icons and icon buttons, as well as regular buttons
         * are split into two containers, which are then positioned on both ends
         * of the card-actions area.
         * You can justify the elements in those groups so they are positioned equally
         * from one another taking up all the space available along the card actions axis.
         * ```html
         * <igx-card-actions layout="justify"></igx-card-actions>
         * ```
         */

        this.layout = 'default';
        /**
         * An \@Input property that sets order of the buttons the actions area.
         * By default all icons/icon buttons are placed at the end of the action
         * area. Any regular buttons(flat, raised) will appear before the icons/icon buttons
         * placed in the actions area.
         * If you want to reverse their positions so that icons appear first, use the `reverse`
         * attribute.
         * ```html
         * <igx-card-actions [reverse]="true"></igx-card-actions>
         * ```
         */

        this.reverse = false;
      }
      /**
       * A getter that returns `true` when the layout has been
       * set to `justify`.
       * @return {?}
       */


      _createClass(IgxCardActionsComponent, [{
        key: "ngOnChanges",

        /**
         * @param {?} changes
         * @return {?}
         */
        value: function ngOnChanges(changes) {
          for (var prop in changes) {
            if (prop === 'vertical') {
              this.isVerticalSet = true;
            }
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this.vertical = !this.isVerticalSet && this.card.horizontal;
        }
      }, {
        key: "isJustifyLayout",
        get: function get() {
          return this.layout === IgxCardActionsLayout.JUSTIFY;
        }
      }]);

      return IgxCardActionsComponent;
    }();

    IgxCardActionsComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-card-actions',
        template: "<div class=\"igx-card-actions__icons\">\n    <ng-content select=\"igx-icon, [igxButton='icon']\"></ng-content>\n</div>\n\n<div #buttons class=\"igx-card-actions__buttons\">\n    <ng-content select=\"[igxButton]\"></ng-content>\n</div>\n\n\n<ng-content></ng-content>\n"
      }]
    }];
    /** @nocollapse */

    IgxCardActionsComponent.ctorParameters = function () {
      return [{
        type: IgxCardComponent,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxCardComponent]
        }]
      }];
    };

    IgxCardActionsComponent.propDecorators = {
      layout: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card-actions']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      vertical: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card-actions--vertical']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isJustifyLayout: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card-actions--justify']
      }],
      reverse: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-card-actions--reverse']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @hidden
     */

    var IgxCardModule = function IgxCardModule() {
      _classCallCheck(this, IgxCardModule);
    };

    IgxCardModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxCardComponent, IgxCardHeaderComponent, IgxCardMediaDirective, IgxCardContentDirective, IgxCardActionsComponent, IgxCardFooterDirective, IgxCardHeaderTitleDirective, IgxCardHeaderSubtitleDirective, IgxCardThumbnailDirective],
        exports: [IgxCardComponent, IgxCardHeaderComponent, IgxCardMediaDirective, IgxCardContentDirective, IgxCardActionsComponent, IgxCardFooterDirective, IgxCardHeaderTitleDirective, IgxCardHeaderSubtitleDirective, IgxCardThumbnailDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxButtonModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$i = 0;
    /** @enum {number} */

    var Direction$1 = {
      NONE: 0,
      NEXT: 1,
      PREV: 2
    };
    Direction$1[Direction$1.NONE] = 'NONE';
    Direction$1[Direction$1.NEXT] = 'NEXT';
    Direction$1[Direction$1.PREV] = 'PREV';
    /**
     * **Ignite UI for Angular Carousel** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/carousel.html)
     *
     * The Ignite UI Carousel is used to browse or navigate through a collection of slides. Slides can contain custom
     * content such as images or cards and be used for things such as on-boarding tutorials or page-based interfaces.
     * It can be used as a separate fullscreen element or inside another component.
     *
     * Example:
     * ```html
     * <igx-carousel>
     *   <igx-slide>
     *     <h3>First Slide Header</h3>
     *     <p>First slide Content</p>
     *   <igx-slide>
     *   <igx-slide>
     *     <h3>Second Slide Header</h3>
     *     <p>Second Slide Content</p>
     * </igx-carousel>
     * ```
     */

    var IgxCarouselComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?} platformUtil
       */
      function IgxCarouselComponent(element, platformUtil) {
        _classCallCheck(this, IgxCarouselComponent);

        this.element = element;
        this.platformUtil = platformUtil;
        /**
         * Returns the `role` attribute of the carousel.
         * ```typescript
         * let carouselRole =  this.carousel.role;
         * ```
         * \@memberof IgxCarouselComponent
         */

        this.role = 'region';
        /**
         * Sets the `id` of the carousel.
         * If not set, the `id` of the first carousel component will be `"igx-carousel-0"`.
         * ```html
         * <igx-carousel id="my-first-carousel"></igx-carousel>
         * ```
         * \@memberof IgxCarouselComponent
         */

        this.id = "igx-carousel-".concat(NEXT_ID$i++);
        /**
         * Sets whether the carousel should `loop` back to the first slide after reaching the last slide.
         * Default value is `true`.
         * ```html
         * <igx-carousel [loop]="false"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */

        this.loop = true;
        /**
         * Sets whether the carousel will `pause` the slide transitions on user interactions.
         * Default value is `true`.
         * ```html
         *  <igx-carousel [pause]="false"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */

        this.pause = true;
        /**
         * Controls whether the carousel should render the left/right `navigation` buttons.
         * Default value is `true`.
         * ```html
         * <igx-carousel [navigation] = "false"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */

        this.navigation = true;
        /**
         * An event that is emitted after a slide transition has happened.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideChanged)="onSlideChanged($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */

        this.onSlideChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after a slide has been added to the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideAdded)="onSlideAdded($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */

        this.onSlideAdded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after a slide has been removed from the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideRemoved)="onSlideRemoved($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */

        this.onSlideRemoved = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after the carousel has been paused.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPaused)="onCarouselPaused($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */

        this.onCarouselPaused = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after the carousel has resumed transitioning between `slides`.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPlaying)="onCarouselPlaying($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */

        this.onCarouselPlaying = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * The collection of `slides` currently in the carousel.
         * ```typescript
         * let slides: IgxSlideComponent[] = this.carousel.slides;
         * ```
         * \@memberOf IgxCarouselComponent
         */

        this.slides = [];
        this._total = 0;
      }
      /**
       * Returns the time `interval` in milliseconds before the slide changes.
       * ```typescript
       * let timeInterval = this.carousel.interval;
       * ```
       * \@memberof IgxCarouselComponent
       * @return {?}
       */


      _createClass(IgxCarouselComponent, [{
        key: "ngOnDestroy",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnDestroy() {
          this._destroyed = true;

          if (this._lastInterval) {
            clearInterval(this._lastInterval);
          }
        }
        /**
         * @hidden
         * \@memberof IgxCarouselComponent
         * @param {?} slide
         * @return {?}
         */

      }, {
        key: "setAriaLabel",
        value: function setAriaLabel(slide) {
          return "Item ".concat(slide.index + 1, " of ").concat(this.total);
        }
        /**
         * Returns the total number of `slides` in the carousel.
         * ```typescript
         * let slideCount =  this.carousel.total;
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "get",

        /**
         * Returns the slide corresponding to the provided `index` or null.
         * ```typescript
         * let slide1 =  this.carousel.get(1);
         * ```
         * \@memberOf IgxCarouselComponent
         * @param {?} index
         * @return {?}
         */
        value: function get(index) {
          var _iteratorNormalCompletion35 = true;
          var _didIteratorError35 = false;
          var _iteratorError35 = undefined;

          try {
            for (var _iterator35 = this.slides[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
              var each = _step35.value;

              if (each.index === index) {
                return each;
              }
            }
          } catch (err) {
            _didIteratorError35 = true;
            _iteratorError35 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion35 && _iterator35["return"] != null) {
                _iterator35["return"]();
              }
            } finally {
              if (_didIteratorError35) {
                throw _iteratorError35;
              }
            }
          }
        }
        /**
         * Adds a new slide to the carousel.
         * ```typescript
         * this.carousel.add(newSlide);
         * ```
         * \@memberOf IgxCarouselComponent
         * @param {?} slide
         * @return {?}
         */

      }, {
        key: "add",
        value: function add(slide) {
          slide.index = this.total;
          this.slides.push(slide);
          this._total += 1;

          if (this.total === 1 || slide.active) {
            this.select(slide);

            if (this.total === 1) {
              this.play();
            }
          } else {
            slide.active = false;
          }

          this.onSlideAdded.emit({
            carousel: this,
            slide: slide
          });
        }
        /**
         * Removes a slide from the carousel.
         * ```typescript
         * this.carousel.remove(slide);
         * ```
         * \@memberOf IgxCarouselComponent
         * @param {?} slide
         * @return {?}
         */

      }, {
        key: "remove",
        value: function remove(slide) {
          if (slide && slide === this.get(slide.index)) {
            // check if the requested slide for delete is present in the carousel
            if (slide.index === this.current) {
              slide.active = false;
              this.next();
            }

            this.slides.splice(slide.index, 1);
            this._total -= 1;

            if (!this.total) {
              this._currentSlide = null;
              return;
            }

            for (var i = 0; i < this.total; i++) {
              this.slides[i].index = i;
            }

            this.onSlideRemoved.emit({
              carousel: this,
              slide: slide
            });
          }
        }
        /**
         * Kicks in a transition for a given slide with a given `direction`.
         * ```typescript
         * this.carousel.select(this.carousel.get(2), Direction.NEXT);
         * ```
         * \@memberOf IgxCarouselComponent
         * @param {?} slide
         * @param {?=} direction
         * @return {?}
         */

      }, {
        key: "select",
        value: function select(slide) {
          var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Direction$1.NONE;

          /** @type {?} */
          var newIndex = slide.index;

          if (direction === Direction$1.NONE) {
            direction = newIndex > this.current ? Direction$1.NEXT : Direction$1.PREV;
          }

          if (slide && slide !== this._currentSlide) {
            this._moveTo(slide, direction);
          }
        }
        /**
         * Transitions to the next slide in the carousel.
         * ```typescript
         * this.carousel.next();
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "next",
        value: function next() {
          /** @type {?} */
          var index = (this.current + 1) % this.total;

          if (index === 0 && !this.loop) {
            this.stop();
            return;
          }

          return this.select(this.get(index), Direction$1.NEXT);
        }
        /**
         * Transitions to the previous slide in the carousel.
         * ```typescript
         * this.carousel.prev();
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "prev",
        value: function prev() {
          /** @type {?} */
          var index = this.current - 1 < 0 ? this.total - 1 : this.current - 1;

          if (!this.loop && index === this.total - 1) {
            this.stop();
            return;
          }

          return this.select(this.get(index), Direction$1.PREV);
        }
        /**
         * Resumes playing of the carousel if in paused state.
         * No operation otherwise.
         * ```typescript
         * this.carousel.play();
         * }
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "play",
        value: function play() {
          if (!this._playing) {
            this._playing = true;
            this.onCarouselPlaying.emit(this);

            this._restartInterval();
          }
        }
        /**
         * Stops slide transitions if the `pause` option is set to `true`.
         * No operation otherwise.
         * ```typescript
         *  this.carousel.stop();
         * }
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "stop",
        value: function stop() {
          if (this.pause) {
            this._playing = false;
            this.onCarouselPaused.emit(this);

            this._resetInterval();
          }
        }
        /**
         * @hidden
         * @private
         * @param {?} slide
         * @param {?} direction
         * @return {?}
         */

      }, {
        key: "_moveTo",
        value: function _moveTo(slide, direction) {
          if (this._destroyed) {
            return;
          }

          slide.direction = direction;
          slide.active = true;

          if (this._currentSlide) {
            this._currentSlide.direction = direction;
            this._currentSlide.active = false;
          }

          this._currentSlide = slide;
          this.onSlideChanged.emit({
            carousel: this,
            slide: slide
          });

          this._restartInterval();
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "_resetInterval",
        value: function _resetInterval() {
          if (this._lastInterval) {
            clearInterval(this._lastInterval);
            this._lastInterval = null;
          }
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "_restartInterval",
        value: function _restartInterval() {
          var _this127 = this;

          this._resetInterval();

          if (!isNaN(this.interval) && this.interval > 0 && this.platformUtil.isBrowser) {
            this._lastInterval = setInterval(function () {
              /** @type {?} */
              var tick = +_this127.interval;

              if (_this127._playing && _this127.total && !isNaN(tick) && tick > 0) {
                _this127.next();
              } else {
                _this127.stop();
              }
            }, this.interval);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onKeydownArrowRight",
        value: function onKeydownArrowRight() {
          var _this128 = this;

          this.next();
          requestAnimationFrame(function () {
            return _this128.nativeElement.focus();
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onKeydownArrowLeft",
        value: function onKeydownArrowLeft() {
          var _this129 = this;

          this.prev();
          requestAnimationFrame(function () {
            return _this129.nativeElement.focus();
          });
        }
      }, {
        key: "interval",
        get: function get() {
          return this._interval;
        }
        /**
         * Sets the time `interval` in milliseconds before the slide changes.
         * If not set, the carousel will not change `slides` automatically.
         * ```html
         * <igx-carousel [interval] = "1000"></igx-carousel>
         * ```
         * \@memberof IgxCarouselComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._interval = +value;

          this._restartInterval();
        }
        /**
         * Returns the `tabIndex` of the carousel component.
         * ```typescript
         * let tabIndex =  this.carousel.tabIndex;
         * ```
         * \@memberof IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "tabIndex",
        get: function get() {
          return 0;
        }
      }, {
        key: "total",
        get: function get() {
          return this._total;
        }
        /**
         * The index of the slide being currently shown.
         * ```typescript
         * let currentSlideNumber =  this.carousel.current;
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "current",
        get: function get() {
          return !this._currentSlide ? 0 : this._currentSlide.index;
        }
        /**
         * Returns a boolean indicating if the carousel is playing.
         * ```typescript
         * let isPlaying =  this.carousel.isPlaying;
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "isPlaying",
        get: function get() {
          return this._playing;
        }
        /**
         * Returns а boolean indicating if the carousel is destroyed.
         * ```typescript
         * let isDestroyed =  this.carousel.isDestroyed;
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "isDestroyed",
        get: function get() {
          return this._destroyed;
        }
        /**
         * Returns a reference to the carousel element in the DOM.
         * ```typescript
         * let nativeElement =  this.carousel.nativeElement;
         * ```
         * \@memberof IgxCarouselComponent
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
      }]);

      return IgxCarouselComponent;
    }();

    IgxCarouselComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-carousel',
        template: "<div tabindex=\"0\" aria-label=\"carousel\" class=\"igx-carousel\"\n        (mouseenter)=\"stop()\"\n        (mouseleave)=\"play()\"\n        (swipeleft)=\"next()\"\n        (swiperight)=\"prev()\"\n        (tap)=\"isPlaying ? stop() : play()\">\n    <ul class=\"igx-carousel__indicators\" [hidden]=\"slides.length <= 1\">\n        <li *ngFor=\"let slide of slides\" [attr.aria-label]=\"setAriaLabel(slide)\" [attr.aria-selected]=\"slide.active\" [class.active]=\"slide.active === true\"\n            (click)=\"select(slide)\"></li>\n    </ul>\n    <div class=\"igx-carousel__inner\" role=\"list\">\n        <ng-content></ng-content>\n    </div>\n    <div *ngIf=\"navigation\">\n        <a role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--prev\" (click)=\"prev()\" [hidden]=\"!slides.length\">\n            <igx-icon fontSet=\"material\">arrow_back</igx-icon>\n        </a>\n        <a role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--next\" (click)=\"next()\" [hidden]=\"!slides.length\">\n            <igx-icon fontSet=\"material\">arrow_forward</igx-icon>\n        </a>\n    </div>\n</div>\n",
        styles: ["\n    :host {\n        display: block;\n        outline-style: none;\n    }"]
      }]
    }];
    /** @nocollapse */

    IgxCarouselComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: PlatformUtil
      }];
    };

    IgxCarouselComponent.propDecorators = {
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      loop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      pause: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      interval: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      tabIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      navigation: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onSlideChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onSlideAdded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onSlideRemoved: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onCarouselPaused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onCarouselPlaying: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onKeydownArrowRight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowright']
      }],
      onKeydownArrowLeft: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowleft']
      }]
    };
    /**
     * A slide component that usually holds an image and/or a caption text.
     * IgxSlideComponent is usually a child component of an IgxCarouselComponent.
     *
     * ```
     * <igx-slide [input bindings] >
     *    <ng-content></ng-content>
     * </igx-slide>
     * ```
     *
     * @export
     */

    var IgxSlideComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} carousel
       */
      function IgxSlideComponent(carousel) {
        _classCallCheck(this, IgxSlideComponent);

        this.carousel = carousel;
        /**
         * @hidden
         */

        this.activeChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * Gets/sets the `active` state of the slide.
       * ```html
       * <igx-carousel>
       *  <igx-slide [active] ="false"></igx-slide>
       * <igx-carousel>
       * ```
       *
       * Two-way data binding.
       * ```html
       * <igx-carousel>
       *  <igx-slide [(active)] ="model.isActive"></igx-slide>
       * <igx-carousel>
       * ```
       * \@memberof IgxSlideComponent
       * @return {?}
       */


      _createClass(IgxSlideComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this.carousel.add(this);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.carousel.remove(this);
        }
      }, {
        key: "active",
        get: function get() {
          return this._active;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._active = value;
          this.activeChange.emit(this._active);
        }
      }]);

      return IgxSlideComponent;
    }();

    IgxSlideComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-slide',
        template: "<div\n    role=\"listitem\"\n    [class.active]=\"active\"\n    class=\"igx-slide\"\n    [attr.aria-selected]=\"active\"\n    [attr.aria-live]=\"active ? 'polite' : null\"\n    [attr.tabIndex]=\"active ? 0 : null\"\n>\n    <ng-content></ng-content>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxSlideComponent.ctorParameters = function () {
      return [{
        type: IgxCarouselComponent
      }];
    };

    IgxSlideComponent.propDecorators = {
      index: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      direction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      active: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.active']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      activeChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @hidden
     */

    var IgxCarouselModule = function IgxCarouselModule() {
      _classCallCheck(this, IgxCarouselModule);
    };

    IgxCarouselModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxCarouselComponent, IgxSlideComponent],
        exports: [IgxCarouselComponent, IgxSlideComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxIconModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var LabelPosition = {
      BEFORE: 'before',
      AFTER: 'after'
    };
    /** @type {?} */

    var noop$3 = function noop$3() {};
    /** @type {?} */


    var nextId$2 = 0;
    /**
     * **Ignite UI for Angular Checkbox** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/checkbox.html)
     *
     * The Ignite UI Checkbox is a selection control that allows users to make a binary choice. It behaves similarly
     * to the native browser checkbox.
     *
     * Example:
     * ```html
     * <igx-checkbox checked="true">
     *   simple checkbox
     * </igx-checkbox>
     * ```
     */

    var IgxCheckboxComponent =
    /*#__PURE__*/
    function () {
      function IgxCheckboxComponent() {
        _classCallCheck(this, IgxCheckboxComponent);

        /**
         * Sets/gets the `id` of the checkbox component.
         * If not set, the `id` of the first checkbox component will be `"igx-checkbox-0"`.
         * ```html
         * <igx-checkbox id="my-first-checkbox"></igx-checkbox>
         * ```
         * ```typescript
         * let checkboxId =  this.checkbox.id;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.id = "igx-checkbox-".concat(nextId$2++);
        /**
         * Sets/gets the id of the `label` element.
         * If not set, the id of the `label` in the first checkbox component will be `"igx-checkbox-0-label"`.
         * ```html
         * <igx-checkbox labelId = "Label1"></igx-checkbox>
         * ```
         * ```typescript
         * let labelId =  this.checkbox.labelId;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.labelId = "".concat(this.id, "-label");
        /**
         * Sets/gets the value of the `tabindex` attribute.
         * ```html
         * <igx-checkbox [tabindex] = "1"></igx-checkbox>
         * ```
         * ```typescript
         * let tabIndex =  this.checkbox.tabindex;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.tabindex = null;
        /**
         *  Sets/gets the position of the `label`.
         *  If not set, the `labelPosition` will have value `"after"`.
         * ```html
         * <igx-checkbox labelPosition = "before"></igx-checkbox>
         * ```
         * ```typescript
         * let labelPosition =  this.checkbox.labelPosition;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.labelPosition = LabelPosition.AFTER;
        /**
         * Enables/Disables the ripple effect.
         * If not set, `disableRipple` will have value `false`.
         * ```html
         * <igx-checkbox [disableRipple] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRippleDisabled = this.checkbox.desableRipple;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.disableRipple = false;
        /**
         * Sets/gets whether the checkbox is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-checkbox [required] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRequired =  this.checkbox.required;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-checkbox aria-labelledby = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabelledBy =  this.checkbox.ariaLabelledBy;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         * ```html
         * <igx-checkbox aria-label = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabel = this.checkbox.aruaLabel;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.ariaLabel = null;
        /**
         * An event that is emitted after the checkbox state is changed.
         * Provides references to the `IgxCheckboxComponent` and the `checked` property as event arguments.
         * \@memberof IgxCheckboxComponent
         */

        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Returns the class of the checkbox component.
         * ```typescript
         * let class =  this.checkbox.cssClass;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.cssClass = 'igx-checkbox';
        /**
         * Sets/gets whether the checkbox component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.checkbox.focused =  true;
         * ```
         * ```typescript
         * let isFocused =  this.checkbox.focused;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.focused = false;
        /**
         * Sets/gets the checkbox indeterminate visual state.
         * Default value is `false`;
         * ```html
         * <igx-checkbox [indeterminate] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isIndeterminate = this.checkbox.indeterminate;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.indeterminate = false;
        /**
         * Sets/gets whether the checkbox is checked.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [checked] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isChecked =  this.checkbox.checked;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.checked = false;
        /**
         * Sets/gets whether the checkbox is disabled.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [disabled] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isDisabled = this.checkbox.disabled;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.disabled = false;
        /**
         * Sets/gets whether the checkbox is readonly.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [readonly]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let readonly = this.checkbox.readonly;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.readonly = false;
        /**
         * Sets/gets whether the checkbox should disable all css transitions.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [disableTransitions]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let disableTransitions = this.checkbox.disableTransitions;
         * ```
         * \@memberof IgxCheckboxComponent
         */

        this.disableTransitions = false;
        /**
         * @hidden
         */

        this.inputId = "".concat(this.id, "-input");
        /**
         * @hidden
         */

        this._onTouchedCallback = noop$3;
        /**
         * @hidden
         */

        this._onChangeCallback = noop$3;
      }
      /**
       * If `disabled` is `false`, switches the `checked` state.
       * ```typescript
       * this.checkbox.toggle();
       * ```
       * \@memberof IgxCheckboxComponent
       * @return {?}
       */


      _createClass(IgxCheckboxComponent, [{
        key: "toggle",
        value: function toggle() {
          if (this.disabled || this.readonly) {
            return;
          }

          this.indeterminate = false;
          this.focused = false;
          this.checked = !this.checked;
          this.change.emit({
            checked: this.checked,
            checkbox: this
          });

          this._onChangeCallback(this.checked);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onCheckboxChange",
        value: function _onCheckboxChange(event) {
          // We have to stop the original checkbox change event
          // from bubbling up since we emit our own change event
          event.stopPropagation();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onCheckboxClick",
        value: function _onCheckboxClick(event) {
          // Since the original checkbox is hidden and the label
          // is used for styling and to change the checked state of the checkbox,
          // we need to prevent the checkbox click event from bubbling up
          // as it gets triggered on label click
          event.stopPropagation();

          if (this.readonly) {
            // readonly prevents the component from changing state (see toggle() method).
            // However, the native checkbox can still be activated through user interaction (focus + space, label click)
            // Prevent the native change so the input remains in sync
            event.preventDefault();
          }

          if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
          }

          this.toggle();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onLabelClick",
        value: function _onLabelClick(event) {
          // We use a span element as a placeholder label
          // in place of the native label, we need to emit
          // the change event separately here alongside
          // the click event emitted on click
          this.toggle();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus(event) {
          this.focused = true;
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur(event) {
          this.focused = false;

          this._onTouchedCallback();
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this._value = value;
          this.checked = !!this._value;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "registerOnChange",

        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getEditElement",
        value: function getEditElement() {
          return this.nativeCheckbox.nativeElement;
        }
      }, {
        key: "labelClass",
        get: function get() {
          switch (this.labelPosition) {
            case LabelPosition.BEFORE:
              return "".concat(this.cssClass, "__label--before");

            case LabelPosition.AFTER:
            default:
              return "".concat(this.cssClass, "__label");
          }
        }
      }]);

      return IgxCheckboxComponent;
    }();

    IgxCheckboxComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxCheckboxComponent,
          multi: true
        }],
        selector: 'igx-checkbox',
        preserveWhitespaces: false,
        template: "<input #checkbox class=\"igx-checkbox__input\"\n    type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [indeterminate]=\"indeterminate\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onCheckboxChange($event)\"\n    (click)=\"_onCheckboxClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<div\n    igxRipple\n    igxRippleTarget=\".igx-checkbox__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    class=\"igx-checkbox__composite-wrapper\"\n>\n    <label #label class=\"igx-checkbox__composite\"\n        [attr.for]=\"inputId\">\n        <svg class=\"igx-checkbox__composite-mark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n            <path d=\"M4.1,12.7 9,17.6 20.3,6.3\" />\n        </svg>\n    </label>\n\n    <div class=\"igx-checkbox__ripple\"></div>\n</div>\n\n<span #placeholderLabel role=\"label\"\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
      }]
    }];
    IgxCheckboxComponent.propDecorators = {
      nativeCheckbox: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['checkbox', {
          "static": true
        }]
      }],
      nativeLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['label', {
          "static": true
        }]
      }],
      placeholderLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['placeholderLabel', {
          "static": true
        }]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      labelId: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      labelPosition: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disableRipple: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ariaLabelledBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['aria-labelledby']
      }],
      ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['aria-label']
      }],
      change: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-checkbox']
      }],
      focused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-checkbox--focused']
      }],
      indeterminate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-checkbox--indeterminate']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-checkbox--checked']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-checkbox--disabled']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      readonly: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disableTransitions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-checkbox--plain']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /** @type {?} */

    var IGX_CHECKBOX_REQUIRED_VALIDATOR = {
      provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALIDATORS"],
      useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
        return IgxCheckboxRequiredDirective;
      }),
      multi: true
    };
    /* tslint:disable directive-selector */

    var IgxCheckboxRequiredDirective =
    /*#__PURE__*/
    function (_angular_forms__WEBPA) {
      _inherits(IgxCheckboxRequiredDirective, _angular_forms__WEBPA);

      function IgxCheckboxRequiredDirective() {
        _classCallCheck(this, IgxCheckboxRequiredDirective);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxCheckboxRequiredDirective).apply(this, arguments));
      }

      return IgxCheckboxRequiredDirective;
    }(_angular_forms__WEBPACK_IMPORTED_MODULE_2__["CheckboxRequiredValidator"]);

    IgxCheckboxRequiredDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: "igx-checkbox[required][formControlName],\n    igx-checkbox[required][formControl],\n    igx-checkbox[required][ngModel]",
        providers: [IGX_CHECKBOX_REQUIRED_VALIDATOR]
      }]
    }];
    /**
     * @hidden
     */

    var IgxCheckboxModule = function IgxCheckboxModule() {
      _classCallCheck(this, IgxCheckboxModule);
    };

    IgxCheckboxModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
        exports: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
        imports: [IgxRippleModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var CHIP_ID = 0;

    var IgxChipComponent =
    /*#__PURE__*/
    function (_DisplayDensityBase5) {
      _inherits(IgxChipComponent, _DisplayDensityBase5);

      /**
       * @param {?} cdr
       * @param {?} elementRef
       * @param {?} renderer
       * @param {?} _displayDensityOptions
       */
      function IgxChipComponent(cdr, elementRef, renderer, _displayDensityOptions) {
        var _this130;

        _classCallCheck(this, IgxChipComponent);

        _this130 = _possibleConstructorReturn(this, _getPrototypeOf(IgxChipComponent).call(this, _displayDensityOptions));
        _this130.cdr = cdr;
        _this130.elementRef = elementRef;
        _this130.renderer = renderer;
        _this130._displayDensityOptions = _displayDensityOptions;
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-chip [id]="'igx-chip-1'"></igx-chip>
         * ```
         */

        _this130.id = "igx-chip-".concat(CHIP_ID++);
        /**
         * An \@Input property that defines if the `IgxChipComponent` can be dragged in order to change it's position.
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true"></igx-chip>
         * ```
         */

        _this130.draggable = false;
        /**
         * An \@Input property that enables/disables the draggable element animation when the element is released.
         * By default it's set to true.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [animateOnRelease]="false"></igx-chip>
         * ```
         */

        _this130.animateOnRelease = true;
        /**
         * An \@Input property that enables/disables the hiding of the base element that has been dragged.
         * By default it's set to true.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [hideBaseOnDrag]="false"></igx-chip>
         * ```
         */

        _this130.hideBaseOnDrag = true;
        /**
         * An \@Input property that defines if the `IgxChipComponent` should render remove button and throw remove events.
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [removable]="true"></igx-chip>
         * ```
         */

        _this130.removable = false;
        /**
         * An \@Input property that defines if the `IgxChipComponent` can be selected on click or through navigation,
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="chip.id" [draggable]="true" [removable]="true" [selectable]="true"></igx-chip>
         * ```
         */

        _this130.selectable = false;
        /**
         * @hidden
         */

        _this130["class"] = '';
        /**
         * An \@Input property that defines if the `IgxChipComponent` is disabled. When disabled it restricts user interactions
         * like focusing on click or tab, selection on click or Space, dragging.
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="chip.id" [disabled]="true"></igx-chip>
         * ```
         */

        _this130.disabled = false;
        /**
         * @hidden
         */

        _this130.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` moving starts.
         * Returns the moving `IgxChipComponent`.
         * ```typescript
         * moveStarted(event: IBaseChipEventArgs){
         *     let movingChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveStart)="moveStarted($event)">
         * ```
         */

        _this130.onMoveStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` moving ends.
         * Returns the moved `IgxChipComponent`.
         * ```typescript
         * moveEnded(event: IBaseChipEventArgs){
         *     let movedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveEnd)="moveEnded($event)">
         * ```
         */

        _this130.onMoveEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` is removed.
         * Returns the removed `IgxChipComponent`.
         * ```typescript
         * remove(event: IBaseChipEventArgs){
         *     let removedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onRemove)="remove($event)">
         * ```
         */

        _this130.onRemove = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` is clicked.
         * Returns the clicked `IgxChipComponent`, whether the event should be canceled.
         * ```typescript
         * chipClick(event: IChipClickEventArgs){
         *     let clickedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onClick)="chipClick($event)">
         * ```
         */

        _this130.onClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected.
         * Returns the selected chip reference, whether the event should be canceled, what is the next selection state and
         * when the event is triggered by interaction `originalEvent` is provided, otherwise `originalEvent` is `null`.
         * ```typescript
         * chipSelect(event: IChipSelectEventArgs){
         *     let selectedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelection)="chipSelect($event)">
         * ```
         */

        _this130.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected and any related animations and transitions also end.
         * ```typescript
         * chipSelectEnd(event: IBaseChipEventArgs){
         *     let selectedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelectionDone)="chipSelectEnd($event)">
         * ```
         */

        _this130.onSelectionDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` keyboard navigation is being used.
         * Returns the focused/selected `IgxChipComponent`, whether the event should be canceled,
         * if the `alt`, `shift` or `control` key is pressed and the pressed key name.
         * ```typescript
         * chipKeyDown(event: IChipKeyDownEventArgs){
         *     let keyDown = event.key;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onKeyDown)="chipKeyDown($event)">
         * ```
         */

        _this130.onKeyDown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the `IgxChipComponent` has entered the `IgxChipsAreaComponent`.
         * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as
         * the original drop event arguments.
         * ```typescript
         * chipEnter(event: IChipEnterDragAreaEventArgs){
         *     let targetChip = event.targetChip;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onDragEnter)="chipEnter($event)">
         * ```
         */

        _this130.onDragEnter = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        _this130._selected = false;
        _this130._selectedItemClass = 'igx-chip__item--selected';
        _this130._movedWhileRemoving = false;
        return _this130;
      }
      /**
       * Sets the `IgxChipComponent` selected state.
       * ```html
       * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [selected]="true">
       * ```
       *
       * Two-way data binding:
       * ```html
       * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [(selected)]="model.isSelected">
       * ```
       * @param {?} newValue
       * @return {?}
       */


      _createClass(IgxChipComponent, [{
        key: "selectClass",

        /**
         * @hidden
         * @param {?} condition
         * @return {?}
         */
        value: function selectClass(condition) {
          var _ref2;

          /** @type {?} */
          var SELECT_CLASS = 'igx-chip__select';
          return _ref2 = {}, _defineProperty(_ref2, SELECT_CLASS, condition), _defineProperty(_ref2, "".concat(SELECT_CLASS, "--hidden"), !condition), _ref2;
        }
        /**
         * @protected
         * @param {?} newValue
         * @param {?=} srcEvent
         * @return {?}
         */

      }, {
        key: "changeSelection",
        value: function changeSelection(newValue) {
          var srcEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          /** @type {?} */
          var onSelectArgs = {
            originalEvent: srcEvent,
            owner: this,
            selected: false,
            cancel: false
          };

          if (newValue && !this._selected) {
            onSelectArgs.selected = true;
            this.onSelection.emit(onSelectArgs);

            if (!onSelectArgs.cancel) {
              this.renderer.addClass(this.chipArea.nativeElement, this._selectedItemClass);
              this._selected = newValue;
              this.selectedChange.emit(this._selected);
            }
          } else if (!newValue && this._selected) {
            this.onSelection.emit(onSelectArgs);

            if (!onSelectArgs.cancel) {
              this.renderer.removeClass(this.chipArea.nativeElement, this._selectedItemClass);
              this._selected = newValue;
              this.selectedChange.emit(this._selected);
            }
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onSelectTransitionDone",
        value: function onSelectTransitionDone(event) {
          if (event.propertyName === 'width' && !!event.target.tagName) {
            // Trigger onSelectionDone on when `width` property is changed and the target is valid element(not comment).
            this.onSelectionDone.emit({
              owner: this,
              originalEvent: event
            });
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipKeyDown",
        value: function onChipKeyDown(event) {
          /** @type {?} */
          var keyDownArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
          };
          this.onKeyDown.emit(keyDownArgs);

          if (keyDownArgs.cancel) {
            return;
          }

          if ((event.key === 'Delete' || event.key === 'Del') && this.removable) {
            this.onRemove.emit({
              originalEvent: event,
              owner: this
            });
          }

          if ((event.key === ' ' || event.key === 'Spacebar') && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
          }

          if (event.key !== 'Tab') {
            event.preventDefault();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onRemoveBtnKeyDown",
        value: function onRemoveBtnKeyDown(event) {
          if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {
            this.onRemove.emit({
              originalEvent: event,
              owner: this
            });
            event.preventDefault();
            event.stopPropagation();
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onRemoveMouseDown",
        value: function onRemoveMouseDown(event) {
          event.stopPropagation();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onRemoveClick",
        value: function onRemoveClick(event) {
          this.onRemove.emit({
            originalEvent: event,
            owner: this
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onRemoveTouchMove",
        value: function onRemoveTouchMove() {
          // We don't remove chip if user starting touch interacting on the remove button moves the chip
          this._movedWhileRemoving = true;
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onRemoveTouchEnd",
        value: function onRemoveTouchEnd(event) {
          if (!this._movedWhileRemoving) {
            this.onRemoveClick(event);
          }

          this._movedWhileRemoving = false;
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        // -----------------------------
        // Start chip igxDrag behavior

      }, {
        key: "onChipDragStart",
        value: function onChipDragStart(event) {
          this.onMoveStart.emit({
            originalEvent: event,
            owner: this
          });
          event.cancel = !this.draggable || this.disabled;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onChipDragEnd",
        value: function onChipDragEnd() {
          if (this.animateOnRelease) {
            this.dragDirective.transitionToOrigin();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipMoveEnd",
        value: function onChipMoveEnd(event) {
          // moveEnd is triggered after return animation has finished. This happen when we drag and release the chip.
          this.onMoveEnd.emit({
            originalEvent: event,
            owner: this
          });

          if (this.selected) {
            this.chipArea.nativeElement.focus();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipDragClicked",
        value: function onChipDragClicked(event) {
          /** @type {?} */
          var clickEventArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
          };
          this.onClick.emit(clickEventArgs);

          if (!clickEventArgs.cancel && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
          }
        } // End chip igxDrag behavior

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        // -----------------------------
        // Start chip igxDrop behavior

      }, {
        key: "onChipDragEnterHandler",
        value: function onChipDragEnterHandler(event) {
          if (this.dragDirective === event.drag || !event.drag.data || !event.drag.data.chip) {
            return;
          }
          /** @type {?} */


          var eventArgs = {
            owner: this,
            dragChip: event.drag.data.chip,
            originalEvent: event
          };
          this.onDragEnter.emit(eventArgs);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipDrop",
        value: function onChipDrop(event) {
          // Cancel the default drop logic
          event.cancel = true;
        }
      }, {
        key: "selected",
        set: function set(newValue) {
          this.changeSelection(newValue);
        }
        /**
         * Returns if the `IgxChipComponent` is selected.
         * ```typescript
         * \@ViewChild('myChip')
         * public chip: IgxChipComponent;
         * selectedChip(){
         *     let selectedChip = this.chip.selected;
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._selected;
        }
        /**
         * An \@Input property that sets the `IgxChipComponent` background color.
         * The `color` property supports string, rgb, hex.
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [color]="'#ff0000'"></igx-chip>
         * ```
         * @param {?} newColor
         * @return {?}
         */

      }, {
        key: "color",
        set: function set(newColor) {
          this.chipArea.nativeElement.style.backgroundColor = newColor;
        }
        /**
         * Returns the background color of the `IgxChipComponent`.
         * ```typescript
         * \@ViewChild('myChip')
         * public chip: IgxChipComponent;
         * ngAfterViewInit(){
         *     let chipColor = this.chip.color;
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this.chipArea.nativeElement.style.backgroundColor;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hostClass",
        get: function get() {
          /** @type {?} */
          var classes = [this.getComponentDensityClass('igx-chip')];
          classes.push(this.disabled ? 'igx-chip--disabled' : ''); // The custom classes should be at the end.

          classes.push(this["class"]);
          return classes.join(' ');
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "removeButtonTemplate",
        get: function get() {
          return this.removeIcon || this.defaultRemoveIcon;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "selectIconTemplate",
        get: function get() {
          return this.selectIcon || this.defaultSelectIcon;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ghostClass",
        get: function get() {
          return this.getComponentDensityClass('igx-chip__ghost');
        }
        /**
         * @return {?}
         */

      }, {
        key: "chipTabindex",
        get: function get() {
          return !this.disabled ? 0 : '';
        }
      }]);

      return IgxChipComponent;
    }(DisplayDensityBase);

    IgxChipComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-chip',
        template: "<div #chipArea class=\"igx-chip__item\"\n    [attr.tabindex]=\"chipTabindex\"\n    (keydown)=\"onChipKeyDown($event)\"\n    [igxDrag]=\"{chip: this}\"\n    [hideBaseOnDrag]=\"hideBaseOnDrag\"\n    [ghostClass]=\"ghostClass\"\n    (dragStart)=\"onChipDragStart($event)\"\n    (dragEnd)=\"onChipDragEnd()\"\n    (transitioned)=\"onChipMoveEnd($event)\"\n    (dragClick)=\"onChipDragClicked($event)\"\n    igxDrop\n    (enter)=\"onChipDragEnterHandler($event)\"\n    (dropped)=\"onChipDrop($event)\">\n\n    <div [ngClass]=\"selectClass(selected)\" (transitionend)=\"onSelectTransitionDone($event)\">\n        <ng-container *ngTemplateOutlet=\"selectIconTemplate\"></ng-container>\n    </div>\n\n    <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n    <div class=\"igx-chip__content\">\n        <ng-content></ng-content>\n    </div>\n\n    <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n\n    <div class=\"igx-chip__remove\" *ngIf=\"removable\"\n        tabindex=\"0\"\n        (keydown)=\"onRemoveBtnKeyDown($event)\"\n        (pointerdown)=\"onRemoveMouseDown($event)\"\n        (mousedown)=\"onRemoveMouseDown($event)\"\n        (click)=\"onRemoveClick($event)\"\n        (touchmove)=\"onRemoveTouchMove()\"\n        (touchend)=\"onRemoveTouchEnd($event)\">\n        <ng-container *ngTemplateOutlet=\"removeButtonTemplate\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultSelectIcon>\n    <igx-icon>done</igx-icon>\n</ng-template>\n\n<ng-template #defaultRemoveIcon>\n    <igx-icon>cancel</igx-icon>\n</ng-template>\n"
      }]
    }];
    /** @nocollapse */

    IgxChipComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxChipComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      draggable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      animateOnRelease: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hideBaseOnDrag: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      removable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      removeIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selectable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selectIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      "class": [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selectedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      color: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onMoveStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onMoveEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRemove: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onSelectionDone: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onKeyDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onDragEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      hostClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.class']
      }],
      dragDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['chipArea', {
          read: IgxDragDirective,
          "static": true
        }]
      }],
      chipArea: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['chipArea', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": true
        }]
      }],
      defaultRemoveIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultRemoveIcon', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultSelectIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultSelectIcon', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxChipsAreaComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       * @param {?} element
       * @param {?} _iterableDiffers
       */
      function IgxChipsAreaComponent(cdr, element, _iterableDiffers) {
        _classCallCheck(this, IgxChipsAreaComponent);

        this.cdr = cdr;
        this.element = element;
        this._iterableDiffers = _iterableDiffers;
        /**
         * @hidden
         */

        this["class"] = '';
        /**
         * Emits an event when `IgxChipComponent`s in the `IgxChipsAreaComponent` should be reordered.
         * Returns an array of `IgxChipComponent`s.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onReorder)="changedOrder($event)"></igx-chips-area>
         * ```
         * ```typescript
         * public changedOrder(event: IChipsAreaReorderEventArgs){
         *      let chips: IgxChipComponent[] = event.chipsArray;
         * }
         * ```
         */

        this.onReorder = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is selected/deselected.
         * Fired after the chips area is initialized if there are initially selected chips as well.
         * Returns an array of selected `IgxChipComponent`s and the `IgxChipAreaComponent`.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onSelection)="selection($event)"></igx-chips-area>
         * ```
         * ```typescript
         * public selection(event: IChipsAreaSelectEventArgs){
         *      let selectedChips: IgxChipComponent[] = event.newSelection;
         * }
         */

        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveStart)="moveStart($event)"></igx-chips-area>
         * ```
         * ```typescript
         * moveStart(event: IBaseChipsAreaEventArgs){
         *      let chipArea = event.owner;
         * }
         * ```
         */

        this.onMoveStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event after an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveEnd)="moveEnd($event)"></igx-chips-area>
         * ```
         * ```typescript
         * moveEnd(event: IBaseChipsAreaEventArgs){
         *      let chipArea = event.owner;
         * }
         * ```
         */

        this.onMoveEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._differ = null;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._differ = this._iterableDiffers.find([]).create(null);
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxChipsAreaComponent, [{
        key: "ngAfterViewInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterViewInit() {
          // If we have initially selected chips through their inputs, we need to get them, because we cannot listen to their events yet.
          if (this.chipsList.length) {
            /** @type {?} */
            var selectedChips = this.chipsList.filter(function (item) {
              return item.selected;
            });

            if (selectedChips.length) {
              this.onSelection.emit({
                originalEvent: null,
                newSelection: selectedChips,
                owner: this
              });
            }
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          var _this131 = this;

          if (this.chipsList) {
            /** @type {?} */
            var changes = this._differ.diff(this.chipsList.toArray());

            if (changes) {
              changes.forEachAddedItem(function (addedChip) {
                addedChip.item.onMoveStart.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this131.destroy$)).subscribe(function (args) {
                  _this131.onChipMoveStart(args);
                });
                addedChip.item.onMoveEnd.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this131.destroy$)).subscribe(function (args) {
                  _this131.onChipMoveEnd(args);
                });
                addedChip.item.onDragEnter.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this131.destroy$)).subscribe(function (args) {
                  _this131.onChipDragEnter(args);
                });
                addedChip.item.onKeyDown.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this131.destroy$)).subscribe(function (args) {
                  _this131.onChipKeyDown(args);
                });

                if (addedChip.item.selectable) {
                  addedChip.item.onSelection.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this131.destroy$)).subscribe(function (args) {
                    _this131.onChipSelectionChange(args);
                  });
                }
              });
              this.modifiedChipsArray = this.chipsList.toArray();
            }
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
        /**
         * @hidden
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipKeyDown",
        value: function onChipKeyDown(event) {
          var _this132 = this;

          /** @type {?} */
          var orderChanged = false;
          /** @type {?} */

          var chipsArray = this.chipsList.toArray();
          /** @type {?} */

          var dragChipIndex = chipsArray.findIndex(function (el) {
            return el === event.owner;
          });

          if (event.originalEvent.shiftKey === true) {
            if (event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') {
              orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex - 1, false, event.originalEvent);

              if (orderChanged) {
                setTimeout(function () {
                  _this132.chipsList.toArray()[dragChipIndex - 1].chipArea.nativeElement.focus();
                });
              }
            } else if (event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') {
              orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex + 1, true, event.originalEvent);
            }
          } else {
            if ((event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') && dragChipIndex > 0) {
              chipsArray[dragChipIndex - 1].chipArea.nativeElement.focus();
            } else if ((event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') && dragChipIndex < chipsArray.length - 1) {
              chipsArray[dragChipIndex + 1].chipArea.nativeElement.focus();
            }
          }
        }
        /**
         * @hidden
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipMoveStart",
        value: function onChipMoveStart(event) {
          this.onMoveStart.emit({
            originalEvent: event.originalEvent,
            owner: this
          });
        }
        /**
         * @hidden
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipMoveEnd",
        value: function onChipMoveEnd(event) {
          this.onMoveEnd.emit({
            originalEvent: event.originalEvent,
            owner: this
          });
        }
        /**
         * @hidden
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipDragEnter",
        value: function onChipDragEnter(event) {
          /** @type {?} */
          var dropChipIndex = this.chipsList.toArray().findIndex(function (el) {
            return el === event.owner;
          });
          /** @type {?} */

          var dragChipIndex = this.chipsList.toArray().findIndex(function (el) {
            return el === event.dragChip;
          });

          if (dragChipIndex < dropChipIndex) {
            // from the left to right
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, true, event.originalEvent);
          } else {
            // from the right to left
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, false, event.originalEvent);
          }
        }
        /**
         * @hidden
         * @protected
         * @param {?} chipIndex
         * @param {?} targetIndex
         * @param {?} shiftRestLeft
         * @param {?} originalEvent
         * @return {?}
         */

      }, {
        key: "positionChipAtIndex",
        value: function positionChipAtIndex(chipIndex, targetIndex, shiftRestLeft, originalEvent) {
          if (chipIndex < 0 || this.chipsList.length <= chipIndex || targetIndex < 0 || this.chipsList.length <= targetIndex) {
            return false;
          }
          /** @type {?} */


          var chipsArray = this.chipsList.toArray();
          /** @type {?} */

          var result = [];

          for (var i = 0; i < chipsArray.length; i++) {
            if (shiftRestLeft) {
              if (chipIndex <= i && i < targetIndex) {
                result.push(chipsArray[i + 1]);
              } else if (i === targetIndex) {
                result.push(chipsArray[chipIndex]);
              } else {
                result.push(chipsArray[i]);
              }
            } else {
              if (targetIndex < i && i <= chipIndex) {
                result.push(chipsArray[i - 1]);
              } else if (i === targetIndex) {
                result.push(chipsArray[chipIndex]);
              } else {
                result.push(chipsArray[i]);
              }
            }
          }

          this.modifiedChipsArray = result;
          /** @type {?} */

          var eventData = {
            chipsArray: this.modifiedChipsArray,
            originalEvent: originalEvent,
            owner: this
          };
          this.onReorder.emit(eventData);
          return true;
        }
        /**
         * @hidden
         * @protected
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipSelectionChange",
        value: function onChipSelectionChange(event) {
          /** @type {?} */
          var selectedChips = this.chipsList.filter(function (chip) {
            return chip.selected;
          });

          if (event.selected && !selectedChips.includes(event.owner)) {
            selectedChips.push(event.owner);
          } else if (!event.selected && selectedChips.includes(event.owner)) {
            selectedChips = selectedChips.filter(function (chip) {
              return chip.id !== event.owner.id;
            });
          }

          this.onSelection.emit({
            originalEvent: event.originalEvent,
            newSelection: selectedChips,
            owner: this
          });
        }
      }, {
        key: "hostClass",
        get: function get() {
          /** @type {?} */
          var classes = ['igx-chip-area'];
          classes.push(this["class"]);
          return classes.join(' ');
        }
      }]);

      return IgxChipsAreaComponent;
    }();

    IgxChipsAreaComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-chips-area',
        template: "<ng-content></ng-content>\n"
      }]
    }];
    /** @nocollapse */

    IgxChipsAreaComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }];
    };

    IgxChipsAreaComponent.propDecorators = {
      "class": [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hostClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.class']
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.width.px']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      height: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.height.px']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onReorder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onMoveStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onMoveEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      chipsList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxChipComponent]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxChipsModule = function IgxChipsModule() {
      _classCallCheck(this, IgxChipsModule);
    };

    IgxChipsModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxChipsAreaComponent, IgxChipComponent],
        exports: [IgxChipsAreaComponent, IgxChipComponent, IgxPrefixDirective, IgxSuffixDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxRippleModule, IgxIconModule, IgxButtonModule, IgxAvatarModule, IgxDragDropModule, IgxPrefixModule, IgxSuffixModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxComboHeaderDirective = function IgxComboHeaderDirective() {
      _classCallCheck(this, IgxComboHeaderDirective);
    };

    IgxComboHeaderDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxComboHeader]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxComboFooterDirective = function IgxComboFooterDirective() {
      _classCallCheck(this, IgxComboFooterDirective);
    };

    IgxComboFooterDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxComboFooter]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxComboItemDirective = function IgxComboItemDirective() {
      _classCallCheck(this, IgxComboItemDirective);
    };

    IgxComboItemDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxComboItem]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxComboEmptyDirective = function IgxComboEmptyDirective() {
      _classCallCheck(this, IgxComboEmptyDirective);
    };

    IgxComboEmptyDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxComboEmpty]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxComboHeaderItemDirective = function IgxComboHeaderItemDirective() {
      _classCallCheck(this, IgxComboHeaderItemDirective);
    };

    IgxComboHeaderItemDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxComboHeaderItem]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxComboAddItemDirective = function IgxComboAddItemDirective() {
      _classCallCheck(this, IgxComboAddItemDirective);
    };

    IgxComboAddItemDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxComboAddItem]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxComboToggleIconDirective = function IgxComboToggleIconDirective() {
      _classCallCheck(this, IgxComboToggleIconDirective);
    };

    IgxComboToggleIconDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxComboToggleIcon]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxComboClearIconDirective = function IgxComboClearIconDirective() {
      _classCallCheck(this, IgxComboClearIconDirective);
    };

    IgxComboClearIconDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxComboClearIcon]'
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxComboAPIService =
    /*#__PURE__*/
    function () {
      function IgxComboAPIService() {
        _classCallCheck(this, IgxComboAPIService);

        this.disableTransitions = false;
      }
      /**
       * @param {?} combo
       * @return {?}
       */


      _createClass(IgxComboAPIService, [{
        key: "register",
        value: function register(combo) {
          this.combo = combo;
        }
        /**
         * @return {?}
         */

      }, {
        key: "clear",
        value: function clear() {
          this.combo = null;
        }
        /**
         * @return {?}
         */

      }, {
        key: "add_custom_item",

        /**
         * @return {?}
         */
        value: function add_custom_item() {
          if (!this.combo) {
            return;
          }

          this.combo.addItemToCollection();
        }
        /**
         * @return {?}
         */

      }, {
        key: "set_selected_item",

        /**
         * @param {?} itemID
         * @param {?=} event
         * @return {?}
         */
        value: function set_selected_item(itemID, event) {
          /** @type {?} */
          var selected = this.combo.isItemSelected(itemID);

          if (itemID === null || itemID === undefined) {
            return;
          }

          if (!selected) {
            this.combo.selectItems([itemID], false, event);
          } else {
            this.combo.deselectItems([itemID], event);
          }
        }
        /**
         * @param {?} itemID
         * @return {?}
         */

      }, {
        key: "is_item_selected",
        value: function is_item_selected(itemID) {
          return this.combo.isItemSelected(itemID);
        }
      }, {
        key: "valueKey",
        get: function get() {
          return this.combo.valueKey !== null && this.combo.valueKey !== undefined ? this.combo.valueKey : null;
        }
        /**
         * @return {?}
         */

      }, {
        key: "item_focusable",
        get: function get() {
          return false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isRemote",
        get: function get() {
          return this.combo.isRemote;
        }
      }, {
        key: "comboID",
        get: function get() {
          return this.combo.id;
        }
      }]);

      return IgxComboAPIService;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var IgxComboItemComponent =
    /*#__PURE__*/
    function (_IgxDropDownItemCompo) {
      _inherits(IgxComboItemComponent, _IgxDropDownItemCompo);

      /**
       * @param {?} comboAPI
       * @param {?} dropDown
       * @param {?} elementRef
       * @param {?} selection
       */
      function IgxComboItemComponent(comboAPI, dropDown, elementRef, selection) {
        var _this133;

        _classCallCheck(this, IgxComboItemComponent);

        _this133 = _possibleConstructorReturn(this, _getPrototypeOf(IgxComboItemComponent).call(this, dropDown, elementRef, null, selection));
        _this133.comboAPI = comboAPI;
        _this133.dropDown = dropDown;
        _this133.elementRef = elementRef;
        _this133.selection = selection;
        /**
         * Gets the height of a list item
         * @hidden
         */

        _this133.itemHeight = '';
        return _this133;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxComboItemComponent, [{
        key: "isVisible",

        /**
         * @hidden
         * @param {?} direction
         * @return {?}
         */
        value: function isVisible(direction) {
          /** @type {?} */
          var rect = this.element.nativeElement.getBoundingClientRect();
          /** @type {?} */

          var parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();

          if (direction === Navigate.Down) {
            return rect.y + rect.height <= parentDiv.y + parentDiv.height;
          }

          return rect.y >= parentDiv.y;
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "clicked",
        value: function clicked(event) {
          this.comboAPI.disableTransitions = false;

          if (this.disabled || this.isHeader) {
            /** @type {?} */
            var focusedItem = this.dropDown.items.find(function (item) {
              return item.focused;
            });

            if (this.dropDown.allowItemsFocus && focusedItem) {
              focusedItem.element.nativeElement.focus({
                preventScroll: true
              });
            }

            return;
          }

          this.dropDown.navigateItem(this.index);
          this.comboAPI.set_selected_item(this.itemID, event);
        }
        /**
         * @hidden
         * \@internal
         * The event that is prevented is the click on the checkbox label element.
         * That is the only visible element that a user can interact with.
         * The click propagates to the host and the preventDefault is to stop it from
         * switching focus to the input it's base on.
         * The toggle happens in an internal handler in the drop-down on the next task queue cycle.
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "disableCheck",
        value: function disableCheck(event) {
          event.preventDefault();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {}
      }, {
        key: "itemID",
        get: function get() {
          /** @type {?} */
          var valueKey = this.comboAPI.valueKey;
          return valueKey !== null ? this.value[valueKey] : this.value;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "comboID",
        get: function get() {
          return this.comboAPI.comboID;
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "disableTransitions",
        get: function get() {
          return this.comboAPI.disableTransitions;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this.comboAPI.is_item_selected(this.itemID);
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this.isHeader) {
            return;
          }

          this._selected = value;
        }
      }]);

      return IgxComboItemComponent;
    }(IgxDropDownItemComponent);

    IgxComboItemComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-combo-item',
        template: "<ng-container *ngIf=\"!isHeader\">\n    <igx-checkbox [checked]=\"selected\" disableRipple=\"true\" [disableTransitions]=\"disableTransitions\" [tabindex]=\"-1\" (click)=\"disableCheck($event)\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<ng-content></ng-content>\n"
      }]
    }];
    /** @nocollapse */

    IgxComboItemComponent.ctorParameters = function () {
      return [{
        type: IgxComboAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_DROPDOWN_BASE]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: IgxSelectionAPIService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxSelectionAPIService]
        }]
      }];
    };

    IgxComboItemComponent.propDecorators = {
      itemHeight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.height.px']
      }],
      clicked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var IGX_COMBO_COMPONENT = 'IgxComboComponentToken';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxComboAddItemComponent =
    /*#__PURE__*/
    function (_IgxComboItemComponen) {
      _inherits(IgxComboAddItemComponent, _IgxComboItemComponen);

      function IgxComboAddItemComponent() {
        _classCallCheck(this, IgxComboAddItemComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxComboAddItemComponent).apply(this, arguments));
      }

      _createClass(IgxComboAddItemComponent, [{
        key: "clicked",

        /**
         * @param {?=} event
         * @return {?}
         */
        value: function clicked(event) {
          this.comboAPI.disableTransitions = false;
          this.comboAPI.add_custom_item();
        }
      }, {
        key: "selected",

        /**
         * @return {?}
         */
        get: function get() {
          return false;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {}
      }]);

      return IgxComboAddItemComponent;
    }(IgxComboItemComponent);

    IgxComboAddItemComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-combo-add-item',
        template: '<ng-content></ng-content>',
        providers: [{
          provide: IgxComboItemComponent,
          useExisting: IgxComboAddItemComponent
        }]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxComboDropDownComponent =
    /*#__PURE__*/
    function (_IgxDropDownComponent) {
      _inherits(IgxComboDropDownComponent, _IgxDropDownComponent);

      /**
       * @param {?} elementRef
       * @param {?} cdr
       * @param {?} selection
       * @param {?} combo
       * @param {?} comboAPI
       * @param {?} _displayDensityOptions
       */
      function IgxComboDropDownComponent(elementRef, cdr, selection, combo, comboAPI, _displayDensityOptions) {
        var _this134;

        _classCallCheck(this, IgxComboDropDownComponent);

        _this134 = _possibleConstructorReturn(this, _getPrototypeOf(IgxComboDropDownComponent).call(this, elementRef, cdr, selection, _displayDensityOptions));
        _this134.elementRef = elementRef;
        _this134.cdr = cdr;
        _this134.selection = selection;
        _this134.combo = combo;
        _this134.comboAPI = comboAPI;
        _this134._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         * \@internal
         */

        _this134.children = null;

        _this134.scrollHandler = function () {
          _this134.comboAPI.disableTransitions = true;
        };

        return _this134;
      }
      /**
       * @protected
       * @return {?}
       */


      _createClass(IgxComboDropDownComponent, [{
        key: "onFocus",

        /**
         * @hidden \@internal
         * @return {?}
         */
        value: function onFocus() {
          this.focusedItem = this._focusedItem || this.items[0];
        }
        /**
         * @hidden \@internal
         * @param {?=} evt
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur(evt) {
          this.focusedItem = null;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onToggleOpened",
        value: function onToggleOpened() {
          this.onOpened.emit();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "navigateFirst",
        value: function navigateFirst() {
          this.navigateItem(this.virtDir.igxForOf.findIndex(function (e) {
            return !e.isHeader;
          }));
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "navigatePrev",
        value: function navigatePrev() {
          if (this._focusedItem && this._focusedItem.index === 0 && this.virtDir.state.startIndex === 0) {
            this.combo.focusSearchInput(false);
          } else {
            _get(_getPrototypeOf(IgxComboDropDownComponent.prototype), "navigatePrev", this).call(this);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "navigateNext",
        value: function navigateNext() {
          /** @type {?} */
          var lastIndex = this.combo.totalItemCount ? this.combo.totalItemCount - 1 : this.virtDir.igxForOf.length - 1;

          if (this._focusedItem && this._focusedItem.index === lastIndex) {
            this.focusAddItemButton();
          } else {
            _get(_getPrototypeOf(IgxComboDropDownComponent.prototype), "navigateNext", this).call(this);
          }
        }
        /**
         * @hidden \@internal
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "selectItem",
        value: function selectItem(item) {
          if (item === null || item === undefined) {
            return;
          }

          this.comboAPI.set_selected_item(item.itemID);
          this._focusedItem = item;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "focusAddItemButton",
        value: function focusAddItemButton() {
          if (this.combo.isAddButtonVisible()) {
            this.focusedItem = this.items[this.items.length - 1];
          }
        }
        /**
         * @protected
         * @param {?} newItem
         * @return {?}
         */

      }, {
        key: "scrollToHiddenItem",
        value: function scrollToHiddenItem(newItem) {}
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "updateScrollPosition",

        /**
         * @hidden \@internal
         * @return {?}
         */
        value: function updateScrollPosition() {
          this.virtDir.getScroll().scrollTop = this._scrollPosition;
        }
        /**
         * @hidden \@internal
         * @param {?} key
         * @return {?}
         */

      }, {
        key: "onItemActionKey",
        value: function onItemActionKey(key) {
          switch (key) {
            case DropDownActionKey.ENTER:
              this.handleEnter();
              break;

            case DropDownActionKey.SPACE:
              this.handleSpace();
              break;

            case DropDownActionKey.ESCAPE:
              this.close();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "handleEnter",
        value: function handleEnter() {
          if (this.isAddItemFocused()) {
            this.combo.addItemToCollection();
          } else {
            this.close();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "handleSpace",
        value: function handleSpace() {
          if (this.isAddItemFocused()) {
            return;
          } else {
            this.selectItem(this.focusedItem);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "isAddItemFocused",
        value: function isAddItemFocused() {
          return this.focusedItem instanceof IgxComboAddItemComponent;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.virtDir.getScroll().addEventListener('scroll', this.scrollHandler);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.virtDir.getScroll().removeEventListener('scroll', this.scrollHandler);
          this.destroy$.next(true);
          this.destroy$.complete();
        }
      }, {
        key: "scrollContainer",
        get: function get() {
          return this.virtDir.dc.location.nativeElement;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "isScrolledToLast",
        get: function get() {
          /** @type {?} */
          var scrollTop = this.virtDir.scrollPosition;
          /** @type {?} */

          var scrollHeight = this.virtDir.getScroll().scrollHeight;
          return Math.floor(scrollTop + this.virtDir.igxForContainerSize) === scrollHeight;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "lastVisibleIndex",
        get: function get() {
          return this.combo.totalItemCount ? Math.floor(this.combo.itemsMaxHeight / this.combo.itemHeight) : this.items.length - 1;
        }
      }, {
        key: "sortedChildren",
        get: function get() {
          if (this.children !== undefined) {
            return this.children.toArray().sort(function (a, b) {
              return a.index - b.index;
            });
          }

          return null;
        }
        /**
         * Get all non-header items
         *
         * ```typescript
         * let myDropDownItems = this.dropdown.items;
         * ```
         * @return {?}
         */

      }, {
        key: "items",
        get: function get() {
          /** @type {?} */
          var items = [];

          if (this.children !== undefined) {
            /** @type {?} */
            var sortedChildren =
            /** @type {?} */
            this.sortedChildren;
            var _iteratorNormalCompletion36 = true;
            var _didIteratorError36 = false;
            var _iteratorError36 = undefined;

            try {
              for (var _iterator36 = sortedChildren[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
                var child = _step36.value;

                if (!child.isHeader) {
                  items.push(child);
                }
              }
            } catch (err) {
              _didIteratorError36 = true;
              _iteratorError36 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion36 && _iterator36["return"] != null) {
                  _iterator36["return"]();
                }
              } finally {
                if (_didIteratorError36) {
                  throw _iteratorError36;
                }
              }
            }
          }

          return items;
        }
      }]);

      return IgxComboDropDownComponent;
    }(IgxDropDownComponent);

    IgxComboDropDownComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-combo-drop-down',
        template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\" [style.height]=\"height\"\n[style.maxHeight]=\"maxHeight\" [attr.id]=\"this.listId\" role=\"listbox\"\n    (onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n    (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <ng-container *ngIf=\"!collapsed\">\n        <ng-content></ng-content>\n    </ng-container>\n</div>\n",
        providers: [{
          provide: IGX_DROPDOWN_BASE,
          useExisting: IgxComboDropDownComponent
        }]
      }]
    }];
    /** @nocollapse */

    IgxComboDropDownComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxSelectionAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_COMBO_COMPONENT]
        }]
      }, {
        type: IgxComboAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxComboDropDownComponent.propDecorators = {
      children: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxComboItemComponent, {
          descendants: true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxComboFilteringPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} combo
       */
      function IgxComboFilteringPipe(combo) {
        _classCallCheck(this, IgxComboFilteringPipe);

        this.combo = combo;
      }
      /**
       * @param {?} collection
       * @param {?} expressions
       * @param {?} logic
       * @return {?}
       */


      _createClass(IgxComboFilteringPipe, [{
        key: "transform",
        value: function transform(collection, expressions, logic) {
          /** @type {?} */
          var filteringExpressionsTree = new FilteringExpressionsTree(logic);
          filteringExpressionsTree.filteringOperands = expressions;
          /** @type {?} */

          var state = {
            expressionsTree: filteringExpressionsTree,
            strategy: new SimpleFilteringStrategy()
          };
          state.expressionsTree.filteringOperands = this.combo.filteringExpressions;

          if (!state.expressionsTree.filteringOperands.length) {
            return collection;
          }
          /** @type {?} */


          var result = DataUtil.filter(cloneArray(collection), state);
          return result;
        }
      }]);

      return IgxComboFilteringPipe;
    }();

    IgxComboFilteringPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'comboFiltering'
      }]
    }];
    /** @nocollapse */

    IgxComboFilteringPipe.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_COMBO_COMPONENT]
        }]
      }];
    };
    /**
     * @hidden
     */


    var SimpleFilteringStrategy =
    /*#__PURE__*/
    function (_FilteringStrategy) {
      _inherits(SimpleFilteringStrategy, _FilteringStrategy);

      function SimpleFilteringStrategy() {
        _classCallCheck(this, SimpleFilteringStrategy);

        return _possibleConstructorReturn(this, _getPrototypeOf(SimpleFilteringStrategy).apply(this, arguments));
      }

      _createClass(SimpleFilteringStrategy, [{
        key: "findMatchByExpression",

        /**
         * @param {?} rec
         * @param {?} expr
         * @return {?}
         */
        value: function findMatchByExpression(rec, expr) {
          /** @type {?} */
          var cond = expr.condition;
          /** @type {?} */

          var val = expr.fieldName === undefined ? rec : rec[expr.fieldName];
          return cond.logic(val, expr.searchVal, expr.ignoreCase);
        }
      }]);

      return SimpleFilteringStrategy;
    }(FilteringStrategy);
    /**
     * @hidden
     */


    var IgxComboSortingPipe =
    /*#__PURE__*/
    function () {
      function IgxComboSortingPipe() {
        _classCallCheck(this, IgxComboSortingPipe);
      }
      /**
       * @param {?} collection
       * @param {?} expressions
       * @return {?}
       */


      _createClass(IgxComboSortingPipe, [{
        key: "transform",
        value: function transform(collection, expressions) {
          if (!expressions.length) {
            return collection;
          }
          /** @type {?} */


          var result = DataUtil.sort(cloneArray(collection), expressions);
          return result;
        }
      }]);

      return IgxComboSortingPipe;
    }();

    IgxComboSortingPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'comboSorting',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxComboSortingPipe.ctorParameters = function () {
      return [];
    };
    /**
     * @hidden
     */


    var IgxComboGroupingPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} combo
       */
      function IgxComboGroupingPipe(combo) {
        _classCallCheck(this, IgxComboGroupingPipe);

        this.combo = combo;
      }
      /**
       * @param {?} collection
       * @param {?} groupKey
       * @return {?}
       */


      _createClass(IgxComboGroupingPipe, [{
        key: "transform",
        value: function transform(collection, groupKey) {
          this.combo.filteredData = collection;

          if (!groupKey && groupKey !== 0 || !collection.length) {
            return collection;
          }
          /** @type {?} */


          var data = cloneArray(collection);
          /** @type {?} */

          var inserts = 0;
          /** @type {?} */

          var currentHeader = null;

          for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var insertFlag = 0;

            if (currentHeader !== collection[i][groupKey]) {
              currentHeader = collection[i][groupKey];
              insertFlag = 1;
            }

            if (insertFlag) {
              var _data$splice;

              data.splice(i + inserts, 0, (_data$splice = {}, _defineProperty(_data$splice, this.combo.valueKey, currentHeader), _defineProperty(_data$splice, this.combo.groupKey, currentHeader), _defineProperty(_data$splice, "isHeader", true), _data$splice));
              inserts++;
            }
          }

          return data;
        }
      }]);

      return IgxComboGroupingPipe;
    }();

    IgxComboGroupingPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'comboGrouping'
      }]
    }];
    /** @nocollapse */

    IgxComboGroupingPipe.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_COMBO_COMPONENT]
        }]
      }];
    };
    /**
     * @hidden
     */


    var IgxComboFilterConditionPipe =
    /*#__PURE__*/
    function () {
      function IgxComboFilterConditionPipe() {
        _classCallCheck(this, IgxComboFilterConditionPipe);
      }

      _createClass(IgxComboFilterConditionPipe, [{
        key: "transform",

        /**
         * @param {?} value
         * @return {?}
         */
        value: function transform(value) {
          return value.split(/(?=[A-Z])/).join(' ');
        }
      }]);

      return IgxComboFilterConditionPipe;
    }();

    IgxComboFilterConditionPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'filterCondition',
        pure: true
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var DataTypes = {
      EMPTY: 'empty',
      PRIMITIVE: 'primitive',
      COMPLEX: 'complex',
      PRIMARYKEY: 'valueKey'
    };
    /**
     * @hidden
     * @type {?}
     */

    var ItemHeights = {
      'comfortable': 40,
      'cosy': 32,
      'compact': 28
    };
    /**
     * @hidden
     * The default number of items that should be in the combo's
     * drop-down list if no `[itemsMaxHeight]` is specified
     * @type {?}
     */

    var itemsInContainer = 10;
    /** @enum {number} */

    var IgxComboState = {
      /**
       * Combo with initial state.
       */
      INITIAL: 0,

      /**
       * Combo with valid state.
       */
      VALID: 1,

      /**
       * Combo with invalid state.
       */
      INVALID: 2
    };
    IgxComboState[IgxComboState.INITIAL] = 'INITIAL';
    IgxComboState[IgxComboState.VALID] = 'VALID';
    IgxComboState[IgxComboState.INVALID] = 'INVALID';
    /**
     * When called with sets A & B, returns A - B (as array);
     * @hidden
     * @param {?} set1
     * @param {?} set2
     * @return {?}
     */

    function diffInSets(set1, set2) {
      /** @type {?} */
      var results = [];
      set1.forEach(function (entry) {
        if (!set2.has(entry)) {
          results.push(entry);
        }
      });
      return results;
    }
    /** @type {?} */


    var NEXT_ID$j = 0;
    /** @type {?} */

    var noop$4 = function noop$4() {};

    var IgxComboComponent =
    /*#__PURE__*/
    function (_DisplayDensityBase6) {
      _inherits(IgxComboComponent, _DisplayDensityBase6);

      /**
       * @param {?} elementRef
       * @param {?} cdr
       * @param {?} selection
       * @param {?} comboAPI
       * @param {?} _displayDensityOptions
       * @param {?} _injector
       */
      function IgxComboComponent(elementRef, cdr, selection, comboAPI, _displayDensityOptions, _injector) {
        var _this135;

        _classCallCheck(this, IgxComboComponent);

        _this135 = _possibleConstructorReturn(this, _getPrototypeOf(IgxComboComponent).call(this, _displayDensityOptions));
        _this135.elementRef = elementRef;
        _this135.cdr = cdr;
        _this135.selection = selection;
        _this135.comboAPI = comboAPI;
        _this135._displayDensityOptions = _displayDensityOptions;
        _this135._injector = _injector;
        /**
         * @hidden \@internal
         */

        _this135.customValueFlag = true;
        /**
         * @hidden \@internal
         */

        _this135.defaultFallbackGroup = 'Other';
        _this135.stringFilters = IgxStringFilteringOperand;
        _this135.booleanFilters = IgxBooleanFilteringOperand;
        _this135._filteringLogic = FilteringLogic.Or;
        _this135._filteringExpressions = [];
        _this135._sortingExpressions = [];
        _this135._groupKey = '';
        _this135._prevInputValue = '';
        _this135._dataType = '';
        _this135.ngControl = null;
        _this135.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        _this135._data = [];
        _this135._filteredData = [];
        _this135._itemHeight = null;
        _this135._itemsMaxHeight = null;
        _this135._remoteSelection = {};
        _this135._onChangeCallback = noop$4;
        _this135._onTouchedCallback = noop$4;
        _this135._overlaySettings = {
          scrollStrategy: new AbsoluteScrollStrategy(),
          positionStrategy: new ConnectedPositioningStrategy(),
          modal: false,
          closeOnOutsideClick: true,
          excludePositionTarget: true
        };
        _this135._value = '';
        _this135._valid = IgxComboState.INITIAL;
        /**
         * Set custom overlay settings that control how the combo's list of items is displayed.
         * Set:
         * ```html
         * <igx-combo [overlaySettings] = "customOverlaySettings"></igx-combo>
         * ```
         *
         * ```typescript
         *  const customSettings = { positionStrategy: { settings: { target: myTarget } } };
         *  combo.overlaySettings = customSettings;
         * ```
         * Get any custom overlay settings used by the combo:
         * ```typescript
         *  const comboOverlaySettings: OverlaySettings = myCombo.overlaySettings;
         * ```
         */

        _this135.overlaySettings = null;
        /**
         * @hidden \@internal
         */

        _this135.searchInput = null;
        /**
         * The custom template, if any, that should be used when rendering ITEMS in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.itemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboItem>
         *          <div class="custom-item" let-item let-key="valueKey">
         *              <div class="custom-item__name">{{ item[key] }}</div>
         *              <div class="custom-item__cost">{{ item.cost }}</div>
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */

        _this135.itemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the HEADER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeader>
         *          <div class="combo__header">
         *              This is a custom header
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */

        _this135.headerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the FOOTER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.footerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboFooter>
         *          <div class="combo__footer">
         *              This is a custom footer
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */

        _this135.footerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering HEADER ITEMS for groups in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeaderItem let-item let-key="groupKey">
         *          <div class="custom-item--group">Group header for {{ item[key] }}</div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */

        _this135.headerItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.addItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboAddItem>
         *          <button class="combo__add-button">
         *              Click to add item
         *          </button>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */

        _this135.addItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.emptyTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboEmpty>
         *          <div class="combo--empty">
         *              There are no items to display
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */

        _this135.emptyTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */

        _this135.toggleIconTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo CLEAR button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.clearIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboClearIcon>
         *          <igx-icon>clear</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */

        _this135.clearIconTemplate = null;
        _this135.dropdownContainer = null;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-combo (onSelectionChange)='handleSelection()'></igx-combo>
         * ```
         */

        _this135.onSelectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-combo onOpening='handleOpening($event)'></igx-combo>
         * ```
         */

        _this135.onOpening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-combo (onOpened)='handleOpened()'></igx-combo>
         * ```
         */

        _this135.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosing)='handleClosing($event)'></igx-combo>
         * ```
         */

        _this135.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosed)='handleClosed()'></igx-combo>
         * ```
         */

        _this135.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when an item is being added to the data collection
         *
         * ```html
         * <igx-combo (onAddition)='handleAdditionEvent()'></igx-combo>
         * ```
         */

        _this135.onAddition = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when the value of the search input changes (e.g. typing, pasting, clear, etc.)
         *
         * ```html
         * <igx-combo (onSearchInput)='handleSearchInputEvent()'></igx-combo>
         * ```
         */

        _this135.onSearchInput = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when new chunk of data is loaded from the virtualization
         *
         * ```html
         * <igx-combo (onDataPreLoad)='handleDataPreloadEvent()'></igx-combo>
         * ```
         */

        _this135.onDataPreLoad = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets/gets combo id.
         *
         * ```typescript
         * // get
         * let id = this.combo.id;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [id]='combo1'></igx-combo>
         * ```
         */

        _this135.id = "igx-combo-".concat(NEXT_ID$j++);
        /**
         * @hidden \@internal
         */

        _this135.cssClass = 'igx-combo'; // Independent of display density, at the time being
        // Independent of display density, at the time being

        /**
         * @hidden \@internal
         */

        _this135.role = 'combobox';
        /**
         * Controls whether custom values can be added to the collection
         *
         * ```typescript
         * // get
         * let comboAllowsCustomValues = this.combo.allowCustomValues;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [allowCustomValues]='true'></igx-combo>
         * ```
         */

        _this135.allowCustomValues = false;
        /**
         * @hidden \@internal
         */

        _this135.filteringLogic = FilteringLogic.Or;
        /**
         * Defines the placeholder value for the combo dropdown search field
         *
         * ```typescript
         * // get
         * let myComboSearchPlaceholder = this.combo.searchPlaceholder;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [searchPlaceholder]='newPlaceHolder'></igx-combo>
         * ```
         */

        _this135.searchPlaceholder = 'Enter a Search Term';
        /**
         * Combo value data source property.
         *
         * ```typescript
         * // get
         * let myComboValueKey = this.combo.valueKey;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [valueKey]='myKey'></igx-combo>
         * ```
         */

        _this135.valueKey = null;
        /**
         * An \@Input property that enabled/disables filtering in the list. The default is `true`.
         * ```html
         * <igx-combo [filterable]="'false'">
         * ```
         */

        _this135.filterable = true;
        /**
         * An \@Input property that enabled/disables combo. The default is `false`.
         * ```html
         * <igx-combo [disabled]="'true'">
         * ```
         */

        _this135.disabled = false;
        /**
         * An \@Input property that sets how the combo will be styled.
         * The allowed values are `line`, `box`, `border` and `search`. The default is `box`.
         * ```html
         * <igx-combo [type]="'line'">
         * ```
         */

        _this135.type = 'box';
        /**
         * @hidden \@internal
         */

        _this135.searchValue = '';

        _this135.onStatusChanged = function () {
          if ((_this135.ngControl.control.touched || _this135.ngControl.control.dirty) && (_this135.ngControl.control.validator || _this135.ngControl.control.asyncValidator)) {
            _this135.valid = _this135.ngControl.valid ? IgxComboState.VALID : IgxComboState.INVALID;
          }

          _this135.manageRequiredAsterisk();
        };

        _this135.comboAPI.register(_assertThisInitialized(_this135));

        return _this135;
      }
      /**
       * @hidden \@internal
       * @return {?}
       */


      _createClass(IgxComboComponent, [{
        key: "onArrowDown",

        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */
        value: function onArrowDown(event) {
          event.preventDefault();
          event.stopPropagation();
          this.open();
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onInputClick",
        value: function onInputClick(event) {
          event.stopPropagation();
          event.preventDefault();
          this.toggle();
        }
        /**
         * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`
         *
         * ```typescript
         * // get
         * let state = this.combo.virtualizationState;
         * ```
         * @return {?}
         */

      }, {
        key: "clearSorting",

        /**
         * @protected
         * @param {?=} field
         * @return {?}
         */
        value: function clearSorting(field) {
          if (field === undefined || field === null) {
            this.sortingExpressions = [];
            return;
          }
          /** @type {?} */


          var currentState = cloneArray(this.sortingExpressions);
          /** @type {?} */

          var index = currentState.findIndex(function (expr) {
            return expr.fieldName === field;
          });

          if (index > -1) {
            currentState.splice(index, 1);
            this.sortingExpressions = currentState;
          }
        }
        /**
         * The text displayed in the combo input
         *
         * ```typescript
         * // get
         * let comboValue = this.combo.value;
         * ```
         * @return {?}
         */

      }, {
        key: "handleKeyUp",

        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */
        value: function handleKeyUp(event) {
          if (event.key === 'ArrowDown' || event.key === 'Down') {
            this.dropdown.focusedItem = this.dropdown.items[0];
            this.dropdownContainer.nativeElement.focus();
          } else if (event.key === 'Escape' || event.key === 'Esc') {
            this.toggle();
          }
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "handleKeyDown",
        value: function handleKeyDown(event) {
          if (event.key === 'ArrowUp' || event.key === 'Up') {
            event.preventDefault();
            event.stopPropagation();
            this.close();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "checkMatch",
        value: function checkMatch() {
          var _this136 = this;

          /** @type {?} */
          var displayKey = this.displayKey;
          /** @type {?} */

          var matchFn = function matchFn(e) {
            /** @type {?} */
            var value = displayKey ? e[displayKey] : e;
            return value.toString().toLowerCase() === _this136.searchValue.trim().toLowerCase();
          };
          /** @type {?} */


          var itemMatch = this.filteredData.some(matchFn);
          this.customValueFlag = this.allowCustomValues && !itemMatch;
        }
        /**
         * @hidden \@internal
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "handleInputChange",
        value: function handleInputChange(event) {
          var _this137 = this;

          /** @type {?} */
          var cdrFlag = false;
          /** @type {?} */

          var vContainer = this.virtDir;

          if (event !== undefined && this._prevInputValue === event) {
            // Nothing has changed
            return;
          } else {
            this._prevInputValue = event !== undefined ? event : '';
          }

          if (event !== undefined) {
            // Do not scroll if not scrollable
            if (vContainer.isScrollable()) {
              vContainer.scrollTo(0);
            } else {
              cdrFlag = true;
            }

            this.onSearchInput.emit(event);
          } else {
            cdrFlag = true;
          }

          if (this.filterable) {
            this.filter(); // If there was no scroll before filtering, check if there is after and detect changes

            if (cdrFlag) {
              vContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["take"])(1)).subscribe(function () {
                if (vContainer.isScrollable()) {
                  _this137.cdr.detectChanges();
                }
              });
            }
          } else {
            this.checkMatch();
          }
        }
        /**
         * @hidden \@internal
         * @param {?} fieldName
         * @param {?=} dir
         * @param {?=} ignoreCase
         * @param {?=} strategy
         * @return {?}
         */

      }, {
        key: "sort",
        value: function sort(fieldName) {
          var dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SortingDirection.Asc;
          var ignoreCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var strategy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultSortingStrategy.instance();

          if (!fieldName) {
            return;
          }
          /** @type {?} */


          var sortingState = cloneArray(this.sortingExpressions, true);
          this.prepare_sorting_expression(sortingState, fieldName, dir, ignoreCase, strategy);
          this.sortingExpressions = sortingState;
        }
        /**
         * @protected
         * @param {?} state
         * @param {?} fieldName
         * @param {?} dir
         * @param {?} ignoreCase
         * @param {?} strategy
         * @return {?}
         */

      }, {
        key: "prepare_sorting_expression",
        value: function prepare_sorting_expression(state, fieldName, dir, ignoreCase, strategy) {
          if (dir === SortingDirection.None) {
            state.splice(state.findIndex(function (expr) {
              return expr.fieldName === fieldName;
            }), 1);
            return;
          }
          /** @type {?} */


          var expression = state.find(function (expr) {
            return expr.fieldName === fieldName;
          });

          if (!expression) {
            state.push({
              fieldName: fieldName,
              dir: dir,
              ignoreCase: ignoreCase,
              strategy: strategy
            });
          } else {
            Object.assign(expression, {
              fieldName: fieldName,
              dir: dir,
              ignoreCase: ignoreCase
            });
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "registerRemoteEntries",

        /**
         * Contains key-value pairs of the selected valueKeys and their resp. displayKeys
         * @private
         * @param {?} ids
         * @param {?=} add
         * @return {?}
         */
        value: function registerRemoteEntries(ids) {
          var add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

          if (add) {
            /** @type {?} */
            var selection = this.getValueDisplayPairs(ids);
            var _iteratorNormalCompletion37 = true;
            var _didIteratorError37 = false;
            var _iteratorError37 = undefined;

            try {
              for (var _iterator37 = selection[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
                var entry = _step37.value;
                this._remoteSelection[entry[this.valueKey]] = entry[this.displayKey];
              }
            } catch (err) {
              _didIteratorError37 = true;
              _iteratorError37 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion37 && _iterator37["return"] != null) {
                  _iterator37["return"]();
                }
              } finally {
                if (_didIteratorError37) {
                  throw _iteratorError37;
                }
              }
            }
          } else {
            var _iteratorNormalCompletion38 = true;
            var _didIteratorError38 = false;
            var _iteratorError38 = undefined;

            try {
              for (var _iterator38 = ids[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
                var _entry = _step38.value;
                delete this._remoteSelection[_entry];
              }
            } catch (err) {
              _didIteratorError38 = true;
              _iteratorError38 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion38 && _iterator38["return"] != null) {
                  _iterator38["return"]();
                }
              } finally {
                if (_didIteratorError38) {
                  throw _iteratorError38;
                }
              }
            }
          }
        }
        /**
         * For `id: any[]` returns a mapped `{ [combo.valueKey]: any, [combo.displayKey]: any }[]`
         * @private
         * @param {?} ids
         * @return {?}
         */

      }, {
        key: "getValueDisplayPairs",
        value: function getValueDisplayPairs(ids) {
          var _this138 = this;

          return this.data.filter(function (entry) {
            return ids.indexOf(entry[_this138.valueKey]) > -1;
          }).map(function (e) {
            var _ref3;

            return _ref3 = {}, _defineProperty(_ref3, _this138.valueKey, e[_this138.valueKey]), _defineProperty(_ref3, _this138.displayKey, e[_this138.displayKey]), _ref3;
          });
        }
        /**
         * Returns if the specified itemID is selected
         * @hidden
         * \@internal
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "isItemSelected",
        value: function isItemSelected(item) {
          return this.selection.is_item_selected(this.id, item);
        }
        /**
         * Triggers change detection on the combo view
         * @return {?}
         */

      }, {
        key: "triggerCheck",
        value: function triggerCheck() {
          this.cdr.detectChanges();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "isAddButtonVisible",
        value: function isAddButtonVisible() {
          // This should always return a boolean value. If this.searchValue was '', it returns '' instead of false;
          return this.searchValue !== '' && this.customValueFlag;
        }
        /**
         * @hidden \@internal
         * @param {?} evt
         * @return {?}
         */

      }, {
        key: "handleSelectAll",
        value: function handleSelectAll(evt) {
          if (evt.checked) {
            this.selectAllItems();
          } else {
            this.deselectAllItems();
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "addItemToCollection",
        value: function addItemToCollection() {
          var _ref4;

          if (!this.searchValue) {
            return;
          }
          /** @type {?} */


          var newValue = this.searchValue.trim();
          /** @type {?} */

          var addedItem = this.displayKey ? (_ref4 = {}, _defineProperty(_ref4, this.valueKey, newValue), _defineProperty(_ref4, this.displayKey, newValue), _ref4) : newValue;

          if (this.groupKey) {
            Object.assign(addedItem, _defineProperty({}, this.groupKey, this.defaultFallbackGroup));
          }
          /** @type {?} */


          var oldCollection = this.data;
          /** @type {?} */

          var newCollection = _toConsumableArray(this.data);

          newCollection.push(addedItem);
          /** @type {?} */

          var args = {
            oldCollection: oldCollection,
            addedItem: addedItem,
            newCollection: newCollection
          };
          this.onAddition.emit(args);
          this.data.push(addedItem); // If you mutate the array, no pipe is invoked and the display isn't updated;
          // if you replace the array, the pipe executes and the display is updated.

          this.data = cloneArray(this.data);
          this.selectItems(this.comboAPI.valueKey !== null ? [addedItem[this.valueKey]] : [addedItem], false);
          this.customValueFlag = false;
          this.searchInput.nativeElement.focus();
          this.dropdown.focusedItem = null;
          this.handleInputChange();
        }
        /**
         * @hidden \@internal
         * @param {?=} opening
         * @return {?}
         */

      }, {
        key: "focusSearchInput",
        value: function focusSearchInput(opening) {
          if (this.displaySearchInput && this.searchInput) {
            this.searchInput.nativeElement.focus();
          } else {
            if (opening) {
              this.dropdownContainer.nativeElement.focus();
            } else {
              this.comboInput.nativeElement.focus();
              this.toggle();
            }
          }
        }
        /**
         * @protected
         * @param {?} searchVal
         * @param {?} condition
         * @param {?} ignoreCase
         * @param {?=} fieldName
         * @return {?}
         */

      }, {
        key: "prepare_filtering_expression",
        value: function prepare_filtering_expression(searchVal, condition, ignoreCase, fieldName) {
          /** @type {?} */
          var newArray = _toConsumableArray(this.filteringExpressions);
          /** @type {?} */


          var expression = newArray.find(function (expr) {
            return expr.fieldName === fieldName;
          });
          /** @type {?} */

          var newExpression = {
            fieldName: fieldName,
            searchVal: searchVal,
            condition: condition,
            ignoreCase: ignoreCase
          };

          if (!expression) {
            newArray.push(newExpression);
          } else {
            Object.assign(expression, newExpression);
          }

          if (this.groupKey) {
            /** @type {?} */
            var expression2 = newArray.find(function (expr) {
              return expr.fieldName === 'isHeader';
            });
            /** @type {?} */

            var headerExpression = {
              fieldName: 'isHeader',
              searchVale: '',
              condition: IgxBooleanFilteringOperand.instance().condition('true'),
              ignoreCase: true
            };

            if (!expression2) {
              newArray.push(headerExpression);
            } else {
              Object.assign(expression2, headerExpression);
            }
          }

          this.filteringExpressions = newArray;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "manageRequiredAsterisk",
        value: function manageRequiredAsterisk() {
          if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.

            /** @type {?} */
            var error = this.ngControl.control.validator(
            /** @type {?} */
            {});
            this.inputGroup.isRequired = error && error.required;
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur() {
          if (this.collapsed) {
            this._onTouchedCallback();

            if (this.ngControl && !this.ngControl.valid) {
              this.valid = IgxComboState.INVALID;
            } else {
              this.valid = IgxComboState.INITIAL;
            }
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus() {
          if (this.collapsed) {
            this._onTouchedCallback();
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "filter",
        value: function filter() {
          this.prepare_filtering_expression(this.searchValue.trim(), IgxStringFilteringOperand.instance().condition('contains'), true, this.dataType === DataTypes.PRIMITIVE ? undefined : this.displayKey);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this.ngControl = this._injector.get(
          /** @type {?} */
          _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControl"], null);
          this._overlaySettings.positionStrategy.settings.target = this.elementRef.nativeElement;
          this.selection.set(this.id, new Set());
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.filteredData = _toConsumableArray(this.data);

          if (this.ngControl) {
            this.ngControl.statusChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(this.onStatusChanged);
            this.manageRequiredAsterisk();
            this.cdr.detectChanges();
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next();
          this.destroy$.complete();
          this.comboAPI.clear();
          this.selection.clear(this.id);
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "dataLoading",
        value: function dataLoading(event) {
          this.onDataPreLoad.emit(event);
        }
        /**
         * @hidden \@internal
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this.selectItems(value, true);
          this.cdr.markForCheck();
        }
        /**
         * @hidden \@internal
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden \@internal
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
        /**
         * @hidden \@internal
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getEditElement",
        value: function getEditElement() {
          return this.comboInput.nativeElement;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "handleClearItems",

        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */
        value: function handleClearItems(event) {
          this.deselectAllItems(true, event);

          if (this.collapsed) {
            this.getEditElement().focus();
          } else {
            this.focusSearchInput(true);
          }

          event.stopPropagation();
        }
        /**
         * A method that opens/closes the combo.
         *
         * ```html
         * <button (click)="combo.toggle()">Toggle Combo</button>
         * <igx-combo #combo></igx-combo>
         * ```
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          /** @type {?} */
          var overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
          this.dropdown.toggle(overlaySettings);
        }
        /**
         * A method that opens the combo.
         *
         * ```html
         * <button (click)="combo.open()">Open Combo</button>
         * <igx-combo #combo></igx-combo>
         * ```
         * @return {?}
         */

      }, {
        key: "open",
        value: function open() {
          /** @type {?} */
          var overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
          this.dropdown.open(overlaySettings);
        }
        /**
         * A method that closes the combo.
         *
         * ```html
         * <button (click)="combo.close()">Close Combo</button>
         * <igx-combo #combo></igx-combo>
         * ```
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          this.dropdown.close();
        }
        /**
         * Gets drop down state.
         *
         * ```typescript
         * let state = this.combo.collapsed;
         * ```
         * @return {?}
         */

      }, {
        key: "selectedItems",

        /**
         * Get current selection state
         * @return {?} Array of selected items
         * ```typescript
         * let selectedItems = this.combo.selectedItems();
         * ```
         */
        value: function selectedItems() {
          /** @type {?} */
          var items = Array.from(this.selection.get(this.id));
          return items;
        }
        /**
         * Select defined items
         * @param {?} newItems new items to be selected
         * @param {?=} clearCurrentSelection if true clear previous selected items
         * ```typescript
         * this.combo.selectItems(["New York", "New Jersey"]);
         * ```
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "selectItems",
        value: function selectItems(newItems, clearCurrentSelection, event) {
          if (newItems) {
            /** @type {?} */
            var newSelection = this.selection.add_items(this.id, newItems, clearCurrentSelection);
            this.setSelection(newSelection, event);
          }
        }
        /**
         * Deselect defined items
         * @param {?} items items to deselected
         * ```typescript
         * this.combo.deselectItems(["New York", "New Jersey"]);
         * ```
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "deselectItems",
        value: function deselectItems(items, event) {
          if (items) {
            /** @type {?} */
            var newSelection = this.selection.delete_items(this.id, items);
            this.setSelection(newSelection, event);
          }
        }
        /**
         * Select all (filtered) items
         * @param {?=} ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
         * ```typescript
         * this.combo.selectAllItems();
         * ```
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "selectAllItems",
        value: function selectAllItems(ignoreFilter, event) {
          /** @type {?} */
          var allVisible = this.selection.get_all_ids(ignoreFilter ? this.data : this.filteredData, this.valueKey);
          /** @type {?} */

          var newSelection = this.selection.add_items(this.id, allVisible);
          this.setSelection(newSelection, event);
        }
        /**
         * Deselect all (filtered) items
         * @param {?=} ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
         * ```typescript
         * this.combo.deselectAllItems();
         * ```
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "deselectAllItems",
        value: function deselectAllItems(ignoreFilter, event) {
          /** @type {?} */
          var newSelection = this.selection.get_empty();

          if (this.filteredData.length !== this.data.length && !ignoreFilter) {
            newSelection = this.selection.delete_items(this.id, this.selection.get_all_ids(this.filteredData, this.valueKey));
          }

          this.setSelection(newSelection, event);
        }
        /**
         * Selects/Deselects a single item
         * @param {?} itemID the itemID of the specific item
         * @param {?=} select If the item should be selected (true) or deselected (false)
         *
         * Without specified valueKey;
         * ```typescript
         * this.combo.valueKey = null;
         * const items: { field: string, region: string}[] = data;
         * this.combo.setSelectedItem(items[0], true);
         * ```
         * With specified valueKey;
         * ```typescript
         * this.combo.valueKey = 'field';
         * const items: { field: string, region: string}[] = data;
         * this.combo.setSelectedItem('Connecticut', true);
         * ```
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "setSelectedItem",
        value: function setSelectedItem(itemID) {
          var select = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var event = arguments.length > 2 ? arguments[2] : undefined;

          if (itemID === null || itemID === undefined) {
            return;
          }

          if (select) {
            this.selectItems([itemID], false, event);
          } else {
            this.deselectItems([itemID], event);
          }
        }
        /**
         * @protected
         * @param {?} newSelection
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "setSelection",
        value: function setSelection(newSelection, event) {
          var _this139 = this;

          /** @type {?} */
          var removed = diffInSets(this.selection.get(this.id), newSelection);
          /** @type {?} */

          var added = diffInSets(newSelection, this.selection.get(this.id));
          /** @type {?} */

          var args = {
            newSelection: Array.from(newSelection),
            oldSelection: Array.from(this.selection.get(this.id) || []),
            added: added,
            removed: removed,
            event: event,
            cancel: false
          };
          this.onSelectionChange.emit(args);

          if (!args.cancel) {
            this.selection.select_items(this.id, args.newSelection, true);
            /** @type {?} */

            var value = '';

            if (this.isRemote) {
              if (args.newSelection.length) {
                /** @type {?} */
                var removedItems = args.oldSelection.filter(function (e) {
                  return args.newSelection.indexOf(e) < 0;
                });
                /** @type {?} */

                var addedItems = args.newSelection.filter(function (e) {
                  return args.oldSelection.indexOf(e) < 0;
                });
                this.registerRemoteEntries(addedItems);
                this.registerRemoteEntries(removedItems, false);
                value = Object.keys(this._remoteSelection).map(function (e) {
                  return _this139._remoteSelection[e];
                }).join(', ');
              } else {
                // If new selection is empty, clear all items
                this.registerRemoteEntries(args.oldSelection, false);
              }
            } else {
              value = this.displayKey !== null && this.displayKey !== undefined ? this.convertKeysToItems(args.newSelection).map(function (entry) {
                return entry[_this139.displayKey];
              }).join(', ') : args.newSelection.join(', ');
            }

            this._value = value;

            this._onChangeCallback(args.newSelection);
          }
        }
        /**
         * if there is a valueKey - map the keys to data items, else - just return the keys
         * @private
         * @param {?} keys
         * @return {?}
         */

      }, {
        key: "convertKeysToItems",
        value: function convertKeysToItems(keys) {
          var _this140 = this;

          if (this.comboAPI.valueKey === null) {
            return keys;
          } // map keys vs. filter data to retain the order of the selected items


          return keys.map(function (key) {
            return _this140.data.find(function (entry) {
              return entry[_this140.valueKey] === key;
            });
          }).filter(function (e) {
            return e !== undefined;
          });
        }
        /**
         * Event handlers
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "handleOpening",
        value: function handleOpening(event) {
          this.onOpening.emit(event);

          if (event.cancel) {
            return;
          }

          this.handleInputChange();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "handleOpened",
        value: function handleOpened() {
          this.triggerCheck();
          this.focusSearchInput(true);
          this.onOpened.emit();
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "handleClosing",
        value: function handleClosing(event) {
          this.onClosing.emit(event);

          if (event.cancel) {
            return;
          }

          this.searchValue = '';
          this.comboInput.nativeElement.focus();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "handleClosed",
        value: function handleClosed() {
          this.onClosed.emit();
        }
      }, {
        key: "displaySearchInput",
        get: function get() {
          return this.filterable || this.allowCustomValues;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ariaExpanded",
        get: function get() {
          return !this.dropdown.collapsed;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "hasPopUp",
        get: function get() {
          return 'listbox';
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ariaOwns",
        get: function get() {
          return this.dropdown.id;
        }
        /**
         * Configures the drop down list height
         *
         * ```typescript
         * // get
         * let myComboItemsMaxHeight = this.combo.itemsMaxHeight;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [itemsMaxHeight]='320'></igx-combo>
         * ```
         * @return {?}
         */

      }, {
        key: "itemsMaxHeight",
        get: function get() {
          if (this._itemsMaxHeight === null || this._itemsMaxHeight === undefined) {
            return this.itemHeight * itemsInContainer;
          }

          return this._itemsMaxHeight;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._itemsMaxHeight = val;
        }
        /**
         * Configures the drop down list item height
         *
         * ```typescript
         * // get
         * let myComboItemHeight = this.combo.itemHeight;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [itemHeight]='32'></igx-combo>
         * ```
         * @return {?}
         */

      }, {
        key: "itemHeight",
        get: function get() {
          if (this._itemHeight === null || this._itemHeight === undefined) {
            return ItemHeights[this.displayDensity];
          }

          return this._itemHeight;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._itemHeight = val;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "inputEmpty",
        get: function get() {
          return !this.value && !this.placeholder;
        }
        /**
         * Combo data source.
         *
         * ```html
         * <!--set-->
         * <igx-combo [data]='items'></igx-combo>
         * ```
         * @return {?}
         */

      }, {
        key: "data",
        get: function get() {
          return this._data;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._data = val ? val : [];
        }
        /**
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "displayKey",
        set: function set(val) {
          this._displayKey = val;
        }
        /**
         * Combo text data source property.
         *
         * ```typescript
         * // get
         * let myComboDisplayKey = this.combo.displayKey;
         *
         * // set
         * this.combo.displayKey = 'val';
         *
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [displayKey]='myDisplayKey'></igx-combo>
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._displayKey ? this._displayKey : this.valueKey;
        }
        /**
         * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
         *
         * ```html
         * <!--set-->
         * <igx-combo [groupKey]='newGroupKey'></igx-combo>
         * ```
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "groupKey",
        set: function set(val) {
          this.clearSorting(this._groupKey);
          this._groupKey = val;
          this.sort(this._groupKey);
        }
        /**
         * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
         *
         * ```typescript
         * // get
         * let currentGroupKey = this.combo.groupKey;
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._groupKey;
        }
        /**
         * Gets if control is valid, when used in a form
         *
         * ```typescript
         * // get
         * let valid = this.combo.valid;
         * ```
         *
         * @return {?}
         */

      }, {
        key: "valid",
        get: function get() {
          return this._valid;
        }
        /**
         * Sets if control is valid, when used in a form
         *
         * ```typescript
         * // set
         * this.combo.valid = IgxComboState.INVALID;
         * ```
         * @param {?} valid
         * @return {?}
         */
        ,
        set: function set(valid) {
          this._valid = valid;
          this.comboInput.valid = IgxInputState[IgxComboState[valid]];
        }
      }, {
        key: "virtualizationState",
        get: function get() {
          return this.virtDir.state;
        }
        /**
         * Sets the current state of the virtualized data.
         *
         * ```typescript
         * // set
         * this.combo.virtualizationState(state);
         * ```
         * @param {?} state
         * @return {?}
         */
        ,
        set: function set(state) {
          this.virtDir.state = state;
        }
        /**
         * Gets total count of the virtual data items, when using remote service.
         *
         * ```typescript
         * // get
         * let count = this.combo.totalItemCount;
         * ```
         * @return {?}
         */

      }, {
        key: "totalItemCount",
        get: function get() {
          return this.virtDir.totalItemCount;
        }
        /**
         * Sets total count of the virtual data items, when using remote service.
         *
         * ```typescript
         * // set
         * this.combo.totalItemCount(remoteService.count);
         * ```
         * @param {?} count
         * @return {?}
         */
        ,
        set: function set(count) {
          this.virtDir.totalItemCount = count;
          this.cdr.detectChanges();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "filteringExpressions",
        get: function get() {
          return this.filterable ? this._filteringExpressions : [];
        }
        /**
         * @hidden \@internal
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._filteringExpressions = value;
          this.cdr.markForCheck();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "sortingExpressions",
        get: function get() {
          return this._sortingExpressions;
        }
        /**
         * @hidden \@internal
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._sortingExpressions = value;
          this.cdr.markForCheck();
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "filteredData",
        get: function get() {
          return this.filterable ? this._filteredData : this.data;
        }
        /**
         * @hidden \@internal
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._filteredData = this.groupKey ? (val || []).filter(function (e) {
            return e.isHeader !== true;
          }) : val;
          this.checkMatch();
        }
      }, {
        key: "dataType",
        get: function get() {
          if (this.displayKey) {
            return DataTypes.COMPLEX;
          }

          return DataTypes.PRIMITIVE;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "isRemote",
        get: function get() {
          return this.totalItemCount > 0 && this.valueKey && this.dataType === DataTypes.COMPLEX;
        }
      }, {
        key: "template",
        get: function get() {
          this._dataType = this.dataType;

          if (this.itemTemplate) {
            return this.itemTemplate;
          }

          if (this._dataType === DataTypes.COMPLEX) {
            return this.complexTemplate;
          }

          return this.primitiveTemplate;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          return {
            $implicit: this
          };
        }
      }, {
        key: "collapsed",
        get: function get() {
          return this.dropdown.collapsed;
        }
      }]);

      return IgxComboComponent;
    }(DisplayDensityBase);

    IgxComboComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-combo',
        template: "<ng-template #complex let-display let-data=\"data\" let-key=\"displayKey\">\n    {{display[key]}}\n</ng-template>\n<ng-template #primitive let-display>\n    {{display}}\n</ng-template>\n<ng-template #empty>\n    <span>The list is empty</span>\n</ng-template>\n<ng-template #addItemDefault let-control>\n    <button igxButton=\"flat\" igxRipple>Add item</button>\n</ng-template>\n<ng-template #headerItemBase let-item let-key=\"valueKey\" let-groupKey=\"groupKey\">\n    {{ item[key] }}\n</ng-template>\n\n<igx-input-group #inputGroup [displayDensity]=\"displayDensity\" [type]=\"type\" (click)=\"onInputClick($event)\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\">\n            <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n        </ng-container>\n    <input igxInput #comboInput name=\"comboInput\" type=\"text\" [value]=\"value\" readonly [attr.placeholder]=\"placeholder\"\n        [disabled]=\"disabled\" (blur)=\"onBlur()\" (focus)=\"onFocus()\"/>\n    <ng-container ngProjectAs=\"igx-suffix\">\n        <ng-content select=\"igx-suffix\"></ng-content>\n    </ng-container>\n    <igx-suffix *ngIf=\"value.length\" aria-label=\"Clear Selection\" class=\"igx-combo__clear-button\" (click)=\"handleClearItems($event)\">\n        <ng-container *ngIf=\"clearIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"clearIconTemplate\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!clearIconTemplate\" fontSet=\"material\">clear</igx-icon>\n    </igx-suffix>\n    <igx-suffix igxButton=\"icon\" class=\"igx-combo__toggle-button\" igxRipple>\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">{{ dropdown.collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<igx-combo-drop-down #igxComboDropDown class=\"igx-combo__drop-down\" [displayDensity]=\"displayDensity\" [width]=\"itemsWidth || '100%'\" (onOpening)=\"handleOpening($event)\"\n    (onClosing)=\"handleClosing($event)\" (onOpened)=\"handleOpened()\" (onClosed)=\"handleClosed()\">\n    <igx-input-group *ngIf=\"displaySearchInput\" [displayDensity]=\"displayDensity\" class=\"igx-combo__search\">\n        <input class=\"igx-combo-input\" igxInput #searchInput name=\"searchInput\" autocomplete=\"off\" type=\"text\"\n            [(ngModel)]=\"searchValue\" (ngModelChange)=\"handleInputChange($event)\" (keyup)=\"handleKeyUp($event)\"\n            (keydown)=\"handleKeyDown($event)\" (focus)=\"dropdown.onBlur($event)\" [attr.placeholder]=\"searchPlaceholder\"\n            aria-autocomplete=\"both\" [attr.aria-owns]=\"dropdown.id\" [attr.aria-labelledby]=\"ariaLabelledBy\" />\n    </igx-input-group>\n    <ng-container *ngTemplateOutlet=\"headerTemplate\">\n    </ng-container>\n    <div #dropdownItemContainer class=\"igx-combo__content\" [style.overflow]=\"'hidden'\" [style.maxHeight.px]=\"itemsMaxHeight\"\n        [igxDropDownItemNavigation]=\"dropdown\" (focus)=\"dropdown.onFocus()\" [tabindex]=\"dropdown.collapsed ? -1 : 0\"\n        role=\"listbox\" [attr.id]=\"dropdown.id\">\n        <ng-template igxFor let-item let-index=\"index\" [igxForOf]=\"data | comboFiltering:filteringExpressions:filteringLogic | comboSorting:sortingExpressions | comboGrouping:groupKey\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForContainerSize]=\"itemsMaxHeight\" [igxForItemSize]=\"itemHeight\"\n            (onChunkPreload)=\"dataLoading($event)\">\n            <igx-combo-item  [itemHeight]='itemHeight' [value]=\"item\" [isHeader]=\"item.isHeader\" role=\"option\" [index]=\"index\">\n                <ng-container *ngIf=\"item.isHeader\">\n                    <ng-container *ngTemplateOutlet=\"headerItemTemplate ? headerItemTemplate : headerItemBase; context: {$implicit: item, data: data, valueKey: valueKey, groupKey: groupKey, displayKey: displayKey}\"></ng-container>\n                </ng-container>\n                <ng-container *ngIf=\"!item.isHeader\">\n                    <ng-container #listItem *ngTemplateOutlet=\"template; context: {$implicit: item, data: data, valueKey: valueKey, displayKey: displayKey};\"></ng-container>\n                </ng-container>\n            </igx-combo-item>\n        </ng-template>\n    </div>\n    <div class=\"igx-combo__add\" *ngIf=\"filteredData.length === 0 || isAddButtonVisible()\">\n        <div class=\"igx-combo__empty\" *ngIf=\"filteredData.length === 0\">\n            <ng-container *ngTemplateOutlet=\"emptyTemplate ? emptyTemplate : empty\">\n            </ng-container>\n        </div>\n        <igx-combo-add-item [itemHeight]='itemHeight' *ngIf=\"isAddButtonVisible()\" [tabindex]=\"dropdown.collapsed ? -1 : customValueFlag ? 1 : -1\"\n            class=\"igx-combo__add-item\" role=\"button\" aria-label=\"Add Item\" [index]=\"virtualScrollContainer.igxForOf.length\">\n            <ng-container *ngTemplateOutlet=\"addItemTemplate ? addItemTemplate : addItemDefault\">\n            </ng-container>\n        </igx-combo-add-item>\n    </div>\n    <ng-container *ngTemplateOutlet=\"footerTemplate\">\n    </ng-container>\n</igx-combo-drop-down>\n",
        providers: [IgxComboAPIService, {
          provide: IGX_COMBO_COMPONENT,
          useExisting: IgxComboComponent
        }, {
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxComboComponent;
          }),
          multi: true
        }]
      }]
    }];
    /** @nocollapse */

    IgxComboComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxSelectionAPIService
      }, {
        type: IgxComboAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    IgxComboComponent.propDecorators = {
      virtDir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxForOfDirective, {
          read: IgxForOfDirective,
          "static": true
        }]
      }],
      overlaySettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      inputGroup: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['inputGroup', {
          read: IgxInputGroupComponent,
          "static": true
        }]
      }],
      comboInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['comboInput', {
          read: IgxInputDirective,
          "static": true
        }]
      }],
      dropdown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxComboDropDownComponent, {
          read: IgxComboDropDownComponent,
          "static": true
        }]
      }],
      searchInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['searchInput', {
          "static": false
        }]
      }],
      itemTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxComboItemDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      headerTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxComboHeaderDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      footerTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxComboFooterDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      headerItemTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxComboHeaderItemDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      addItemTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxComboAddItemDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      emptyTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxComboEmptyDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      toggleIconTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxComboToggleIconDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      clearIconTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxComboClearIconDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      primitiveTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['primitive', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      complexTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['complex', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      virtualScrollContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxForOfDirective, {
          "static": true
        }]
      }],
      dropdownContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['dropdownItemContainer', {
          "static": true
        }]
      }],
      onSelectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onOpening: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onOpened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onAddition: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onSearchInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onDataPreLoad: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.width']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-combo']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ["attr.role"]
      }],
      ariaExpanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-expanded']
      }],
      hasPopUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-haspopup']
      }],
      ariaOwns: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-owns']
      }],
      allowCustomValues: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      itemsMaxHeight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      itemsWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      itemHeight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      placeholder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      searchPlaceholder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      valueKey: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      displayKey: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      groupKey: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filterable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ariaLabelledBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-labelledby']
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onArrowDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.ArrowDown', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Alt.ArrowDown', ['$event']]
      }]
    };
    /**
     * @hidden
     */

    var IgxComboModule = function IgxComboModule() {
      _classCallCheck(this, IgxComboModule);
    };

    IgxComboModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxComboComponent, IgxComboItemComponent, IgxComboFilterConditionPipe, IgxComboGroupingPipe, IgxComboFilteringPipe, IgxComboSortingPipe, IgxComboDropDownComponent, IgxComboAddItemComponent, IgxComboItemDirective, IgxComboEmptyDirective, IgxComboHeaderItemDirective, IgxComboHeaderDirective, IgxComboFooterDirective, IgxComboAddItemDirective, IgxComboToggleIconDirective, IgxComboClearIconDirective],
        exports: [IgxComboComponent, IgxComboItemComponent, IgxComboDropDownComponent, IgxComboAddItemComponent, IgxComboItemDirective, IgxComboEmptyDirective, IgxComboHeaderItemDirective, IgxComboHeaderDirective, IgxComboFooterDirective, IgxComboAddItemDirective, IgxComboToggleIconDirective, IgxComboClearIconDirective],
        imports: [IgxRippleModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxInputGroupModule, _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"], IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule],
        providers: [IgxSelectionAPIService]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @abstract
     */

    var DatePickerUtil =
    /*#__PURE__*/
    function () {
      function DatePickerUtil() {
        _classCallCheck(this, DatePickerUtil);
      }

      _createClass(DatePickerUtil, null, [{
        key: "parseDateFormat",

        /**
         * This method generates date parts structure based on editor mask and locale.
         * @param {?} maskValue
         * @param {?=} locale
         * @return {?} array containing information about date parts - type, position, format
         */
        value: function parseDateFormat(maskValue) {
          var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DatePickerUtil.DEFAULT_LOCALE;

          /** @type {?} */
          var dateStruct = [];

          if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
          } else {
            /** @type {?} */
            var mask = maskValue ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            /** @type {?} */

            var maskArray = Array.from(mask);
            /** @type {?} */

            var monthInitPosition = mask.indexOf("M"
            /* MonthChar */
            );
            /** @type {?} */

            var dayInitPosition = mask.indexOf("d"
            /* DayChar */
            );
            /** @type {?} */

            var yearInitPosition = mask.indexOf("y"
            /* YearChar */
            );

            if (yearInitPosition !== -1) {
              dateStruct.push({
                type: "year"
                /* Year */
                ,
                initialPosition: yearInitPosition,
                formatType: DatePickerUtil.getYearFormatType(mask)
              });
            }

            if (monthInitPosition !== -1) {
              dateStruct.push({
                type: "month"
                /* Month */
                ,
                initialPosition: monthInitPosition,
                formatType: DatePickerUtil.getMonthFormatType(mask)
              });
            }

            if (dayInitPosition !== -1) {
              dateStruct.push({
                type: "day"
                /* Day */
                ,
                initialPosition: dayInitPosition,
                formatType: DatePickerUtil.getDayFormatType(mask)
              });
            }

            for (var i = 0; i < maskArray.length; i++) {
              if (!DatePickerUtil.isDateChar(maskArray[i])) {
                dateStruct.push({
                  type: DatePickerUtil.SEPARATOR,
                  initialPosition: i,
                  value: maskArray[i]
                });
              }
            }

            dateStruct.sort(function (a, b) {
              return a.initialPosition - b.initialPosition;
            });
            DatePickerUtil.fillDatePartsPositions(dateStruct);
          }

          return dateStruct;
        }
        /**
         * This method generates input mask based on date parts.
         * @param {?} dateStruct array
         * @return {?} input mask
         */

      }, {
        key: "getInputMask",
        value: function getInputMask(dateStruct) {
          /** @type {?} */
          var inputMask = [];

          for (var i = 0; i < dateStruct.length; i++) {
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
              inputMask.push(dateStruct[i].value);
            } else if (dateStruct[i].type === "day"
            /* Day */
            || dateStruct[i].type === "month"
            /* Month */
            ) {
                inputMask.push('00');
              } else if (dateStruct[i].type === "year"
            /* Year */
            ) {
                switch (dateStruct[i].formatType) {
                  case "numeric"
                  /* Numeric */
                  :
                    {
                      inputMask.push('0000');
                      break;
                    }

                  case "2-digit"
                  /* TwoDigits */
                  :
                    {
                      inputMask.push('00');
                      break;
                    }
                }
              }
          }

          return inputMask.join('');
        }
        /**
         * This method generates editor mask.
         * @param {?} dateStruct
         * @return {?} editor mask
         */

      }, {
        key: "getMask",
        value: function getMask(dateStruct) {
          /** @type {?} */
          var mask = [];

          for (var i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].formatType) {
              case "numeric"
              /* Numeric */
              :
                {
                  if (dateStruct[i].type === "day"
                  /* Day */
                  ) {
                      mask.push('d');
                    } else if (dateStruct[i].type === "month"
                  /* Month */
                  ) {
                      mask.push('M');
                    } else {
                    mask.push('yyyy');
                  }

                  break;
                }

              case "2-digit"
              /* TwoDigits */
              :
                {
                  if (dateStruct[i].type === "day"
                  /* Day */
                  ) {
                      mask.push('dd');
                    } else if (dateStruct[i].type === "month"
                  /* Month */
                  ) {
                      mask.push('MM');
                    } else {
                    mask.push('yy');
                  }
                }
            }

            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
              mask.push(dateStruct[i].value);
            }
          }

          return mask.join('');
        }
        /**
         * This method parses an input string base on date parts and returns a date and its validation state.
         * @param {?} dateFormatParts
         * @param {?} prevDateValue
         * @param {?} inputValue
         * @return {?} object containing a date and its validation state
         */

      }, {
        key: "parseDateArray",
        value: function parseDateArray(dateFormatParts, prevDateValue, inputValue) {
          /** @type {?} */
          var dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
          /** @type {?} */

          var monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
          /** @type {?} */

          var yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
          /** @type {?} */

          var yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year"
          /* Year */
          ).formatType;
          /** @type {?} */

          var day = dayStr !== '' ? parseInt(dayStr, 10) : 1;
          /** @type {?} */

          var month = monthStr !== '' ? parseInt(monthStr, 10) - 1 : 0;
          /** @type {?} */

          var year;

          if (yearStr === '') {
            year = yearFormat === "2-digit"
            /* TwoDigits */
            ? '00' : '2000';
          } else {
            year = yearStr;
          }
          /** @type {?} */


          var yearPrefix;

          if (prevDateValue) {
            /** @type {?} */
            var originalYear = prevDateValue.getFullYear().toString();

            if (originalYear.length === 4) {
              yearPrefix = originalYear.substring(0, 2);
            }
          } else {
            yearPrefix = '20';
          }
          /** @type {?} */


          var fullYear = yearFormat === "2-digit"
          /* TwoDigits */
          ? yearPrefix.concat(year) : year;

          if (month < 0 || month > 11 || month === NaN) {
            return {
              state: "invalid"
              /* Invalid */
              ,
              value: inputValue
            };
          }

          if (day < 1 || day > DatePickerUtil.daysInMonth(fullYear, month + 1) || day === NaN) {
            return {
              state: "invalid"
              /* Invalid */
              ,
              value: inputValue
            };
          }

          return {
            state: "valid"
            /* Valid */
            ,
            date: new Date(fullYear, month, day)
          };
        }
        /**
         * @param {?} mask
         * @return {?}
         */

      }, {
        key: "maskToPromptChars",
        value: function maskToPromptChars(mask) {
          /** @type {?} */
          var result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
          return result;
        }
        /**
         * This method replaces prompt chars with empty string.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "trimUnderlines",
        value: function trimUnderlines(value) {
          /** @type {?} */
          var result = value.replace(/_/g, '');
          return result;
        }
        /**
         * This method is used for spinning date parts.
         * @param {?} dateFormatParts
         * @param {?} inputValue
         * @param {?} position
         * @param {?} delta
         * @param {?} isSpinLoop
         * @return {?} modified text input
         */

      }, {
        key: "getModifiedDateInput",
        value: function getModifiedDateInput(dateFormatParts, inputValue, position, delta, isSpinLoop) {
          /** @type {?} */
          var datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
          /** @type {?} */

          var datePartType = datePart.type;
          /** @type {?} */

          var datePartFormatType = datePart.formatType;
          /** @type {?} */

          var newValue;
          /** @type {?} */

          var datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
          newValue = parseInt(datePartValue, 10);
          /** @type {?} */

          var maxValue;
          /** @type {?} */

          var minValue;
          /** @type {?} */

          var minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
          minValue = minMax.min;
          maxValue = minMax.max;

          if (isNaN(newValue)) {
            if (minValue === 'infinite') {
              newValue = 2000;
            } else {
              newValue = minValue;
            }
          }
          /** @type {?} */


          var tempValue = newValue;
          tempValue += delta; // Infinite loop for full years

          if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
          }

          if (isSpinLoop) {
            if (tempValue > maxValue) {
              tempValue = minValue;
            }

            if (tempValue < minValue) {
              tempValue = maxValue;
            }

            newValue = tempValue;
          } else {
            if (tempValue <= maxValue && tempValue >= minValue) {
              newValue = tempValue;
            }
          }
          /** @type {?} */


          var startIdx = datePart.position[0];
          /** @type {?} */

          var endIdx = datePart.position[1];
          /** @type {?} */

          var start = inputValue.slice(0, startIdx);
          /** @type {?} */

          var end = inputValue.slice(endIdx, inputValue.length);
          /** @type {?} */

          var changedPart;
          /** @type {?} */

          var prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
          changedPart = newValue < 10 ? "".concat(prefix).concat(newValue) : "".concat(newValue);
          return "".concat(start).concat(changedPart).concat(end);
        }
        /**
         * This method returns date input with prompt chars.
         * @param {?} dateFormatParts
         * @param {?} date
         * @param {?} inputValue
         * @return {?} date input including prompt chars
         */

      }, {
        key: "addPromptCharsEditMode",
        value: function addPromptCharsEditMode(dateFormatParts, date, inputValue) {
          /** @type {?} */
          var dateArray = Array.from(inputValue);

          for (var i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].formatType === "numeric"
            /* Numeric */
            ) {
                if (dateFormatParts[i].type === "day"
                /* Day */
                && date.getDate() < 10 || dateFormatParts[i].type === "month"
                /* Month */
                && date.getMonth() + 1 < 10) {
                  dateArray.splice(dateFormatParts[i].position[0], 0, DatePickerUtil.PROMPT_CHAR);
                  dateArray.join('');
                }
              }
          }

          return dateArray.join('');
        }
        /**
         * This method checks if date input is done.
         * @param {?} dateFormatParts
         * @param {?} input
         * @return {?} input completeness
         */

      }, {
        key: "checkForCompleteDateInput",
        value: function checkForCompleteDateInput(dateFormatParts, input) {
          /** @type {?} */
          var dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
          /** @type {?} */

          var monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
          /** @type {?} */

          var yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
          /** @type {?} */

          var dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
          /** @type {?} */

          var monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);

          if (DatePickerUtil.isFullInput(dayValue, dayStr) && DatePickerUtil.isFullInput(monthValue, monthStr) && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
          } else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
          } else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
          }

          return '';
        }
        /**
         * @private
         * @param {?} format
         * @return {?}
         */

      }, {
        key: "getYearFormatType",
        value: function getYearFormatType(format) {
          switch (format.match(new RegExp("y"
          /* YearChar */
          , 'g')).length) {
            case 1:
              {
                // y (2020)
                return "numeric"
                /* Numeric */
                ;
              }

            case 4:
              {
                // yyyy (2020)
                return "numeric"
                /* Numeric */
                ;
              }

            case 2:
              {
                // yy (20)
                return "2-digit"
                /* TwoDigits */
                ;
              }
          }
        }
        /**
         * @private
         * @param {?} format
         * @return {?}
         */

      }, {
        key: "getMonthFormatType",
        value: function getMonthFormatType(format) {
          switch (format.match(new RegExp("M"
          /* MonthChar */
          , 'g')).length) {
            case 1:
              {
                // M (8)
                return "numeric"
                /* Numeric */
                ;
              }

            case 2:
              {
                // MM (08)
                return "2-digit"
                /* TwoDigits */
                ;
              }
          }
        }
        /**
         * @private
         * @param {?} format
         * @return {?}
         */

      }, {
        key: "getDayFormatType",
        value: function getDayFormatType(format) {
          switch (format.match(new RegExp("d"
          /* DayChar */
          , 'g')).length) {
            case 1:
              {
                // d (6)
                return "numeric"
                /* Numeric */
                ;
              }

            case 2:
              {
                // dd (06)
                return "2-digit"
                /* TwoDigits */
                ;
              }
          }
        }
        /**
         * @private
         * @param {?} locale
         * @return {?}
         */

      }, {
        key: "getDefaultLocaleMask",
        value: function getDefaultLocaleMask(locale) {
          /** @type {?} */
          var dateStruct = [];
          /** @type {?} */

          var formatter = new Intl.DateTimeFormat(locale);
          /** @type {?} */

          var formatToParts = formatter.formatToParts(new Date());

          for (var i = 0; i < formatToParts.length; i++) {
            if (formatToParts[i].type === DatePickerUtil.SEPARATOR) {
              dateStruct.push({
                type: DatePickerUtil.SEPARATOR,
                value: formatToParts[i].value
              });
            } else {
              dateStruct.push({
                type: formatToParts[i].type
              });
            }
          }
          /** @type {?} */


          var formatterOptions = formatter.resolvedOptions();

          for (var _i15 = 0; _i15 < dateStruct.length; _i15++) {
            switch (dateStruct[_i15].type) {
              case "day"
              /* Day */
              :
                {
                  dateStruct[_i15].formatType = formatterOptions.day;
                  break;
                }

              case "month"
              /* Month */
              :
                {
                  dateStruct[_i15].formatType = formatterOptions.month;
                  break;
                }

              case "year"
              /* Year */
              :
                {
                  dateStruct[_i15].formatType = formatterOptions.month;
                  break;
                }
            }
          }

          DatePickerUtil.fillDatePartsPositions(dateStruct);
          return dateStruct;
        }
        /**
         * @private
         * @param {?} char
         * @return {?}
         */

      }, {
        key: "isDateChar",
        value: function isDateChar(_char10) {
          return _char10 === "y"
          /* YearChar */
          || _char10 === "M"
          /* MonthChar */
          || _char10 === "d"
          /* DayChar */
          ;
        }
        /**
         * @private
         * @param {?} formatType
         * @return {?}
         */

      }, {
        key: "getNumericFormatPrefix",
        value: function getNumericFormatPrefix(formatType) {
          switch (formatType) {
            case "2-digit"
            /* TwoDigits */
            :
              {
                return '0';
              }

            case "numeric"
            /* Numeric */
            :
              {
                return DatePickerUtil.PROMPT_CHAR;
              }
          }
        }
        /**
         * @private
         * @param {?} dateFormatParts
         * @param {?} datePart
         * @param {?} inputValue
         * @return {?}
         */

      }, {
        key: "getMinMaxValue",
        value: function getMinMaxValue(dateFormatParts, datePart, inputValue) {
          /** @type {?} */
          var maxValue;
          /** @type {?} */

          var minValue;

          switch (datePart.type) {
            case "month"
            /* Month */
            :
              {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
              }

            case "day"
            /* Day */
            :
              {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year"
                /* Year */
                ), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
              }

            case "year"
            /* Year */
            :
              {
                if (datePart.formatType === "2-digit"
                /* TwoDigits */
                ) {
                    minValue = 0;
                    maxValue = 99;
                  } else {
                  // Infinite loop
                  minValue = 'infinite';
                  maxValue = 'infinite';
                }

                break;
              }
          }

          return {
            min: minValue,
            max: maxValue
          };
        }
        /**
         * @private
         * @param {?} fullYear
         * @param {?} month
         * @return {?}
         */

      }, {
        key: "daysInMonth",
        value: function daysInMonth(fullYear, month) {
          return new Date(fullYear, month, 0).getDate();
        }
        /**
         * @private
         * @param {?} dateFormatParts
         * @param {?} type
         * @param {?} inputValue
         * @param {?=} trim
         * @return {?}
         */

      }, {
        key: "getDateValueFromInput",
        value: function getDateValueFromInput(dateFormatParts, type, inputValue) {
          var trim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

          /** @type {?} */
          var partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
          /** @type {?} */

          var result = inputValue.substring(partPosition[0], partPosition[1]);
          return trim ? DatePickerUtil.trimUnderlines(result) : result;
        }
        /**
         * @private
         * @param {?} dateFormatParts
         * @param {?} inputValue
         * @param {?=} trim
         * @return {?}
         */

      }, {
        key: "getDayValueFromInput",
        value: function getDayValueFromInput(dateFormatParts, inputValue) {
          var trim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day"
          /* Day */
          , inputValue, trim);
        }
        /**
         * @private
         * @param {?} dateFormatParts
         * @param {?} inputValue
         * @param {?=} trim
         * @return {?}
         */

      }, {
        key: "getMonthValueFromInput",
        value: function getMonthValueFromInput(dateFormatParts, inputValue) {
          var trim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month"
          /* Month */
          , inputValue, trim);
        }
        /**
         * @private
         * @param {?} dateFormatParts
         * @param {?} inputValue
         * @param {?=} trim
         * @return {?}
         */

      }, {
        key: "getYearValueFromInput",
        value: function getYearValueFromInput(dateFormatParts, inputValue) {
          var trim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year"
          /* Year */
          , inputValue, trim);
        }
        /**
         * @private
         * @param {?} dateFormatParts
         * @param {?} type
         * @return {?}
         */

      }, {
        key: "getDateFormatPart",
        value: function getDateFormatPart(dateFormatParts, type) {
          /** @type {?} */
          var result = dateFormatParts.filter(function (datePart) {
            return datePart.type === type;
          })[0];
          return result;
        }
        /**
         * @private
         * @param {?} value
         * @param {?} input
         * @return {?}
         */

      }, {
        key: "isFullInput",
        value: function isFullInput(value, input) {
          return value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR;
        }
        /**
         * @private
         * @param {?} dateFormatParts
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isFullYearInput",
        value: function isFullYearInput(dateFormatParts, value) {
          switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year"
          /* Year */
          ).formatType) {
            case "numeric"
            /* Numeric */
            :
              {
                return value !== '' && value.length === 4;
              }

            case "2-digit"
            /* TwoDigits */
            :
              {
                return value !== '' && value.length === 2;
              }

            default:
              {
                return false;
              }
          }
        }
        /**
         * @private
         * @param {?} dateFormatParts
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "getDatePartOnPosition",
        value: function getDatePartOnPosition(dateFormatParts, position) {
          /** @type {?} */
          var result = dateFormatParts.filter(function (element) {
            return element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR;
          })[0];
          return result;
        }
        /**
         * @private
         * @param {?} yearPart
         * @param {?} inputValue
         * @return {?}
         */

      }, {
        key: "getFullYearFromString",
        value: function getFullYearFromString(yearPart, inputValue) {
          return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
        }
        /**
         * @private
         * @param {?} dateArray
         * @return {?}
         */

      }, {
        key: "fillDatePartsPositions",
        value: function fillDatePartsPositions(dateArray) {
          /** @type {?} */
          var currentPos = 0;

          for (var i = 0; i < dateArray.length; i++) {
            // Day|Month part positions
            if (dateArray[i].type === "day"
            /* Day */
            || dateArray[i].type === "month"
            /* Month */
            ) {
                // Offset 2 positions for number
                dateArray[i].position = [currentPos, currentPos + 2];
                currentPos += 2;
              } else if (dateArray[i].type === "year"
            /* Year */
            ) {
                // Year part positions
                switch (dateArray[i].formatType) {
                  case "numeric"
                  /* Numeric */
                  :
                    {
                      // Offset 4 positions for full year
                      dateArray[i].position = [currentPos, currentPos + 4];
                      currentPos += 4;
                      break;
                    }

                  case "2-digit"
                  /* TwoDigits */
                  :
                    {
                      // Offset 2 positions for short year
                      dateArray[i].position = [currentPos, currentPos + 2];
                      currentPos += 2;
                      break;
                    }
                }
              } else if (dateArray[i].type === DatePickerUtil.SEPARATOR) {
              // Separator positions
              dateArray[i].position = [currentPos, currentPos + 1];
              currentPos++;
            }
          }
        }
      }]);

      return DatePickerUtil;
    }();

    DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
    DatePickerUtil.SEPARATOR = 'literal';
    DatePickerUtil.NUMBER_OF_MONTHS = 12;
    DatePickerUtil.PROMPT_CHAR = '_';
    DatePickerUtil.DEFAULT_LOCALE = 'en';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @type {?}
     */

    var IGX_DATE_PICKER_COMPONENT = 'IgxDatePickerComponentToken';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var DatePickerDisplayValuePipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _datePicker
       */
      function DatePickerDisplayValuePipe(_datePicker) {
        _classCallCheck(this, DatePickerDisplayValuePipe);

        this._datePicker = _datePicker;
      }
      /**
       * @param {?} value
       * @param {?=} args
       * @return {?}
       */


      _createClass(DatePickerDisplayValuePipe, [{
        key: "transform",
        value: function transform(value, args) {
          if (value !== '') {
            if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
              return '';
            }

            this._datePicker.rawDateString = value;
            return DatePickerUtil.trimUnderlines(value);
          }

          return '';
        }
      }]);

      return DatePickerDisplayValuePipe;
    }();

    DatePickerDisplayValuePipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'displayValue'
      }]
    }];
    /** @nocollapse */

    DatePickerDisplayValuePipe.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_DATE_PICKER_COMPONENT]
        }]
      }];
    };
    /**
     * @hidden
     */


    var DatePickerInputValuePipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _datePicker
       */
      function DatePickerInputValuePipe(_datePicker) {
        _classCallCheck(this, DatePickerInputValuePipe);

        this._datePicker = _datePicker;
      }
      /**
       * @param {?} value
       * @param {?=} args
       * @return {?}
       */


      _createClass(DatePickerInputValuePipe, [{
        key: "transform",
        value: function transform(value, args) {
          if (this._datePicker.invalidDate !== '') {
            return this._datePicker.invalidDate;
          } else {
            if (this._datePicker.value === null || this._datePicker.value === undefined) {
              return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
            } else {
              return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
            }
          }
        }
      }]);

      return DatePickerInputValuePipe;
    }();

    DatePickerInputValuePipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'inputValue'
      }]
    }];
    /** @nocollapse */

    DatePickerInputValuePipe.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_DATE_PICKER_COMPONENT]
        }]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * IgxDatePickerTemplateDirective can be used to re-template the date-picker input-group.
     *
     * @hidden
     */


    var IgxDatePickerTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxDatePickerTemplateDirective(template) {
      _classCallCheck(this, IgxDatePickerTemplateDirective);

      this.template = template;
    };

    IgxDatePickerTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxDatePickerTemplate]'
      }]
    }];
    /** @nocollapse */

    IgxDatePickerTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * IgxDatePickerActionsDirective can be used to re-template the dropdown/dialog action buttons.
     */


    var IgxDatePickerActionsDirective =
    /**
     * @param {?} template
     */
    function IgxDatePickerActionsDirective(template) {
      _classCallCheck(this, IgxDatePickerActionsDirective);

      this.template = template;
    };

    IgxDatePickerActionsDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxDatePickerActions]'
      }]
    }];
    /** @nocollapse */

    IgxDatePickerActionsDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */


    var InteractionMode = {
      DropDown: 'dropdown',
      Dialog: 'dialog'
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxCalendarContainerComponent =
    /*#__PURE__*/
    function () {
      function IgxCalendarContainerComponent() {
        _classCallCheck(this, IgxCalendarContainerComponent);

        this.mode = InteractionMode.Dialog;
        this.vertical = false;
        this.onClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onTodaySelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.styleClass = 'igx-date-picker';
      }
      /**
       * @return {?}
       */


      _createClass(IgxCalendarContainerComponent, [{
        key: "onEscape",

        /**
         * @param {?} event
         * @return {?}
         */
        value: function onEscape(event) {
          event.preventDefault();
          this.onClose.emit();
        }
        /**
         * Returns whether the date-picker is in readonly dialog mode.
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "closeCalendar",

        /**
         * Emits close event for the calendar.
         * @return {?}
         */
        value: function closeCalendar() {
          this.onClose.emit();
        }
        /**
         * Emits today selection event for the calendar.
         * @return {?}
         */

      }, {
        key: "triggerTodaySelection",
        value: function triggerTodaySelection() {
          this.onTodaySelection.emit();
        }
      }, {
        key: "dropdownCSS",
        get: function get() {
          return this.mode === InteractionMode.DropDown;
        }
        /**
         * @return {?}
         */

      }, {
        key: "verticalCSS",
        get: function get() {
          return this.vertical && this.mode === InteractionMode.Dialog;
        }
      }, {
        key: "isReadonly",
        get: function get() {
          return this.mode === InteractionMode.Dialog;
        }
      }]);

      return IgxCalendarContainerComponent;
    }();

    IgxCalendarContainerComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-calendar-container',
        template: "<ng-template #defaultDatePickerActions>\n    <div *ngIf=\"cancelButtonLabel || todayButtonLabel\" class=\"igx-date-picker__buttons\">\n        <button #closeButton *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"closeCalendar()\">\n            {{ cancelButtonLabel }}\n        </button>\n        <button #todayButton *ngIf=\"todayButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"triggerTodaySelection()\">\n            {{ todayButtonLabel }}\n        </button>\n    </div>\n</ng-template>\n<igx-calendar #calendar></igx-calendar>\n<ng-container *ngTemplateOutlet=\"datePickerActions ? datePickerActions.template : defaultDatePickerActions\"></ng-container>\n",
        styles: [':host {display: block;}']
      }]
    }];
    IgxCalendarContainerComponent.propDecorators = {
      calendar: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['calendar', {
          "static": true
        }]
      }],
      mode: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      vertical: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cancelButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      todayButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      datePickerActions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onClose: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onTodaySelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      styleClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-date-picker']
      }],
      dropdownCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-date-picker--dropdown']
      }],
      verticalCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-date-picker--vertical']
      }],
      onEscape: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.esc', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.alt.arrowup', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$k = 0;
    /** @enum {string} */

    var PredefinedFormatOptions = {
      ShortDate: 'shortDate',
      MediumDate: 'mediumDate',
      LongDate: 'longDate',
      FullDate: 'fullDate'
    };
    /**
     * **Ignite UI for Angular Date Picker** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/date_picker.html)
     *
     * The Ignite UI Date Picker displays a popup calendar that lets users select a single date.
     *
     * Example:
     * ```html
     * <igx-date-picker [(ngModel)]="selectedDate"></igx-date-picker>
     * ```
     */

    var IgxDatePickerComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _overlayService
       * @param {?} element
       * @param {?} _cdr
       * @param {?} _moduleRef
       */
      function IgxDatePickerComponent(_overlayService, element, _cdr, _moduleRef) {
        _classCallCheck(this, IgxDatePickerComponent);

        this._overlayService = _overlayService;
        this.element = element;
        this._cdr = _cdr;
        this._moduleRef = _moduleRef;
        /**
         * An \@Input property that sets the `IgxDatePickerComponent` label.
         * The default label is 'Date'.
         * ```html
         * <igx-date-picker [label]="Calendar"></igx-date-picker>
         * ```
         */

        this.label = 'Date';
        /**
         * An \@Input property that sets the `IgxDatePickerComponent` label visibility.
         * By default the visibility is set to true.
         * <igx-date-picker [labelVisibility]="false"></igx-date-picker>
         */

        this.labelVisibility = true;
        /**
         * An \@Input property that sets on which day the week starts.
         * ```html
         * <igx-date-picker [weekStart]="WEEKDAYS.FRIDAY" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */

        this.weekStart = WEEKDAYS.SUNDAY;
        /**
         * Sets/gets the number of month views displayed.
         * Default value is `1`.
         * ```html
         * <igx-date-picker [monthsViewNumber]="2"></igx-date-picker>
         * ```
         * ```typescript
         * let monthViewsDisplayed = this.datePicker.monthsViewNumber;
         * ```
         */

        this.monthsViewNumber = 1;
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-date-picker [id]="'igx-date-picker-3'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */

        this.id = "igx-date-picker-".concat(NEXT_ID$k++);
        /**
         * An \@Input property that sets the orientation of the `IgxDatePickerComponent` header.
         * ```html
         * <igx-date-picker [vertical]="'true'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */

        this.vertical = false;
        /**
         * An \@Input property that sets whether `IgxDatePickerComponent` is in dialog or drop down mode.
         * ```html
         * <igx-date-picker mode="dropdown"></igx-date-picker>
         * ```
         */

        this.mode = InteractionMode.Dialog;
        /**
         * An \@Input property that sets whether the `IgxDatePickerComponent` date parts would spin continuously or stop when min/max is reached.
         * ```html
         * <igx-date-picker [isSpinLoop]="false"></igx-date-picker>
         * ```
         */

        this.isSpinLoop = true;
        /**
         * An event that is emitted when the `IgxDatePickerComponent` calendar is opened.
         */

        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted after the `IgxDatePickerComponent` is closed.
         */

        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the `IgxDatePickerComponent` is being closed.
         */

        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property that is fired when selection is made in the calendar.
         * ```typescript
         * public selection(event){
         *    alert("A date has been selected!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onSelection)="selection($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */

        this.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property that is fired when date picker value is changed.
         * ```typescript
         * public valueChanged(event){
         *    alert("Date picker value is changed");
         * }
         * ```
         * ```html
         * <igx-date-picker (valueChange)="valueChanged($event)" mode="dropdown"></igx-date-picker>
         * ```
         */

        this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property that fires when the user types/spins to a disabled date in the date-picker editor.
         * ```typescript
         * public onDisabledDate(event){
         *    alert("This date is disabled!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onDisabledDate)="onDisabledDate($event)"></igx-date-picker>
         * ```
         */

        this.onDisabledDate = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property that fires when the user types/spins invalid date in the date-picker editor.
         * ```typescript
         * public onValidationFailed(event){
         *    alert("This date is not valid!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onValidationFailed)="onValidationFailed($event)"></igx-date-picker>
         * ```
         */

        this.onValidationFailed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.hasHeader = true;
        this.collapsed = true;
        this.displayValuePipe = new DatePickerDisplayValuePipe(this);
        this.inputValuePipe = new DatePickerInputValuePipe(this);
        this.dateFormatParts = [];
        this.isEmpty = true;
        this.invalidDate = '';
        this.spinDelta = 1;
        this.defaultLocale = 'en';
        this._formatOptions = {
          day: 'numeric',
          month: 'short',
          weekday: 'short',
          year: 'numeric'
        };
        this._formatViews = {
          day: false,
          month: true,
          year: false
        };
        this._destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._disabledDates = null;
        this._specialDates = null;
        this._onOpen = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._onClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();

        this._onTouchedCallback = function () {};

        this._onChangeCallback = function () {};
      }
      /**
       * Returns the format options of the `IgxDatePickerComponent`.
       * ```typescript
       * \@ViewChild("MyDatePicker")
       * public datePicker: IgxDatePickerComponent;
       * ngAfterViewInit(){
       *    let formatOptions = this.datePicker.formatOptions;
       * }
       * ```
       * @return {?}
       */


      _createClass(IgxDatePickerComponent, [{
        key: "onSpaceClick",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function onSpaceClick(event) {
          this.openDialog(this.getInputGroupElement());
          event.preventDefault();
        }
        /**
         * Method that sets the selected date.
         * ```typescript
         * public date = new Date();
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    this.datePicker.writeValue(this.date);
         * }
         * ```
         * \@memberOf {\@link IgxDatePickerComponent}
         * @param {?} value The date you want to select.
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this.value = value;

          this._cdr.markForCheck();
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
        /**
         * @hidden
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getEditElement",
        value: function getEditElement() {
          /** @type {?} */
          var inputElement = this.editableInput || this.readonlyInput || this.input;
          return inputElement ? inputElement.nativeElement : null;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getInputGroupElement",
        value: function getInputGroupElement() {
          return this.inputGroup ? this.inputGroup.element.nativeElement : null;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this141 = this;

          this._positionSettings = {
            openAnimation: fadeIn,
            closeAnimation: fadeOut
          };
          this._defaultDropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(this._positionSettings),
            outlet: this.outlet
          };
          this._modalOverlaySettings = {
            closeOnOutsideClick: true,
            modal: true,
            outlet: this.outlet
          };

          this._overlayService.onOpening.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function (overlay) {
            return overlay.id === _this141._componentID;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function (eventArgs) {
            _this141._onOpening(eventArgs);
          });

          this._overlayService.onOpened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function (overlay) {
            return overlay.id === _this141._componentID;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function () {
            _this141._onOpened();
          });

          this._overlayService.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function (overlay) {
            return overlay.id === _this141._componentID;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function () {
            _this141._onClosed();
          });

          this._overlayService.onClosing.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function (overlay) {
            return overlay.id === _this141._componentID;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function (event) {
            _this141.onClosing.emit(event); // If canceled in a user onClosing handler


            if (event.cancel) {
              return;
            } // Do not focus the input if clicking outside in dropdown mode

            /** @type {?} */


            var input = _this141.getEditElement();

            if (input && !(event.event && _this141.mode === InteractionMode.DropDown)) {
              input.focus();
            }
          });

          if (this.mode === InteractionMode.DropDown) {
            this.dateFormatParts = DatePickerUtil.parseDateFormat(this.mask, this.locale);

            if (this.mask === undefined) {
              this.mask = DatePickerUtil.getMask(this.dateFormatParts);
            }

            this.inputMask = DatePickerUtil.getInputMask(this.dateFormatParts);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this142 = this;

          if (this.mode === InteractionMode.DropDown && this.editableInput) {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.editableInput.nativeElement, 'keydown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(function () {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"]);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function (res) {
              return _this142.onKeyDown(res);
            });
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this._componentID) {
            this._overlayService.hide(this._componentID);
          }

          this._destroy$.next(true);

          this._destroy$.complete();
        }
        /**
         * Selects today's date from calendar and change the input field value, \@calendar.viewDate and \@calendar.value.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         * this.datePicker.triggerTodaySelection();
         * }
         * ```
         * \@memberOf {\@link IgxDatePickerComponent}
         * @return {?}
         */

      }, {
        key: "triggerTodaySelection",
        value: function triggerTodaySelection() {
          /** @type {?} */
          var today = new Date(Date.now());
          this.handleSelection(today);
        }
        /**
         * Change the calendar selection and calling this method will emit the \@calendar.onSelection event,
         * which will fire \@handleSelection method.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         * this.datePicker.selectDate(this.date);
         * }
         * ```
         * \@memberOf {\@link IgxDatePickerComponent}
         * @param {?} date passed date that has to be set to the calendar.
         * @return {?}
         */

      }, {
        key: "selectDate",
        value: function selectDate(date) {
          /** @type {?} */
          var oldValue = this.value;
          this.value = date;
          this.emitValueChangeEvent(oldValue, this.value);
          this.onSelection.emit(date);
        }
        /**
         * Deselects the calendar date.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         * this.datePicker.deselectDate();
         * }
         * ```
         * \@memberOf {\@link IgxDatePickerComponent}
         * @return {?}
         */

      }, {
        key: "deselectDate",
        value: function deselectDate() {
          /** @type {?} */
          var oldValue = this.value;
          this.value = null;
          this.emitValueChangeEvent(oldValue, this.value);

          if (this.calendar) {
            this.calendar.deselectDate();
          }
        }
        /**
         * Opens the date picker drop down or dialog.
         * @param {?=} target HTMLElement - the target element to use for positioning the drop down container according to
         * ```html
         * <igx-date-picker [value]="date" mode="dropdown" #retemplated>
         *   <ng-template igxDatePickerTemplate let-openDialog="openDialog"
         *                let-displayData="displayData">
         *     <igx-input-group>
         *       <input #dropDownTarget igxInput [value]="displayData" />
         *       <igx-suffix (click)="openDialog(dropDownTarget)">
         *         <igx-icon>alarm</igx-icon>
         *       </igx-suffix>
         *     </igx-input-group>
         *   </ng-template>
         * </igx-date-picker>
         * ```
         * @return {?}
         */

      }, {
        key: "openDialog",
        value: function openDialog(target) {
          if (!this.collapsed) {
            return;
          }

          switch (this.mode) {
            case InteractionMode.Dialog:
              {
                this.hasHeader = true;
                /** @type {?} */

                var modalOverlay = this.modalOverlaySettings !== undefined ? this._modalOverlay : this._modalOverlaySettings;
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, modalOverlay, this._moduleRef);

                this._overlayService.show(this._componentID);

                break;
              }

            case InteractionMode.DropDown:
              {
                this.hasHeader = false;

                if (target) {
                  this.dropDownOverlaySettings.positionStrategy.settings.target = target;
                }

                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, this.dropDownOverlaySettings, this._moduleRef);

                this._overlayService.show(this._componentID);

                break;
              }
          }
        }
        /**
         * Close the calendar.
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "closeCalendar",
        value: function closeCalendar() {
          this._overlayService.hide(this._componentID);
        }
        /**
         * Clear the input field, date picker value and calendar selection.
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "clear",
        value: function clear() {
          this.isEmpty = true;
          this.invalidDate = '';
          this.deselectDate();

          this._setCursorPosition(0);
        }
        /**
         * Evaluates when \@calendar.onSelection event was fired
         * and update the input value.
         *
         * @hidden
         * @param {?} date
         * @return {?}
         */

      }, {
        key: "handleSelection",
        value: function handleSelection(date) {
          if (this.value) {
            date.setHours(this.value.getHours());
            date.setMinutes(this.value.getMinutes());
            date.setSeconds(this.value.getSeconds());
            date.setMilliseconds(this.value.getMilliseconds());
          }
          /** @type {?} */


          var oldValue = this.value;
          this.value = date;
          this.emitValueChangeEvent(oldValue, this.value);
          this.calendar.viewDate = date;
          this.closeCalendar();
          this.onSelection.emit(date);
        }
        /**
         * Evaluates when the input blur event was fired
         * and re-calculate the date picker value.
         *
         * @hidden
         * @param {?} event
         *
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur(event) {
          this._isInEditMode = false;
          this.calculateDate(event.target.value, event.type);
        }
        /**
         * Evaluates when the input focus event was fired
         * and re-calculate the editor text.
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus() {
          this._isInEditMode = true;

          if (this.value && this.invalidDate === '') {
            this._transformedDate = this._getEditorDate(this.value);
          }
        }
        /**
         * Evaluates when the keydown event was fired for up/down keys
         * to provide spinning of date parts.
         *
         * @hidden
         * @param {?} event
         *
         * @return {?}
         */

      }, {
        key: "onKeyDown",
        value: function onKeyDown(event) {
          switch (event.key) {
            case "ArrowUp"
            /* UP_ARROW */
            :
            case "Up"
            /* UP_ARROW_IE */
            :
              event.preventDefault();
              event.stopPropagation();
              this.spinValue(event.target.value, 1, event.type);
              break;

            case "ArrowDown"
            /* DOWN_ARROW */
            :
            case "Down"
            /* DOWN_ARROW_IE */
            :
              if (event.altKey) {
                this.openDialog(this.getInputGroupElement());
              } else {
                event.preventDefault();
                event.stopPropagation();
                this.spinValue(event.target.value, -1, event.type);
              }

              break;

            default:
              break;
          }
        }
        /**
         * Evaluates when the mouse wheel event was fired
         * to provide spinning of date parts.
         *
         * @hidden
         * @param {?} event
         *
         * @return {?}
         */

      }, {
        key: "onWheel",
        value: function onWheel(event) {
          if (this._isInEditMode) {
            event.preventDefault();
            event.stopPropagation();
            /** @type {?} */

            var sign = event.deltaY > 0 ? -1 : 1;
            this.spinValue(event.target.value, sign, event.type);
          }
        }
        /**
         * Evaluates when input event was fired in editor.
         *
         * @hidden
         * @param {?} event
         *
         * @return {?}
         */

      }, {
        key: "onInput",
        value: function onInput(event) {
          var _this143 = this;

          /** @type {?} */
          var targetValue = event.target.value;
          /** @type {?} */

          var cursorPosition = this._getCursorPosition();
          /** @type {?} */


          var checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, targetValue);
          this._isInEditMode = true;

          if (targetValue !== DatePickerUtil.maskToPromptChars(this.inputMask)) {
            this.isEmpty = false;
          } // If all date parts are completed, change the date-picker value, stay in edit mode


          if (checkInput === 'complete' && event.inputType !== 'deleteContentBackward') {
            this._transformedDate = targetValue;
            this.calculateDate(targetValue, event.type);

            this._setCursorPosition(cursorPosition);
          } else if (checkInput === 'partial') {
            // While editing, if one date part is deleted, date-picker value is set to null, the remaining input stays intact.
            this.deselectDate();
            requestAnimationFrame(function () {
              _this143.getEditElement().value = targetValue;

              _this143._setCursorPosition(cursorPosition);
            });
          } else if (checkInput === 'empty') {
            // Total clean-up as input is deleted.
            this.isEmpty = true;
            this.deselectDate();
          }
        }
        /**
         * @private
         * @param {?} oldValue
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "emitValueChangeEvent",
        value: function emitValueChangeEvent(oldValue, newValue) {
          if (!isEqual(oldValue, newValue)) {
            this.valueChange.emit(newValue);
          }
        }
        /**
         * @private
         * @param {?} dateString
         * @param {?} invokedByEvent
         * @return {?}
         */

      }, {
        key: "calculateDate",
        value: function calculateDate(dateString, invokedByEvent) {
          if (dateString !== '') {
            /** @type {?} */
            var prevDateValue = this.value;
            /** @type {?} */

            var inputValue = invokedByEvent === 'blur' ? this.rawDateString : dateString;
            /** @type {?} */

            var newDateArray = DatePickerUtil.parseDateArray(this.dateFormatParts, prevDateValue, inputValue);

            if (newDateArray.state === "valid"
            /* Valid */
            ) {
                /** @type {?} */
                var newValue = newDateArray.date; // Restore the time part if any

                if (prevDateValue) {
                  newValue.setHours(prevDateValue.getHours());
                  newValue.setMinutes(prevDateValue.getMinutes());
                  newValue.setSeconds(prevDateValue.getSeconds());
                  newValue.setMilliseconds(prevDateValue.getMilliseconds());
                }

                if (this.disabledDates === null || this.disabledDates !== null && !isDateInRanges(newValue, this.disabledDates)) {
                  /** @type {?} */
                  var oldValue = this.value;
                  this.value = newValue;
                  this.emitValueChangeEvent(oldValue, this.value);
                  this.invalidDate = '';
                } else {
                  /** @type {?} */
                  var args = {
                    datePicker: this,
                    currentValue: newValue
                  };
                  this.onDisabledDate.emit(args);
                }
              } else {
              /** @type {?} */
              var _args = {
                datePicker: this,
                prevValue: prevDateValue
              };
              this.invalidDate = dateString;
              this.onValidationFailed.emit(_args);
            }
          }
        }
        /**
         * @private
         * @param {?} inputValue
         * @param {?} sign
         * @param {?} eventType
         * @return {?}
         */

      }, {
        key: "spinValue",
        value: function spinValue(inputValue, sign, eventType) {
          this._isInEditMode = true;
          this.isEmpty = false;
          /** @type {?} */

          var cursorPosition = this._getCursorPosition();
          /** @type {?} */


          var modifiedInputValue = DatePickerUtil.getModifiedDateInput(this.dateFormatParts, inputValue, cursorPosition, this.spinDelta * sign, this.isSpinLoop);
          this.getEditElement().value = modifiedInputValue;

          this._setCursorPosition(cursorPosition);
          /** @type {?} */


          var checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, modifiedInputValue);

          if (checkInput === 'complete') {
            this._isInEditMode = true;
            this.calculateDate(modifiedInputValue, eventType);

            this._setCursorPosition(cursorPosition);
          }
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onOpening",
        value: function _onOpening(event) {
          this._initializeCalendarContainer(
          /** @type {?} */
          event.componentRef.instance);

          this.collapsed = false;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_onOpened",
        value: function _onOpened() {
          this._onTouchedCallback();

          this.onOpened.emit(this); // TODO: remove this line after deprecating 'onOpen'

          this._onOpen.emit(this);

          if (this.calendar) {
            this._focusCalendarDate();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_onClosed",
        value: function _onClosed() {
          this.collapsed = true;
          this._componentID = null;
          this.onClosed.emit(this);
        }
        /**
         * @private
         * @param {?} componentInstance
         * @return {?}
         */

      }, {
        key: "_initializeCalendarContainer",
        value: function _initializeCalendarContainer(componentInstance) {
          var _this144 = this;

          this.calendar = componentInstance.calendar;
          /** @type {?} */

          var isVertical = this.vertical && this.mode === InteractionMode.Dialog;
          this.calendar.hasHeader = this.hasHeader;
          this.calendar.formatOptions = this.formatOptions;
          this.calendar.formatViews = this.formatViews;
          this.calendar.locale = this.locale;
          this.calendar.vertical = isVertical;
          this.calendar.weekStart = this.weekStart;
          this.calendar.specialDates = this.specialDates;
          this.calendar.disabledDates = this.disabledDates;
          this.calendar.headerTemplate = this.headerTemplate;
          this.calendar.subheaderTemplate = this.subheaderTemplate;
          this.calendar.hideOutsideDays = this.hideOutsideDays;
          this.calendar.monthsViewNumber = this.monthsViewNumber;
          this.calendar.onSelection.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function (ev) {
            return _this144.handleSelection(ev);
          });

          if (this.value) {
            this.calendar.value = this.value;
            this.calendar.viewDate = this.value;
          }

          componentInstance.mode = this.mode;
          componentInstance.vertical = isVertical;
          componentInstance.cancelButtonLabel = this.cancelButtonLabel;
          componentInstance.todayButtonLabel = this.todayButtonLabel;
          componentInstance.datePickerActions = this.datePickerActionsDirective;
          componentInstance.onClose.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function () {
            return _this144.closeCalendar();
          });
          componentInstance.onTodaySelection.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function () {
            return _this144.triggerTodaySelection();
          });
        } // Focus a date, after the calendar appearance into DOM.

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_focusCalendarDate",
        value: function _focusCalendarDate() {
          var _this145 = this;

          requestAnimationFrame(function () {
            _this145.calendar.daysView.focusActiveDate();
          });
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_setLocaleToDate",
        value: function _setLocaleToDate(value) {
          if (isIE()) {
            // this is a workaround fixing the following IE11 issue:
            // IE11 has added character code 8206 (mark for RTL) to the output of toLocaleDateString() that
            // precedes each portion that comprises the total date... For more information read this article:
            // tslint:disable-next-line: max-line-length
            // https://www.csgpro.com/blog/2016/08/a-bad-date-with-internet-explorer-11-trouble-with-new-unicode-characters-in-javascript-date-strings/

            /** @type {?} */
            var localeDateStrIE = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
            return localeDateStrIE.toLocaleDateString(this.locale);
          }

          return value.toLocaleDateString(this.locale);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getCursorPosition",
        value: function _getCursorPosition() {
          return this.getEditElement().selectionStart;
        }
        /**
         * @private
         * @param {?} start
         * @param {?=} end
         * @return {?}
         */

      }, {
        key: "_setCursorPosition",
        value: function _setCursorPosition(start) {
          var _this146 = this;

          var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;
          requestAnimationFrame(function () {
            _this146.getEditElement().setSelectionRange(start, end);
          });
        }
        /**
         * Apply custom user formatter upon date.
         * @private
         * @param {?} formatter custom formatter function.
         * @param {?} date passed date
         * @return {?}
         */

      }, {
        key: "_customFormatChecker",
        value: function _customFormatChecker(formatter, date) {
          return this.formatter ? this.formatter(date) : this._setLocaleToDate(date);
        }
        /*
            * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
            * using @angular/common formatDate method: https://angular.io/api/common/formatDate
            * @param  value: string | number | Date
            * @returns formatted string
            */

        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_getDisplayDate",
        value: function _getDisplayDate(value) {
          if (this.format && !this.formatter) {
            /** @type {?} */
            var locale = this.locale || this.defaultLocale;
            return Object(_angular_common__WEBPACK_IMPORTED_MODULE_3__["formatDate"])(value, this.format, locale);
          } else {
            return this._customFormatChecker(this.formatter, value);
          }
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_getEditorDate",
        value: function _getEditorDate(value) {
          /** @type {?} */
          var locale = this.locale || this.defaultLocale;
          /** @type {?} */

          var changedValue = value ? Object(_angular_common__WEBPACK_IMPORTED_MODULE_3__["formatDate"])(value, this.mask, locale) : '';
          return DatePickerUtil.addPromptCharsEditMode(this.dateFormatParts, this.value, changedValue);
        }
      }, {
        key: "formatOptions",
        get: function get() {
          return this._formatOptions;
        }
        /**
         * Sets the format options of the `IgxDatePickerComponent`.
         * ```typescript
         * public Options;
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    this.Options = {
         *        day: "numeric",
         *        month: "long",
         *        weekday: "long",
         *        year: "numeric"
         *    }
         * this.datePicker.formatOptions = this.Options;
         * }
         * ```
         * @param {?} formatOptions
         * @return {?}
         */
        ,
        set: function set(formatOptions) {
          this._formatOptions = Object.assign(this._formatOptions, formatOptions);
        }
        /**
         * Returns the date display format of the `IgxDatePickerComponent` in dropdown mode.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    let format = this.datePicker.format;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "format",
        get: function get() {
          return this._format === undefined ? PredefinedFormatOptions.ShortDate : this._format;
        }
        /**
         * Sets the date format of the `IgxDatePickerComponent` when in editable dropdown mode.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * this.datePicker.format = 'yyyy-M-d';
         * }
         * ```
         * @param {?} format
         * @return {?}
         */
        ,
        set: function set(format) {
          this._format = format;
        }
        /**
         * Returns the format views of the `IgxDatePickerComponent`.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    let formatViews = this.datePicker.formatViews;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "formatViews",
        get: function get() {
          return this._formatViews;
        }
        /**
         * Sets the format views of the `IgxDatePickerComponent`.
         * ```typescript
         * public Views;
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    this.Views = {day:false, month: false, year:false};
         *    this.datePicker.formatViews = this.Views;
         * }
         * ```
         * @param {?} formatViews
         * @return {?}
         */
        ,
        set: function set(formatViews) {
          this._formatViews = Object.assign(this._formatViews, formatViews);
        }
        /**
         * Gets the disabled dates descriptors.
         * ```typescript
         * let disabledDates = this.datepicker.disabledDates;
         * ```
         * @return {?}
         */

      }, {
        key: "disabledDates",
        get: function get() {
          return this._disabledDates;
        }
        /**
         * Sets the disabled dates' descriptors.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    this.datePicker.disabledDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._disabledDates = value;
        }
        /**
         * Gets the special dates descriptors.
         * ```typescript
         * let specialDates = this.datepicker.specialDates;
         * ```
         * @return {?}
         */

      }, {
        key: "specialDates",
        get: function get() {
          return this._specialDates;
        }
        /**
         * Sets the special dates' descriptors.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    this.datePicker.specialDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._specialDates = value;
        }
        /**
         * @return {?}
         */

      }, {
        key: "modalOverlaySettings",
        get: function get() {
          return this._modalOverlay;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._modalOverlay = value;
        }
        /**
         * @return {?}
         */

      }, {
        key: "dropDownOverlaySettings",
        get: function get() {
          return this._dropDownOverlaySettings || this._defaultDropDownOverlaySettings;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._dropDownOverlaySettings = value;
        }
        /**
         * Returns the formatted date when `IgxDatePickerComponent` is in dialog mode.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * public selection(event){
         *    let selectedDate = this.datePicker.displayData;
         *    alert(selectedDate);
         * }
         * ```
         * ```html
         * <igx-date-picker #MyDatePicker (onSelection)="selection()" todayButtonLabel="today"></igx-date-picker>
         * ```
         * @return {?}
         */

      }, {
        key: "displayData",
        get: function get() {
          if (this.value) {
            return this._customFormatChecker(this.formatter, this.value);
          }

          return '';
        }
        /**
         * hidden
         * @return {?}
         */

      }, {
        key: "transformedDate",
        get: function get() {
          if (this._value) {
            this._transformedDate = this._isInEditMode ? this._getEditorDate(this._value) : this._getDisplayDate(this._value);
            this.isEmpty = false;
          } else {
            this._transformedDate = this._isInEditMode ? DatePickerUtil.maskToPromptChars(this.inputMask) : '';
          }

          return this._transformedDate;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._transformedDate = value;
        }
        /**
         * Gets the input group template.
         * ```typescript
         * let template = this.template();
         * ```
         * \@memberof IgxDatePickerComponent
         * @return {?}
         */

      }, {
        key: "template",
        get: function get() {
          if (this.datePickerTemplateDirective) {
            return this.datePickerTemplateDirective.template;
          }

          return this.mode === InteractionMode.Dialog ? this.readOnlyDatePickerTemplate : this.editableDatePickerTemplate;
        }
        /**
         * Gets the context passed to the input group template.
         * \@memberof IgxDatePickerComponent
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          var _this147 = this;

          return {
            disabled: this.disabled,
            disabledDates: this.disabledDates,
            displayData: this.displayData,
            format: this.format,
            isSpinLoop: this.isSpinLoop,
            label: this.label,
            labelVisibility: this.labelVisibility,
            locale: this.locale,
            mask: this.mask,
            mode: this.mode,
            specialDates: this.specialDates,
            value: this.value,
            openDialog: function openDialog(target) {
              return _this147.openDialog(target);
            }
          };
        }
        /**
         * An \@Input property that gets/sets the selected date.
         * ```typescript
         * public date: Date = new Date();
         * ```
         * ```html
         * <igx-date-picker [value]="date"></igx-date-picker>
         * ```
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * @param {?} date
         * @return {?}
         */
        ,
        set: function set(date) {
          this._value = date;

          this._onChangeCallback(date);
        }
        /**
         * @deprecated Use 'onOpened' instead.
         * An event that is emitted when the `IgxDatePickerComponent` calendar is opened.
         * ```typescript
         * public open(event){
         *    alert("The date-picker calendar has been opened!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onOpen)="open($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         * @return {?}
         */

      }, {
        key: "onOpen",
        get: function get() {
          return this._onOpen;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._onOpen = val;
        }
        /**
         * @deprecated Use 'onClosed' instead.
         * "An event that is emitted when the `IgxDatePickerComponent` is closed.
         * ```typescript
         * public close(event){
         *    alert("The date-picker has been closed!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onClose)="close($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         * @return {?}
         */

      }, {
        key: "onClose",
        get: function get() {
          return this._onClose;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._onClose = val;
        }
      }]);

      return IgxDatePickerComponent;
    }();

    IgxDatePickerComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxDatePickerComponent,
          multi: true
        }],
        // tslint:disable-next-line:component-selector
        selector: 'igx-date-picker',
        template: "<ng-template #readOnlyDatePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <igx-prefix>\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input #readonlyInput class=\"igx-date-picker__input-date\" igxInput [value]=\"displayData || ''\"\n            [disabled]=\"disabled\" readonly />\n    </igx-input-group>\n</ng-template>\n\n<ng-template #editableDatePickerTemplate>\n    <igx-input-group #editableInputGroup [supressInputAutofocus]=\"true\">\n        <igx-prefix (click)=\"openDialog(editableInputGroup.element.nativeElement)\">\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input #editableInput class=\"igx-date-picker__input-date\" igxInput [igxTextSelection]=\"true\"\n            type=\"text\" [value]=\"transformedDate\"\n            [igxMask]=\"inputMask\" [placeholder]=\"mask\" [disabled]=\"disabled\" [displayValuePipe]=\"displayValuePipe\"\n            [focusedValuePipe]=\"inputValuePipe\" (blur)=\"onBlur($event)\" (wheel)=\"onWheel($event)\"\n            (input)=\"onInput($event)\" (focus)=\"onFocus()\" />\n        <igx-suffix *ngIf=\"!isEmpty\" (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
        styles: ["\n        :host {\n            display: block;\n        }\n    "]
      }]
    }];
    /** @nocollapse */

    IgxDatePickerComponent.ctorParameters = function () {
      return [{
        type: IgxOverlayService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxOverlayService]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleRef"]
      }];
    };

    IgxDatePickerComponent.propDecorators = {
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      labelVisibility: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      locale: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      weekStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      formatOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hideOutsideDays: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      monthsViewNumber: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      format: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      mask: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      formatViews: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabledDates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      specialDates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      modalOverlaySettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dropDownOverlaySettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      formatter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      vertical: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      todayButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cancelButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      mode: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isSpinLoop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      outlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onOpen: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onOpened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClose: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      valueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onDisabledDate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onValidationFailed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      readOnlyDatePickerTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['readOnlyDatePickerTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      editableDatePickerTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['editableDatePickerTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      inputGroup: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxInputGroupComponent, {
          "static": false
        }]
      }],
      editableInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['editableInput', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      readonlyInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['readonlyInput', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      input: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxInputDirective, {
          "static": false
        }]
      }],
      datePickerTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxDatePickerTemplateDirective, {
          read: IgxDatePickerTemplateDirective,
          "static": false
        }]
      }],
      headerTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxCalendarHeaderTemplateDirective, {
          read: IgxCalendarHeaderTemplateDirective,
          "static": false
        }]
      }],
      subheaderTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxCalendarSubheaderTemplateDirective, {
          read: IgxCalendarSubheaderTemplateDirective,
          "static": false
        }]
      }],
      datePickerActionsDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxDatePickerActionsDirective, {
          read: IgxDatePickerActionsDirective,
          "static": false
        }]
      }],
      onSpaceClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.spacebar', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.space', ['$event']]
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("'onOpen' @Output property is deprecated. Use 'onOpened' instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]])], IgxDatePickerComponent.prototype, "onOpen", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("'onClose' @Output property is deprecated. Use 'onClosed' instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]])], IgxDatePickerComponent.prototype, "onClose", null);
    /**
     * @hidden
     */

    var IgxDatePickerModule = function IgxDatePickerModule() {
      _classCallCheck(this, IgxDatePickerModule);
    };

    IgxDatePickerModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxDatePickerComponent, IgxCalendarContainerComponent, IgxDatePickerActionsDirective, IgxDatePickerTemplateDirective, DatePickerDisplayValuePipe, DatePickerInputValuePipe],
        exports: [IgxDatePickerComponent, IgxDatePickerTemplateDirective, IgxDatePickerActionsDirective, DatePickerDisplayValuePipe, DatePickerInputValuePipe],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxIconModule, IgxInputGroupModule, IgxCalendarModule, IgxButtonModule, IgxRippleModule, IgxMaskModule, IgxTextSelectionModule],
        entryComponents: [IgxCalendarContainerComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxDialogTitleDirective = function IgxDialogTitleDirective() {
      _classCallCheck(this, IgxDialogTitleDirective);

      this.defaultStyle = true;
    };

    IgxDialogTitleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'igx-dialog-title,[igxDialogTitle]'
      }]
    }];
    IgxDialogTitleDirective.propDecorators = {
      defaultStyle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-dialog__window-title']
      }]
    };
    /**
     * @hidden
     */

    var IgxDialogActionsDirective = function IgxDialogActionsDirective() {
      _classCallCheck(this, IgxDialogActionsDirective);

      this.defaultClass = true;
    };

    IgxDialogActionsDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: 'igx-dialog-actions,[igxDialogActions]'
      }]
    }];
    IgxDialogActionsDirective.propDecorators = {
      defaultClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-dialog__window-actions']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var DIALOG_ID = 0;
    /**
     * **Ignite UI for Angular Dialog Window** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/dialog.html)
     *
     * The Ignite UI Dialog Window presents a dialog window to the user which can simply display messages or display
     * more complicated visuals such as a user sign-in form.  It also provides a right and left button
     * which can be used for custom actions.
     *
     * Example:
     * ```html
     * <button (click)="form.open()">Show Dialog</button>
     * <igx-dialog #form title="Sign In" rightButtonLabel="OK">
     *   <div>
     *     <input type="text" igxInput/>
     *     <label igxLabel>Username</label>
     *   </div>
     *   <div>
     *     <input type="password" igxInput/>
     *     <label igxLabel>Password</label>
     *   </div>
     * </igx-dialog>
     * ```
     */

    var IgxDialogComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} navService
       */
      function IgxDialogComponent(elementRef, navService) {
        _classCallCheck(this, IgxDialogComponent);

        this.elementRef = elementRef;
        this.navService = navService;
        /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-dialog [id]="'igx-dialog-56'" #alert title="Notification" leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.id = "igx-dialog-".concat(DIALOG_ID++);
        /**
         * An \@Input property controlling the `title` of the dialog.
         * ```html
         * <igx-dialog title="Notification" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.title = '';
        /**
         *  An \@Input property controlling the `message` of the dialog.
         * ```html
         * <igx-dialog message="Your email was sent!" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.message = '';
        /**
         * An \@Input property to set the `label` of the left button of the dialog.
         * ```html
         * <igx-dialog leftButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.leftButtonLabel = '';
        /**
         * An \@Input property to set the left button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog leftButtonType="raised" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.leftButtonType = 'flat';
        /**
         * An \@Input property to set the left button color. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonColor="yellow" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.leftButtonColor = '';
        /**
         * An \@Input property to set the left button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonBackgroundColor="black" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.leftButtonBackgroundColor = '';
        /**
         * An \@Input property to set the left button `ripple`. The `ripple` animates a click/tap to a component as a series of fading waves.
         * The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonRipple="green" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.leftButtonRipple = '';
        /**
         * An \@Input property to set the `label` of the right button of the dialog.
         * ```html
         * <igx-dialog rightButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.rightButtonLabel = '';
        /**
         * An \@Input property to set the right button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog rightButtonType="fab" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.rightButtonType = 'flat';
        /**
         * An \@Input property to set the right button `color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonColor="yellow" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.rightButtonColor = '';
        /**
         * An \@Input property to set the right button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonBackgroundColor="black" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.rightButtonBackgroundColor = '';
        /**
         * An \@Input property to set the right button `ripple`.
         * ```html
         * <igx-dialog rightButtonRipple="green" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */

        this.rightButtonRipple = '';
        /**
         * An event that is emitted when the dialog is opened.
         * ```html
         * <igx-dialog (onOpen)="onDialogOpenHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */

        this.onOpen = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the dialog is closed.
         * ```html
         * <igx-dialog (onClose)="onDialogCloseHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */

        this.onClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the left button is clicked.
         * ```html
         * <igx-dialog (onLeftButtonSelect)="onDialogOKSelected($event)" #dialog leftButtonLabel="OK" rightButtonLabel="Cancel">
         * </igx-dialog>
         * ```
         */

        this.onLeftButtonSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the right button is clicked.
         * ```html
         * <igx-dialog (onRightButtonSelect)="onDialogOKSelected($event)"
         * #dialog title="Confirmation" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK"
         * rightButtonRipple="#4CAF50" closeOnOutsideSelect="true">
         * </igx-dialog>
         * ```
         */

        this.onRightButtonSelect = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._positionSettings = {
          openAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInBottom, {
            params: {
              fromPosition: 'translateY(100%)'
            }
          }),
          closeAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideOutTop, {
            params: {
              toPosition: 'translateY(-100%)'
            }
          })
        };
        this._closeOnOutsideSelect = false;
        this._isModal = true;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * The default `tabindex` attribute for the component
         *
         * @hidden
         */

        this.tabindex = -1;
        this._titleId = IgxDialogComponent.NEXT_ID++ + '_title';
        this._overlayDefaultSettings = {
          positionStrategy: new GlobalPositionStrategy(this._positionSettings),
          scrollStrategy: new NoOpScrollStrategy(),
          modal: this.isModal,
          closeOnOutsideClick: this.closeOnOutsideSelect
        };
      }
      /**
       * @return {?}
       */


      _createClass(IgxDialogComponent, [{
        key: "ngAfterContentInit",

        /**
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this148 = this;

          this.toggleRef.onClosing.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function () {
            return _this148.emitCloseFromDialog();
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "emitCloseFromDialog",
        value: function emitCloseFromDialog() {
          this.onClose.emit({
            dialog: this,
            event: null
          });
        }
        /**
         * A method that opens the dialog.
         * \@memberOf {\@link IgxDialogComponent}
         * ```html
         * <button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
         * <igx-dialog #dialog></igx-dialog>
         * ```
         * @param {?=} overlaySettings
         * @return {?}
         */

      }, {
        key: "open",
        value: function open() {
          var overlaySettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._overlayDefaultSettings;
          this.toggleRef.open(overlaySettings);
          this.onOpen.emit({
            dialog: this,
            event: null
          });

          if (!this.leftButtonLabel && !this.rightButtonLabel) {
            this.toggleRef.element.focus();
          }
        }
        /**
         * A method that that closes the dialog.
         * \@memberOf {\@link IgxDialogComponent}
         * ```html
         * <button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
         * <igx-dialog #dialog></igx-dialog>
         * ```
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          // `onClose` will emit from `toggleRef.onClosing` subscription
          this.toggleRef.close();
        }
        /**
         * A method that opens/closes the dialog.
         * \@memberOf {\@link IgxDialogComponent}
         * ```html
         * <button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
         * <igx-dialog #dialog></igx-dialog>
         * ```
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          this.isOpen ? this.close() : this.open();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDialogSelected",
        value: function onDialogSelected(event) {
          event.stopPropagation();

          if (this.isOpen && this.closeOnOutsideSelect && event.target.classList.contains(IgxDialogComponent.DIALOG_CLASS)) {
            this.close();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onInternalLeftButtonSelect",
        value: function onInternalLeftButtonSelect(event) {
          this.onLeftButtonSelect.emit({
            dialog: this,
            event: event
          });
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onInternalRightButtonSelect",
        value: function onInternalRightButtonSelect(event) {
          this.onRightButtonSelect.emit({
            dialog: this,
            event: event
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          if (this.navService && this.id) {
            this.navService.add(this.id, this);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.navService && this.id) {
            this.navService.remove(this.id);
          }
        }
      }, {
        key: "isModal",
        get: function get() {
          return this._isModal;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._overlayDefaultSettings.modal = val;
          this._isModal = val;
        }
        /**
         * An \@Input property that allows you to enable the "close on click outside the dialog". By default it's disabled.
         * ```html
         * <igx-dialog closeOnOutsideSelect="true" leftButtonLabel="Cancel" (onLeftButtonSelect)="dialog.close()"
         * rightButtonLabel="OK" rightButtonRipple="#4CAF50" (onRightButtonSelect)="onDialogOKSelected($event)">
         * </igx-dialog>
         * ```
         * @return {?}
         */

      }, {
        key: "closeOnOutsideSelect",
        get: function get() {
          return this._closeOnOutsideSelect;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._overlayDefaultSettings.closeOnOutsideClick = val;
          this._closeOnOutsideSelect = val;
        }
        /**
         * Get the position and animation settings used by the dialog.
         * ```typescript
         * \@ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
         * let currentPosition: PositionSettings = this.alert.positionSettings
         * ```
         * @return {?}
         */

      }, {
        key: "positionSettings",
        get: function get() {
          return this._positionSettings;
        }
        /**
         * Set the position and animation settings used by the dialog.
         * ```typescript
         * import { slideInLeft, slideOutRight } from 'igniteui-angular';
         * ...
         * \@ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
         *  public newPositionSettings: PositionSettings = {
         *      openAnimation: useAnimation(slideInTop, { params: { duration: '2000ms' } }),
         *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '2000ms'} }),
         *      horizontalDirection: HorizontalAlignment.Left,
         *      verticalDirection: VerticalAlignment.Middle,
         *      horizontalStartPoint: HorizontalAlignment.Left,
         *      verticalStartPoint: VerticalAlignment.Middle,
         *      minSize: { height: 100, width: 100 }
         *  };
         * this.alert.positionSettings = this.newPositionSettings;
         * ```
         * @param {?} settings
         * @return {?}
         */
        ,
        set: function set(settings) {
          this._positionSettings = settings;
          this._overlayDefaultSettings.positionStrategy = new GlobalPositionStrategy(this._positionSettings);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "element",
        get: function get() {
          return this.elementRef.nativeElement;
        }
        /**
         * Returns the value of state. Possible state values are "open" or "close".
         * ```typescript
         * \@ViewChild("MyDialog")
         * public dialog: IgxDialogComponent;
         * ngAfterViewInit() {
         *    let dialogState = this.dialog.state;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "state",
        get: function get() {
          return this.isOpen ? 'open' : 'close';
        }
        /**
         * Returns whether the dialog is visible to the end user.
         * ```typescript
         * \@ViewChild("MyDialog")
         * public dialog: IgxDialogComponent;
         * ngAfterViewInit() {
         *    let dialogOpen = this.dialog.isOpen;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "isOpen",
        get: function get() {
          return !this.toggleRef.collapsed;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isCollapsed",
        get: function get() {
          return this.toggleRef.collapsed;
        }
        /**
         * Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.
         * ```typescript
         * \@ViewChild("MyDialog")
         * public dialog: IgxDialogComponent;
         * ngAfterViewInit() {
         *    let dialogRole = this.dialog.role;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "role",
        get: function get() {
          if (this.leftButtonLabel !== '' && this.rightButtonLabel !== '') {
            return 'dialog';
          } else if (this.leftButtonLabel !== '' || this.rightButtonLabel !== '') {
            return 'alertdialog';
          } else {
            return 'alert';
          }
        }
        /**
         * Returns the value of the title id.
         * ```typescript
         * \@ViewChild("MyDialog")
         * public dialog: IgxDialogComponent;
         * ngAfterViewInit() {
         *    let dialogTitle = this.dialog.titleId;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "titleId",
        get: function get() {
          return this._titleId;
        }
      }]);

      return IgxDialogComponent;
    }();

    IgxDialogComponent.NEXT_ID = 1;
    IgxDialogComponent.DIALOG_CLASS = 'igx-dialog';
    IgxDialogComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-dialog',
        template: "<div tabindex=\"0\" #dialog class=\"igx-dialog\" igxToggle (click)=\"onDialogSelected($event)\">\n    <div #dialogWindow class=\"igx-dialog__window\"  [attr.role]=\"role\" [attr.aria-labelledby]=\"titleId\">\n\n        <div *ngIf=\"title\" [attr.id]=\"titleId\" class=\"igx-dialog__window-title\">\n            {{ title }}\n        </div>\n        <ng-content *ngIf=\"!title\" select=\"igx-dialog-title,[igxDialogTitle]\"></ng-content>\n\n        <div class=\"igx-dialog__window-content\" *ngIf=\"message\">{{ message }}</div>\n        <ng-content *ngIf=\"!message\"></ng-content>\n\n        <div *ngIf=\"leftButtonLabel || rightButtonLabel\" class=\"igx-dialog__window-actions\">\n            <button *ngIf=\"leftButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ leftButtonType }}\" igxButtonColor=\"{{ leftButtonColor }}\" igxButtonBackground=\"{{ leftButtonBackgroundColor }}\"\n                igxRipple=\"{{ leftButtonRipple }}\" (click)=\"onInternalLeftButtonSelect($event)\">\n                {{ leftButtonLabel }}\n            </button>\n            <button *ngIf=\"rightButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ rightButtonType }}\" igxButtonColor=\"{{ rightButtonColor }}\" igxButtonBackground=\"{{ rightButtonBackgroundColor }}\"\n                igxRipple=\"{{ rightButtonRipple }}\" (click)=\"onInternalRightButtonSelect($event)\">\n                {{ rightButtonLabel }}\n            </button>\n        </div>\n        <ng-content *ngIf=\"!leftButtonLabel && !rightButtonLabel\" select=\"igx-dialog-actions,[igxDialogActions]\"></ng-content>\n\n    </div>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxDialogComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: IgxNavigationService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    IgxDialogComponent.propDecorators = {
      toggleRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxToggleDirective, {
          "static": true
        }]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isModal: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      title: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      message: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      leftButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      leftButtonType: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      leftButtonColor: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      leftButtonBackgroundColor: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      leftButtonRipple: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rightButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rightButtonType: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rightButtonColor: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rightButtonBackgroundColor: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rightButtonRipple: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      closeOnOutsideSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      positionSettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onOpen: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClose: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onLeftButtonSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRightButtonSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      isOpen: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isCollapsed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-dialog--hidden']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      titleId: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @hidden
     */

    var IgxDialogModule = function IgxDialogModule() {
      _classCallCheck(this, IgxDialogModule);
    };

    IgxDialogModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
        exports: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO: Refactor - export in a separate file

    var IgxRow =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} id
       * @param {?} index
       * @param {?} data
       */
      function IgxRow(id, index, data) {
        _classCallCheck(this, IgxRow);

        this.id = id;
        this.index = index;
        this.data = data;
      }
      /**
       * @return {?}
       */


      _createClass(IgxRow, [{
        key: "createEditEventArgs",
        value: function createEditEventArgs() {
          return {
            rowID: this.id,
            oldValue: Object.assign({}, this.data),
            newValue: this.newData,
            cancel: false
          };
        }
      }]);

      return IgxRow;
    }();

    var IgxCell =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} id
       * @param {?} rowIndex
       * @param {?} column
       * @param {?} value
       * @param {?} editValue
       * @param {?} rowData
       */
      function IgxCell(id, rowIndex, column, value, editValue, rowData) {
        _classCallCheck(this, IgxCell);

        this.id = id;
        this.rowIndex = rowIndex;
        this.column = column;
        this.value = value;
        this.editValue = editValue;
        this.rowData = rowData;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(IgxCell, [{
        key: "castToNumber",
        value: function castToNumber(value) {
          if (this.column.dataType === 'number' && !this.column.inlineEditorTemplate) {
            /** @type {?} */
            var v = parseFloat(value);
            return !isNaN(v) && isFinite(v) ? v : 0;
          }

          return value;
        }
        /**
         * @return {?}
         */

      }, {
        key: "createEditEventArgs",
        value: function createEditEventArgs() {
          return {
            rowID: this.id.rowID,
            cellID: this.id,
            oldValue: this.value,
            newValue: this.editValue,
            cancel: false
          };
        }
      }]);

      return IgxCell;
    }();

    var IgxGridCRUDService =
    /*#__PURE__*/
    function () {
      function IgxGridCRUDService() {
        _classCallCheck(this, IgxGridCRUDService);

        this.cell = null;
        this.row = null;
      }
      /**
       * @param {?} cell
       * @return {?}
       */


      _createClass(IgxGridCRUDService, [{
        key: "createCell",
        value: function createCell(cell) {
          return new IgxCell(cell.cellID, cell.rowIndex, cell.column, cell.value, cell.value, cell.row.rowData);
        }
        /**
         * @param {?} cell
         * @return {?}
         */

      }, {
        key: "createRow",
        value: function createRow(cell) {
          return new IgxRow(cell.id.rowID, cell.rowIndex, cell.rowData);
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "sameRow",
        value: function sameRow(rowID) {
          return this.row && this.row.id === rowID;
        }
        /**
         * @param {?} cell
         * @return {?}
         */

      }, {
        key: "sameCell",
        value: function sameCell(cell) {
          return this.cell.id.rowID === cell.id.rowID && this.cell.id.columnID === cell.id.columnID;
        }
        /**
         * @return {?}
         */

      }, {
        key: "beginRowEdit",

        /**
         * @return {?}
         */
        value: function beginRowEdit() {
          if (this.grid.rowEditable && (this.grid.primaryKey === undefined || this.grid.primaryKey === null)) {
            console.warn('The grid must have a `primaryKey` specified when using `rowEditable`!');
          }

          this.row = this.createRow(this.cell);
          /** @type {?} */

          var args = {
            rowID: this.row.id,
            oldValue: this.row.data,
            cancel: false
          };
          this.grid.onRowEditEnter.emit(args);

          if (args.cancel) {
            this.endRowEdit();
            return;
          }

          this.row.transactionState = this.grid.transactions.getAggregatedValue(this.row.id, true);
          this.grid.transactions.startPending();
          this.grid.openRowOverlay(this.row.id);
        }
        /**
         * @return {?}
         */

      }, {
        key: "endRowEdit",
        value: function endRowEdit() {
          this.row = null;
        }
        /**
         * @param {?} cell
         * @return {?}
         */

      }, {
        key: "begin",
        value: function begin(cell) {
          /** @type {?} */
          var newCell = this.createCell(cell);
          newCell.primaryKey = this.primaryKey;
          /** @type {?} */

          var args = {
            cellID: newCell.id,
            rowID: newCell.id.rowID,
            oldValue: newCell.value,
            cancel: false
          };
          this.grid.onCellEditEnter.emit(args);

          if (args.cancel) {
            this.end();
            return;
          }

          if (this.rowEditing) {
            if (this.row && !this.sameRow(newCell.id.rowID)) {
              this.grid.endEdit(true);
              this.cell = newCell;
              this.beginRowEdit();
              return;
            }

            this.cell = newCell;

            if (!this.row) {
              this.beginRowEdit();
              return;
            }
          } else {
            this.cell = newCell;
            this.endRowEdit();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "end",
        value: function end() {
          this.cell = null;
        }
        /**
         * @param {?} rowIndex
         * @param {?} columnIndex
         * @return {?}
         */

      }, {
        key: "isInEditMode",
        value: function isInEditMode(rowIndex, columnIndex) {
          if (!this.cell) {
            return false;
          }

          return this.cell.column.index === columnIndex && this.cell.rowIndex === rowIndex;
        }
      }, {
        key: "inEditMode",
        get: function get() {
          return !!this.cell;
        }
        /**
         * @return {?}
         */

      }, {
        key: "rowEditing",
        get: function get() {
          return this.grid.rowEditable;
        }
        /**
         * @return {?}
         */

      }, {
        key: "primaryKey",
        get: function get() {
          return this.grid.primaryKey;
        }
      }]);

      return IgxGridCRUDService;
    }();

    IgxGridCRUDService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];

    var IgxGridSelectionService =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} zone
       */
      function IgxGridSelectionService(zone) {
        _classCallCheck(this, IgxGridSelectionService);

        this.zone = zone;
        this.dragMode = false;
        this.keyboardState =
        /** @type {?} */
        {};
        this.pointerState =
        /** @type {?} */
        {};
        this.selection = new Map();
        this.temp = new Map();
        this._ranges = new Set();
        this.rowSelection = new Set();
        this.initPointerState();
        this.initKeyboardState();
      }
      /**
       * Returns the current selected ranges in the grid from both
       * keyboard and pointer interactions
       * @return {?}
       */


      _createClass(IgxGridSelectionService, [{
        key: "initKeyboardState",

        /**
         * Resets the keyboard state
         * @return {?}
         */
        value: function initKeyboardState() {
          this.keyboardState.node = null;
          this.keyboardState.shift = false;
          this.keyboardState.range = null;
          this.keyboardState.active = false;
        }
        /**
         * Resets the pointer state
         * @return {?}
         */

      }, {
        key: "initPointerState",
        value: function initPointerState() {
          this.pointerState.node = null;
          this.pointerState.ctrl = false;
          this.pointerState.shift = false;
          this.pointerState.range = null;
          this.pointerState.primaryButton = true;
        }
        /**
         * Adds a single node.
         * Single clicks | Ctrl + single clicks on cells is the usual case.
         * @param {?} node
         * @param {?=} addToRange
         * @return {?}
         */

      }, {
        key: "add",
        value: function add(node) {
          var addToRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          this.selection.has(node.row) ? this.selection.get(node.row).add(node.column) : this.selection.set(node.row, new Set()).get(node.row).add(node.column);

          if (addToRange) {
            this._ranges.add(JSON.stringify(this.generateRange(node)));
          }
        }
        /**
         * Adds the active keyboard range selection (if any) to the `ranges` meta.
         * @return {?}
         */

      }, {
        key: "addKeyboardRange",
        value: function addKeyboardRange() {
          if (this.keyboardState.range) {
            this._ranges.add(JSON.stringify(this.keyboardState.range));
          }
        }
        /**
         * @param {?} node
         * @return {?}
         */

      }, {
        key: "remove",
        value: function remove(node) {
          if (this.selection.has(node.row)) {
            this.selection.get(node.row)["delete"](node.column);
          }

          if (this.isActiveNode(node)) {
            this.activeElement = null;
          }

          this._ranges["delete"](JSON.stringify(this.generateRange(node)));
        }
        /**
         * @param {?} node
         * @return {?}
         */

      }, {
        key: "isInMap",
        value: function isInMap(node) {
          return this.selection.has(node.row) && this.selection.get(node.row).has(node.column) || this.temp.has(node.row) && this.temp.get(node.row).has(node.column);
        }
        /**
         * @param {?} node
         * @return {?}
         */

      }, {
        key: "selected",
        value: function selected(node) {
          return this.isActiveNode(node) && this.grid.isCellSelectable || this.isInMap(node);
        }
        /**
         * @param {?} node
         * @return {?}
         */

      }, {
        key: "isActiveNode",
        value: function isActiveNode(node) {
          if (this.activeElement) {
            /** @type {?} */
            var isActive = this.activeElement.column === node.column && this.activeElement.row === node.row;

            if (this.grid.hasColumnLayouts) {
              /** @type {?} */
              var layout = this.activeElement.layout;
              return isActive && this.isActiveLayout(layout, node.layout);
            }

            return isActive;
          }

          return false;
        }
        /**
         * @param {?} current
         * @param {?} target
         * @return {?}
         */

      }, {
        key: "isActiveLayout",
        value: function isActiveLayout(current, target) {
          return current.columnVisibleIndex === target.columnVisibleIndex;
        }
        /**
         * @param {?} node
         * @param {?=} state
         * @return {?}
         */

      }, {
        key: "addRangeMeta",
        value: function addRangeMeta(node, state) {
          this._ranges.add(JSON.stringify(this.generateRange(node, state)));
        }
        /**
         * @param {?} node
         * @param {?=} state
         * @return {?}
         */

      }, {
        key: "removeRangeMeta",
        value: function removeRangeMeta(node, state) {
          this._ranges["delete"](JSON.stringify(this.generateRange(node, state)));
        }
        /**
         * Generates a new selection range from the given `node`.
         * If `state` is passed instead it will generate the range based on the passed `node`
         * and the start node of the `state`.
         * @param {?} node
         * @param {?=} state
         * @return {?}
         */

      }, {
        key: "generateRange",
        value: function generateRange(node, state) {
          if (!state) {
            return {
              rowStart: node.row,
              rowEnd: node.row,
              columnStart: node.column,
              columnEnd: node.column
            };
          }

          var _state$node = state.node,
              row = _state$node.row,
              column = _state$node.column;
          /** @type {?} */

          var rowStart = Math.min(node.row, row);
          /** @type {?} */

          var rowEnd = Math.max(node.row, row);
          /** @type {?} */

          var columnStart = Math.min(node.column, column);
          /** @type {?} */

          var columnEnd = Math.max(node.column, column);
          return {
            rowStart: rowStart,
            rowEnd: rowEnd,
            columnStart: columnStart,
            columnEnd: columnEnd
          };
        }
        /**
         *
         * @param {?} node
         * @param {?} shift
         * @param {?} shiftTab
         * @return {?}
         */

      }, {
        key: "keyboardStateOnKeydown",
        value: function keyboardStateOnKeydown(node, shift, shiftTab) {
          this.keyboardState.active = true;
          this.initPointerState();
          this.keyboardState.shift = shift && !shiftTab; // Kb navigation with shift and no previous node.
          // Clear the current selection init the start node.

          if (this.keyboardState.shift && !this.keyboardState.node) {
            this.clear();
            this.keyboardState.node = node;
          }
        }
        /**
         * @param {?} node
         * @param {?} emitter
         * @param {?} dom
         * @return {?}
         */

      }, {
        key: "keyboardStateOnFocus",
        value: function keyboardStateOnFocus(node, emitter, dom) {
          /** @type {?} */
          var kbState = this.keyboardState; // Focus triggered by keyboard navigation

          if (kbState.active) {
            if (isChromium()) {
              this._moveSelectionChrome(dom);
            } // Start generating a range if shift is hold


            if (kbState.shift) {
              this.dragSelect(node, kbState);
              kbState.range = this.generateRange(node, kbState);
              emitter.emit(this.generateRange(node, kbState));
              return;
            }

            this.initKeyboardState();
            this.clear();
            this.add(node);
          }
        }
        /**
         * @param {?} node
         * @param {?} shift
         * @param {?} ctrl
         * @return {?}
         */

      }, {
        key: "pointerDown",
        value: function pointerDown(node, shift, ctrl) {
          this.addKeyboardRange();
          this.initKeyboardState();
          this.pointerState.ctrl = ctrl;
          this.pointerState.shift = shift; // No ctrl key pressed - no multiple selection

          if (!ctrl) {
            this.clear();
          }

          if (shift) {
            // No previously 'clicked' node. Use the last active node.
            if (!this.pointerState.node) {
              this.pointerState.node = this.activeElement || node;
            }

            this.pointerDownShiftKey(node);
            this.clearTextSelection();
            return;
          }

          this.removeRangeMeta(node);
          this.pointerState.node = node;
        }
        /**
         * @param {?} node
         * @return {?}
         */

      }, {
        key: "pointerDownShiftKey",
        value: function pointerDownShiftKey(node) {
          this.clear();
          this.selectRange(node, this.pointerState);
        }
        /**
         * @param {?} target
         * @param {?} source
         * @return {?}
         */

      }, {
        key: "mergeMap",
        value: function mergeMap(target, source) {
          /** @type {?} */
          var iterator = source.entries();
          /** @type {?} */

          var pair = iterator.next();
          /** @type {?} */

          var key;
          /** @type {?} */

          var value;

          while (!pair.done) {
            var _pair$value = _slicedToArray(pair.value, 2);

            key = _pair$value[0];
            value = _pair$value[1];

            if (target.has(key)) {
              (function () {
                /** @type {?} */
                var newValue = target.get(key);
                value.forEach(function (record) {
                  return newValue.add(record);
                });
                target.set(key, newValue);
              })();
            } else {
              target.set(key, value);
            }

            pair = iterator.next();
          }
        }
        /**
         * @param {?} node
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "pointerEnter",
        value: function pointerEnter(node, event) {
          // https://www.w3.org/TR/pointerevents/#the-button-property
          this.dragMode = event.buttons === 1 && event.button === -1;

          if (!this.dragMode) {
            return false;
          }

          this.clearTextSelection(); // If the users triggers a drag-like event by first clicking outside the grid cells
          // and then enters in the grid body we may not have a initial pointer starting node.
          // Assume the first pointerenter node is where we start.

          if (!this.pointerState.node) {
            this.pointerState.node = node;
          }

          this.pointerState.ctrl ? this.selectRange(node, this.pointerState, this.temp) : this.dragSelect(node, this.pointerState);
          return true;
        }
        /**
         * @param {?} node
         * @param {?} emitter
         * @return {?}
         */

      }, {
        key: "pointerUp",
        value: function pointerUp(node, emitter) {
          var _this149 = this;

          if (this.dragMode) {
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            this.mergeMap(this.selection, this.temp);
            this.zone.runTask(function () {
              return emitter.emit(_this149.generateRange(node, _this149.pointerState));
            });
            this.temp.clear();
            this.dragMode = false;
            return true;
          }

          if (this.pointerState.shift) {
            this.clearTextSelection();
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            emitter.emit(this.generateRange(node, this.pointerState));
            return true;
          }

          this.add(node);
          return false;
        }
        /**
         * @param {?} node
         * @param {?} state
         * @param {?=} collection
         * @return {?}
         */

      }, {
        key: "selectRange",
        value: function selectRange(node, state) {
          var collection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.selection;

          if (collection === this.temp) {
            collection.clear();
          }

          var _this$generateRange = this.generateRange(node, state),
              rowStart = _this$generateRange.rowStart,
              rowEnd = _this$generateRange.rowEnd,
              columnStart = _this$generateRange.columnStart,
              columnEnd = _this$generateRange.columnEnd;

          for (var i = rowStart; i <= rowEnd; i++) {
            for (var j =
            /** @type {?} */
            columnStart; j <= columnEnd; j++) {
              collection.has(i) ? collection.get(i).add(j) : collection.set(i, new Set()).get(i).add(j);
            }
          }
        }
        /**
         * @param {?} node
         * @param {?} state
         * @return {?}
         */

      }, {
        key: "dragSelect",
        value: function dragSelect(node, state) {
          if (!this.pointerState.ctrl) {
            this.selection.clear();
          }

          this.selectRange(node, state);
        }
        /**
         * @param {?=} clearAcriveEl
         * @return {?}
         */

      }, {
        key: "clear",
        value: function clear() {
          var clearAcriveEl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (clearAcriveEl) {
            this.activeElement = null;
          }

          this.selection.clear();
          this.temp.clear();

          this._ranges.clear();
        }
        /**
         * @return {?}
         */

      }, {
        key: "clearTextSelection",
        value: function clearTextSelection() {
          /** @type {?} */
          var selection = window.getSelection();

          if (selection.rangeCount) {
            this._selectionRange = selection.getRangeAt(0);

            this._selectionRange.collapse(true);

            selection.removeAllRanges();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "restoreTextSelection",
        value: function restoreTextSelection() {
          /** @type {?} */
          var selection = window.getSelection();

          if (!selection.rangeCount) {
            selection.addRange(this._selectionRange || document.createRange());
          }
        }
        /**
         * (╯°□°）╯︵ ┻━┻
         * Chrome and Chromium don't care about the active
         * range after keyboard navigation, thus this.
         * @param {?} node
         * @return {?}
         */

      }, {
        key: "_moveSelectionChrome",
        value: function _moveSelectionChrome(node) {
          /** @type {?} */
          var selection = window.getSelection();
          selection.removeAllRanges();
          /** @type {?} */

          var range = new Range();
          range.selectNode(node);
          range.collapse(true);
          selection.addRange(range);
        }
        /**
         * Returns array of the selected row id's.
         * @return {?}
         */

      }, {
        key: "getSelectedRows",
        value: function getSelectedRows() {
          return this.rowSelection.size ? Array.from(this.rowSelection.keys()) : [];
        }
        /**
         * Clears row selection, if filtering is applied clears only selected rows from filtered data.
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "clearRowSelection",
        value: function clearRowSelection(event) {
          var _this150 = this;

          /** @type {?} */
          var removedRec = this.isFilteringApplied() ? this.getRowIDs(this.allData).filter(function (rID) {
            return _this150.isRowSelected(rID);
          }) : this.getSelectedRows();
          /** @type {?} */

          var newSelection = this.isFilteringApplied() ? this.getSelectedRows().filter(function (x) {
            return !removedRec.includes(x);
          }) : [];
          this.emitRowSelectionEvent(newSelection, [], removedRec, event);
        }
        /**
         * Select all rows, if filtering is applied select only from filtered data.
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "selectAllRows",
        value: function selectAllRows(event) {
          var _this151 = this;

          /** @type {?} */
          var allRowIDs = this.getRowIDs(this.allData);
          /** @type {?} */

          var addedRows = allRowIDs.filter(function (rID) {
            return !_this151.isRowSelected(rID);
          });
          /** @type {?} */

          var newSelection = this.rowSelection.size ? this.getSelectedRows().concat(addedRows) : addedRows;
          this.emitRowSelectionEvent(newSelection, addedRows, [], event);
        }
        /**
         * Select the specified row and emit event.
         * @param {?} rowID
         * @param {?=} clearPrevSelection
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "selectRowById",
        value: function selectRowById(rowID, clearPrevSelection, event) {
          if (!this.grid.isRowSelectable || this.isRowDeleted(rowID)) {
            return;
          }

          clearPrevSelection = !this.grid.isMultiRowSelectionEnabled || clearPrevSelection;
          /** @type {?} */

          var newSelection = clearPrevSelection ? [rowID] : this.getSelectedRows().indexOf(rowID) !== -1 ? this.getSelectedRows() : [].concat(_toConsumableArray(this.getSelectedRows()), [rowID]);
          /** @type {?} */

          var removed = clearPrevSelection ? this.getSelectedRows() : [];
          this.emitRowSelectionEvent(newSelection, [rowID], removed, event);
        }
        /**
         * Deselect the specified row and emit event.
         * @param {?} rowID
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "deselectRow",
        value: function deselectRow(rowID, event) {
          if (!this.isRowSelected(rowID)) {
            return;
          }
          /** @type {?} */


          var newSelection = this.getSelectedRows().filter(function (r) {
            return r !== rowID;
          });

          if (this.rowSelection.size && this.rowSelection.has(rowID)) {
            this.emitRowSelectionEvent(newSelection, [], [rowID], event);
          }
        }
        /**
         * Select specified rows. No event is emitted.
         * @param {?} rowIDs
         * @param {?=} clearPrevSelection
         * @return {?}
         */

      }, {
        key: "selectRowsWithNoEvent",
        value: function selectRowsWithNoEvent(rowIDs, clearPrevSelection) {
          var _this152 = this;

          if (clearPrevSelection) {
            this.rowSelection.clear();
          }

          rowIDs.forEach(function (rowID) {
            _this152.rowSelection.add(rowID);
          });
          this.allRowsSelected = undefined;
        }
        /**
         * Deselect specified rows. No event is emitted.
         * @param {?} rowIDs
         * @return {?}
         */

      }, {
        key: "deselectRowsWithNoEvent",
        value: function deselectRowsWithNoEvent(rowIDs) {
          var _this153 = this;

          rowIDs.forEach(function (rowID) {
            return _this153.rowSelection["delete"](rowID);
          });
          this.allRowsSelected = undefined;
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "isRowSelected",
        value: function isRowSelected(rowID) {
          return this.rowSelection.size > 0 && this.rowSelection.has(rowID);
        }
        /**
         * Select range from last selected row to the current specified row.
         * @param {?} rowID
         * @param {?} rowData
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "selectMultipleRows",
        value: function selectMultipleRows(rowID, rowData, event) {
          var _this154 = this;

          this.allRowsSelected = undefined;

          if (!this.rowSelection.size || this.isRowDeleted(rowID)) {
            this.selectRowById(rowID);
            return;
          }
          /** @type {?} */


          var gridData = this.allData;
          /** @type {?} */

          var lastRowID = this.getSelectedRows()[this.rowSelection.size - 1];
          /** @type {?} */

          var currIndex = gridData.indexOf(this.getRowDataById(lastRowID));
          /** @type {?} */

          var newIndex = gridData.indexOf(rowData);
          /** @type {?} */

          var rows = gridData.slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1);
          /** @type {?} */

          var added = this.getRowIDs(rows).filter(function (rID) {
            return !_this154.isRowSelected(rID);
          });
          /** @type {?} */

          var newSelection = this.getSelectedRows().concat(added);
          this.emitRowSelectionEvent(newSelection, added, [], event);
        }
        /**
         * @return {?}
         */

      }, {
        key: "areAllRowSelected",
        value: function areAllRowSelected() {
          if (!this.grid.data) {
            return false;
          }

          if (this.allRowsSelected !== undefined) {
            return this.allRowsSelected;
          }
          /** @type {?} */


          var dataItemsID = this.getRowIDs(this.allData);
          return this.allRowsSelected = Math.min(this.rowSelection.size, dataItemsID.length) > 0 && new Set(Array.from(this.rowSelection.values()).concat(dataItemsID)).size === this.rowSelection.size;
        }
        /**
         * @return {?}
         */

      }, {
        key: "hasSomeRowSelected",
        value: function hasSomeRowSelected() {
          var _this155 = this;

          /** @type {?} */
          var filteredData = this.isFilteringApplied() ? this.getRowIDs(this.grid.filteredData).some(function (rID) {
            return _this155.isRowSelected(rID);
          }) : true;
          return this.rowSelection.size > 0 && filteredData && !this.areAllRowSelected();
        }
        /**
         * @return {?}
         */

      }, {
        key: "emitRowSelectionEvent",

        /**
         * @param {?} newSelection
         * @param {?} added
         * @param {?} removed
         * @param {?=} event
         * @return {?}
         */
        value: function emitRowSelectionEvent(newSelection, added, removed, event) {
          /** @type {?} */
          var currSelection = this.getSelectedRows();

          if (this.areEqualCollections(currSelection, newSelection)) {
            return;
          }
          /** @type {?} */


          var args = {
            oldSelection: currSelection,
            newSelection: newSelection,
            added: added,
            removed: removed,
            event: event,
            cancel: false
          };
          this.grid.onRowSelectionChange.emit(args);

          if (args.cancel) {
            return;
          }

          this.selectRowsWithNoEvent(args.newSelection, true);
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "getRowDataById",
        value: function getRowDataById(rowID) {
          if (!this.grid.primaryKey) {
            return rowID;
          }
          /** @type {?} */


          var rowIndex = this.getRowIDs(this.grid.gridAPI.get_all_data(true)).indexOf(rowID);
          return rowIndex < 0 ? {} : this.grid.gridAPI.get_all_data(true)[rowIndex];
        }
        /**
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "getRowIDs",
        value: function getRowIDs(data) {
          var _this156 = this;

          return this.grid.primaryKey && data.length ? data.map(function (rec) {
            return rec[_this156.grid.primaryKey];
          }) : data;
        }
        /**
         * @return {?}
         */

      }, {
        key: "clearHeaderCBState",
        value: function clearHeaderCBState() {
          this.allRowsSelected = undefined;
        }
        /**
         * Clear rowSelection and update checkbox state
         * @return {?}
         */

      }, {
        key: "clearAllSelectedRows",
        value: function clearAllSelectedRows() {
          this.rowSelection.clear();
          this.clearHeaderCBState();
        }
        /**
         * Returns all data in the grid, with applied filtering and sorting and without deleted rows.
         * @return {?}
         */

      }, {
        key: "areEqualCollections",

        /**
         * @private
         * @param {?} first
         * @param {?} second
         * @return {?}
         */
        value: function areEqualCollections(first, second) {
          return first.length === second.length && new Set(first.concat(second)).size === first.length;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "isFilteringApplied",
        value: function isFilteringApplied() {
          /** @type {?} */
          var grid =
          /** @type {?} */
          this.grid;
          return !FilteringExpressionsTree.empty(grid.filteringExpressionsTree) || !FilteringExpressionsTree.empty(grid.advancedFilteringExpressionsTree);
        }
        /**
         * @private
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "isRowDeleted",
        value: function isRowDeleted(rowID) {
          return this.grid.gridAPI.row_deleted_transaction(rowID);
        }
      }, {
        key: "ranges",
        get: function get() {
          // The last action was keyboard + shift selection -> add it
          this.addKeyboardRange();
          /** @type {?} */

          var ranges = Array.from(this._ranges).map(function (range) {
            return JSON.parse(range);
          }); // No ranges but we have a focused cell -> add it

          if (!ranges.length && this.activeElement && this.grid.isCellSelectable) {
            ranges.push(this.generateRange(this.activeElement));
          }

          return ranges;
        }
        /**
         * @return {?}
         */

      }, {
        key: "primaryButton",
        get: function get() {
          return this.pointerState.primaryButton;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.pointerState.primaryButton = value;
        }
      }, {
        key: "filteredSelectedRowIds",
        get: function get() {
          var _this157 = this;

          return this.isFilteringApplied() ? this.getRowIDs(this.allData).filter(function (rowID) {
            return _this157.isRowSelected(rowID);
          }) : this.getSelectedRows().filter(function (rowID) {
            return !_this157.isRowDeleted(rowID);
          });
        }
      }, {
        key: "allData",
        get: function get() {
          var _this158 = this;

          /** @type {?} */
          var allData = this.isFilteringApplied() || this.grid.sortingExpressions.length ? this.grid.filteredSortedData : this.grid.gridAPI.get_all_data(true);
          return allData.filter(function (rData) {
            return !_this158.isRowDeleted(_this158.grid.gridAPI.get_row_id(rData));
          });
        }
      }]);

      return IgxGridSelectionService;
    }();

    IgxGridSelectionService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /** @nocollapse */

    IgxGridSelectionService.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };
    /**
     * @return {?}
     */


    function isChromium() {
      return (/Chrom|e?ium/g.test(navigator.userAgent) || /Google Inc/g.test(navigator.vendor)) && !/Edge/g.test(navigator.userAgent);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var EVENT_SUFFIX = 'precise';
    /**
     * Touch gestures manager based on Hammer.js
     * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
     * @hidden
     */

    var HammerGesturesManager =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _zone
       * @param {?} doc
       * @param {?} platformUtil
       */
      function HammerGesturesManager(_zone, doc, platformUtil) {
        _classCallCheck(this, HammerGesturesManager);

        this._zone = _zone;
        this.doc = doc;
        this.platformUtil = platformUtil;
        /**
         * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
         */

        this.hammerOptions = {};
        this._hammerManagers = [];
        this.platformBrowser = this.platformUtil.isBrowser;

        if (this.platformBrowser) {
          this.hammerOptions = {
            // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
            // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
            inputClass: Hammer.TouchInput,
            recognizers: [[Hammer.Pan, {
              threshold: 0
            }], [Hammer.Swipe, {
              direction: Hammer.DIRECTION_HORIZONTAL
            }], [Hammer.Tap], [Hammer.Tap, {
              event: 'doubletap',
              taps: 2
            }, ['tap']]]
          };
        }
      }
      /**
       * @param {?} eventName
       * @return {?}
       */


      _createClass(HammerGesturesManager, [{
        key: "supports",
        value: function supports(eventName) {
          return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
        }
        /**
         * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
         * Modeling after other event plugins for easy future modifications.
         * @param {?} element
         * @param {?} eventName
         * @param {?} eventHandler
         * @param {?=} options
         * @return {?}
         */

      }, {
        key: "addEventListener",
        value: function addEventListener(element, eventName, eventHandler) {
          var _this159 = this;

          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

          if (!this.platformBrowser) {
            return;
          } // Creating the manager bind events, must be done outside of angular


          return this._zone.runOutsideAngular(function () {
            /** @type {?} */
            var mc = _this159.getManagerForElement(element);

            if (mc === null) {
              // new Hammer is a shortcut for Manager with defaults
              mc = new Hammer(element, Object.assign(_this159.hammerOptions, options));

              _this159.addManagerForElement(element, mc);
            }
            /** @type {?} */


            var handler = function handler(eventObj) {
              _this159._zone.run(function () {
                eventHandler(eventObj);
              });
            };

            mc.on(eventName, handler);
            return function () {
              mc.off(eventName, handler);
            };
          });
        }
        /**
         * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
         * Modeling after other event plugins for easy future modifications.
         *
         * @param {?} target Can be one of either window, body or document(fallback default).
         * @param {?} eventName
         * @param {?} eventHandler
         * @return {?}
         */

      }, {
        key: "addGlobalEventListener",
        value: function addGlobalEventListener(target, eventName, eventHandler) {
          if (!this.platformBrowser) {
            return;
          }
          /** @type {?} */


          var element = this.getGlobalEventTarget(target); // Creating the manager bind events, must be done outside of angular

          return this.addEventListener(
          /** @type {?} */
          element, eventName, eventHandler);
        }
        /**
         * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
         * Supported: window, document, body. Defaults to document for invalid args.
         * @param {?} target Target name
         * @return {?}
         */

      }, {
        key: "getGlobalEventTarget",
        value: function getGlobalEventTarget(target) {
          return Object(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["ɵgetDOM"])().getGlobalEventTarget(this.doc, target);
        }
        /**
         * Set HammerManager options.
         *
         * @param {?} element The DOM element used to create the manager on.
         *
         * ### Example
         *
         * ```ts
         * manager.setManagerOption(myElem, "pan", { pointers: 1 });
         * ```
         * @param {?} event
         * @param {?} options
         * @return {?}
         */

      }, {
        key: "setManagerOption",
        value: function setManagerOption(element, event, options) {
          /** @type {?} */
          var manager = this.getManagerForElement(element);
          manager.get(event).set(options);
        }
        /**
         * Add an element and manager map to the internal collection.
         *
         * @param {?} element The DOM element used to create the manager on.
         * @param {?} manager
         * @return {?}
         */

      }, {
        key: "addManagerForElement",
        value: function addManagerForElement(element, manager) {
          this._hammerManagers.push({
            element: element,
            manager: manager
          });
        }
        /**
         * Get HammerManager for the element or null
         *
         * @param {?} element The DOM element used to create the manager on.
         * @return {?}
         */

      }, {
        key: "getManagerForElement",
        value: function getManagerForElement(element) {
          /** @type {?} */
          var result = this._hammerManagers.filter(function (value, index, array) {
            return value.element === element;
          });

          return result.length ? result[0].manager : null;
        }
        /**
         * Destroys the HammerManager for the element, removing event listeners in the process.
         *
         * @param {?} element The DOM element used to create the manager on.
         * @return {?}
         */

      }, {
        key: "removeManagerForElement",
        value: function removeManagerForElement(element) {
          /** @type {?} */
          var index = null;

          for (var i = 0; i < this._hammerManagers.length; i++) {
            if (element === this._hammerManagers[i].element) {
              index = i;
              break;
            }
          }

          if (index !== null) {
            /** @type {?} */
            var item = this._hammerManagers.splice(index, 1)[0]; // destroy also


            item.manager.destroy();
          }
        }
        /**
         * Destroys all internally tracked HammerManagers, removing event listeners in the process.
         * @return {?}
         */

      }, {
        key: "destroy",
        value: function destroy() {
          var _iteratorNormalCompletion39 = true;
          var _didIteratorError39 = false;
          var _iteratorError39 = undefined;

          try {
            for (var _iterator39 = this._hammerManagers[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
              var item = _step39.value;
              item.manager.destroy();
            }
          } catch (err) {
            _didIteratorError39 = true;
            _iteratorError39 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion39 && _iterator39["return"] != null) {
                _iterator39["return"]();
              }
            } finally {
              if (_didIteratorError39) {
                throw _iteratorError39;
              }
            }
          }

          this._hammerManagers = [];
        }
      }]);

      return HammerGesturesManager;
    }();

    HammerGesturesManager.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /** @nocollapse */

    HammerGesturesManager.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
        }]
      }, {
        type: PlatformUtil
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */


    var FilterMode = {
      quickFilter: 'quickFilter',
      excelStyleFilter: 'excelStyleFilter'
    };
    /** @enum {string} */

    var GridSummaryPosition = {
      top: 'top',
      bottom: 'bottom'
    };
    /** @enum {string} */

    var GridSummaryCalculationMode = {
      rootLevelOnly: 'rootLevelOnly',
      childLevelsOnly: 'childLevelsOnly',
      rootAndChildLevels: 'rootAndChildLevels'
    };
    /** @enum {string} */

    var GridKeydownTargetType = {
      dataCell: 'dataCell',
      summaryCell: 'summaryCell',
      groupRow: 'groupRow',
      hierarchicalRow: 'hierarchicalRow'
    };
    /** @enum {string} */

    var GridSelectionMode = {
      none: 'none',
      single: 'single',
      multiple: 'multiple'
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Providing reference to `IgxGridCellComponent`:
     * ```typescript
     * \@ViewChild('grid', { read: IgxGridComponent })
     *  public grid: IgxGridComponent;
     * ```
     * ```typescript
     *  let column = this.grid.columnList.first;
     * ```
     * ```typescript
     *  let cell = column.cells[0];
     * ```
     */

    var IgxGridCellComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} selectionService
       * @param {?} crudService
       * @param {?} gridAPI
       * @param {?} cdr
       * @param {?} element
       * @param {?} zone
       * @param {?} touchManager
       * @param {?} platformUtil
       */
      function IgxGridCellComponent(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) {
        var _this160 = this;

        _classCallCheck(this, IgxGridCellComponent);

        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.touchManager = touchManager;
        this.platformUtil = platformUtil;
        this._vIndex = -1;
        /**
         * Sets/gets the highlight class of the cell.
         * Default value is `"igx-highlight"`.
         * ```typescript
         * let highlightClass = this.cell.highlightClass;
         * ```
         * ```typescript
         * this.cell.highlightClass = 'igx-cell-highlight';
         * ```
         * \@memberof IgxGridCellComponent
         */

        this.highlightClass = 'igx-highlight';
        /**
         * Sets/gets the active highlight class class of the cell.
         * Default value is `"igx-highlight__active"`.
         * ```typescript
         * let activeHighlightClass = this.cell.activeHighlightClass;
         * ```
         * ```typescript
         * this.cell.activeHighlightClass = 'igx-cell-highlight_active';
         * ```
         * \@memberof IgxGridCellComponent
         */

        this.activeHighlightClass = 'igx-highlight__active';
        /**
         * @hidden
         * \@internal
         */

        this.lastPinned = false;
        /**
         * Returns whether the cell is in edit mode.
         */

        this.editMode = false;
        /**
         * Sets/get the `tabindex` property of the cell.
         * Default value is `0`.
         * ```typescript
         * this.cell.tabindex = 1;
         * ```
         * ```typescript
         * let cellTabIndex = this.cell.tabindex;
         * ```
         * \@memberof IgxGridCellComponent
         */

        this.tabindex = 0;
        /**
         * Sets/get the `role` property of the cell.
         * Default value is `"gridcell"`.
         * ```typescript
         * this.cell.role = 'grid-cell';
         * ```
         * ```typescript
         * let cellRole = this.cell.role;
         * ```
         * \@memberof IgxGridCellComponent
         */

        this.role = 'gridcell';
        /**
         * Gets the width of the cell.
         * ```typescript
         * let cellWidth = this.cell.width;
         * ```
         * \@memberof IgxGridCellComponent
         */

        this.width = '';
        /**
         * @hidden
         * \@internal
         */

        this.focused = false;
        this.isInCompositionMode = false;
        this._cellSelection = GridSelectionMode.multiple;
        /**
         *
         * @hidden
         * \@internal
         */

        this.pointerdown = function (event) {
          if (!isLeftClick(event)) {
            _this160.selectionService.addKeyboardRange();

            _this160.selectionService.initKeyboardState();

            _this160.selectionService.primaryButton = false;
            return;
          }

          _this160.selectionService.pointerDown(_this160.selectionNode, event.shiftKey, event.ctrlKey);
        };
        /**
         *
         * @hidden
         * \@internal
         */


        this.pointerenter = function (event) {
          /** @type {?} */
          var dragMode = _this160.selectionService.pointerEnter(_this160.selectionNode, event);

          if (dragMode) {
            _this160.grid.cdr.detectChanges();
          }
        };
        /**
         * @hidden
         * \@internal
         */


        this.pointerup = function (event) {
          if (_this160.grid.hasColumnLayouts) {
            _this160.grid.navigation.setStartNavigationCell(_this160.colStart, _this160.rowStart, null);
          }

          if (!isLeftClick(event)) {
            return;
          }

          if (_this160.selectionService.pointerUp(_this160.selectionNode, _this160.grid.onRangeSelection)) {
            _this160.grid.cdr.detectChanges();
          }

          _this160._updateCRUDStatus();
        };
        /**
         * @hidden
         * \@internal
         */


        this.onDoubleClick = function (event) {
          if (event.type === 'doubletap') {
            // prevent double-tap to zoom on iOS

            /** @type {?} */
            event.preventDefault();
          }

          if (_this160.editable && !_this160.editMode && !_this160.row.deleted) {
            _this160.crudService.begin(_this160);
          }

          _this160.grid.onDoubleClick.emit({
            cell: _this160,
            event: event
          });
        };
      }
      /**
       * Gets the cell template context object.
       * ```typescript
       *  let context = this.cell.context();
       * ```
       * \@memberof IgxGridCellComponent
       * @return {?}
       */


      _createClass(IgxGridCellComponent, [{
        key: "addPointerListeners",

        /**
         * @private
         * @param {?} selection
         * @return {?}
         */
        value: function addPointerListeners(selection) {
          if (selection !== GridSelectionMode.multiple) {
            return;
          }

          this.nativeElement.addEventListener('pointerdown', this.pointerdown);
          this.nativeElement.addEventListener('pointerenter', this.pointerenter);
          this.nativeElement.addEventListener('pointerup', this.pointerup);
        }
        /**
         * @private
         * @param {?} selection
         * @return {?}
         */

      }, {
        key: "removePointerListeners",
        value: function removePointerListeners(selection) {
          if (selection !== GridSelectionMode.multiple) {
            return;
          }

          this.nativeElement.removeEventListener('pointerdown', this.pointerdown);
          this.nativeElement.removeEventListener('pointerenter', this.pointerenter);
          this.nativeElement.removeEventListener('pointerup', this.pointerup);
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this161 = this;

          this.zone.runOutsideAngular(function () {
            _this161.addPointerListeners(_this161.cellSelectionMode); // IE 11 workarounds


            if (isIE()) {
              _this161.compositionStartHandler = function () {
                return _this161.isInCompositionMode = true;
              };

              _this161.compositionEndHandler = function () {
                return _this161.isInCompositionMode = false;
              }; // Hitting Enter with IME submits and exits from edit mode instead of first closing the IME dialog


              _this161.nativeElement.addEventListener('compositionstart', _this161.compositionStartHandler);

              _this161.nativeElement.addEventListener('compositionend', _this161.compositionEndHandler);
            }
          });

          if (this.platformUtil.isIOS) {
            this.touchManager.addEventListener(this.nativeElement, 'doubletap', this.onDoubleClick,
            /** @type {?} */
            {
              cssProps: {}
              /* don't disable user-select, etc */

            });
          }
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _this162 = this;

          this.zone.runOutsideAngular(function () {
            _this162.removePointerListeners(_this162.cellSelectionMode);

            if (isIE()) {
              _this162.nativeElement.removeEventListener('compositionstart', _this162.compositionStartHandler);

              _this162.nativeElement.removeEventListener('compositionend', _this162.compositionEndHandler);
            }
          });
          this.touchManager.destroy();
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "_updateCRUDStatus",
        value: function _updateCRUDStatus() {
          if (this.editMode) {
            return;
          }
          /** @type {?} */


          var crud = this.crudService;
          /** @type {?} */

          var editableCell = this.crudService.cell;
          /** @type {?} */

          var editMode = !!(crud.row || crud.cell);

          if (this.editable && editMode && !this.row.deleted) {
            if (editableCell) {
              this.gridAPI.update_cell(editableCell, editableCell.editValue);
            }

            crud.end();
            this.grid.notifyChanges();
            crud.begin(this);
            return;
          }

          if (editableCell && crud.sameRow(this.cellID.rowID)) {
            this.gridAPI.submit_value();
          } else if (editMode && !crud.sameRow(this.cellID.rowID)) {
            this.grid.endEdit(true);
          }
        }
        /**
         * @deprecated
         * Gets whether the cell is selected.
         * ```typescript
         * let isCellSelected = thid.cell.isCellSelected();
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "isCellSelected",
        value: function isCellSelected() {
          return this.selectionService.selected(this.selectionNode);
        }
        /**
         * @hidden
         * \@internal
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          if (changes.value && !changes.value.firstChange) {
            if (this.highlight) {
              this.highlight.lastSearchInfo.searchedText = this.grid.lastSearchInfo.searchText;
              this.highlight.lastSearchInfo.caseSensitive = this.grid.lastSearchInfo.caseSensitive;
              this.highlight.lastSearchInfo.exactMatch = this.grid.lastSearchInfo.exactMatch;
            }
          }
        }
        /**
         * Starts/ends edit mode for the cell.
         *
         * ```typescript
         * cell.setEditMode(true);
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "setEditMode",
        value: function setEditMode(value) {
          if (this.row.deleted) {
            return;
          }

          if (this.editable && value) {
            this.gridAPI.submit_value();
            this.crudService.begin(this);
          } else {
            this.gridAPI.escape_editMode();
          }

          this.grid.notifyChanges();
        }
        /**
         * Sets new value to the cell.
         * ```typescript
         * this.cell.update('New Value');
         * ```
         * \@memberof IgxGridCellComponent
         * @param {?} val
         * @return {?}
         */
        // TODO: Refactor

      }, {
        key: "update",
        value: function update(val) {
          if (this.row.deleted) {
            return;
          }
          /** @type {?} */


          var cell = this.crudService.createCell(this);
          /** @type {?} */

          var args = this.gridAPI.update_cell(cell, val);

          if (this.crudService.cell && this.crudService.sameCell(cell)) {
            if (args.cancel) {
              return;
            }

            this.gridAPI.escape_editMode();
          }

          this.cdr.markForCheck();
        }
        /**
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onClick",
        value: function onClick(event) {
          this.grid.onCellClick.emit({
            cell: this,
            event: event
          });
        }
        /**
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onContextMenu",
        value: function onContextMenu(event) {
          this.grid.onContextMenu.emit({
            cell: this,
            event: event
          });
        }
        /**
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus(event) {
          if (this.focused) {
            return;
          }

          this.focused = true;
          this.row.focused = true;
          /** @type {?} */

          var node = this.selectionNode;
          /** @type {?} */

          var shouldEmitSelection = !this.selectionService.isActiveNode(node);

          if (this.selectionService.primaryButton) {
            this._updateCRUDStatus();

            this.selectionService.activeElement = node;
          } else {
            this.selectionService.activeElement = null;

            if (this.crudService.inEditMode && !this.editMode) {
              this.gridAPI.submit_value();
            }
          }

          this.selectionService.primaryButton = true;

          if (this.cellSelectionMode === GridSelectionMode.multiple && this.selectionService.activeElement) {
            this.selectionService.add(this.selectionService.activeElement, false); // pointer events handle range generation

            this.selectionService.keyboardStateOnFocus(node, this.grid.onRangeSelection, this.nativeElement);
          }

          if (this.grid.isCellSelectable && shouldEmitSelection) {
            this.grid.onSelection.emit({
              cell: this,
              event: event
            });
          }
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur() {
          this.focused = false;
          this.row.focused = false;
        }
        /**
         * @protected
         * @param {?} key
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "handleAlt",
        value: function handleAlt(key, event) {
          if (this.row.nativeElement.tagName.toLowerCase() === 'igx-tree-grid-row' && this.isToggleKey(key)) {
            /** @type {?} */
            var collapse =
            /** @type {?} */
            this.row.expanded && ROW_COLLAPSE_KEYS.has(key);
            /** @type {?} */

            var expand = !
            /** @type {?} */
            this.row.expanded && ROW_EXPAND_KEYS.has(key);

            if (collapse) {
              /** @type {?} */
              this.gridAPI.trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
            } else if (expand) {
              /** @type {?} */
              this.gridAPI.trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
            }
          }
        }
        /**
         * @protected
         * @param {?} shift
         * @return {?}
         */

      }, {
        key: "handleTab",
        value: function handleTab(shift) {
          if (shift) {
            this.grid.navigation.performShiftTabKey(this.row.nativeElement, this.selectionNode);
          } else {
            this.grid.navigation.performTab(this.row.nativeElement, this.selectionNode);
          }
        }
        /**
         * @protected
         * @param {?} ctrl
         * @return {?}
         */

      }, {
        key: "handleEnd",
        value: function handleEnd(ctrl) {
          if (ctrl) {
            this.grid.navigation.goToLastCell();
          } else {
            this.grid.navigation.onKeydownEnd(this.rowIndex, false, this.rowStart);
          }
        }
        /**
         * @protected
         * @param {?} ctrl
         * @return {?}
         */

      }, {
        key: "handleHome",
        value: function handleHome(ctrl) {
          if (ctrl) {
            this.grid.navigation.goToFirstCell();
          } else {
            this.grid.navigation.onKeydownHome(this.rowIndex, false, this.rowStart);
          }
        } // TODO: Refactor

        /**
         *
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          /** @type {?} */
          var key = event.key.toLowerCase();
          /** @type {?} */

          var shift = event.shiftKey;
          /** @type {?} */

          var ctrl = event.ctrlKey;
          /** @type {?} */

          var node = this.selectionNode;

          if (!SUPPORTED_KEYS.has(key)) {
            return;
          }

          event.stopPropagation();
          /** @type {?} */

          var keydownArgs = {
            targetType: 'dataCell',
            target: this,
            event: event,
            cancel: false
          };
          this.grid.onGridKeydown.emit(keydownArgs);

          if (keydownArgs.cancel) {
            this.selectionService.clear();
            this.selectionService.keyboardState.active = true;
            return;
          }

          if (event.altKey) {
            event.preventDefault();
            this.handleAlt(key, event);
            return;
          }

          this.selectionService.keyboardStateOnKeydown(node, shift, shift && key === 'tab');

          if (key === 'tab') {
            event.preventDefault();
          }

          if (this.editMode) {
            if (NAVIGATION_KEYS.has(key)) {
              if (this.column.inlineEditorTemplate) {
                return;
              }

              if (['date', 'boolean'].indexOf(this.column.dataType) > -1) {
                return;
              }

              return;
            }
          }

          if (NAVIGATION_KEYS.has(key)) {
            event.preventDefault();
          }

          switch (key) {
            case 'tab':
              this.handleTab(shift);
              break;

            case 'end':
              this.handleEnd(ctrl);
              break;

            case 'home':
              this.handleHome(ctrl);
              break;

            case 'arrowleft':
            case 'left':
              if (ctrl) {
                this.grid.navigation.onKeydownHome(node.row, false, this.rowStart);
                break;
              }

              this.grid.navigation.onKeydownArrowLeft(this.nativeElement, this.selectionNode);
              break;

            case 'arrowright':
            case 'right':
              if (ctrl) {
                this.grid.navigation.onKeydownEnd(node.row, false, this.rowStart);
                break;
              }

              this.grid.navigation.onKeydownArrowRight(this.nativeElement, this.selectionNode);
              break;

            case 'arrowup':
            case 'up':
              if (ctrl) {
                this.grid.navigation.navigateTop(this.visibleColumnIndex);
                break;
              }

              this.grid.navigation.navigateUp(this.row.nativeElement, this.selectionNode);
              break;

            case 'arrowdown':
            case 'down':
              if (ctrl) {
                this.grid.navigation.navigateBottom(this.visibleColumnIndex);
                break;
              }

              this.grid.navigation.navigateDown(this.row.nativeElement, this.selectionNode);
              break;

            case 'enter':
            case 'f2':
              this.onKeydownEnterEditMode();
              break;

            case 'escape':
            case 'esc':
              this.onKeydownExitEditMode();
              break;

            case ' ':
            case 'spacebar':
            case 'space':
              if (this.grid.isRowSelectable) {
                this.row.selected ? this.selectionService.deselectRow(this.row.rowID, event) : this.selectionService.selectRowById(this.row.rowID, false, event);
              }

              break;

            default:
              return;
          }
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "onKeydownEnterEditMode",
        value: function onKeydownEnterEditMode() {
          if (this.isInCompositionMode) {
            return;
          }

          if (this.column.editable && !this.row.deleted) {
            if (this.editMode) {
              this.grid.endEdit(true);
              this.nativeElement.focus();
            } else {
              this.crudService.begin(this);
            }
          }
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "onKeydownExitEditMode",
        value: function onKeydownExitEditMode() {
          if (this.isInCompositionMode) {
            return;
          }

          if (this.editMode) {
            /** @type {?} */
            var args = this.crudService.cell.createEditEventArgs();
            this.grid.onCellEditCancel.emit(args);

            if (args.cancel) {
              return;
            }

            this.grid.endEdit(false);
            this.nativeElement.focus();
          }
        }
        /**
         * If the provided string matches the text in the cell, the text gets highlighted.
         * ```typescript
         * this.cell.highlightText('Cell Value', true);
         * ```
         * \@memberof IgxGridCellComponent
         * @param {?} text
         * @param {?=} caseSensitive
         * @param {?=} exactMatch
         * @return {?}
         */

      }, {
        key: "highlightText",
        value: function highlightText(text, caseSensitive, exactMatch) {
          return this.highlight && this.column.searchable ? this.highlight.highlight(text, caseSensitive, exactMatch) : 0;
        }
        /**
         * Clears the highlight of the text in the cell.
         * ```typescript
         * this.cell.clearHighLight();
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "clearHighlight",
        value: function clearHighlight() {
          if (this.highlight && this.column.searchable) {
            this.highlight.clearHighlight();
          }
        }
        /**
         * @hidden
         * \@internal
         * @param {?} range
         * @return {?}
         */

      }, {
        key: "calculateSizeToFit",
        value: function calculateSizeToFit(range) {
          return Math.max.apply(Math, _toConsumableArray(Array.from(this.nativeElement.children).map(function (child) {
            return getNodeSizeViaRange(range, child);
          })));
        }
        /**
         * @private
         * @param {?} key
         * @return {?}
         */

      }, {
        key: "isToggleKey",
        value: function isToggleKey(key) {
          return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
        }
      }, {
        key: "context",
        get: function get() {
          return {
            $implicit: this.value,
            cell: this
          };
        }
        /**
         * Gets the cell template.
         * ```typescript
         * let template = this.cell.template;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "template",
        get: function get() {
          if (this.editMode) {
            /** @type {?} */
            var inlineEditorTemplate = this.column.inlineEditorTemplate;
            return inlineEditorTemplate ? inlineEditorTemplate : this.inlineEditorTemplate;
          }

          if (this.cellTemplate) {
            return this.cellTemplate;
          }

          return this.defaultCellTemplate;
        }
        /**
         * Gets the `id` of the grid in which the cell is stored.
         * ```typescript
         * let gridId = this.cell.gridID;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "gridID",
        get: function get() {
          return this.row.gridID;
        }
        /**
         * Gets the grid of the cell.
         * ```typescript
         * let grid = this.cell.grid;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "grid",
        get: function get() {
          return this.gridAPI.grid;
        }
        /**
         * Gets the `index` of the row where the cell is stored.
         * ```typescript
         * let rowIndex = this.cell.rowIndex;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "rowIndex",
        get: function get() {
          return this.row.index;
        }
        /**
         * Gets the `index` of the cell column.
         * ```typescript
         * let columnIndex = this.cell.columnIndex;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "columnIndex",
        get: function get() {
          return this.column.index;
        }
        /**
         * Gets the visible `index` of the in which the cell is stored.
         * ```typescript
         * let visibleColumnIndex = this.cell.visibleColumnIndex;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "visibleColumnIndex",
        get: function get() {
          return this.column.columnLayoutChild ? this.column.visibleIndex : this._vIndex;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._vIndex = val;
        }
        /**
         * Gets the ID of the cell.
         * ```typescript
         * let cellID = this.cell.cellID;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "cellID",
        get: function get() {
          /** @type {?} */
          var primaryKey = this.grid.primaryKey;
          /** @type {?} */

          var rowID = primaryKey ? this.rowData[primaryKey] : this.rowData;
          return {
            rowID: rowID,
            columnID: this.columnIndex,
            rowIndex: this.rowIndex
          };
        }
        /**
         * Returns a reference to the nativeElement of the cell.
         * ```typescript
         * let cellNativeElement = this.cell.nativeElement;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
        /**
         * @deprecated
         * Use `cell.editMode` as a getter and
         * `cell.setEditMode(true | false)` to start/exit edit mode.
         *
         * Gets/sets whether the cell is in edit mode.
         * ```typescript
         * let isCellInEditMode = this.cell.inEditMode;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "inEditMode",
        get: function get() {
          return this.editMode;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.setEditMode(value);
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "cellSelectionMode",
        get: function get() {
          return this._cellSelection;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          var _this163 = this;

          if (this._cellSelection === value) {
            return;
          }

          this.zone.runOutsideAngular(function () {
            value === GridSelectionMode.multiple ? _this163.addPointerListeners(value) : _this163.removePointerListeners(_this163._cellSelection);
          });
          this._cellSelection = value;
        }
        /**
         * Gets whether the cell is editable.
         * ```typescript
         * let isCellReadonly = this.cell.readonly;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "readonly",
        get: function get() {
          return !this.column.editable;
        }
        /**
         * @return {?}
         */

      }, {
        key: "gridRowSpan",
        get: function get() {
          return this.column.gridRowSpan;
        }
        /**
         * @return {?}
         */

      }, {
        key: "gridColumnSpan",
        get: function get() {
          return this.column.gridColumnSpan;
        }
        /**
         * @return {?}
         */

      }, {
        key: "rowEnd",
        get: function get() {
          return this.column.rowEnd;
        }
        /**
         * @return {?}
         */

      }, {
        key: "colEnd",
        get: function get() {
          return this.column.colEnd;
        }
        /**
         * @return {?}
         */

      }, {
        key: "rowStart",
        get: function get() {
          return this.column.rowStart;
        }
        /**
         * @return {?}
         */

      }, {
        key: "colStart",
        get: function get() {
          return this.column.colStart;
        }
        /**
         * Returns a string containing the grid `id` and the column `field` concatenated by "_".
         * ```typescript
         * let describedBy = this.cell.describedBy;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "describedby",
        get: function get() {
          return "".concat(this.row.gridID, "_").concat(this.column.field);
        }
        /**
         * Gets whether the cell is selected.
         * ```typescript
         * let isSelected = this.cell.selected;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this.selectionService.selected(this.selectionNode);
        }
        /**
         * Selects/deselects the cell.
         * ```typescript
         * this.cell.selected = true.
         * ```
         * \@memberof IgxGridCellComponent
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          /** @type {?} */
          var node = this.selectionNode;
          val ? this.selectionService.add(node) : this.selectionService.remove(node);
          this.grid.notifyChanges();
        }
        /**
         * @return {?}
         */

      }, {
        key: "dirty",
        get: function get() {
          if (this.grid.rowEditable) {
            /** @type {?} */
            var rowCurrentState = this.grid.transactions.getAggregatedValue(this.row.rowID, false);

            if (rowCurrentState) {
              return rowCurrentState[this.column.field] !== undefined && rowCurrentState[this.column.field] !== null;
            }
          } else {
            /** @type {?} */
            var rowTransaction = this.grid.transactions.getState(this.row.rowID);
            return rowTransaction && rowTransaction.value && (rowTransaction.value[this.column.field] || rowTransaction.value[this.column.field] === 0 || rowTransaction.value[this.column.field] === false);
          }

          return false;
        }
        /**
         * Sets the current edit value while a cell is in edit mode.
         * Only for cell editing mode.
         * ```typescript
         * this.cell.editValue = value;
         * ```
         * \@memberof IgxGridCellComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "editValue",
        set: function set(value) {
          if (this.crudService.inEditMode) {
            this.crudService.cell.editValue = value;
          }
        }
        /**
         * Gets the current edit value while a cell is in edit mode.
         * Only for cell editing mode.
         * ```typescript
         * let editValue = this.cell.editValue;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        ,
        get: function get() {
          if (this.crudService.inEditMode) {
            return this.crudService.cell.editValue;
          }
        }
        /**
         * Returns whether the cell is editable.
         * @return {?}
         */

      }, {
        key: "editable",
        get: function get() {
          return this.column.editable;
        }
        /**
         * @protected
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "highlight",
        set: function set(value) {
          this._highlight = value;

          if (this._highlight && this.grid.lastSearchInfo.searchText) {
            this._highlight.highlight(this.grid.lastSearchInfo.searchText, this.grid.lastSearchInfo.caseSensitive, this.grid.lastSearchInfo.exactMatch);

            this._highlight.activateIfNecessary();
          }
        }
        /**
         * @protected
         * @return {?}
         */
        ,
        get: function get() {
          return this._highlight;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "selectionNode",
        get: function get() {
          return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            layout: this.column.columnLayoutChild ? {
              rowStart: this.column.rowStart,
              colStart: this.column.colStart,
              rowEnd: this.column.rowEnd,
              colEnd: this.column.colEnd,
              columnVisibleIndex: this.visibleColumnIndex
            } : null
          };
        }
      }]);

      return IgxGridCellComponent;
    }();

    IgxGridCellComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        selector: 'igx-grid-cell',
        template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"focused\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n            [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n",
        providers: [HammerGesturesManager]
      }]
    }];
    /** @nocollapse */

    IgxGridCellComponent.ctorParameters = function () {
      return [{
        type: IgxGridSelectionService
      }, {
        type: IgxGridCRUDService
      }, {
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: HammerGesturesManager
      }, {
        type: PlatformUtil
      }];
    };

    IgxGridCellComponent.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      row: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowData: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cellTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      formatter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.data-rowIndex']
      }],
      visibleColumnIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.data-visibleIndex']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cellSelectionMode: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      lastPinned: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__td--pinned-last']
      }],
      editMode: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__td--editing']
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      readonly: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-readonly']
      }],
      gridRowSpan: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.-ms-grid-row-span']
      }],
      gridColumnSpan: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.-ms-grid-column-span']
      }],
      rowEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.grid-row-end']
      }],
      colEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.grid-column-end']
      }],
      rowStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.-ms-grid-row']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.grid-row-start']
      }],
      colStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.-ms-grid-column']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.grid-column-start']
      }],
      describedby: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-describedby']
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.min-width']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.max-width']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.flex-basis']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-selected']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__td--selected']
      }],
      dirty: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__td--edited']
      }],
      focused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__td--active']
      }],
      defaultCellTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultCell', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      inlineEditorTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['inlineEditor', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      highlight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxTextHighlightDirective, {
          read: IgxTextHighlightDirective,
          "static": false
        }]
      }],
      onDoubleClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['dblclick', ['$event']]
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }],
      onContextMenu: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['contextmenu', ['$event']]
      }],
      onFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus', ['$event']]
      }],
      onBlur: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['blur']
      }],
      dispatchEvent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown', ['$event']]
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("'inEditMode' is deprecated\nUse 'editMode' to get the current state and 'setEditMode(boolean)' as a setter"), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxGridCellComponent.prototype, "inEditMode", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateMethod("'isCellSelected' is deprecated. Use 'selected' property instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", []), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:returntype", void 0)], IgxGridCellComponent.prototype, "isCellSelected", null);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @abstract
     * @template T
     */

    var IgxRowComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       * @param {?} crudService
       * @param {?} selectionService
       * @param {?} element
       * @param {?} cdr
       */
      function IgxRowComponent(gridAPI, crudService, selectionService, element, cdr) {
        _classCallCheck(this, IgxRowComponent);

        this.gridAPI = gridAPI;
        this.crudService = crudService;
        this.selectionService = selectionService;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */

        this.role = 'row';
        /**
         * @hidden
         */

        this.dragging = false;
        /**
         * @hidden
         */

        this.focused = false;
        /**
         * @hidden
         * \@internal
         */

        this.defaultCssClass = 'igx-grid__tr';
      }
      /**
       *  The data passed to the row component.
       *
       * ```typescript
       * // get the row data for the first selected row
       * let selectedRowData = this.grid.selectedRows[0].rowData;
       * ```
       * @return {?}
       */


      _createClass(IgxRowComponent, [{
        key: "onClick",

        /**
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */
        value: function onClick(event) {
          if (this.grid.rowSelection === 'none' || this.deleted) {
            return;
          }

          if (event.shiftKey && this.grid.rowSelection === 'multiple') {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
          }

          this.selectionService.selectRowById(this.rowID, !event.ctrlKey, event);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onRowSelectorClick",
        value: function onRowSelectorClick(event) {
          event.stopPropagation();

          if (event.shiftKey && this.grid.rowSelection === 'multiple') {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
          }

          this.selected ? this.selectionService.deselectRow(this.rowID, event) : this.selectionService.selectRowById(this.rowID, false, event);
        }
        /**
         * Updates the specified row object and the data source record with the passed value.
         * This method emits `onEditDone` event.
         *
         * ```typescript
         * // update the second selected row's value
         * let newValue = "Apple";
         * this.grid.selectedRows[1].update(newValue);
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "update",
        value: function update(value) {
          /** @type {?} */
          var crudService = this.crudService;

          if (crudService.inEditMode && crudService.cell.id.rowID === this.rowID) {
            this.grid.endEdit(false);
          }
          /** @type {?} */


          var row = new IgxRow(this.rowID, this.index, this.rowData);
          this.gridAPI.update_row(row, value);
          this.cdr.markForCheck();
        }
        /**
         * Removes the specified row from the grid's data source.
         * This method emits `onRowDeleted` event.
         *
         * ```typescript
         * // delete the third selected row from the grid
         * this.grid.selectedRows[2].delete();
         * ```
         * @return {?}
         */

      }, {
        key: "delete",
        value: function _delete() {
          this.grid.deleteRowById(this.rowID);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngDoCheck",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngDoCheck() {
          this.cdr.markForCheck();
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "resolveClasses",
        value: function resolveClasses() {
          /** @type {?} */
          var indexClass = this.index % 2 ? this.grid.evenRowCSS : this.grid.oddRowCSS;
          /** @type {?} */

          var selectedClass = this.selected ? 'igx-grid__tr--selected' : '';
          /** @type {?} */

          var editClass = this.inEditMode ? 'igx-grid__tr--edit' : '';
          /** @type {?} */

          var dirtyClass = this.dirty ? 'igx-grid__tr--edited' : '';
          /** @type {?} */

          var deletedClass = this.deleted ? 'igx-grid__tr--deleted' : '';
          /** @type {?} */

          var mrlClass = this.grid.hasColumnLayouts ? 'igx-grid__tr--mrl' : '';
          /** @type {?} */

          var dragClass = this.dragging ? 'igx-grid__tr--drag' : '';
          return "".concat(this.defaultCssClass, " ").concat(indexClass, " ").concat(selectedClass, " ").concat(editClass, " ").concat(dirtyClass, "\n         ").concat(deletedClass, " ").concat(mrlClass, " ").concat(dragClass).trim();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "rowData",
        get: function get() {
          if (this.inEditMode) {
            return Object.assign({}, this._rowData, this.grid.transactions.getAggregatedValue(this.rowID, false));
          }

          return this._rowData;
        }
        /**
         * @param {?} v
         * @return {?}
         */
        ,
        set: function set(v) {
          this._rowData = v;
        }
        /**
         * @return {?}
         */

      }, {
        key: "dataRowIndex",
        get: function get() {
          return this.index;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "styleClasses",
        get: function get() {
          return this.resolveClasses();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return this.selectionService.isRowSelected(this.rowID);
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          value ? this.selectionService.selectRowsWithNoEvent([this.rowID]) : this.selectionService.deselectRowsWithNoEvent([this.rowID]);
          this.grid.cdr.markForCheck();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "columns",
        get: function get() {
          return this.grid.visibleColumns;
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "viewIndex",
        get: function get() {
          if (
          /** @type {?} */
          this.grid.groupingExpressions.length) {
            return this.grid.filteredSortedData.indexOf(this.rowData);
          }

          return this.index + this.grid.page * this.grid.perPage;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "pinnedColumns",
        get: function get() {
          return this.grid.pinnedColumns;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "unpinnedColumns",
        get: function get() {
          return this.grid.unpinnedColumns;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "showRowSelectors",
        get: function get() {
          return this.grid.showRowSelectors;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "dirty",
        get: function get() {
          /** @type {?} */
          var row = this.grid.transactions.getState(this.rowID);

          if (row) {
            return row.type === TransactionType.ADD || row.type === TransactionType.UPDATE;
          }

          return false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isSelected",
        get: function get() {
          return this.selectionService.isRowSelected(this.rowID);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "rowDraggable",
        get: function get() {
          return this.grid.rowDraggable;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "added",
        get: function get() {
          /** @type {?} */
          var row = this.grid.transactions.getState(this.rowID);

          if (row) {
            return row.type === TransactionType.ADD;
          }

          return false;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "deleted",
        get: function get() {
          return this.gridAPI.row_deleted_transaction(this.rowID);
        } // TODO: Refactor

        /**
         * @return {?}
         */

      }, {
        key: "inEditMode",
        get: function get() {
          if (this.grid.rowEditable) {
            /** @type {?} */
            var editRowState = this.crudService.row;
            return editRowState && editRowState.id === this.rowID || false;
          } else {
            return false;
          }
        }
        /**
         * Get a reference to the grid that contains the selected row.
         *
         * ```typescript
         * handleRowSelection(event) {
         *  // the grid on which the onRowSelectionChange event was triggered
         *  const grid = event.row.grid;
         * }
         * ```
         *
         * ```html
         *  <igx-grid
         *    [data]="data"
         *    (onRowSelectionChange)="handleRowSelection($event)">
         *  </igx-grid>
         * ```
         * @return {?}
         */

      }, {
        key: "grid",
        get: function get() {
          return this.gridAPI.grid;
        }
        /**
         * Gets the ID of the row.
         * A row in the grid is identified either by:
         * - primaryKey data value,
         * - the whole rowData, if the primaryKey is omitted.
         *
         * ```typescript
         * let rowID = this.grid.selectedRows[2].rowID;
         * ```
         * @return {?}
         */

      }, {
        key: "rowID",
        get: function get() {
          /** @type {?} */
          var primaryKey = this.grid.primaryKey;
          return primaryKey ? this._rowData[primaryKey] : this._rowData;
        }
        /**
         * The native DOM element representing the row. Could be null in certain environments.
         *
         * ```typescript
         * // get the nativeElement of the second selected row
         * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
         * ```
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
      }, {
        key: "rowCheckboxAriaLabel",
        get: function get() {
          return this.grid.primaryKey ? this.selected ? 'Deselect row with key ' + this.rowID : 'Select row with key ' + this.rowID : this.selected ? 'Deselect row' : 'Select row';
        }
      }, {
        key: "resolveDragIndicatorClasses",
        get: function get() {
          /** @type {?} */
          var defaultDragIndicatorCssClass = 'igx-grid__drag-indicator';
          /** @type {?} */

          var dragIndicatorOff = this.grid.rowDragging && !this.dragging ? 'igx-grid__drag-indicator--off' : '';
          return "".concat(defaultDragIndicatorCssClass, " ").concat(dragIndicatorOff);
        }
      }]);

      return IgxRowComponent;
    }();

    IgxRowComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /** @nocollapse */

    IgxRowComponent.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: IgxGridCRUDService
      }, {
        type: IgxGridSelectionService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxRowComponent.propDecorators = {
      rowData: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      index: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      gridID: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      virtDirRow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['igxDirRef', {
          read: IgxGridForOfDirective,
          "static": false
        }]
      }],
      checkboxElement: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxCheckboxComponent;
        }), {
          read: IgxCheckboxComponent,
          "static": false
        }]
      }],
      cells: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxGridCellComponent;
        })]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      dataRowIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.data-rowIndex']
      }],
      styleClasses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class']
      }],
      selected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-selected']
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty('isSelected property is deprecated. Use selected property instead.'), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [])], IgxRowComponent.prototype, "isSelected", null);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @return {?}
     */

    function WatchChanges() {
      return function (target, key, propDesc) {
        /** @type {?} */
        var privateKey = '_' + key.toString();
        propDesc = propDesc || {
          configurable: true,
          enumerable: true
        };

        propDesc.get = propDesc.get || function () {
          return this[privateKey];
        };
        /** @type {?} */


        var originalSetter = propDesc.set || function (val) {
          this[privateKey] = val;
        };

        propDesc.set = function (val) {
          /** @type {?} */
          var init = this._init;
          /** @type {?} */

          var oldValue = this[key];

          if (val !== oldValue || typeof val === 'object' && val === oldValue) {
            originalSetter.call(this, val);

            if (this.ngOnChanges && !init) {
              // in case wacthed prop changes trigger ngOnChanges manually

              /** @type {?} */
              var changes = _defineProperty({}, key, new _angular_core__WEBPACK_IMPORTED_MODULE_1__["SimpleChange"](oldValue, val, false));

              this.ngOnChanges(changes);
            }
          }
        };

        return propDesc;
      };
    }
    /**
     * @return {?}
     */


    function WatchColumnChanges() {
      return function (target, key, propDesc) {
        /** @type {?} */
        var privateKey = '_' + key.toString();
        propDesc = propDesc || {
          configurable: true,
          enumerable: true
        };

        propDesc.get = propDesc.get || function () {
          return this[privateKey];
        };
        /** @type {?} */


        var originalSetter = propDesc.set || function (val) {
          this[privateKey] = val;
        };

        propDesc.set = function (val) {
          /** @type {?} */
          var init = this._init;
          /** @type {?} */

          var oldValue = this[key];
          originalSetter.call(this, val);

          if (val !== oldValue || typeof val === 'object' && val === oldValue) {
            if (this.rowIslandAPI.rowIsland) {
              this.rowIslandAPI.rowIsland.updateColumnList();
            }
          }
        };

        return propDesc;
      };
    }
    /**
     * @param {?=} repaint
     * @return {?}
     */


    function notifyChanges() {
      var repaint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return function (_, key, propDesc) {
        /** @type {?} */
        var privateKey = "__".concat(key);
        propDesc = propDesc || {
          enumerable: true,
          configurable: true
        };
        /** @type {?} */

        var originalSetter = propDesc ? propDesc.set : null;

        propDesc.get = propDesc.get || function () {
          return this[privateKey];
        };

        propDesc.set = function (newValue) {
          if (originalSetter) {
            originalSetter.call(this, newValue);

            if (this.grid) {
              this.grid.notifyChanges(repaint);
            }
          } else {
            if (newValue === this[key]) {
              return;
            }

            this[privateKey] = newValue;

            if (this.grid) {
              this.grid.notifyChanges(repaint);
            }
          }
        };

        return (
          /** @type {?} */
          propDesc
        );
      };
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxRowIslandAPIService =
    /*#__PURE__*/
    function () {
      function IgxRowIslandAPIService() {
        _classCallCheck(this, IgxRowIslandAPIService);

        this.change = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.state = new Map();
        this.destroyMap = new Map();
        this.childRowIslands = new Map();
        this.childGrids = new Map();
      }
      /**
       * @param {?} rowIsland
       * @return {?}
       */


      _createClass(IgxRowIslandAPIService, [{
        key: "register",
        value: function register(rowIsland) {
          this.state.set(rowIsland.id, rowIsland);
          this.destroyMap.set(rowIsland.id, new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]());
        }
        /**
         * @param {?} rowIsland
         * @return {?}
         */

      }, {
        key: "unsubscribe",
        value: function unsubscribe(rowIsland) {
          this.state["delete"](rowIsland.id);
        }
        /**
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "get",
        value: function get(id) {
          return this.state.get(id);
        }
        /**
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "unset",
        value: function unset(id) {
          this.state["delete"](id);
          this.destroyMap["delete"](id);
        }
        /**
         * @param {?} oldId
         * @param {?} newId
         * @return {?}
         */

      }, {
        key: "reset",
        value: function reset(oldId, newId) {
          /** @type {?} */
          var destroy = this.destroyMap.get(oldId);
          /** @type {?} */

          var rowIsland = this.get(oldId);
          this.unset(oldId);

          if (rowIsland) {
            this.state.set(newId, rowIsland);
          }

          if (destroy) {
            this.destroyMap.set(newId, destroy);
          }
        }
        /**
         * @param {?} rowIsland
         * @return {?}
         */

      }, {
        key: "registerChildRowIsland",
        value: function registerChildRowIsland(rowIsland) {
          this.childRowIslands.set(rowIsland.key, rowIsland);
          this.destroyMap.set(rowIsland.key, new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]());
        }
        /**
         * @param {?} rowIsland
         * @return {?}
         */

      }, {
        key: "unsetChildRowIsland",
        value: function unsetChildRowIsland(rowIsland) {
          this.childRowIslands["delete"](rowIsland.key);
          this.destroyMap["delete"](rowIsland.key);
        }
        /**
         * @param {?} rowIslandKey
         * @return {?}
         */

      }, {
        key: "getChildRowIsland",
        value: function getChildRowIsland(rowIslandKey) {
          return this.childRowIslands.get(rowIslandKey);
        }
        /**
         * @param {?} parentRowID
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "registerChildGrid",
        value: function registerChildGrid(parentRowID, grid) {
          this.childGrids.set(parentRowID, grid);
        }
        /**
         * @param {?=} inDepth
         * @return {?}
         */

      }, {
        key: "getChildGrids",
        value: function getChildGrids(inDepth) {
          /** @type {?} */
          var allChildren = [];
          this.childGrids.forEach(function (grid) {
            allChildren.push(grid);
          });

          if (inDepth) {
            this.childRowIslands.forEach(function (layout) {
              allChildren = allChildren.concat(layout.rowIslandAPI.getChildGrids(inDepth));
            });
          }

          return allChildren;
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "getChildGridByID",
        value: function getChildGridByID(rowID) {
          return this.childGrids.get(rowID);
        }
      }]);

      return IgxRowIslandAPIService;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var clear = function clear(el) {
      return el === 0 || Boolean(el);
    };
    /** @type {?} */


    var first = function first(arr) {
      return arr[0];
    };
    /** @type {?} */


    var last = function last(arr) {
      return arr[arr.length - 1];
    };

    var IgxSummaryOperand =
    /*#__PURE__*/
    function () {
      function IgxSummaryOperand() {
        _classCallCheck(this, IgxSummaryOperand);
      }

      _createClass(IgxSummaryOperand, [{
        key: "operate",

        /**
         * Executes the static `count` method and returns `IgxSummaryResult[]`.
         * ```typescript
         * interface IgxSummaryResult {
         *   key: string;
         *   label: string;
         *   summaryResult: any;
         * }
         * ```
         * Can be overridden in the inherited classes to provide customization for the `summary`.
         * ```typescript
         * class CustomSummary extends IgxSummaryOperand {
         *   constructor() {
         *     super();
         *   }
         *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
         *     const result = [];
         *     result.push({
         *       key: "test",
         *       label: "Test",
         *       summaryResult: IgxSummaryOperand.count(data)
         *     });
         *     return result;
         *   }
         * }
         * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
         * ```
         * \@memberof IgxSummaryOperand
         * @param {?=} data
         * @param {?=} allData
         * @param {?=} fieldName
         * @return {?}
         */
        value: function operate() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var allData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var fieldName = arguments.length > 2 ? arguments[2] : undefined;
          return [{
            key: 'count',
            label: 'Count',
            summaryResult: IgxSummaryOperand.count(data)
          }];
        }
      }], [{
        key: "count",

        /**
         * Counts all the records in the data source.
         * If filtering is applied, counts only the filtered records.
         * ```typescript
         * IgxSummaryOperand.count(dataSource);
         * ```
         * \@memberof IgxSummaryOperand
         * @param {?} data
         * @return {?}
         */
        value: function count(data) {
          return data.length;
        }
      }]);

      return IgxSummaryOperand;
    }(); // @dynamic


    var IgxNumberSummaryOperand =
    /*#__PURE__*/
    function (_IgxSummaryOperand) {
      _inherits(IgxNumberSummaryOperand, _IgxSummaryOperand);

      function IgxNumberSummaryOperand() {
        _classCallCheck(this, IgxNumberSummaryOperand);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxNumberSummaryOperand).apply(this, arguments));
      }

      _createClass(IgxNumberSummaryOperand, [{
        key: "operate",

        /**
         * Executes the static methods and returns `IgxSummaryResult[]`.
         * ```typescript
         * interface IgxSummaryResult {
         *   key: string;
         *   label: string;
         *   summaryResult: any;
         * }
         * ```
         * Can be overridden in the inherited classes to provide customization for the `summary`.
         * ```typescript
         * class CustomNumberSummary extends IgxNumberSummaryOperand {
         *   constructor() {
         *     super();
         *   }
         *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
         *     const result = [];
         *     result.push({
         *       key: "avg",
         *       label: "Avg",
         *       summaryResult: IgxNumberSummaryOperand.average(data)
         *     });
         *     result.push({
         *       key: "max",
         *       label: "Max",
         *       summaryResult: IgxNumberSummaryOperand.max(data)
         *     });
         *     return result;
         *   }
         * }
         * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
         * ```
         * \@memberof IgxNumberSummaryOperand
         * @param {?=} data
         * @param {?=} allData
         * @param {?=} fieldName
         * @return {?}
         */
        value: function operate() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var allData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var fieldName = arguments.length > 2 ? arguments[2] : undefined;

          /** @type {?} */
          var result = _get(_getPrototypeOf(IgxNumberSummaryOperand.prototype), "operate", this).call(this, data, allData, fieldName);

          result.push({
            key: 'min',
            label: 'Min',
            summaryResult: IgxNumberSummaryOperand.min(data)
          });
          result.push({
            key: 'max',
            label: 'Max',
            summaryResult: IgxNumberSummaryOperand.max(data)
          });
          result.push({
            key: 'sum',
            label: 'Sum',
            summaryResult: IgxNumberSummaryOperand.sum(data)
          });
          result.push({
            key: 'average',
            label: 'Avg',
            summaryResult: IgxNumberSummaryOperand.average(data)
          });
          return result;
        }
      }], [{
        key: "min",

        /**
         * Returns the minimum numeric value in the provided data records.
         * If filtering is applied, returns the minimum value in the filtered data records.
         * ```typescript
         * IgxNumberSummaryOperand.min(data);
         * ```
         * \@memberof IgxNumberSummaryOperand
         * @param {?} data
         * @return {?}
         */
        value: function min(data) {
          return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) {
            return Math.min(a, b);
          }) : 0;
        }
        /**
         * Returns the maximum numeric value in the provided data records.
         * If filtering is applied, returns the maximum value in the filtered data records.
         * ```typescript
         * IgxNumberSummaryOperand.max(data);
         * ```
         * \@memberof IgxNumberSummaryOperand
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "max",
        value: function max(data) {
          return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) {
            return Math.max(a, b);
          }) : 0;
        }
        /**
         * Returns the sum of the numeric values in the provided data records.
         * If filtering is applied, returns the sum of the numeric values in the data records.
         * ```typescript
         * IgxNumberSummaryOperand.sum(data);
         * ```
         * \@memberof IgxNumberSummaryOperand
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "sum",
        value: function sum(data) {
          return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) {
            return +a + +b;
          }) : 0;
        }
        /**
         * Returns the average numeric value in the data provided data records.
         * If filtering is applied, returns the average numeric value in the filtered data records.
         * ```typescript
         * IgxSummaryOperand.average(data);
         * ```
         * \@memberof IgxNumberSummaryOperand
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "average",
        value: function average(data) {
          return data.length && data.filter(clear).length ? this.sum(data) / this.count(data) : 0;
        }
      }]);

      return IgxNumberSummaryOperand;
    }(IgxSummaryOperand); // @dynamic


    var IgxDateSummaryOperand =
    /*#__PURE__*/
    function (_IgxSummaryOperand2) {
      _inherits(IgxDateSummaryOperand, _IgxSummaryOperand2);

      function IgxDateSummaryOperand() {
        _classCallCheck(this, IgxDateSummaryOperand);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxDateSummaryOperand).apply(this, arguments));
      }

      _createClass(IgxDateSummaryOperand, [{
        key: "operate",

        /**
         * Executes the static methods and returns `IgxSummaryResult[]`.
         * ```typescript
         * interface IgxSummaryResult {
         *   key: string;
         *   label: string;
         *   summaryResult: any;
         * }
         * ```
         * Can be overridden in the inherited classes to provide customization for the `summary`.
         * ```typescript
         * class CustomDateSummary extends IgxDateSummaryOperand {
         *   constructor() {
         *     super();
         *   }
         *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
         *     const result = [];
         *     result.push({
         *       key: "latest",
         *       label: "Latest Date",
         *       summaryResult: IgxDateSummaryOperand.latest(data)
         *     });
         *     return result;
         *   }
         * }
         * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
         * ```
         * \@memberof IgxDateSummaryOperand
         * @param {?=} data
         * @param {?=} allData
         * @param {?=} fieldName
         * @return {?}
         */
        value: function operate() {
          var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var allData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var fieldName = arguments.length > 2 ? arguments[2] : undefined;

          /** @type {?} */
          var result = _get(_getPrototypeOf(IgxDateSummaryOperand.prototype), "operate", this).call(this, data, allData, fieldName);

          result.push({
            key: 'earliest',
            label: 'Earliest',
            summaryResult: IgxDateSummaryOperand.earliest(data)
          });
          result.push({
            key: 'latest',
            label: 'Latest',
            summaryResult: IgxDateSummaryOperand.latest(data)
          });
          return result;
        }
      }], [{
        key: "latest",

        /**
         * Returns the latest date value in the data records.
         * If filtering is applied, returns the latest date value in the filtered data records.
         * ```typescript
         * IgxDateSummaryOperand.latest(data);
         * ```
         * \@memberof IgxDateSummaryOperand
         * @param {?} data
         * @return {?}
         */
        value: function latest(data) {
          return data.length && data.filter(clear).length ? first(data.filter(clear).sort(function (a, b) {
            return new Date(b).valueOf() - new Date(a).valueOf();
          })) : undefined;
        }
        /**
         * Returns the earliest date value in the data records.
         * If filtering is applied, returns the latest date value in the filtered data records.
         * ```typescript
         * IgxDateSummaryOperand.earliest(data);
         * ```
         * \@memberof IgxDateSummaryOperand
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "earliest",
        value: function earliest(data) {
          return data.length && data.filter(clear).length ? last(data.filter(clear).sort(function (a, b) {
            return new Date(b).valueOf() - new Date(a).valueOf();
          })) : undefined;
        }
      }]);

      return IgxDateSummaryOperand;
    }(IgxSummaryOperand);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxFilterCellTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxFilterCellTemplateDirective(template) {
      _classCallCheck(this, IgxFilterCellTemplateDirective);

      this.template = template;
    };

    IgxFilterCellTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxFilterCellTemplate]'
      }]
    }];
    /** @nocollapse */

    IgxFilterCellTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxCellTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxCellTemplateDirective(template) {
      _classCallCheck(this, IgxCellTemplateDirective);

      this.template = template;
    };

    IgxCellTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCell]'
      }]
    }];
    /** @nocollapse */

    IgxCellTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxCellHeaderTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxCellHeaderTemplateDirective(template) {
      _classCallCheck(this, IgxCellHeaderTemplateDirective);

      this.template = template;
    };

    IgxCellHeaderTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxHeader]'
      }]
    }];
    /** @nocollapse */

    IgxCellHeaderTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxCellFooterTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxCellFooterTemplateDirective(template) {
      _classCallCheck(this, IgxCellFooterTemplateDirective);

      this.template = template;
    };

    IgxCellFooterTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxFooter]'
      }]
    }];
    /** @nocollapse */

    IgxCellFooterTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxCellEditorTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxCellEditorTemplateDirective(template) {
      _classCallCheck(this, IgxCellEditorTemplateDirective);

      this.template = template;
    };

    IgxCellEditorTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxCellEditor]'
      }]
    }];
    /** @nocollapse */

    IgxCellEditorTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * **Ignite UI for Angular Column** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html#columns-configuration)
     *
     * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
     * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
     * the column using `ng-template` which will be used for all cells within the column.
     */


    var IgxColumnComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       * @param {?} cdr
       * @param {?} rowIslandAPI
       */
      function IgxColumnComponent(gridAPI, cdr, rowIslandAPI) {
        _classCallCheck(this, IgxColumnComponent);

        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.rowIslandAPI = rowIslandAPI;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * \@memberof IgxColumnComponent
         */

        this.header = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.resizable = false;
        /**
         * @hidden
         */

        this.hiddenChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         * \@memberof IgxColumnComponent
         */

        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         * \@memberof IgxColumnComponent
         */

        this.disablePinning = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.movable = false;
        /**
         * @hidden
         */

        this.widthChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._calcWidth = null;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.headerClasses = '';
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * \@memberof IgxColumnComponent
         */

        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.sortingIgnoreCase = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.dataType = DataType.String;
        /**
         * @hidden
         */

        this.pinnedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */

        this.searchable = true;
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         * \@memberof IgxColumnComponent
         */

        this.parent = null;
        /**
         * @hidden
         */

        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */

        this._pinned = false;
        /**
         * @hidden
         */

        this._summaries = null;
        /**
         * @hidden
         */

        this._filters = null;
        /**
         * @hidden
         */

        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */

        this._hidden = false;
        /**
         * @hidden
         */

        this._disablePinning = false;
        /**
         * @hidden
         */

        this._defaultMinWidth = '';
        /**
         * @hidden
         */

        this._hasSummary = false;
        this._vIndex = NaN;
      }
      /**
       * Gets whether the column is editable.
       * Default value is `false`.
       * ```typescript
       * let isEditable = this.column.editable;
       * ```
       * \@memberof IgxColumnComponent
       * @return {?}
       */


      _createClass(IgxColumnComponent, [{
        key: "resetCaches",

        /**
         * @hidden
         * \@internal
         * @return {?}
         */
        value: function resetCaches() {
          this._vIndex = NaN;

          if (this.grid) {
            this.cacheCalcWidth();
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
          }

          if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
          }

          if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
          }

          if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
          }

          if (!this.summaries) {
            switch (this.dataType) {
              case DataType.String:
              case DataType.Boolean:
                this.summaries = IgxSummaryOperand;
                break;

              case DataType.Number:
                this.summaries = IgxNumberSummaryOperand;
                break;

              case DataType.Date:
                this.summaries = IgxDateSummaryOperand;
                break;

              default:
                this.summaries = IgxSummaryOperand;
                break;
            }
          }

          if (!this.filters) {
            switch (this.dataType) {
              case DataType.Boolean:
                this.filters = IgxBooleanFilteringOperand.instance();
                break;

              case DataType.Number:
                this.filters = IgxNumberFilteringOperand.instance();
                break;

              case DataType.Date:
                this.filters = IgxDateFilteringOperand.instance();
                break;

              case DataType.String:
              default:
                this.filters = IgxStringFilteringOperand.instance();
                break;
            }
          }
        }
        /**
         * @hidden
         * @param {?} isRow
         * @param {?} isIE
         * @return {?}
         */

      }, {
        key: "getGridTemplate",
        value: function getGridTemplate(isRow, isIE) {
          if (isRow) {
            /** @type {?} */
            var rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ? "(1fr)[".concat(rowsCount, "]") : "repeat(".concat(rowsCount, ",1fr)");
          } else {
            return this.getColumnSizesString(this.children);
          }
        }
        /**
         * @param {?} children
         * @return {?}
         */

      }, {
        key: "getInitialChildColumnSizes",
        value: function getInitialChildColumnSizes(children) {
          var _this164 = this;

          /** @type {?} */
          var columnSizes = []; // find the smallest col spans

          children.forEach(function (col) {
            if (!col.colStart) {
              return;
            }
            /** @type {?} */


            var newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */

            var newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            /** @type {?} */

            var bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */

            var bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;

            if (columnSizes[col.colStart - 1] === undefined) {
              // If nothing is defined yet take any column at first
              // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
              columnSizes[col.colStart - 1] = {
                ref: col,
                width: col.widthSetByUser || _this164.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                colSpan: col.gridColumnSpan,
                colEnd: col.colStart + col.gridColumnSpan,
                widthSetByUser: col.widthSetByUser
              };
            } else if (newWidthSet || newSpanSmaller && (bothWidthsSet || bothWidthsNotSet)) {
              // If a column is set already it should either not have width defined or have width with bigger span than the new one.

              /**
               *  If replaced column has bigger span, we want to fill the remaining columns
               *  that the replacing column does not fill with the old one.
               **/
              if (bothWidthsSet && newSpanSmaller) {
                // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                // We have not yet replaced it so we can use it directly from the columnSizes collection.
                // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                for (var i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                  if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                    columnSizes[i] = columnSizes[col.colStart - 1];
                  } else {
                    break;
                  }
                }
              } // Replace the old column with the new one.


              columnSizes[col.colStart - 1] = {
                ref: col,
                width: col.widthSetByUser || _this164.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                colSpan: col.gridColumnSpan,
                colEnd: col.colStart + col.gridColumnSpan,
                widthSetByUser: col.widthSetByUser
              };
            } else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
              // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
              // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
              // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
              for (var _i16 = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; _i16 < col.colStart - 1 + col.gridColumnSpan; _i16++) {
                if (!columnSizes[_i16] || !columnSizes[_i16].widthSetByUser) {
                  columnSizes[_i16] = {
                    ref: col,
                    width: col.widthSetByUser || _this164.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                  };
                } else {
                  break;
                }
              }
            }
          }); // Flatten columnSizes so there are not columns with colSpan > 1

          for (var i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
              /** @type {?} */
              var j = 1; // Replace all empty places depending on how much the current column spans starting from next col.

              for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                if (columnSizes[i + j] && (!columnSizes[i].width && columnSizes[i + j].width || !columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan || !!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan)) {
                  // If we reach an already defined column that has width and the current doesn't have or
                  // if the reached column has bigger colSpan we stop.
                  break;
                } else {
                  /** @type {?} */
                  var width = columnSizes[i].widthSetByUser ? columnSizes[i].width / columnSizes[i].colSpan : columnSizes[i].width;
                  columnSizes[i + j] = {
                    ref: columnSizes[i].ref,
                    width: width,
                    colSpan: 1,
                    colEnd: columnSizes[i].colEnd,
                    widthSetByUser: columnSizes[i].widthSetByUser
                  };
                }
              } // Update the current column width so it is divided between all columns it spans and set it to 1.


              columnSizes[i].width = columnSizes[i].widthSetByUser ? columnSizes[i].width / columnSizes[i].colSpan : columnSizes[i].width;
              columnSizes[i].colSpan = 1; // Update the index based on how much we have replaced. Subtract 1 because we started from 1.

              i += j - 1;
            }
          }

          return columnSizes;
        }
        /**
         * @param {?} children
         * @return {?}
         */

      }, {
        key: "getFilledChildColumnSizes",
        value: function getFilledChildColumnSizes(children) {
          /** @type {?} */
          var columnSizes = this.getInitialChildColumnSizes(children); // fill the gaps if there are any

          /** @type {?} */

          var result = [];

          for (var i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && !!columnSizes[i].width) {
              result.push(columnSizes[i].width + 'px');
            } else {
              result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
          }

          return result;
        }
        /**
         * @protected
         * @param {?} children
         * @return {?}
         */

      }, {
        key: "getColumnSizesString",
        value: function getColumnSizesString(children) {
          /** @type {?} */
          var res = this.getFilledChildColumnSizes(children);
          return res.join(' ');
        }
        /**
         * @return {?}
         */

      }, {
        key: "getResizableColUnderEnd",
        value: function getResizableColUnderEnd() {
          if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{
              target: this,
              spanUsed: 1
            }];
          }
          /** @type {?} */


          var columnSized = this.getInitialChildColumnSizes(this.parent.children);
          /** @type {?} */

          var targets = [];
          /** @type {?} */

          var colEnd = this.colEnd ? this.colEnd : this.colStart + 1;

          for (var i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
              targets.push({
                target: columnSized[i].ref,
                spanUsed: 1
              });
            }
          }
          /** @type {?} */


          var targetsSquashed = [];

          for (var j = 0; j < targets.length; j++) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === targets[j].target.field) {
              targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            } else {
              targetsSquashed.push(targets[j]);
            }
          }

          return targetsSquashed;
        }
        /**
         * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
         * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
         * Column cannot be pinned if:
         * - Is already pinned
         * - index argument is out of range
         * - The pinned area exceeds 80% of the grid width
         * ```typescript
         * let success = this.column.pin();
         * ```
         * \@memberof IgxColumnComponent
         * @param {?=} index
         * @return {?}
         */

      }, {
        key: "pin",
        value: function pin(index) {
          // TODO: Probably should the return type of the old functions
          // should be moved as a event parameter.
          if (this.grid) {
            this.grid.endEdit(true);
          }

          if (this._pinned) {
            return false;
          }

          if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
          }
          /** @type {?} */


          var grid =
          /** @type {?} */
          this.grid;
          /** @type {?} */

          var hasIndex = index !== undefined;

          if (hasIndex && (index < 0 || index >= grid.pinnedColumns.length)) {
            return false;
          }

          if (!this.parent && !this.pinnable) {
            return false;
          }

          this._pinned = true;
          this.pinnedChange.emit(this._pinned);
          this._unpinnedIndex = grid._unpinnedColumns.indexOf(this);
          index = index !== undefined ? index : grid._pinnedColumns.length;
          /** @type {?} */

          var targetColumn = grid._pinnedColumns[index];
          /** @type {?} */

          var args = {
            column: this,
            insertAtIndex: index,
            isPinned: true
          };
          grid.onColumnPinning.emit(args);

          if (grid._pinnedColumns.indexOf(this) === -1) {
            grid._pinnedColumns.splice(args.insertAtIndex, 0, this);

            if (grid._unpinnedColumns.indexOf(this) !== -1) {
              grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1);
            }
          }

          if (hasIndex) {
            grid._moveColumns(this, targetColumn);
          }

          if (this.columnGroup) {
            this.allChildren.forEach(function (child) {
              return child.pin();
            });
            grid.reinitPinStates();
          }

          grid.resetCaches();
          grid.notifyChanges();

          if (this.columnLayoutChild) {
            this.grid.columns.filter(function (x) {
              return x.columnLayout;
            }).forEach(function (x) {
              return x.populateVisibleIndexes();
            });
          }

          this.grid.filteringService.refreshExpressions(); // this.grid.refreshSearch(true);

          return true;
        }
        /**
         * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
         * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
         * Column cannot be unpinned if:
         * - Is already unpinned
         * - index argument is out of range
         * ```typescript
         * let success = this.column.unpin();
         * ```
         * \@memberof IgxColumnComponent
         * @param {?=} index
         * @return {?}
         */

      }, {
        key: "unpin",
        value: function unpin(index) {
          if (this.grid) {
            this.grid.endEdit(true);
          }

          if (!this._pinned) {
            return false;
          }

          if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
          }
          /** @type {?} */


          var grid =
          /** @type {?} */
          this.grid;
          /** @type {?} */

          var hasIndex = index !== undefined;

          if (hasIndex && (index < 0 || index >= grid._unpinnedColumns.length)) {
            return false;
          }

          index = index !== undefined ? index : this._unpinnedIndex !== undefined ? this._unpinnedIndex : this.index;
          this._pinned = false;
          this.pinnedChange.emit(this._pinned);
          /** @type {?} */

          var targetColumn = grid._unpinnedColumns[index];

          grid._unpinnedColumns.splice(index, 0, this);

          if (grid._pinnedColumns.indexOf(this) !== -1) {
            grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
          }

          if (hasIndex) {
            grid._moveColumns(this, targetColumn);
          }

          if (this.columnGroup) {
            this.allChildren.forEach(function (child) {
              return child.unpin();
            });
          }

          grid.reinitPinStates();
          grid.resetCaches();
          /** @type {?} */

          var insertAtIndex = grid._unpinnedColumns.indexOf(this);
          /** @type {?} */


          var args = {
            column: this,
            insertAtIndex: insertAtIndex,
            isPinned: false
          };
          grid.onColumnPinning.emit(args);
          grid.notifyChanges();

          if (this.columnLayoutChild) {
            this.grid.columns.filter(function (x) {
              return x.columnLayout;
            }).forEach(function (x) {
              return x.populateVisibleIndexes();
            });
          }

          this.grid.filteringService.refreshExpressions(); // this.grid.refreshSearch(true);

          return true;
        }
        /**
         * Returns a reference to the top level parent column.
         * ```typescript
         * let topLevelParent =  this.column.topLevelParent;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "autosize",

        /**
         * Autosize the column to the longest currently visible cell value, including the header cell.
         * ```typescript
         * \@ViewChild('grid') grid: IgxGridComponent;
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * column.autosize();
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        value: function autosize() {
          if (!this.columnGroup) {
            this.width = this.getLargestCellWidth();
            this.grid.reflow();
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getCalcWidth",
        value: function getCalcWidth() {
          if (this._calcWidth !== null && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
          }

          this.cacheCalcWidth();
          return this._calcWidth;
        }
        /**
         * @hidden
         * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
         * ```typescript
         * \@ViewChild('grid') grid: IgxGridComponent;
         *
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let size = column.getLargestCellWidth();
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "getLargestCellWidth",
        value: function getLargestCellWidth() {
          /** @type {?} */
          var range = this.grid.document.createRange();
          /** @type {?} */

          var largest = new Map();

          if (this.cells.length > 0) {
            /** @type {?} */
            var cellsContentWidths = [];

            if (this.cells[0].nativeElement.children.length > 0) {
              this.cells.forEach(function (cell) {
                return cellsContentWidths.push(cell.calculateSizeToFit(range));
              });
            } else {
              cellsContentWidths = this.cells.map(function (cell) {
                return getNodeSizeViaRange(range, cell.nativeElement);
              });
            }
            /** @type {?} */


            var index = cellsContentWidths.indexOf(Math.max.apply(Math, _toConsumableArray(cellsContentWidths)));
            /** @type {?} */

            var cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            /** @type {?} */

            var cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) + parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max.apply(Math, _toConsumableArray(cellsContentWidths)), cellPadding);
          }

          if (this.headerCell) {
            /** @type {?} */
            var headerCell;

            if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
              headerCell = Math.max.apply(Math, _toConsumableArray(Array.from(this.headerCell.elementRef.nativeElement.children[0].children).map(function (child) {
                return getNodeSizeViaRange(range, child);
              })));
            } else {
              headerCell = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
            }

            if (this.sortable || this.filterable) {
              headerCell += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
            }
            /** @type {?} */


            var headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
            /** @type {?} */

            var headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) + parseFloat(headerStyle.borderRightWidth);
            largest.set(headerCell, headerPadding);
          }
          /** @type {?} */


          var largestCell = Math.max.apply(Math, _toConsumableArray(Array.from(largest.keys())));
          /** @type {?} */

          var width = Math.ceil(largestCell + largest.get(largestCell));

          if (Number.isNaN(width)) {
            return this.width;
          } else {
            return width + 'px';
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getCellWidth",
        value: function getCellWidth() {
          /** @type {?} */
          var colWidth = this.width;
          /** @type {?} */

          var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;

          if (this.columnLayoutChild) {
            return '';
          }

          if (colWidth && !isPercentageWidth) {
            /** @type {?} */
            var cellWidth = colWidth;

            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
              cellWidth += 'px';
            }

            return cellWidth;
          } else {
            return colWidth;
          }
        }
        /**
         * @hidden
         * \@internal
         * @protected
         * @return {?}
         */

      }, {
        key: "cacheCalcWidth",
        value: function cacheCalcWidth() {
          /** @type {?} */
          var grid = this.gridAPI.grid;
          /** @type {?} */

          var colWidth = this.width;
          /** @type {?} */

          var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;

          if (isPercentageWidth) {
            this._calcWidth = parseInt(colWidth, 10) / 100 * (grid.calcWidth - grid.featureColumnsWidth);
          } else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
          } else {
            this._calcWidth = this.width;
          }

          this.calcPixelWidth = parseInt(this._calcWidth, 10);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "populateVisibleIndexes",

        /**
         * @hidden
         * @return {?}
         */
        value: function populateVisibleIndexes() {}
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
      }, {
        key: "editable",
        get: function get() {
          // Updating the primary key when grid has transactions (incl. row edit)
          // should not be allowed, as that can corrupt transaction state.

          /** @type {?} */
          var rowEditable = this.grid && this.grid.rowEditable;
          /** @type {?} */

          var hasTransactions = this.grid && this.grid.transactions.enabled;

          if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
            return false;
          }

          if (this._editable !== undefined) {
            return this._editable;
          } else {
            return rowEditable;
          }
        }
        /**
         * Sets whether the column is editable.
         * ```typescript
         * this.column.editable = true;
         * ```
         * ```html
         * <igx-column [editable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} editable
         * @return {?}
         */
        ,
        set: function set(editable) {
          this._editable = editable;
        }
        /**
         * Gets a value indicating whether the summary for the column is enabled.
         * ```typescript
         * let hasSummary = this.column.hasSummary;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "hasSummary",
        get: function get() {
          return this._hasSummary;
        }
        /**
         * Sets a value indicating whether the summary for the column is enabled.
         * Default value is `false`.
         * ```html
         * <igx-column [hasSummary] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._hasSummary = value;

          if (this.grid) {
            this.grid.summaryService.resetSummaryHeight();
          }
        }
        /**
         * Gets whether the column is hidden.
         * ```typescript
         * let isHidden = this.column.hidden;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "hidden",
        get: function get() {
          return this._hidden;
        }
        /**
         * Sets the column hidden property.
         * Default value is `false`.
         * ```html
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-column [(hidden)] = "model.isHidden"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._hidden !== value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);

            if (this.columnLayoutChild && this.parent.hidden !== value) {
              this.parent.hidden = value;
              return;
            }

            if (this.grid) {
              this.grid.endEdit(false);
              this.grid.summaryService.resetSummaryHeight();
              this.grid.filteringService.refreshExpressions();
              this.grid.notifyChanges(); // this.grid.refreshSearch(true);
            }
          }
        }
        /**
         * Gets the `width` of the column.
         * ```typescript
         * let columnWidth = this.column.width;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "width",
        get: function get() {
          return this.widthSetByUser ? this._width : this.defaultWidth;
        }
        /**
         * Sets the `width` of the column.
         * ```html
         * <igx-column [width] = "'25%'"></igx-column>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-column [(width)]="model.columns[0].width"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            this._width = value;

            if (this.grid) {
              this.cacheCalcWidth();
            }

            this.widthChange.emit(this._width);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "calcWidth",
        get: function get() {
          return this.getCalcWidth();
        }
        /**
         * Sets/gets the minimum `width` of the column.
         * Default value is `88`;
         * ```typescript
         * let columnMinWidth = this.column.minWidth;
         * ```
         * ```html
         * <igx-column [minWidth] = "'15%'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "minWidth",
        set: function set(value) {
          /** @type {?} */
          var minVal = parseFloat(value);

          if (Number.isNaN(minVal)) {
            return;
          }

          this._defaultMinWidth = value;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
        }
        /**
         * Gets the column index.
         * ```typescript
         * let columnIndex = this.column.index;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "index",
        get: function get() {
          return this.grid.columns.indexOf(this);
        }
        /**
         * Gets whether the column is `pinned`.
         * ```typescript
         * let isPinned = this.column.pinned;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "pinned",
        get: function get() {
          return this._pinned;
        }
        /**
         * Sets whether the column is pinned.
         * Default value is `false`.
         * ```html
         * <igx-column [pinned] = "true"></igx-column>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._pinned !== value) {
            if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
              value ? this.pin() : this.unpin();
              return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */


            this._pinned = value;
            this.pinnedChange.emit(this._pinned);
          }
        }
        /**
         * Gets the column `summaries`.
         * ```typescript
         * let columnSummaries = this.column.summaries;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "summaries",
        get: function get() {
          return this._summaries;
        }
        /**
         * Sets the column `summaries`.
         * ```typescript
         * this.column.summaries = IgxNumberSummaryOperand;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} classRef
         * @return {?}
         */
        ,
        set: function set(classRef) {
          this._summaries = new classRef();

          if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            /** @type {?} */this.grid._summaryPipeTrigger++;
            this.grid.summaryService.resetSummaryHeight();
          }
        }
        /**
         * Gets the column `filters`.
         * ```typescript
         * let columnFilters = this.column.filters'
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "filters",
        get: function get() {
          return this._filters;
        }
        /**
         * Sets the column `filters`.
         * ```typescript
         * this.column.filters = IgxBooleanFilteringOperand.instance().
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} instance
         * @return {?}
         */
        ,
        set: function set(instance) {
          this._filters = instance;
        }
        /**
         * Gets the column `sortStrategy`.
         * ```typescript
         * let sortStrategy = this.column.sortStrategy
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "sortStrategy",
        get: function get() {
          return this._sortStrategy;
        }
        /**
         * Sets the column `sortStrategy`.
         * ```typescript
         * this.column.sortStrategy = new CustomSortingStrategy().
         * class CustomSortingStrategy extends SortingStrategy {...}
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} classRef
         * @return {?}
         */
        ,
        set: function set(classRef) {
          this._sortStrategy = classRef;
        }
        /**
         * Gets the function that compares values for grouping.
         * ```typescript
         * let groupingComparer = this.column.groupingComparer'
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "groupingComparer",
        get: function get() {
          return this._groupingComparer;
        }
        /**
         * Sets a custom function to compare values for grouping.
         * Subsequent values in the sorted data that the function returns 0 for are grouped.
         * ```typescript
         * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} funcRef
         * @return {?}
         */
        ,
        set: function set(funcRef) {
          this._groupingComparer = funcRef;
        }
        /**
         * Gets the default minimum `width` of the column.
         * ```typescript
         * let defaultMinWidth =  this.column.defaultMinWidth;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "defaultMinWidth",
        get: function get() {
          if (!this.grid) {
            return '80';
          }

          switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
              return '64';

            case DisplayDensity.compact:
              return '56';

            default:
              return '80';
          }
        }
        /**
         * The reference to the `igx-grid` owner.
         * ```typescript
         * let gridComponent = this.column.grid;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "grid",
        get: function get() {
          return this.gridAPI.grid;
        }
        /**
         * Returns a reference to the `bodyTemplate`.
         * ```typescript
         * let bodyTemplate = this.column.bodyTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "bodyTemplate",
        get: function get() {
          return this._bodyTemplate;
        }
        /**
         * Sets the body template.
         * ```html
         * <ng-template #bodyTemplate igxCell let-val>
         *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
         *       <span> {{val}} </span>
         *    </div>
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'bodyTemplate'", {read: TemplateRef })
         * public bodyTemplate: TemplateRef<any>;
         * this.column.bodyTemplate = this.bodyTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {
          this._bodyTemplate = template;
        }
        /**
         * Returns a reference to the header template.
         * ```typescript
         * let headerTemplate = this.column.headerTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "headerTemplate",
        get: function get() {
          return this._headerTemplate;
        }
        /**
         * Sets the header template.
         * Note that the column header height is fixed and any content bigger than it will be cut off.
         * ```html
         * <ng-template #headerTemplate>
         *   <div style = "background-color:black" (click) = "changeColor(val)">
         *       <span style="color:red" >{{column.field}}</span>
         *   </div>
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'headerTemplate'", {read: TemplateRef })
         * public headerTemplate: TemplateRef<any>;
         * this.column.headerTemplate = this.headerTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {
          this._headerTemplate = template;
        }
        /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.column.inlineEditorTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "inlineEditorTemplate",
        get: function get() {
          return this._inlineEditorTemplate;
        }
        /**
         * Sets the inline editor template.
         * ```html
         * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
         *     <input type="string" [(ngModel)]="cell.value"/>
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
         * public inlineEditorTemplate: TemplateRef<any>;
         * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {
          this._inlineEditorTemplate = template;
        }
        /**
         * Returns a reference to the `filterCellTemplate`.
         * ```typescript
         * let filterCellTemplate = this.column.filterCellTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "filterCellTemplate",
        get: function get() {
          return this._filterCellTemplate;
        }
        /**
         * Sets the quick filter template.
         * ```html
         * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
         *    <input (input)="onInput()">
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'filterCellTemplate'", {read: TemplateRef })
         * public filterCellTemplate: TemplateRef<any>;
         * this.column.filterCellTemplate = this.filterCellTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {
          this._filterCellTemplate = template;
        }
        /**
         * Gets the cells of the column.
         * ```typescript
         * let columnCells =  this.column.cells;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "cells",
        get: function get() {
          var _this165 = this;

          return this.grid.rowList.filter(function (row) {
            return row instanceof IgxRowComponent;
          }).map(function (row) {
            if (row.cells) {
              return row.cells.filter(function (cell) {
                return cell.columnIndex === _this165.index;
              });
            }
          }).reduce(function (a, b) {
            return a.concat(b);
          }, []);
        }
        /**
         * Gets the column visible index.
         * If the column is not visible, returns `-1`.
         * ```typescript
         * let visibleColumnIndex =  this.column.visibleIndex;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "visibleIndex",
        get: function get() {
          var _this166 = this;

          if (!isNaN(this._vIndex)) {
            return this._vIndex;
          }
          /** @type {?} */


          var unpinnedColumns = this.grid.unpinnedColumns.filter(function (c) {
            return !c.columnGroup;
          });
          /** @type {?} */

          var pinnedColumns = this.grid.pinnedColumns.filter(function (c) {
            return !c.columnGroup;
          });
          /** @type {?} */

          var col = this;
          /** @type {?} */

          var vIndex = -1;

          if (this.columnGroup) {
            col =
            /** @type {?} */
            this.allChildren.filter(function (c) {
              return !c.columnGroup;
            })[0];
          }

          if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(function (x) {
              return x.column === _this166;
            }).index;
          }

          if (!this.pinned) {
            /** @type {?} */
            var indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
          } else {
            vIndex = pinnedColumns.indexOf(col);
          }

          this._vIndex = vIndex;
          return vIndex;
        }
        /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "columnGroup",
        get: function get() {
          return false;
        }
        /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "columnLayout",
        get: function get() {
          return false;
        }
        /**
         * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnLayoutChild =  this.column.columnLayoutChild;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "columnLayoutChild",
        get: function get() {
          return this.parent && this.parent.columnLayout;
        }
        /**
         * Returns the children columns collection.
         * Returns an empty array if the column does not contain children columns.
         * ```typescript
         * let childrenColumns =  this.column.allChildren;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "allChildren",
        get: function get() {
          return [];
        }
        /**
         * Returns the level of the column in a column group.
         * Returns `0` if the column doesn't have a `parent`.
         * ```typescript
         * let columnLevel =  this.column.level;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "level",
        get: function get() {
          /** @type {?} */
          var ptr = this.parent;
          /** @type {?} */

          var lvl = 0;

          while (ptr) {
            lvl++;
            ptr = ptr.parent;
          }

          return lvl;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isLastPinned",
        get: function get() {
          return this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
        }
        /**
         * @return {?}
         */

      }, {
        key: "gridRowSpan",
        get: function get() {
          return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
        }
        /**
         * @return {?}
         */

      }, {
        key: "gridColumnSpan",
        get: function get() {
          return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
        }
        /**
         * Returns the filteringExpressionsTree of the column.
         * ```typescript
         * let tree =  this.column.filteringExpressionsTree;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "filteringExpressionsTree",
        get: function get() {
          return (
            /** @type {?} */
            this.grid.filteringExpressionsTree.find(this.field)
          );
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "isPrimaryColumn",
        get: function get() {
          return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
        }
      }, {
        key: "topLevelParent",
        get: function get() {
          /** @type {?} */
          var parent = this.parent;

          while (parent && parent.parent) {
            parent = parent.parent;
          }

          return parent;
        }
        /**
         * Returns a reference to the header of the column.
         * ```typescript
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let headerCell = column.headerCell;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "headerCell",
        get: function get() {
          var _this167 = this;

          return this.grid.headerCellList.find(function (header) {
            return header.column === _this167;
          });
        }
        /**
         * Returns a reference to the filter cell of the column.
         * ```typescript
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let filterell = column.filterell;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "filterCell",
        get: function get() {
          var _this168 = this;

          return this.grid.filterCellList.find(function (filterCell) {
            return filterCell.column === _this168;
          });
        }
        /**
         * Returns a reference to the header group of the column.
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "headerGroup",
        get: function get() {
          var _this169 = this;

          return this.grid.headerGroupsList.find(function (headerGroup) {
            return headerGroup.column === _this169;
          });
        }
      }, {
        key: "pinnable",
        get: function get() {
          /** @type {?} */
          var gridUnpinnedWidth =
          /** @type {?} */
          this.grid.getUnpinnedWidth(true);
          /** @type {?} */

          var elementWidth = this.parent ? parseInt(this.topLevelParent.width, 10) : parseInt(this.width, 10);
          return (
            /** @type {?} */
            this.grid._init || !(gridUnpinnedWidth - elementWidth < this.grid.unpinnedAreaMinWidth)
          );
        }
      }]);

      return IgxColumnComponent;
    }();

    IgxColumnComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-column',
        template: ""
      }]
    }];
    /** @nocollapse */

    IgxColumnComponent.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxRowIslandAPIService
      }];
    };

    IgxColumnComponent.propDecorators = {
      field: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      header: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      sortable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      groupable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      editable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filterable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      resizable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hasSummary: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hidden: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hiddenChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      disableHiding: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disablePinning: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      movable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      widthChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      maxWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      minWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      headerClasses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      headerGroupClasses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cellClasses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cellStyles: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      formatter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filteringIgnoreCase: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      sortingIgnoreCase: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dataType: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      pinned: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      pinnedChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      summaries: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      searchable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filters: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      sortStrategy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      groupingComparer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      bodyTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['cellTemplate']
      }],
      headerTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      inlineEditorTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['cellEditorTemplate']
      }],
      filterCellTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['filterCellTemplate']
      }],
      rowEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      colEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      colStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cellTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxCellTemplateDirective, {
          read: IgxCellTemplateDirective,
          "static": false
        }]
      }],
      headTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxCellHeaderTemplateDirective, {
          read: IgxCellHeaderTemplateDirective,
          descendants: false
        }]
      }],
      editorTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxCellEditorTemplateDirective, {
          read: IgxCellEditorTemplateDirective,
          "static": false
        }]
      }],
      filterCellTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxFilterCellTemplateDirective, {
          read: IgxFilterCellTemplateDirective,
          "static": false
        }]
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "header", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "sortable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(true), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "groupable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxColumnComponent.prototype, "editable", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "filterable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "resizable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(true), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxColumnComponent.prototype, "hasSummary", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(true), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxColumnComponent.prototype, "hidden", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "disableHiding", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "disablePinning", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchColumnChanges(), notifyChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "movable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(true), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxColumnComponent.prototype, "width", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String)], IgxColumnComponent.prototype, "maxWidth", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxColumnComponent.prototype, "minWidth", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "headerClasses", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "cellClasses", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "cellStyles", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Function)], IgxColumnComponent.prototype, "formatter", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxColumnComponent.prototype, "pinned", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("The property is deprecated. Please, use `column.grid.id` instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String)], IgxColumnComponent.prototype, "gridID", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(true), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxColumnComponent.prototype, "summaries", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxColumnComponent.prototype, "searchable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]])], IgxColumnComponent.prototype, "bodyTemplate", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]])], IgxColumnComponent.prototype, "headerTemplate", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]])], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([notifyChanges(), WatchColumnChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]])], IgxColumnComponent.prototype, "filterCellTemplate", null);

    var IgxColumnGroupComponent =
    /*#__PURE__*/
    function (_IgxColumnComponent) {
      _inherits(IgxColumnGroupComponent, _IgxColumnComponent);

      /**
       * @param {?} gridAPI
       * @param {?} cdr
       * @param {?} rowIslandAPI
       */
      function IgxColumnGroupComponent(gridAPI, cdr, rowIslandAPI) {
        var _this170;

        _classCallCheck(this, IgxColumnGroupComponent);

        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        _this170 = _possibleConstructorReturn(this, _getPrototypeOf(IgxColumnGroupComponent).call(this, gridAPI, cdr, rowIslandAPI));
        _this170.gridAPI = gridAPI;
        _this170.cdr = cdr;
        _this170.rowIslandAPI = rowIslandAPI;
        _this170.children = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * Sets/gets whether the column group is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.columnGroup.searchable;
         * ```
         * ```html
         *  <igx-column-group [searchable] = "false"></igx-column-group>
         * ```
         * \@memberof IgxColumnGroupComponent
         */

        _this170.searchable = true;
        /**
         * @hidden
         */

        _this170.hiddenChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this170;
      }
      /**
       * Gets the column group `summaries`.
       * ```typescript
       * let columnGroupSummaries = this.columnGroup.summaries;
       * ```
       * \@memberof IgxColumnGroupComponent
       * @return {?}
       */


      _createClass(IgxColumnGroupComponent, [{
        key: "ngAfterContentInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this171 = this;

          /*
              @ContentChildren with descendants still returns the `parent`
              component in the query list.
          */
          if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
          }

          this.children.reset(this.children.toArray().slice(1));
          this.children.forEach(function (child) {
            child.parent = _this171;
          });
          /*
              TO DO: In Angular 9 this need to be removed, because the @ContentChildren will not return the `parent`
              component in the query list.
          */

          this.children.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (change) {
            if (change.first === _this171) {
              _this171.children.reset(_this171.children.toArray().slice(1));

              _this171.children.forEach(function (child) {
                child.parent = _this171;
              });
            }
          });
        }
        /**
         * Returns the children columns collection.
         * ```typescript
         * let columns =  this.columnGroup.allChildren;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */

      }, {
        key: "summaries",
        get: function get() {
          return this._summaries;
        }
        /**
         * Sets the column group `summaries`.
         * ```typescript
         * this.columnGroup.summaries = IgxNumberSummaryOperand;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} classRef
         * @return {?}
         */
        ,
        set: function set(classRef) {}
        /**
         * Gets the column group `filters`.
         * ```typescript
         * let columnGroupFilters = this.columnGroup.filters;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */

      }, {
        key: "filters",
        get: function get() {
          return this._filters;
        }
        /**
         * Sets the column group `filters`.
         * ```typescript
         * this.columnGroup.filters = IgxStringFilteringOperand;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} classRef
         * @return {?}
         */
        ,
        set: function set(classRef) {}
        /**
         * Returns a reference to the body template.
         * ```typescript
         * let bodyTemplate = this.columnGroup.bodyTemplate;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */

      }, {
        key: "bodyTemplate",
        get: function get() {
          return this._bodyTemplate;
        }
        /**
         * @hidden
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {}
        /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */

      }, {
        key: "inlineEditorTemplate",
        get: function get() {
          return this._inlineEditorTemplate;
        }
        /**
         * @hidden
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {}
        /**
         * Gets the column group cells.
         * ```typescript
         * let columnCells = this.columnGroup.cells;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */

      }, {
        key: "cells",
        get: function get() {
          return [];
        }
        /**
         * Gets whether the column group is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */

      }, {
        key: "hidden",
        get: function get() {
          return this.allChildren.every(function (c) {
            return c.hidden;
          });
        }
        /**
         * Sets the column group hidden property.
         * ```html
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         *
         * Two-way data binding
         * ```html
         * <igx-column [(hidden)] = "model.columns[0].isHidden"></igx-column>
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._hidden = value;
          this.hiddenChange.emit(this._hidden);
          this.children.forEach(function (child) {
            return child.hidden = value;
          });
        }
      }, {
        key: "allChildren",
        get: function get() {
          return flatten(this.children.toArray());
        }
        /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let isColumnGroup =  this.columnGroup.columnGroup
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */

      }, {
        key: "columnGroup",
        get: function get() {
          return true;
        }
        /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "columnLayout",
        get: function get() {
          return false;
        }
        /**
         * Gets the width of the column group.
         * ```typescript
         * let columnGroupWidth = this.columnGroup.width;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */

      }, {
        key: "width",
        get: function get() {
          /** @type {?} */
          var isChildrenWidthInPercent = false;
          /** @type {?} */

          var width;
          width = "".concat(this.children.reduce(function (acc, val) {
            if (val.hidden) {
              return acc;
            }

            if (typeof val.width === 'string' && val.width.indexOf('%') !== -1) {
              isChildrenWidthInPercent = true;
            }

            return acc + parseInt(val.width, 10);
          }, 0));
          return isChildrenWidthInPercent ? width + '%' : width;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {}
      }]);

      return IgxColumnGroupComponent;
    }(IgxColumnComponent);

    IgxColumnGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: IgxColumnComponent,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxColumnGroupComponent;
          })
        }],
        selector: 'igx-column-group',
        template: ""
      }]
    }];
    /** @nocollapse */

    IgxColumnGroupComponent.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxRowIslandAPIService
      }];
    };

    IgxColumnGroupComponent.propDecorators = {
      children: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxColumnComponent, {
          read: IgxColumnComponent
        }]
      }],
      summaries: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      searchable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filters: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hidden: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hiddenChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };

    var IgxColumnLayoutComponent =
    /*#__PURE__*/
    function (_IgxColumnGroupCompon) {
      _inherits(IgxColumnLayoutComponent, _IgxColumnGroupCompon);

      function IgxColumnLayoutComponent() {
        var _this172;

        _classCallCheck(this, IgxColumnLayoutComponent);

        _this172 = _possibleConstructorReturn(this, _getPrototypeOf(IgxColumnLayoutComponent).apply(this, arguments));
        _this172.childrenVisibleIndexes = [];
        return _this172;
      }
      /**
       * Gets the width of the column layout.
       * ```typescript
       * let columnGroupWidth = this.columnGroup.width;
       * ```
       * \@memberof IgxColumnGroupComponent
       * @return {?}
       */


      _createClass(IgxColumnLayoutComponent, [{
        key: "getCalcWidth",

        /**
         * @hidden
         * @return {?}
         */
        value: function getCalcWidth() {
          /** @type {?} */
          var borderWidth = 0;

          if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {
            /** @type {?} */
            var headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement.children[0]);
            borderWidth = parseInt(headerStyles.borderRightWidth, 10);
          }

          return _get(_getPrototypeOf(IgxColumnLayoutComponent.prototype), "getCalcWidth", this).call(this) + borderWidth;
        }
        /**
         * Gets the column visible index.
         * If the column is not visible, returns `-1`.
         * ```typescript
         * let visibleColumnIndex =  this.column.visibleIndex;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this173 = this;

          _get(_getPrototypeOf(IgxColumnLayoutComponent.prototype), "ngAfterContentInit", this).call(this);

          if (!this.hidden) {
            this.hidden = this.allChildren.some(function (x) {
              return x.hidden;
            });
          } else {
            this.children.forEach(function (child) {
              return child.hidden = _this173.hidden;
            });
          }

          this.children.forEach(function (child) {
            child.movable = false;
          });
        }
        /*
             * Gets whether the group contains the last pinned child column of the column layout.
             * ```typescript
             * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
             * ```
             * @memberof IgxColumnLayoutComponent
             */

        /**
         * @return {?}
         */

      }, {
        key: "populateVisibleIndexes",

        /**
         * @hidden
         * @return {?}
         */
        value: function populateVisibleIndexes() {
          var _this174 = this;

          this.childrenVisibleIndexes = [];
          /** @type {?} */

          var grid = this.gridAPI.grid;
          /** @type {?} */

          var columns = grid && grid.pinnedColumns && grid.unpinnedColumns ? grid.pinnedColumns.concat(grid.unpinnedColumns) : [];
          /** @type {?} */

          var orderedCols = columns.filter(function (x) {
            return !x.columnGroup && !x.hidden;
          }).sort(function (a, b) {
            return a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart;
          });
          this.children.forEach(function (child) {
            /** @type {?} */
            var rs = child.rowStart || 1;
            /** @type {?} */

            var vIndex = 0; // filter out all cols with larger rowStart

            /** @type {?} */

            var cols = orderedCols.filter(function (c) {
              return !c.columnGroup && (c.rowStart || 1) <= rs;
            });
            vIndex = cols.indexOf(child);

            _this174.childrenVisibleIndexes.push({
              column: child,
              index: vIndex
            });
          });
        }
      }, {
        key: "width",
        get: function get() {
          /** @type {?} */
          var width = this.getFilledChildColumnSizes(this.children).reduce(function (acc, val) {
            return acc + parseInt(val, 10);
          }, 0);
          return width;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {}
        /**
         * @return {?}
         */

      }, {
        key: "columnLayout",
        get: function get() {
          return true;
        }
      }, {
        key: "visibleIndex",
        get: function get() {
          if (!isNaN(this._vIndex)) {
            return this._vIndex;
          }
          /** @type {?} */


          var unpinnedColumns = this.grid.unpinnedColumns.filter(function (c) {
            return c.columnLayout && !c.hidden;
          });
          /** @type {?} */

          var pinnedColumns = this.grid.pinnedColumns.filter(function (c) {
            return c.columnLayout && !c.hidden;
          });
          /** @type {?} */

          var vIndex = -1;

          if (!this.pinned) {
            /** @type {?} */
            var indexInCollection = unpinnedColumns.indexOf(this);
            vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
          } else {
            vIndex = pinnedColumns.indexOf(this);
          }

          this._vIndex = vIndex;
          return vIndex;
        }
        /*
             * Gets whether the column layout is hidden.
             * ```typescript
             * let isHidden = this.columnGroup.hidden;
             * ```
             * @memberof IgxColumnGroupComponent
             */

        /**
         * @return {?}
         */

      }, {
        key: "hidden",
        get: function get() {
          return this._hidden;
        }
        /**
         * Sets the column layout hidden property.
         * ```typescript
         * <igx-column-layout [hidden] = "true"></igx-column->
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._hidden = value;
          this.children.forEach(function (child) {
            return child.hidden = value;
          });

          if (this.grid && this.grid.columns && this.grid.columns.length > 0) {
            // reset indexes in case columns are hidden/shown runtime
            this.grid.columns.filter(function (x) {
              return x.columnGroup;
            }).forEach(function (x) {
              return x.populateVisibleIndexes();
            });
          }
        }
      }, {
        key: "hasLastPinnedChildColumn",
        get: function get() {
          return this.children.some(function (child) {
            return child.isLastPinned;
          });
        }
      }]);

      return IgxColumnLayoutComponent;
    }(IgxColumnGroupComponent);

    IgxColumnLayoutComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        providers: [{
          provide: IgxColumnComponent,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxColumnLayoutComponent;
          })
        }],
        selector: 'igx-column-layout',
        template: ""
      }]
    }];
    IgxColumnLayoutComponent.propDecorators = {
      hidden: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxColumnResizingService =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} zone
       */
      function IgxColumnResizingService(zone) {
        _classCallCheck(this, IgxColumnResizingService);

        this.zone = zone;
        /**
         * @hidden
         */

        this.resizeCursor = null;
        /**
         * @hidden
         */

        this.showResizer = false;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxColumnResizingService, [{
        key: "autosizeColumnOnDblClick",

        /**
         * Autosizes the column to the longest currently visible cell value, including the header cell.
         * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
         * then the column is sized to its maxWidth.
         * If the column is pinned and the autosized column width will cause the pinned area to become bigger
         * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
         * @return {?}
         */
        value: function autosizeColumnOnDblClick() {
          /** @type {?} */
          var currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
          /** @type {?} */

          var size = this.column.getLargestCellWidth();

          if (this.column.pinned) {
            /** @type {?} */
            var newPinnedWidth = this.column.grid.getPinnedWidth(true) - currentColWidth + parseFloat(size);

            if (newPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
              this.column.width = size;
            }
          } else if (this.column.maxWidth && parseFloat(size) > parseFloat(this.column.maxWidth)) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
          } else if (parseFloat(size) < parseFloat(this.column.minWidth)) {
            this.column.width = this.column.minWidth + 'px';
          } else {
            this.column.width = size;
          }

          this.zone.run(function () {});
          this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
          });
        }
        /**
         * Resizes the column regaridng to the column minWidth and maxWidth.
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "resizeColumn",
        value: function resizeColumn(event) {
          this.showResizer = false;
          /** @type {?} */

          var diff = event.clientX - this.startResizePos;
          /** @type {?} */

          var currentColWidth = parseFloat(this.column.width);
          /** @type {?} */

          var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
          currentColWidth = Number.isNaN(currentColWidth) || currentColWidth < actualWidth ? actualWidth : currentColWidth;
          /** @type {?} */

          var colMinWidth = this.getColMinWidth(this.column);
          /** @type {?} */

          var colMaxWidth = this.getColMaxWidth(this.column);

          if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
          } else {
            if (currentColWidth + diff < colMinWidth) {
              this.column.width = colMinWidth + 'px';
            } else if (colMaxWidth && currentColWidth + diff > colMaxWidth) {
              this.column.width = colMaxWidth + 'px';
            } else {
              this.column.width = currentColWidth + diff + 'px';
            }
          }

          this.zone.run(function () {});

          if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
              column: this.column,
              prevWidth: currentColWidth.toString(),
              newWidth: this.column.width
            });
          }

          this.isColumnResizing = false;
        }
        /**
         * @protected
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "getColMinWidth",
        value: function getColMinWidth(column) {
          /** @type {?} */
          var currentColWidth = parseFloat(column.width);
          /** @type {?} */

          var actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
          currentColWidth = Number.isNaN(currentColWidth) || currentColWidth < actualWidth ? actualWidth : currentColWidth;
          /** @type {?} */

          var actualMinWidth = parseFloat(column.minWidth);
          return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
        }
        /**
         * @protected
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "getColMaxWidth",
        value: function getColMaxWidth(column) {
          return column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(column.maxWidth);
        }
        /**
         * @protected
         * @param {?} column
         * @param {?} diff
         * @return {?}
         */

      }, {
        key: "resizeColumnLayoutFor",
        value: function resizeColumnLayoutFor(column, diff) {
          var _this175 = this;

          /** @type {?} */
          var relativeColumns = column.getResizableColUnderEnd();
          /** @type {?} */

          var combinedSpan = relativeColumns.reduce(function (acc, col) {
            return acc + col.spanUsed;
          }, 0);

          if (column.pinned) {
            /** @type {?} */
            var pinnedWidth = this.column.grid.getPinnedWidth(true);
            /** @type {?} */

            var maxPinnedWidth = this.column.grid.calcPinnedContainerMaxWidth;

            if (pinnedWidth + diff > maxPinnedWidth) {
              diff = maxPinnedWidth - pinnedWidth;
            }
          } // Resize first those who might reach min/max width

          /** @type {?} */


          var columnsToResize = _toConsumableArray(relativeColumns);
          /** @type {?} */


          var updatedDiff = diff;
          /** @type {?} */

          var updatedCombinedSpan = combinedSpan;
          /** @type {?} */

          var setMinMaxCols = false;

          var _loop4 = function _loop4() {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            /** @type {?} */

            var newCombinedSpan = updatedCombinedSpan;
            /** @type {?} */

            var newColsToResize = [];
            columnsToResize.forEach(function (col) {
              /** @type {?} */
              var currentResizeWidth = parseFloat(col.target.calcWidth);
              /** @type {?} */

              var resizeScaled = diff / updatedCombinedSpan * col.target.gridColumnSpan;
              /** @type {?} */

              var minWidth = _this175.getColMinWidth(col.target);
              /** @type {?} */


              var maxWidth = _this175.getColMaxWidth(col.target);

              if (currentResizeWidth + resizeScaled < minWidth) {
                col.target.width = minWidth + 'px';
                updatedDiff += currentResizeWidth - minWidth;
                newCombinedSpan -= col.spanUsed;
                setMinMaxCols = true;
              } else if (maxWidth && currentResizeWidth + resizeScaled > maxWidth) {
                col.target.width = maxWidth + 'px';
                updatedDiff -= maxWidth - currentResizeWidth;
                newCombinedSpan -= col.spanUsed;
                setMinMaxCols = true;
              } else {
                // Save new ones that can be resized
                newColsToResize.push(col);
              }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
          };

          do {
            _loop4();
          } while (setMinMaxCols); // Those left that don't reach min/max size resize them normally.


          columnsToResize.forEach(function (col) {
            /** @type {?} */
            var currentResizeWidth = parseFloat(col.target.calcWidth);
            /** @type {?} */

            var resizeScaled = updatedDiff / updatedCombinedSpan * col.target.gridColumnSpan;
            col.target.width = currentResizeWidth + resizeScaled + 'px';
          });
        }
      }, {
        key: "resizerHeight",
        get: function get() {
          /** @type {?} */
          var height = this.column.grid.getVisibleContentHeight(); // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.

          /** @type {?} */

          var columnHeightMultiplier = 1;

          if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
          }

          if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
          }

          return height;
        }
        /**
         * Returns the minimal possible width to which the column can be resized.
         * @return {?}
         */

      }, {
        key: "restrictResizeMin",
        get: function get() {
          /** @type {?} */
          var actualMinWidth = parseFloat(this.column.minWidth);
          /** @type {?} */

          var minWidth = actualMinWidth < parseFloat(this.column.width) ? actualMinWidth : parseFloat(this.column.width);
          return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
        }
        /**
         * Returns the maximal possible width to which the column can be resized.
         * @return {?}
         */

      }, {
        key: "restrictResizeMax",
        get: function get() {
          /** @type {?} */
          var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;

          if (this.column.pinned) {
            /** @type {?} */
            var pinnedMaxWidth = this.pinnedMaxWidth = this.column.grid.calcPinnedContainerMaxWidth - this.column.grid.getPinnedWidth(true) + actualWidth;

            if (this.column.maxWidth && parseFloat(this.column.maxWidth) < pinnedMaxWidth) {
              this.pinnedMaxWidth = this.column.maxWidth;
              return parseFloat(this.column.maxWidth) - actualWidth;
            } else {
              return pinnedMaxWidth - actualWidth;
            }
          } else {
            if (this.column.maxWidth) {
              return parseFloat(this.column.maxWidth) - actualWidth;
            } else {
              return Number.MAX_SAFE_INTEGER;
            }
          }
        }
      }]);

      return IgxColumnResizingService;
    }();

    IgxColumnResizingService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /** @nocollapse */

    IgxColumnResizingService.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var DEFAULT_DATE_FORMAT = 'mediumDate';
    /** @type {?} */

    var DEBOUNCE_TIME = 200;
    /**
     * @hidden
     */

    var IgxResizeHandleDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} zone
       * @param {?} element
       * @param {?} colResizingService
       */
      function IgxResizeHandleDirective(zone, element, colResizingService) {
        _classCallCheck(this, IgxResizeHandleDirective);

        this.zone = zone;
        this.element = element;
        this.colResizingService = colResizingService;
        /**
         * @hidden
         */

        this._dblClick = false;
        /**
         * @hidden
         */

        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxResizeHandleDirective, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this176 = this;

          if (!this.column.columnGroup && this.column.resizable) {
            this.zone.runOutsideAngular(function () {
              Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(_this176.element.nativeElement, 'mousedown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounceTime"])(DEBOUNCE_TIME), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this176.destroy$)).subscribe(function (event) {
                if (_this176._dblClick) {
                  _this176._dblClick = false;
                  return;
                }

                if (event.button === 0) {
                  _this176._onResizeAreaMouseDown(event);

                  _this176.column.grid.resizeLine.resizer.onMousedown(event);
                }
              });
            });
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.element.nativeElement, 'mouseup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounceTime"])(DEBOUNCE_TIME), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function () {
              _this176.colResizingService.isColumnResizing = false;
              _this176.colResizingService.showResizer = false;

              _this176.column.grid.cdr.detectChanges();
            });
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onMouseOver",
        value: function onMouseOver() {
          this.colResizingService.resizeCursor = 'col-resize';
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onDoubleClick",
        value: function onDoubleClick() {
          this._dblClick = true;
          this.colResizingService.column = this.column;
          this.colResizingService.autosizeColumnOnDblClick();
        }
        /**
         * @hidden
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onResizeAreaMouseDown",
        value: function _onResizeAreaMouseDown(event) {
          this.colResizingService.column = this.column;
          this.colResizingService.isColumnResizing = true;
          this.colResizingService.startResizePos = event.clientX;
          this.colResizingService.showResizer = true;
          this.column.grid.cdr.detectChanges();
        }
      }]);

      return IgxResizeHandleDirective;
    }();

    IgxResizeHandleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxResizeHandle]'
      }]
    }];
    /** @nocollapse */

    IgxResizeHandleDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: IgxColumnResizingService
      }];
    };

    IgxResizeHandleDirective.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxResizeHandle']
      }],
      onMouseOver: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['mouseover']
      }],
      onDoubleClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['dblclick']
      }]
    };
    /**
     * @hidden
     */

    var IgxColumnResizerDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?} document
       * @param {?} zone
       */
      function IgxColumnResizerDirective(element, document, zone) {
        var _this177 = this;

        _classCallCheck(this, IgxColumnResizerDirective);

        this.element = element;
        this.document = document;
        this.zone = zone;
        this.restrictHResizeMin = Number.MIN_SAFE_INTEGER;
        this.restrictHResizeMax = Number.MAX_SAFE_INTEGER;
        this.resizeEnd = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.resizeStart = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.resize = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._destroy = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.resizeStart.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["map"])(function (event) {
          return event.clientX;
        }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["switchMap"])(function (offset) {
          return _this177.resize.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["map"])(function (event) {
            return event.clientX - offset;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this177.resizeEnd), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this177._destroy));
        })).subscribe(function (pos) {
          /** @type {?} */
          var left = _this177._left + pos;
          /** @type {?} */

          var min = _this177._left - _this177.restrictHResizeMin;
          /** @type {?} */

          var max = _this177._left + _this177.restrictHResizeMax;
          _this177.left = left < min ? min : left;

          if (left > max) {
            _this177.left = max;
          }
        });
      }
      /**
       * @return {?}
       */


      _createClass(IgxColumnResizerDirective, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this178 = this;

          this.zone.runOutsideAngular(function () {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(_this178.document.defaultView, 'mousemove').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(function () {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"]);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this178._destroy)).subscribe(function (res) {
              return _this178.onMousemove(res);
            });
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(_this178.document.defaultView, 'mouseup').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this178._destroy)).subscribe(function (res) {
              return _this178.onMouseup(res);
            });
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroy.next(true);

          this._destroy.complete();
        }
        /**
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "onMouseup",

        /**
         * @param {?} event
         * @return {?}
         */
        value: function onMouseup(event) {
          this.resizeEnd.next(event);
          this.resizeEnd.complete();
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onMousedown",
        value: function onMousedown(event) {
          event.preventDefault();
          /** @type {?} */

          var parent = this.element.nativeElement.parentElement.parentElement;
          this.left = this._left = event.clientX - parent.getBoundingClientRect().left;
          this.top = event.target.getBoundingClientRect().top - parent.getBoundingClientRect().top;
          this.resizeStart.next(event);
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onMousemove",
        value: function onMousemove(event) {
          event.preventDefault();
          this.resize.next(event);
        }
      }, {
        key: "left",
        set: function set(val) {
          var _this179 = this;

          requestAnimationFrame(function () {
            return _this179.element.nativeElement.style.left = val + 'px';
          });
        }
        /**
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "top",
        set: function set(val) {
          var _this180 = this;

          requestAnimationFrame(function () {
            return _this180.element.nativeElement.style.top = val + 'px';
          });
        }
      }]);

      return IgxColumnResizerDirective;
    }();

    IgxColumnResizerDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxResizer]'
      }]
    }];
    /** @nocollapse */

    IgxColumnResizerDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };

    IgxColumnResizerDirective.propDecorators = {
      restrictHResizeMin: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      restrictHResizeMax: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      resizeEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      resizeStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      resize: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @hidden
     */

    var IgxColumnMovingService =
    /*#__PURE__*/
    function () {
      function IgxColumnMovingService() {
        _classCallCheck(this, IgxColumnMovingService);
      }

      _createClass(IgxColumnMovingService, [{
        key: "column",

        /**
         * @return {?}
         */
        get: function get() {
          return this._column;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (val) {
            this._column = val;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "icon",
        get: function get() {
          return this._icon;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (val) {
            this._icon = val;
          }
        }
      }]);

      return IgxColumnMovingService;
    }();

    IgxColumnMovingService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"],
      args: [{
        providedIn: 'root'
      }]
    }];
    /** @nocollapse */

    IgxColumnMovingService.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
      factory: function IgxColumnMovingService_Factory() {
        return new IgxColumnMovingService();
      },
      token: IgxColumnMovingService,
      providedIn: "root"
    });
    /** @enum {number} */

    var DropPosition = {
      BeforeDropTarget: 0,
      AfterDropTarget: 1,
      None: 2
    };
    DropPosition[DropPosition.BeforeDropTarget] = 'BeforeDropTarget';
    DropPosition[DropPosition.AfterDropTarget] = 'AfterDropTarget';
    DropPosition[DropPosition.None] = 'None';
    /**
     * @hidden
     */

    var IgxColumnMovingDragDirective =
    /*#__PURE__*/
    function (_IgxDragDirective) {
      _inherits(IgxColumnMovingDragDirective, _IgxDragDirective);

      /**
       * @param {?} _element
       * @param {?} _viewContainer
       * @param {?} _zone
       * @param {?} _renderer
       * @param {?} _cdr
       * @param {?} cms
       */
      function IgxColumnMovingDragDirective(_element, _viewContainer, _zone, _renderer, _cdr, cms) {
        var _this181;

        _classCallCheck(this, IgxColumnMovingDragDirective);

        _this181 = _possibleConstructorReturn(this, _getPrototypeOf(IgxColumnMovingDragDirective).call(this, _cdr, _element, _viewContainer, _zone, _renderer));
        _this181.cms = cms;
        _this181._ghostClass = 'igx-grid__drag-ghost-image';
        _this181.ghostImgIconClass = 'igx-grid__drag-ghost-image-icon';
        _this181.ghostImgIconGroupClass = 'igx-grid__drag-ghost-image-icon-group';
        return _this181;
      }
      /**
       * @param {?} val
       * @return {?}
       */


      _createClass(IgxColumnMovingDragDirective, [{
        key: "ngOnDestroy",

        /**
         * @return {?}
         */
        value: function ngOnDestroy() {
          this._unsubscribe();
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onEscape",
        value: function onEscape(event) {
          this.cms.cancelDrop = true;
          this.onPointerUp(event);
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onPointerDown",
        value: function onPointerDown(event) {
          var _this182 = this;

          if (!this.draggable || event.target.getAttribute('draggable') === 'false') {
            return;
          }

          event.preventDefault();
          event.stopPropagation();
          this._removeOnDestroy = false;
          this.cms.column = this.column;
          this.ghostClass = this._ghostClass;

          _get(_getPrototypeOf(IgxColumnMovingDragDirective.prototype), "onPointerDown", this).call(this, event);

          this.cms.isColumnMoving = true;
          this.column.grid.cdr.detectChanges();
          /** @type {?} */

          var args = {
            source: this.column
          };
          this.column.grid.onColumnMovingStart.emit(args);
          this.subscription$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.column.grid.document.defaultView, 'keydown').subscribe(function (ev) {
            if (ev.key === "Escape"
            /* ESCAPE */
            || ev.key === "Esc"
            /* ESCAPE_IE */
            ) {
                _this182.onEscape(ev);
              }
          });
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onPointerMove",
        value: function onPointerMove(event) {
          event.preventDefault();

          _get(_getPrototypeOf(IgxColumnMovingDragDirective.prototype), "onPointerMove", this).call(this, event);

          if (this._dragStarted && this.ghostElement && !this.column.grid.draggedColumn) {
            this.column.grid.draggedColumn = this.column;
            this.column.grid.cdr.detectChanges();
          }

          if (this.cms.isColumnMoving) {
            /** @type {?} */
            var args = {
              source: this.column,
              cancel: false
            };
            this.column.grid.onColumnMoving.emit(args);

            if (args.cancel) {
              this.onEscape(event);
            }
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onPointerUp",
        value: function onPointerUp(event) {
          var _this183 = this;

          // Run it explicitly inside the zone because sometimes onPointerUp executes after the code below.
          this.zone.run(function () {
            _get(_getPrototypeOf(IgxColumnMovingDragDirective.prototype), "onPointerUp", _this183).call(_this183, event);

            _this183.cms.isColumnMoving = false;
            _this183.column.grid.draggedColumn = null;

            _this183.column.grid.cdr.detectChanges();
          });

          this._unsubscribe();
        }
        /**
         * @protected
         * @param {?} pageX
         * @param {?} pageY
         * @return {?}
         */

      }, {
        key: "createGhost",
        value: function createGhost(pageX, pageY) {
          _get(_getPrototypeOf(IgxColumnMovingDragDirective.prototype), "createGhost", this).call(this, pageX, pageY);

          this.ghostElement.style.height = null;
          this.ghostElement.style.minWidth = null;
          this.ghostElement.style.flexBasis = null;
          this.ghostElement.style.position = null;
          /** @type {?} */

          var icon = document.createElement('i');
          /** @type {?} */

          var text = document.createTextNode('block');
          icon.appendChild(text);
          icon.classList.add('material-icons');
          this.cms.icon = icon;

          if (!this.column.columnGroup) {
            this.renderer.addClass(icon, this.ghostImgIconClass);
            this.ghostElement.insertBefore(icon, this.ghostElement.firstElementChild);
            this.ghostLeft = this._ghostStartX = pageX - this.ghostElement.getBoundingClientRect().width / 3 * 2;
            this.ghostTop = this._ghostStartY = pageY - this.ghostElement.getBoundingClientRect().height / 3 * 2;
          } else {
            this.ghostElement.insertBefore(icon, this.ghostElement.childNodes[0]);
            this.renderer.addClass(icon, this.ghostImgIconGroupClass);
            this.ghostElement.children[0].style.paddingLeft = '0px';
            this.ghostLeft = this._ghostStartX = pageX - this.ghostElement.getBoundingClientRect().width / 3 * 2;
            this.ghostTop = this._ghostStartY = pageY - this.ghostElement.getBoundingClientRect().height / 3 * 2;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          if (this.subscription$) {
            this.subscription$.unsubscribe();
            this.subscription$ = null;
          }
        }
      }, {
        key: "data",
        set: function set(val) {
          this._column = val;
        }
        /**
         * @return {?}
         */

      }, {
        key: "column",
        get: function get() {
          return this._column;
        }
        /**
         * @return {?}
         */

      }, {
        key: "draggable",
        get: function get() {
          return this.column && (this.column.movable || this.column.groupable && !this.column.columnGroup);
        }
        /**
         * @return {?}
         */

      }, {
        key: "icon",
        get: function get() {
          return this.cms.icon;
        }
      }]);

      return IgxColumnMovingDragDirective;
    }(IgxDragDirective);

    IgxColumnMovingDragDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxColumnMovingDrag]'
      }]
    }];
    /** @nocollapse */

    IgxColumnMovingDragDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxColumnMovingService
      }];
    };

    IgxColumnMovingDragDirective.propDecorators = {
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxColumnMovingDrag']
      }]
    };
    /**
     * @hidden
     */

    var IgxColumnMovingDropDirective =
    /*#__PURE__*/
    function (_IgxDropDirective) {
      _inherits(IgxColumnMovingDropDirective, _IgxDropDirective);

      /**
       * @param {?} elementRef
       * @param {?} renderer
       * @param {?} zone
       * @param {?} cms
       */
      function IgxColumnMovingDropDirective(elementRef, renderer, zone, cms) {
        var _this184;

        _classCallCheck(this, IgxColumnMovingDropDirective);

        _this184 = _possibleConstructorReturn(this, _getPrototypeOf(IgxColumnMovingDropDirective).call(this, elementRef, renderer, zone));
        _this184.elementRef = elementRef;
        _this184.renderer = renderer;
        _this184.zone = zone;
        _this184.cms = cms;
        _this184._dropIndicator = null;
        _this184._lastDropIndicator = null;
        _this184._dragLeave = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        _this184._dropIndicatorClass = 'igx-grid__th-drop-indicator--active';
        return _this184;
      }
      /**
       * @param {?} val
       * @return {?}
       */


      _createClass(IgxColumnMovingDropDirective, [{
        key: "ngOnDestroy",

        /**
         * @return {?}
         */
        value: function ngOnDestroy() {
          this._dragLeave.next(true);

          this._dragLeave.complete();
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragOver",
        value: function onDragOver(event) {
          /** @type {?} */
          var drag = event.detail.owner;

          if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
          }

          if (this.isDropTarget && this.cms.column !== this.column && this.cms.column.level === this.column.level && this.cms.column.parent === this.column.parent) {
            if (this._lastDropIndicator) {
              this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
            }
            /** @type {?} */


            var clientRect = this.elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */

            var pos = clientRect.left + clientRect.width / 2;
            /** @type {?} */

            var parent = this.elementRef.nativeElement.parentElement;

            if (event.detail.pageX < pos) {
              this._dropPos = DropPosition.BeforeDropTarget;
              this._lastDropIndicator = this._dropIndicator = parent.firstElementChild;
            } else {
              this._dropPos = DropPosition.AfterDropTarget;
              this._lastDropIndicator = this._dropIndicator = parent.lastElementChild;
            }

            if (this.cms.icon.innerText !== 'block') {
              this.renderer.addClass(this._dropIndicator, this._dropIndicatorClass);
            }
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragEnter",
        value: function onDragEnter(event) {
          var _this185 = this;

          /** @type {?} */
          var drag = event.detail.owner;

          if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
          }

          if (this.column && this.cms.column.grid.id !== this.column.grid.id) {
            this.cms.icon.innerText = 'block';
            return;
          }

          if (this.isDropTarget && this.cms.column !== this.column && this.cms.column.level === this.column.level && this.cms.column.parent === this.column.parent) {
            if (!this.column.pinned || this.column.pinned && this.cms.column.pinned) {
              this.cms.icon.innerText = 'swap_horiz';
            }

            if (!this.cms.column.pinned && this.column.pinned) {
              /** @type {?} */
              var nextPinnedWidth = this.column.grid.getPinnedWidth(true) + parseFloat(this.cms.column.width);

              if (nextPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
                this.cms.icon.innerText = 'lock';
              } else {
                this.cms.icon.innerText = 'block';
              }
            }
          } else {
            this.cms.icon.innerText = 'block';
          }

          if (this.horizontalScroll) {
            this.cms.icon.innerText = event.target.id === 'right' ? 'arrow_forward' : 'arrow_back';
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(100).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._dragLeave)).subscribe(function () {
              _this185.cms.column.grid.wheelHandler();

              event.target.id === 'right' ? _this185.horizontalScroll.scrollPosition += 15 : _this185.horizontalScroll.scrollPosition -= 15;
            });
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragLeave",
        value: function onDragLeave(event) {
          /** @type {?} */
          var drag = event.detail.owner;

          if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
          }

          this.cms.icon.innerText = 'block';

          if (this._dropIndicator) {
            this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
          }

          if (this.horizontalScroll) {
            this._dragLeave.next(true);
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragDrop",
        value: function onDragDrop(event) {
          event.preventDefault();
          /** @type {?} */

          var drag = event.detail.owner;

          if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
          }

          if (this.column && this.cms.column.grid.id !== this.column.grid.id) {
            return;
          }

          if (this.horizontalScroll) {
            this._dragLeave.next(true);
          }

          if (this.isDropTarget) {
            /** @type {?} */
            var args = {
              source: this.cms.column,
              target: this.column
            };
            /** @type {?} */

            var nextPinnedWidth;

            if (this.column.pinned && !this.cms.column.pinned) {
              nextPinnedWidth = this.column.grid.getPinnedWidth(true) + parseFloat(this.cms.column.width);
            }

            if (nextPinnedWidth && nextPinnedWidth > this.column.grid.calcPinnedContainerMaxWidth || this.column.level !== this.cms.column.level || this.column.parent !== this.cms.column.parent || this.cms.cancelDrop) {
              this.cms.cancelDrop = false;
              this.column.grid.onColumnMovingEnd.emit(args);
              return;
            }

            this.column.grid.moveColumn(this.cms.column, this.column, this._dropPos);
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
          }
        }
      }, {
        key: "data",
        set: function set(val) {
          if (val instanceof IgxColumnComponent) {
            this._column = val;
          }

          if (val instanceof IgxGridForOfDirective) {
            this._hVirtDir = val;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "column",
        get: function get() {
          return this._column;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isDropTarget",
        get: function get() {
          return this._column && this._column.grid.hasMovableColumns && this.cms.column.movable && (!this._column.pinned && this.cms.column.disablePinning || !this.cms.column.disablePinning);
        }
        /**
         * @return {?}
         */

      }, {
        key: "horizontalScroll",
        get: function get() {
          if (this._hVirtDir) {
            return this._hVirtDir;
          }
        }
      }]);

      return IgxColumnMovingDropDirective;
    }(IgxDropDirective);

    IgxColumnMovingDropDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxColumnMovingDrop]'
      }]
    }];
    /** @nocollapse */

    IgxColumnMovingDropDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: IgxColumnMovingService
      }];
    };

    IgxColumnMovingDropDirective.propDecorators = {
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxColumnMovingDrop']
      }]
    };

    var IgxGridBodyDirective = function IgxGridBodyDirective() {
      _classCallCheck(this, IgxGridBodyDirective);
    };

    IgxGridBodyDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxGridBody]',
        providers: [IgxForOfSyncService]
      }]
    }];
    /**
     * @hidden
     */

    var IgxDatePipeComponent =
    /*#__PURE__*/
    function (_angular_common__WEBP) {
      _inherits(IgxDatePipeComponent, _angular_common__WEBP);

      /**
       * @param {?} locale
       */
      function IgxDatePipeComponent(locale) {
        _classCallCheck(this, IgxDatePipeComponent);

        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        return _possibleConstructorReturn(this, _getPrototypeOf(IgxDatePipeComponent).call(this, locale));
      }
      /**
       * @param {?} value
       * @param {?} locale
       * @return {?}
       */


      _createClass(IgxDatePipeComponent, [{
        key: "transform",
        value: function transform(value, locale) {
          if (value && value instanceof Date) {
            if (locale) {
              return _get(_getPrototypeOf(IgxDatePipeComponent.prototype), "transform", this).call(this, value, DEFAULT_DATE_FORMAT, undefined, locale);
            } else {
              return _get(_getPrototypeOf(IgxDatePipeComponent.prototype), "transform", this).call(this, value);
            }
          } else {
            return value;
          }
        }
      }]);

      return IgxDatePipeComponent;
    }(_angular_common__WEBPACK_IMPORTED_MODULE_3__["DatePipe"]);

    IgxDatePipeComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'igxdate'
      }]
    }];
    /** @nocollapse */

    IgxDatePipeComponent.ctorParameters = function () {
      return [{
        type: String,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["LOCALE_ID"]]
        }]
      }];
    };
    /**
     * @hidden
     */


    var IgxDecimalPipeComponent =
    /*#__PURE__*/
    function (_angular_common__WEBP2) {
      _inherits(IgxDecimalPipeComponent, _angular_common__WEBP2);

      /**
       * @param {?} locale
       */
      function IgxDecimalPipeComponent(locale) {
        _classCallCheck(this, IgxDecimalPipeComponent);

        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        return _possibleConstructorReturn(this, _getPrototypeOf(IgxDecimalPipeComponent).call(this, locale));
      }
      /**
       * @param {?} value
       * @param {?} locale
       * @return {?}
       */


      _createClass(IgxDecimalPipeComponent, [{
        key: "transform",
        value: function transform(value, locale) {
          if (value && typeof value === 'number') {
            if (locale) {
              return _get(_getPrototypeOf(IgxDecimalPipeComponent.prototype), "transform", this).call(this, value, undefined, locale);
            } else {
              return _get(_getPrototypeOf(IgxDecimalPipeComponent.prototype), "transform", this).call(this, value);
            }
          } else {
            return value;
          }
        }
      }]);

      return IgxDecimalPipeComponent;
    }(_angular_common__WEBPACK_IMPORTED_MODULE_3__["DecimalPipe"]);

    IgxDecimalPipeComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'igxdecimal'
      }]
    }];
    /** @nocollapse */

    IgxDecimalPipeComponent.ctorParameters = function () {
      return [{
        type: String,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["LOCALE_ID"]]
        }]
      }];
    };
    /**
     * @hidden
     */


    var RowEditPositionStrategy =
    /*#__PURE__*/
    function (_ConnectedPositioning2) {
      _inherits(RowEditPositionStrategy, _ConnectedPositioning2);

      function RowEditPositionStrategy() {
        var _this186;

        _classCallCheck(this, RowEditPositionStrategy);

        _this186 = _possibleConstructorReturn(this, _getPrototypeOf(RowEditPositionStrategy).apply(this, arguments));
        _this186.isTop = false;
        _this186.isTopInitialPosition = null;
        return _this186;
      }
      /**
       * @param {?} contentElement
       * @param {?} size
       * @param {?=} document
       * @param {?=} initialCall
       * @return {?}
       */


      _createClass(RowEditPositionStrategy, [{
        key: "position",
        value: function position(contentElement, size, document, initialCall) {
          /** @type {?} */
          var container = this.settings.container; // grid.tbody

          /** @type {?} */

          var target =
          /** @type {?} */
          this.settings.target; // Position of the overlay depends on the available space in the grid.
          // If the bottom space is not enough then the the row overlay will show at the top of the row.
          // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),
          // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).

          this.isTop = this.isTopInitialPosition !== null ? this.isTopInitialPosition : container.getBoundingClientRect().bottom < target.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height; // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.

          contentElement.style.width = target.clientWidth + 'px';
          this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? VerticalAlignment.Top : VerticalAlignment.Bottom;
          this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;

          _get(_getPrototypeOf(RowEditPositionStrategy.prototype), "position", this).call(this, contentElement, {
            width: target.clientWidth,
            height: target.clientHeight
          }, document, initialCall);
        }
      }]);

      return RowEditPositionStrategy;
    }(ConnectedPositioningStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @abstract
     */


    var ItemPropertyValueChanged =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} propName
       */
      function ItemPropertyValueChanged(propName) {
        _classCallCheck(this, ItemPropertyValueChanged);

        this.valueChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._propName = propName;
      }
      /**
       * @return {?}
       */


      _createClass(ItemPropertyValueChanged, [{
        key: "onValueChanged",

        /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        value: function onValueChanged(value) {
          /** @type {?} */
          var currentValue = this.value;

          if (value !== currentValue) {
            this.object[this._propName] = value;
            this.valueChanged.emit({
              oldValue: currentValue,
              newValue: value
            });
          }
        }
      }, {
        key: "object",
        get: function get() {
          return this._object;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value) {
            this._object = value;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this.object ? this.object[this._propName] : null;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.onValueChanged(value);
        }
      }]);

      return ItemPropertyValueChanged;
    }();

    ItemPropertyValueChanged.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      valueChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @hidden
     */

    var ColumnChooserItemBase =
    /*#__PURE__*/
    function (_ItemPropertyValueCha) {
      _inherits(ColumnChooserItemBase, _ItemPropertyValueCha);

      /**
       * @param {?} prop
       */
      function ColumnChooserItemBase(prop) {
        var _this187;

        _classCallCheck(this, ColumnChooserItemBase);

        _this187 = _possibleConstructorReturn(this, _getPrototypeOf(ColumnChooserItemBase).call(this, prop));
        _this187.prop = prop;
        _this187.indentation = 30;
        return _this187;
      }
      /**
       * @return {?}
       */


      _createClass(ColumnChooserItemBase, [{
        key: "column",
        get: function get() {
          return this.object;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value) {
            this.object = value;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "name",
        get: function get() {
          return this.column ? this.column.header ? this.column.header : this.column.field : '';
        }
        /**
         * @return {?}
         */

      }, {
        key: "level",
        get: function get() {
          return this.column.level;
        }
        /**
         * @return {?}
         */

      }, {
        key: "calcIndent",
        get: function get() {
          return this.indentation * this.level;
        }
      }]);

      return ColumnChooserItemBase;
    }(ItemPropertyValueChanged);

    ColumnChooserItemBase.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      indentation: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      container: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxColumnHidingItemDirective =
    /*#__PURE__*/
    function (_ColumnChooserItemBas) {
      _inherits(IgxColumnHidingItemDirective, _ColumnChooserItemBas);

      function IgxColumnHidingItemDirective() {
        _classCallCheck(this, IgxColumnHidingItemDirective);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxColumnHidingItemDirective).call(this, 'hidden'));
      }
      /**
       * @return {?}
       */


      _createClass(IgxColumnHidingItemDirective, [{
        key: "disabled",
        get: function get() {
          return this.column.disableHiding;
        }
      }]);

      return IgxColumnHidingItemDirective;
    }(ColumnChooserItemBase);

    IgxColumnHidingItemDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxColumnHidingItem]'
      }]
    }];
    /** @nocollapse */

    IgxColumnHidingItemDirective.ctorParameters = function () {
      return [];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */


    var ColumnDisplayOrder = {
      Alphabetical: 'Alphabetical',
      DisplayOrder: 'DisplayOrder'
    };

    var CustomFilteringStrategy =
    /*#__PURE__*/
    function (_FilteringStrategy2) {
      _inherits(CustomFilteringStrategy, _FilteringStrategy2);

      function CustomFilteringStrategy() {
        _classCallCheck(this, CustomFilteringStrategy);

        return _possibleConstructorReturn(this, _getPrototypeOf(CustomFilteringStrategy).apply(this, arguments));
      }

      _createClass(CustomFilteringStrategy, [{
        key: "filter",

        /**
         * @param {?} data
         * @param {?} expressionsTree
         * @return {?}
         */
        value: function filter(data, expressionsTree) {
          var _this188 = this;

          /** @type {?} */
          var res = [];
          data.forEach(function (item) {
            if (_this188.matchRecord(item,
            /** @type {?} */
            expressionsTree.filteringOperands[0])) {
              res.push(item);
            } else if (item.column.columnGroup) {
              if (item.column.allChildren.findIndex(function (child) {
                return _this188.matchRecord(child,
                /** @type {?} */
                expressionsTree.filteringOperands[1]) || _this188.matchRecord(child,
                /** @type {?} */
                expressionsTree.filteringOperands[2]);
              }) > -1) {
                res.push(item);
              }
            }
          });
          return res;
        }
      }]);

      return CustomFilteringStrategy;
    }(FilteringStrategy);
    /**
     * @hidden
     * @abstract
     */


    var ColumnChooserBase =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       */
      function ColumnChooserBase(cdr) {
        _classCallCheck(this, ColumnChooserBase);

        this.cdr = cdr;
        /**
         * Hides/ shows the filtering columns input from the UI.
         */

        this.disableFilter = false;
        /**
         * Access to the columnHidingUI:
         * ```typescript
         * \@ViewChild('column-hiding-component')
         *  public columnHidingUI: IgxColumnHidingComponent;
         * ```
         * Sets/gets the max height of the column area.
         * ```typescript
         * let columnsAreaMaxHeight =  this.columnHidingUI.columnsAreaMaxHeight;
         * ```
         *
         * ```html
         * <igx-column-hiding [columnsAreaMaxHeight]="200px"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         */

        this.columnsAreaMaxHeight = '100%';
        /**
         * Sets/Gets the css class selector.
         * By default the value of the `class` attribute is `"igx-column-hiding"`.
         * ```typescript
         * let cssCLass =  this.columnHidingUI.cssClass;
         * ```
         * ```typescript
         * this.columnHidingUI.cssClass = 'column-chooser';
         * ```
         * \@memberof ColumnChooserBase
         */

        this.cssClass = 'igx-column-hiding';
        /**
         * @hidden
         */

        this._currentColumns = [];
        /**
         * @hidden
         */

        this._gridColumns = [];
        /**
         * @hidden
         */

        this._rawColumns = [];
        /**
         * @hidden
         */

        this._columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
        /**
         * @hidden
         */

        this._filterCriteria = '';
        /**
         * @hidden
         */

        this._filterColumnsPrompt = '';
        /**
         * @hidden
         */

        this._title = '';
      }
      /**
       * Gets the grid columns that are going to be manipulated.
       * ```typescript
       * let gridColumns = this.columnHidingUI.columns;
       * ```
       * \@memberof ColumnChooserBase
       * @return {?}
       */


      _createClass(ColumnChooserBase, [{
        key: "ngOnDestroy",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnDestroy() {
          var _iteratorNormalCompletion40 = true;
          var _didIteratorError40 = false;
          var _iteratorError40 = undefined;

          try {
            for (var _iterator40 = this._currentColumns[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
              var item = _step40.value;
              item.valueChanged.unsubscribe();
            }
          } catch (err) {
            _didIteratorError40 = true;
            _iteratorError40 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion40 && _iterator40["return"] != null) {
                _iterator40["return"]();
              }
            } finally {
              if (_didIteratorError40) {
                throw _iteratorError40;
              }
            }
          }
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "createColumnItems",
        value: function createColumnItems() {
          var _this189 = this;

          if (this._gridColumns.length > 0) {
            this._rawColumns = [];

            this._gridColumns.forEach(function (column) {
              /** @type {?} */
              var item = _this189.createColumnItem(_this189, column);

              if (item) {
                _this189._rawColumns.push(item);
              }
            });

            this._currentColumns = this._rawColumns.slice(0);
            this.orderColumns(this._columnDisplayOrder);
          }
        }
        /**
         * @hidden
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "orderColumns",
        value: function orderColumns(value) {
          this._columnDisplayOrder = value;

          if (value === ColumnDisplayOrder[ColumnDisplayOrder.Alphabetical] || value === ColumnDisplayOrder.Alphabetical) {
            this._currentColumns = this._rawColumns.slice(0).sort(function (current, next) {
              return current.name.toLowerCase().localeCompare(next.name.toLowerCase());
            });
          } else {
            this._currentColumns = this._rawColumns;
          }
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "filter",
        value: function filter() {
          /** @type {?} */
          var filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.Or);
          filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('name'));
          filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('field'));
          filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('header'));
          /** @type {?} */

          var strategy = new CustomFilteringStrategy();
          this._currentColumns = strategy.filter(this._currentColumns, filteringExpressionsTree);
        }
        /**
         * @hidden
         * @protected
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "createFilteringExpression",
        value: function createFilteringExpression(fieldName) {
          return {
            condition: IgxStringFilteringOperand.instance().condition('contains'),
            fieldName: fieldName,
            ignoreCase: true,
            searchVal: this._filterCriteria
          };
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "clearFiltering",
        value: function clearFiltering() {
          this.createColumnItems();
        }
      }, {
        key: "columns",
        get: function get() {
          return this._gridColumns;
        }
        /**
         * Sets the the grid columns that are going to be manipulated.
         * ```html
         * <igx-column-hiding [columns]="grid.columns"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value) {
            this._gridColumns = value;
            this.createColumnItems();

            if (this.filterCriteria) {
              this.filter();
            }
          }
        }
        /**
         * Sets/gets the title of the column chooser.
         * ```typescript
         * let title =  this.columnHidingUI.title;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */

      }, {
        key: "title",
        get: function get() {
          return this._title;
        }
        /**
         * ```html
         * <igx-column-hiding [title]="'IgxColumnHidingComponent Title'"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._title = value ? value : '';
        }
        /**
         * Gets the prompt that is displayed in the filter input.
         * ```typescript
         * let filterColumnsPrompt =  this.columnHidingUI.filterColumnsPrompt;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */

      }, {
        key: "filterColumnsPrompt",
        get: function get() {
          return this._filterColumnsPrompt;
        }
        /**
         * Sets the prompt that is going to be displayed in the filter input.
         * ```html
         * <igx-column-hiding [filterColumnsPrompt]="'Type here to search'"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._filterColumnsPrompt = value ? value : '';
        }
        /**
         * Gets the items of the selected columns.
         * ```typescript
         * let columnItems =  this.columnHidingUI.columnItems;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */

      }, {
        key: "columnItems",
        get: function get() {
          return this._currentColumns;
        }
        /**
         * Gets the value which filters the columns list.
         * ```typescript
         * let filterCriteria =  this.columnHidingUI.filterCriteria;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */

      }, {
        key: "filterCriteria",
        get: function get() {
          return this._filterCriteria;
        }
        /**
         * Sets the value which filters the columns list.
         * ```html
         *  <igx-column-hiding [filterCriteria]="'ID'"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (!value || value.length === 0) {
            this.clearFiltering();
            this._filterCriteria = '';
            this.cdr.detectChanges();
            return;
          } else if (this._filterCriteria && this._filterCriteria.length > value.length) {
            this.clearFiltering();
          }

          this._filterCriteria = value;
          this.filter();
          this.cdr.detectChanges();
        }
        /**
         * Gets the display order of the columns.
         * ```typescript
         * let columnDisplayOrder  =  this.columnHidingUI.columnDisplayOrder;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */

      }, {
        key: "columnDisplayOrder",
        get: function get() {
          return this._columnDisplayOrder;
        }
        /**
         * Sets the display order of the columns.
         * ```typescript
         * this.columnHidingUI.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value !== undefined) {
            this.orderColumns(value);

            if (this._filterCriteria.length > 0) {
              this.filter();
            }
          }
        }
      }]);

      return ColumnChooserBase;
    }();

    ColumnChooserBase.propDecorators = {
      columns: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      title: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filterColumnsPrompt: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disableFilter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnItems: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filterCriteria: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnDisplayOrder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnsAreaMaxHeight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.class']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxColumnHidingComponent =
    /*#__PURE__*/
    function (_ColumnChooserBase) {
      _inherits(IgxColumnHidingComponent, _ColumnChooserBase);

      /**
       * @param {?} cdr
       */
      function IgxColumnHidingComponent(cdr) {
        var _this190;

        _classCallCheck(this, IgxColumnHidingComponent);

        _this190 = _possibleConstructorReturn(this, _getPrototypeOf(IgxColumnHidingComponent).call(this, cdr));
        _this190.cdr = cdr;
        /**
         * Sets/gets the text of the button that shows all columns if they are hidden.
         * ```typescript
         * let showAllButtonText =  this.columnHiding.showAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [showAllText] = "'Show Columns'"></igx-column-hiding>
         * ```
         * \@memberof IgxColumnHidingComponent
         */

        _this190.showAllText = 'Show All';
        /**
         * Sets/gets the text of the button that hides all columns if they are shown.
         * ```typescript
         * let hideAllButtonText =  this.columnHiding.hideAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [hideAllText] = "'Hide Columns'"></igx-column-hiding>
         * ```
         * \@memberof IgxColumnHidingComponent
         */

        _this190.hideAllText = 'Hide All';
        /**
         * An event that is emitted after the columns visibility is changed.
         * Provides references to the `column` and the `newValue` properties as event arguments.
         * ```html
         *  <igx-column-hiding (onColumnVisibilityChanged) = "onColumnVisibilityChanged($event)"></igx-column-hiding>
         * ```
         * \@memberof IgxColumnHidingComponent
         */

        _this190.onColumnVisibilityChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        _this190.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        return _this190;
      }
      /**
       * Returns a boolean indicating whether the `HIDE ALL` button is disabled.
       * ```html
       * <igx-column-hiding #columnHidingUI
       *     [columns]="grid.columns" [title]="'Column Hiding'">
       * </igx-column-hiding>
       * ```
       * ```typescript
       * \@ViewChild("'columnHidingUI'")
       * public columnHiding: IgxColumnHidingComponent;
       * let isHideAlldisabled =  this.columnHiding.disableHideAll;
       * ```
       * \@memberof IgxColumnHidingComponent
       * @return {?}
       */


      _createClass(IgxColumnHidingComponent, [{
        key: "createColumnItem",

        /**
         * @hidden
         * @protected
         * @param {?} container
         * @param {?} column
         * @return {?}
         */
        value: function createColumnItem(container, column) {
          var _this191 = this;

          if (column.grid.hasColumnLayouts && !column.columnLayout) {
            return null;
          }
          /** @type {?} */


          var item = new IgxColumnHidingItemDirective();
          item.container = container;
          item.column = column;
          item.valueChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (args) {
            _this191.onVisibilityChanged({
              column: item.column,
              newValue: args.newValue
            });
          });
          return item;
        }
        /**
         * Shows all columns in the grid.
         * ```typescript
         * this.columnHiding.showAllColumns();
         * ```
         * \@memberof IgxColumnHidingComponent
         * @return {?}
         */

      }, {
        key: "showAllColumns",
        value: function showAllColumns() {
          /** @type {?} */
          var collection = this.hidableColumns;
          var _iteratorNormalCompletion41 = true;
          var _didIteratorError41 = false;
          var _iteratorError41 = undefined;

          try {
            for (var _iterator41 = collection[Symbol.iterator](), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {
              var col = _step41.value;
              col.value = false;
            }
          } catch (err) {
            _didIteratorError41 = true;
            _iteratorError41 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion41 && _iterator41["return"] != null) {
                _iterator41["return"]();
              }
            } finally {
              if (_didIteratorError41) {
                throw _iteratorError41;
              }
            }
          }
        }
        /**
         * Hides all columns in the grid.
         * ```typescript
         * this.columnHiding.hideAllColumns();
         * ```
         * \@memberof IgxColumnHidingComponent
         * @return {?}
         */

      }, {
        key: "hideAllColumns",
        value: function hideAllColumns() {
          /** @type {?} */
          var collection = this.hidableColumns;
          var _iteratorNormalCompletion42 = true;
          var _didIteratorError42 = false;
          var _iteratorError42 = undefined;

          try {
            for (var _iterator42 = collection[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
              var col = _step42.value;
              col.value = true;
            }
          } catch (err) {
            _didIteratorError42 = true;
            _iteratorError42 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion42 && _iterator42["return"] != null) {
                _iterator42["return"]();
              }
            } finally {
              if (_didIteratorError42) {
                throw _iteratorError42;
              }
            }
          }
        }
        /**
         * @hidden
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "onVisibilityChanged",
        value: function onVisibilityChanged(args) {
          this.onColumnVisibilityChanged.emit(args);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
      }, {
        key: "disableHideAll",
        get: function get() {
          if (!this.columnItems || this.columnItems.length < 1 || this.hiddenColumnsCount === this.columns.length) {
            return true;
          } else if (this.hidableColumns.length < 1 || this.hidableColumns.length === this.hidableColumns.filter(function (col) {
            return col.value;
          }).length) {
            return true;
          } else {
            return false;
          }
        }
        /**
         * Returns a boolean indicating whether the `SHOW ALL` button is disabled.
         * ```typescript
         * let isShowAlldisabled =  this.columnHiding.disableShowAll;
         * ```
         * \@memberof IgxColumnHidingComponent
         * @return {?}
         */

      }, {
        key: "disableShowAll",
        get: function get() {
          if (!this.columnItems || this.columnItems.length < 1 || this.hiddenColumnsCount < 1 || this.hidableColumns.length < 1) {
            return true;
          } else if (this.hidableColumns.length === this.hidableColumns.filter(function (col) {
            return !col.value;
          }).length) {
            return true;
          } else {
            return false;
          }
        }
        /**
         * Gets the count of the hidden columns.
         * ```typescript
         * let hiddenColumnsCount =  this.columnHiding.hiddenColumnsCount;
         * ```
         * \@memberof IgxColumnHidingComponent
         * @return {?}
         */

      }, {
        key: "hiddenColumnsCount",
        get: function get() {
          return this.columns ? this.columns.filter(function (col) {
            return col.hidden;
          }).length : 0;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hidableColumns",
        get: function get() {
          return this.columnItems.filter(function (col) {
            return !col.disabled;
          });
        }
      }]);

      return IgxColumnHidingComponent;
    }(ColumnChooserBase);

    IgxColumnHidingComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        preserveWhitespaces: false,
        selector: 'igx-column-hiding',
        template: "<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox\n        *ngFor=\"let columnItem of hidableColumns\"\n        class=\"igx-column-hiding__columns-item\"\n        (onColumnVisibilityChanged)=\"onVisibilityChanged($event)\"\n        (change)=\"columnItem.value = !columnItem.value\"\n        [checked]=\"columnItem.value\"\n        [disabled]=\"columnItem.disabled\"\n        [style.margin-left.px]=\"columnItem.calcIndent\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n\n<div class=\"igx-column-hiding__buttons\">\n    <button igxButton igxRipple (click)=\"showAllColumns()\" [disabled]=\"disableShowAll\">{{ showAllText }}</button>\n    <button igxButton igxRipple (click)=\"hideAllColumns()\" [disabled]=\"disableHideAll\">{{ hideAllText }}</button>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxColumnHidingComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxColumnHidingComponent.propDecorators = {
      disableHideAll: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disableShowAll: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      showAllText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hideAllText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onColumnVisibilityChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @hidden
     */

    var IgxColumnHidingModule = function IgxColumnHidingModule() {
      _classCallCheck(this, IgxColumnHidingModule);
    };

    IgxColumnHidingModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxColumnHidingComponent, IgxColumnHidingItemDirective],
        exports: [IgxColumnHidingComponent],
        imports: [IgxButtonModule, IgxCheckboxModule, IgxInputGroupModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxColumnPinningItemDirective =
    /*#__PURE__*/
    function (_ColumnChooserItemBas2) {
      _inherits(IgxColumnPinningItemDirective, _ColumnChooserItemBas2);

      function IgxColumnPinningItemDirective() {
        _classCallCheck(this, IgxColumnPinningItemDirective);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxColumnPinningItemDirective).call(this, 'pinned'));
      }
      /**
       * Returns whether a column could be pinned.
       * It's not possible to pin a column if there is not enough space for the unpinned area.
       * ```typescript
       * const columnItem: IgxColumnPinningItemDirective;
       * this.columnItem.pinnable;
       * ```
       * @return {?}
       */


      _createClass(IgxColumnPinningItemDirective, [{
        key: "pinnable",
        get: function get() {
          return this.column.pinnable;
        }
      }]);

      return IgxColumnPinningItemDirective;
    }(ColumnChooserItemBase);

    IgxColumnPinningItemDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxColumnPinningItem]'
      }]
    }];
    /** @nocollapse */

    IgxColumnPinningItemDirective.ctorParameters = function () {
      return [];
    };

    var IgxColumnPinningComponent =
    /*#__PURE__*/
    function (_ColumnChooserBase2) {
      _inherits(IgxColumnPinningComponent, _ColumnChooserBase2);

      /**
       * @param {?} cdr
       */
      function IgxColumnPinningComponent(cdr) {
        var _this192;

        _classCallCheck(this, IgxColumnPinningComponent);

        _this192 = _possibleConstructorReturn(this, _getPrototypeOf(IgxColumnPinningComponent).call(this, cdr));
        _this192.cdr = cdr;
        return _this192;
      }
      /**
       * @hidden
       * @param {?} container
       * @param {?} column
       * @return {?}
       */


      _createClass(IgxColumnPinningComponent, [{
        key: "createColumnItem",
        value: function createColumnItem(container, column) {
          if (column.level !== 0 || column.disablePinning) {
            return null;
          }
          /** @type {?} */


          var item = new IgxColumnPinningItemDirective();
          item.container = container;
          item.column = column;
          return item;
        }
        /**
         * @hidden
         * @param {?} event
         * @param {?} columnItem
         * @return {?}
         */

      }, {
        key: "checkboxValueChange",
        value: function checkboxValueChange(event, columnItem) {
          if (event.checked && !columnItem.pinnable) {
            event.checkbox.checked = false;
            return false;
          }

          columnItem.value = !columnItem.value;
        }
      }]);

      return IgxColumnPinningComponent;
    }(ColumnChooserBase);

    IgxColumnPinningComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        preserveWhitespaces: false,
        selector: 'igx-column-pinning',
        template: "\n<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox igxColumnPinningItem\n        *ngFor=\"let columnItem of columnItems\"\n        class=\"igx-column-hiding__columns-item\"\n        (change)=\"checkboxValueChange($event, columnItem)\"\n        [checked]=\"columnItem.value\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxColumnPinningComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxColumnPinningModule = function IgxColumnPinningModule() {
      _classCallCheck(this, IgxColumnPinningModule);
    };

    IgxColumnPinningModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxColumnPinningComponent, IgxColumnPinningItemDirective],
        exports: [IgxColumnPinningComponent],
        imports: [IgxCheckboxModule, IgxInputGroupModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * This class encapsulates the Toolbar's logic and is internally used by
     * the `IgxGridComponent`, `IgxTreeGridComponent` and `IgxHierarchicalGridComponent`.
     */

    var IgxGridToolbarComponent =
    /*#__PURE__*/
    function (_DisplayDensityBase7) {
      _inherits(IgxGridToolbarComponent, _DisplayDensityBase7);

      /**
       * @param {?} gridAPI
       * @param {?} cdr
       * @param {?} excelExporter
       * @param {?} csvExporter
       * @param {?} _displayDensityOptions
       */
      function IgxGridToolbarComponent(gridAPI, cdr, excelExporter, csvExporter, _displayDensityOptions) {
        var _this193;

        _classCallCheck(this, IgxGridToolbarComponent);

        _this193 = _possibleConstructorReturn(this, _getPrototypeOf(IgxGridToolbarComponent).call(this, _displayDensityOptions));
        _this193.gridAPI = gridAPI;
        _this193.cdr = cdr;
        _this193.excelExporter = excelExporter;
        _this193.csvExporter = csvExporter;
        _this193._displayDensityOptions = _displayDensityOptions;
        _this193._filterColumnsPrompt = 'Filter columns list ...';
        _this193._positionSettings = {
          horizontalDirection: HorizontalAlignment.Left,
          horizontalStartPoint: HorizontalAlignment.Right,
          verticalDirection: VerticalAlignment.Bottom,
          verticalStartPoint: VerticalAlignment.Bottom
        };
        _this193._overlaySettings = {
          positionStrategy: new ConnectedPositioningStrategy(_this193._positionSettings),
          scrollStrategy: new AbsoluteScrollStrategy(),
          modal: false,
          closeOnOutsideClick: true,
          excludePositionTarget: true
        };
        return _this193;
      }
      /**
       * Gets the default text shown in the filtering box.
       * ```typescript
       * const filterPrompt = this.grid.toolbar.filterColumnsPrompt;
       * ```
       * @return {?}
       */


      _createClass(IgxGridToolbarComponent, [{
        key: "getTitle",

        /**
         * Returns the title of `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarTitle = this.igxGrid1.toolbar.getTitle();
         * ```
         * @return {?}
         */
        value: function getTitle() {
          return this.grid != null ? this.grid.toolbarTitle : '';
        }
        /**
         * Returns the text of the export button of the `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarExportText = this.igxGrid1.toolbar.getTitle();
         * ```
         * @return {?}
         */

      }, {
        key: "getExportText",
        value: function getExportText() {
          return this.grid != null ? this.grid.exportText : '';
        }
        /**
         * Returns the text of the Excel export button of the `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarExcelText = this.igxGrid1.toolbar.getExportExcelText();
         * ```
         * @return {?}
         */

      }, {
        key: "getExportExcelText",
        value: function getExportExcelText() {
          return this.grid != null ? this.grid.exportExcelText : '';
        }
        /**
         * Returns the text of the CSV export button of the `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarCSVText = this.igxGrid1.toolbar.getExportCsvText();
         * ```
         * @return {?}
         */

      }, {
        key: "getExportCsvText",
        value: function getExportCsvText() {
          return this.grid != null ? this.grid.exportCsvText : '';
        }
        /**
         * Toggles the export button's dropdown menu.
         * ```typescript
         * this.igxGrid1.toolbar.exportClicked();
         * ```
         * @return {?}
         */

      }, {
        key: "exportClicked",
        value: function exportClicked() {
          this._overlaySettings.positionStrategy.settings.target = this.exportButton.nativeElement;
          this._overlaySettings.outlet = this.grid.outletDirective;
          this.exportDropdown.toggle(this._overlaySettings);
        }
        /**
         * Exports the grid to excel.
         * ```typescript
         * this.igxGrid1.toolbar.exportToExcelClicked();
         * ```
         * @return {?}
         */

      }, {
        key: "exportToExcelClicked",
        value: function exportToExcelClicked() {
          this.performExport(this.excelExporter, 'excel');
        }
        /**
         * Exports the grid to CSV.
         * ```typescript
         * this.igxGrid1.toolbar.exportToCsvClicked();
         * ```
         * @return {?}
         */

      }, {
        key: "exportToCsvClicked",
        value: function exportToCsvClicked() {
          this.performExport(this.csvExporter, 'csv');
        }
        /**
         * @private
         * @param {?} exp
         * @param {?} exportType
         * @return {?}
         */

      }, {
        key: "performExport",
        value: function performExport(exp, exportType) {
          this.exportClicked();
          /** @type {?} */

          var fileName = 'ExportedData';
          /** @type {?} */

          var options = exportType === 'excel' ? new IgxExcelExporterOptions(fileName) : new IgxCsvExporterOptions(fileName, CsvFileTypes.CSV);
          /** @type {?} */

          var args = {
            grid: this.grid,
            exporter: exp,
            options: options,
            cancel: false
          };
          this.grid.onToolbarExporting.emit(args);

          if (args.cancel) {
            return;
          }

          exp["export"](this.grid, options);
        }
        /**
         * Toggles the Column Hiding UI.
         * ```typescript
         * this.grid1.toolbar.toggleColumnHidingUI();
         * ```
         * @return {?}
         */

      }, {
        key: "toggleColumnHidingUI",
        value: function toggleColumnHidingUI() {
          this._overlaySettings.positionStrategy.settings.target = this.columnHidingButton.nativeElement;
          this._overlaySettings.outlet = this.grid.outletDirective;
          this.columnHidingDropdown.toggle(this._overlaySettings);
        }
        /**
         * Toggles the Column Pinning UI.
         * ```typescript
         * this.grid1.toolbar.toggleColumnPinningUI();
         * ```
         * @return {?}
         */

      }, {
        key: "toggleColumnPinningUI",
        value: function toggleColumnPinningUI() {
          this._overlaySettings.positionStrategy.settings.target = this.columnPinningButton.nativeElement;
          this._overlaySettings.outlet = this.grid.outletDirective;
          this.columnPinningDropdown.toggle(this._overlaySettings);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "showAdvancedFilteringUI",
        value: function showAdvancedFilteringUI() {
          this.grid.openAdvancedFilteringDialog();
        }
        /**
         * Returns the `context` object which represents the `template context` binding into the
         * `toolbar custom container` by providing references to the parent IgxGird and the toolbar itself.
         * ```typescript
         * const context =  this.igxGrid.toolbar.context;
         * ```
         * @return {?}
         */

      }, {
        key: "filterColumnsPrompt",
        get: function get() {
          return this._filterColumnsPrompt;
        }
        /**
         * Sets the default text shown in the filtering box.
         * ```typescript
         * this.grid.toolbar.filterColumnsPrompt('Filter columns ...');
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._filterColumnsPrompt = value;
        }
        /**
         * Gets the height for the `IgxGridToolbarComponent`'s drop down panels.
         * ```typescript
         * const dropdownHeight = this.grid.toolbar.defaultDropDownsMaxHeight;
         * ```
         * @return {?}
         */

      }, {
        key: "defaultDropDownsMaxHeight",
        get: function get() {
          /** @type {?} */
          var gridHeight = this.grid.calcHeight;
          return gridHeight ? gridHeight * 0.7 + 'px' : '100%';
        }
        /**
         * Returns a reference to the `IgxGridComponent` component, hosting the `IgxGridToolbarComponent`.
         * ```typescript
         * const grid = this.igxGrid1.toolbar.grid;
         * ```
         * @return {?}
         */

      }, {
        key: "grid",
        get: function get() {
          return this.gridAPI.grid;
        }
        /**
         * Returns whether the `IgxGridComponent` renders an export button.
         * ```typescript
         * const exportButton = this.igxGrid1.toolbar.shouldShowExportButton;
         * ```
         * @return {?}
         */

      }, {
        key: "shouldShowExportButton",
        get: function get() {
          return this.grid != null && (this.grid.exportExcel || this.grid.exportCsv);
        }
        /**
         * Returns whether the `IgxGridComponent` renders an Excel export button.
         * ```typescript
         * const exportExcelButton = this.igxGrid1.toolbar.shouldShowExportExcelButton;
         * ```
         * @return {?}
         */

      }, {
        key: "shouldShowExportExcelButton",
        get: function get() {
          return this.grid != null && this.grid.exportExcel;
        }
        /**
         * Returns whether the `IgxGridComponent` renders an CSV export button.
         * ```typescript
         * const exportCSVButton = this.igxGrid1.toolbar.shouldShowExportCsvButton;
         * ```
         * @return {?}
         */

      }, {
        key: "shouldShowExportCsvButton",
        get: function get() {
          return this.grid != null && this.grid.exportCsv;
        }
        /**
         * Returns how many columns are pinned.
         * ```typescript
         * const pinnedCount = this.igxGrid1.toolbar.pinnedColumnsCount;
         * ```
         * @return {?}
         */

      }, {
        key: "pinnedColumnsCount",
        get: function get() {
          return this.grid.pinnedColumns.filter(function (col) {
            return !col.columnLayout;
          }).length;
        }
        /**
         * Returns the theme of the `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarTheme = this.grid.toolbar.hostClass;
         * ```
         * @return {?}
         */

      }, {
        key: "hostClass",
        get: function get() {
          return this.getComponentDensityClass('igx-grid-toolbar');
        }
      }, {
        key: "context",
        get: function get() {
          return {
            // $implicit: this
            grid: this.grid,
            toolbar: this
          };
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "customContentTemplate",
        get: function get() {
          if (this.grid != null && this.grid.toolbarCustomContentTemplate != null) {
            return this.grid.toolbarCustomContentTemplate.template;
          } else {
            return null;
          }
        }
      }]);

      return IgxGridToolbarComponent;
    }(DisplayDensityBase);

    IgxGridToolbarComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-grid-toolbar',
        template: "<span class=\"igx-grid-toolbar__title\" *ngIf=\"getTitle()\">\n    {{ getTitle() }}\n</span>\n\n<div class=\"igx-grid-toolbar__custom-content\" *ngIf=\"customContentTemplate != null\">\n    <ng-container *ngTemplateOutlet=\"customContentTemplate; context: context\">\n    </ng-container>\n</div>\n\n<div class=\"igx-grid-toolbar__actions\">\n    <div *ngIf=\"grid.allowAdvancedFiltering\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #advancedFilteringButton name=\"btnAdvancedFiltering\" igxRipple\n            [ngClass]=\"grid.advancedFilteringExpressionsTree ? 'igx-grid-toolbar__adv-filter--filtered' : 'igx-grid-toolbar__adv-filter'\"\n            (click)=\"showAdvancedFilteringUI()\">\n            <div class=\"igx-grid-toolbar__button-space\">\n                <igx-icon>\n                    filter_list\n                </igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_title}}</span>\n            </div>\n        </button>\n    </div>\n\n    <div *ngIf=\"grid.columnHiding\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnHidingButton name=\"btnColumnHiding\" igxRipple\n            (click)=\"toggleColumnHidingUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount > 0\">visibility_off</igx-icon>\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount === 0\">visibility</igx-icon>\n                <span>{{ grid.hiddenColumnsCount }}</span>\n                <span>{{ grid.hiddenColumnsText }}</span>\n            </div>\n        </button>\n        <igx-drop-down #columnHidingDropdown>\n            <igx-column-hiding\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnHidingTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"\n                (onColumnVisibilityChanged)=\"grid.toggleColumnVisibility($event)\">\n            </igx-column-hiding>\n        </igx-drop-down>\n    </div>\n    <div *ngIf=\"grid.columnPinning\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnPinningButton name=\"btnColumnPinning\" igxRipple\n            (click)=\"toggleColumnPinningUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"pinnedColumnsCount > 0\">lock</igx-icon>\n                <igx-icon *ngIf=\"pinnedColumnsCount === 0\">lock_open</igx-icon>\n                <span>{{ pinnedColumnsCount }}</span>\n                <span>{{ grid.pinnedColumnsText }}</span>\n                <span></span>\n            </div>\n        </button>\n        <igx-drop-down #columnPinningDropdown>\n            <igx-column-pinning\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnPinningTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"></igx-column-pinning>\n        </igx-drop-down>\n    </div>\n\n    <div class=\"igx-grid-toolbar__dropdown\" *ngIf=\"shouldShowExportButton\" id=\"btnExport\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" igxRipple #btnExport\n                (click)=\"exportClicked()\">\n            <span class=\"igx-grid-toolbar__button-space\">\n                <igx-icon fontSet=\"material\">import_export</igx-icon>\n                <span>{{ getExportText() }}</span>\n                <igx-icon fontSet=\"material\">arrow_drop_down</igx-icon>\n            </span>\n        </button>\n\n        <igx-drop-down #exportDropdown>\n            <ul class=\"igx-grid-toolbar__dd-list\">\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportExcelButton\" id=\"btnExportExcel\"\n                (click)=\"exportToExcelClicked()\">{{ getExportExcelText() }}</li>\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportCsvButton\" id=\"btnExportCsv\"\n                (click)=\"exportToCsvClicked()\">{{ getExportCsvText() }}</li>\n            </ul>\n        </igx-drop-down>\n    </div>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxGridToolbarComponent.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxExcelExporterService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: IgxCsvExporterService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxGridToolbarComponent.propDecorators = {
      gridID: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid-toolbar']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filterColumnsPrompt: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      defaultDropDownsMaxHeight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnHidingDropdown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['columnHidingDropdown', {
          read: IgxDropDownComponent,
          "static": false
        }]
      }],
      columnHidingUI: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxColumnHidingComponent, {
          "static": false
        }]
      }],
      columnHidingButton: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['columnHidingButton', {
          read: IgxButtonDirective,
          "static": false
        }]
      }],
      exportDropdown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['exportDropdown', {
          read: IgxDropDownComponent,
          "static": false
        }]
      }],
      exportButton: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['btnExport', {
          read: IgxButtonDirective,
          "static": false
        }]
      }],
      columnPinningDropdown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['columnPinningDropdown', {
          read: IgxDropDownComponent,
          "static": false
        }]
      }],
      columnPinningUI: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxColumnPinningComponent, {
          "static": false
        }]
      }],
      columnPinningButton: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['columnPinningButton', {
          read: IgxButtonDirective,
          "static": false
        }]
      }],
      hostClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.class']
      }]
    };
    /**
     * The IgxGridToolbarCustomContentDirective directive is used to mark an 'ng-template' (with
     * the 'igxToolbarCustomContent' selector) defined in the IgxGrid which is used to provide
     * custom content for cener part of the IgxGridToolbar.
     */

    var IgxGridToolbarCustomContentDirective =
    /**
     * @param {?} template
     */
    function IgxGridToolbarCustomContentDirective(template) {
      _classCallCheck(this, IgxGridToolbarCustomContentDirective);

      this.template = template;
    };

    IgxGridToolbarCustomContentDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxToolbarCustomContent]'
      }]
    }];
    /** @nocollapse */

    IgxGridToolbarCustomContentDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var IgxRowEditTemplateDirective = function IgxRowEditTemplateDirective() {
      _classCallCheck(this, IgxRowEditTemplateDirective);
    };

    IgxRowEditTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRowEdit]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxRowEditTextDirective = function IgxRowEditTextDirective() {
      _classCallCheck(this, IgxRowEditTextDirective);
    };

    IgxRowEditTextDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRowEditText]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxRowEditActionsDirective = function IgxRowEditActionsDirective() {
      _classCallCheck(this, IgxRowEditActionsDirective);
    };

    IgxRowEditActionsDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRowEditActions]'
      }]
    }]; // TODO: Refactor circular ref, deps and logic

    /**
     * @hidden
     */

    var IgxRowEditTabStopDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} api
       * @param {?} element
       */
      function IgxRowEditTabStopDirective(api, element) {
        var _this194 = this;

        _classCallCheck(this, IgxRowEditTabStopDirective);

        this.api = api;
        this.element = element;
        /**
         * Sets the cell in edit mode and focus its native element
         * @param cellIndex index of the cell to activate
         */

        this.activateCell = function () {
          /** @type {?} */
          var cell = _this194.grid.rowInEditMode.cells.find(function (e) {
            return e.visibleColumnIndex === _this194.currentCellIndex;
          });

          cell.nativeElement.focus();
          cell.setEditMode(true);
          _this194.currentCellIndex = -1;
        };
      }
      /**
       * @return {?}
       */


      _createClass(IgxRowEditTabStopDirective, [{
        key: "handleTab",

        /**
         * @param {?} event
         * @return {?}
         */
        value: function handleTab(event) {
          event.stopPropagation();

          if (this.grid.rowEditTabs.last === this && !event.shiftKey || this.grid.rowEditTabs.first === this && event.shiftKey) {
            this.move(event);
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "handleEscape",
        value: function handleEscape(event) {
          this.grid.endEdit(false, event);
          /** @type {?} */

          var activeNode = this.grid.selectionService.activeElement; //  on right click activeNode is deleted, so we may have no one

          if (activeNode) {
            /** @type {?} */
            var cell = this.grid.navigation.getCellElementByVisibleIndex(activeNode.row, activeNode.layout ? activeNode.layout.columnVisibleIndex : activeNode.column);
            cell.focus();
          }
        }
        /**
         * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
         * If cell is out of view first scrolls to the cell
         * @private
         * @param {?} event keyboard event containing information about whether SHIFT key was pressed
         * @return {?}
         */

      }, {
        key: "move",
        value: function move(event) {
          event.preventDefault();
          this.currentCellIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;

          if (!this.grid.navigation.isColumnFullyVisible(this.currentCellIndex)) {
            this.grid.navigation.performHorizontalScrollToCell(this.grid.rowInEditMode.index, this.currentCellIndex, false, this.activateCell);
          } else {
            this.activateCell();
          }
        }
      }, {
        key: "grid",
        get: function get() {
          return this.api.grid;
        }
      }]);

      return IgxRowEditTabStopDirective;
    }();

    IgxRowEditTabStopDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: "[igxRowEditTabStop]"
      }]
    }];
    /** @nocollapse */

    IgxRowEditTabStopDirective.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxRowEditTabStopDirective.propDecorators = {
      handleTab: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Tab', ["$event"]]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Shift.Tab', ["$event"]]
      }],
      handleEscape: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Escape', ["$event"]]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxGridGroupByRowComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       * @param {?} gridSelection
       * @param {?} element
       * @param {?} cdr
       */
      function IgxGridGroupByRowComponent(gridAPI, gridSelection, element, cdr) {
        _classCallCheck(this, IgxGridGroupByRowComponent);

        this.gridAPI = gridAPI;
        this.gridSelection = gridSelection;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */

        this.defaultCssClass = 'igx-grid__group-row';
        /**
         * @hidden
         */

        this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
        /**
         * @hidden
         */

        this.isFocused = false;
        /**
         * @hidden
         */

        this.tabindex = 0;
      }
      /**
       * Returns whether the row is focused.
       * ```
       * let gridRowFocused = this.grid1.rowList.first.focused;
       * ```
       * @return {?}
       */


      _createClass(IgxGridGroupByRowComponent, [{
        key: "onFocus",

        /**
         * @hidden
         * @return {?}
         */
        value: function onFocus() {
          this.isFocused = true;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur() {
          this.isFocused = false;
        }
        /**
         * Toggles the group row.
         * ```typescript
         * this.grid1.rowList.first.toggle()
         * ```
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          /** @type {?} */
          var isVirtualized = !this.grid.verticalScrollContainer.dc.instance.notVirtual;
          /** @type {?} */

          var groupRowIndex = this.index;
          this.grid.toggleGroup(this.groupRow);

          if (isVirtualized) {
            /** @type {?} */
            var groupRow = this.grid.nativeElement.querySelector("[data-rowIndex=\"".concat(groupRowIndex, "\"]"));

            if (groupRow) {
              groupRow.focus();
            }
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "onKeydown",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function onKeydown(event) {
          // TODO: Refactor

          /** @type {?} */
          var key = event.key.toLowerCase();

          if (!SUPPORTED_KEYS.has(key)) {
            return;
          }

          event.stopPropagation();
          /** @type {?} */

          var keydownArgs = {
            targetType: 'groupRow',
            target: this,
            event: event,
            cancel: false
          };
          this.grid.onGridKeydown.emit(keydownArgs);

          if (keydownArgs.cancel) {
            return;
          }

          event.preventDefault();

          if (!this.isKeySupportedInGroupRow(key, event.shiftKey, event.altKey) || event.ctrlKey) {
            return;
          }

          if (this.isToggleKey(key, event.altKey)) {
            if (this.expanded && ROW_COLLAPSE_KEYS.has(key) || !this.expanded && ROW_EXPAND_KEYS.has(key)) {
              this.toggle();
            }

            return;
          }
          /** @type {?} */


          var selection = this.gridSelection;
          selection.keyboardState.shift = event.shiftKey && !(key === 'tab');
          /** @type {?} */

          var activeNode = selection.activeElement ? Object.assign({}, selection.activeElement) : this.selectionNode;
          activeNode.row = this.index;

          switch (key) {
            case 'arrowdown':
            case 'down':
              this.grid.navigation.navigateDown(this.nativeElement, activeNode);
              break;

            case 'arrowup':
            case 'up':
              this.grid.navigation.navigateUp(this.nativeElement, activeNode);
              break;

            case 'tab':
              this.handleTabKey(event.shiftKey, activeNode);
              break;
          }
        }
        /**
         * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
         * ```typescript
         * this.grid1.rowList.first.grid;
         * ```
         * @return {?}
         */

      }, {
        key: "handleTabKey",

        /**
         * @private
         * @param {?} shift
         * @param {?} activeNode
         * @return {?}
         */
        value: function handleTabKey(shift, activeNode) {
          if (shift) {
            this.grid.navigation.performShiftTabKey(this.nativeElement, activeNode);
          } else {
            if (this.index === this.grid.dataView.length - 1 && this.grid.rootSummariesEnabled) {
              this.grid.navigation.onKeydownHome(0, true);
            } else {
              /** @type {?} */
              var orderedColumns = this.grid.navigation.gridOrderedColumns;
              /** @type {?} */

              var lastCol = orderedColumns[orderedColumns.length - 1];
              activeNode.column = lastCol.columnLayoutChild ? lastCol.parent.visibleIndex : lastCol.visibleIndex;
              this.grid.navigation.performTab(this.nativeElement, activeNode);
            }
          }
        }
        /**
         * @private
         * @param {?} key
         * @param {?=} shift
         * @param {?=} alt
         * @return {?}
         */

      }, {
        key: "isKeySupportedInGroupRow",
        value: function isKeySupportedInGroupRow(key) {
          var shift = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var alt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (shift) {
            return ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
          }

          return this.isToggleKey(key, alt) ? true : ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
        }
        /**
         * @private
         * @param {?} key
         * @param {?} altKey
         * @return {?}
         */

      }, {
        key: "isToggleKey",
        value: function isToggleKey(key, altKey) {
          return altKey && ['left', 'right', 'up', 'down', 'arrowleft', 'arrowright', 'arrowup', 'arrowdown'].indexOf(key) !== -1;
        }
      }, {
        key: "focused",
        get: function get() {
          return this.isFocused;
        }
        /**
         * Returns whether the group row is expanded.
         * ```typescript
         * const groupRowExpanded = this.grid1.rowList.first.expanded;
         * ```
         * @return {?}
         */

      }, {
        key: "expanded",
        get: function get() {
          return this.grid.isExpandedGroup(this.groupRow);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "describedBy",
        get: function get() {
          /** @type {?} */
          var grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
          return this.gridID + '_' + grRowExpr;
        }
        /**
         * @return {?}
         */

      }, {
        key: "dataRowIndex",
        get: function get() {
          return this.index;
        }
        /**
         * Returns a reference to the underlying HTML element.
         * ```typescript
         * const groupRowElement = this.nativeElement;
         * ```
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
        /**
         * Returns the style classes applied to the group rows.
         * ```typescript
         * const groupCssStyles = this.grid1.rowList.first.styleClasses;
         * ```
         * @return {?}
         */

      }, {
        key: "styleClasses",
        get: function get() {
          return "".concat(this.defaultCssClass, " ") + "".concat(this.paddingIndentationCssClass, "-") + this.groupRow.level + (this.focused ? " ".concat(this.defaultCssClass, "--active") : '');
        }
      }, {
        key: "iconTemplate",
        get: function get() {
          if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultGroupByExpandedTemplate;
          } else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultGroupByCollapsedTemplate;
          }
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "selectionNode",
        get: function get() {
          return {
            row: this.index,
            column: this.gridSelection.activeElement ? this.gridSelection.activeElement.column : 0
          };
        }
      }, {
        key: "grid",
        get: function get() {
          return this.gridAPI.grid;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "dataType",
        get: function get() {
          /** @type {?} */
          var column = this.grid.getColumnByName(this.groupRow.expression.fieldName);
          return column && column.dataType || DataType.String;
        }
      }]);

      return IgxGridGroupByRowComponent;
    }();

    IgxGridGroupByRowComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-groupby-row',
        template: "<ng-container #defaultGroupRow>\n    <div (click)=\"toggle()\" class=\"igx-grid__grouping-indicator\">\n            <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n            </ng-container>\n    </div>\n\n    <div class=\"igx-grid__group-content\" #groupContent>\n        <ng-container *ngTemplateOutlet=\"grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }\">\n        </ng-container>\n    </div>\n\n    <ng-template #defaultGroupByExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n    </ng-template>\n\n    <ng-template #defaultGroupByCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </ng-template>\n\n\n    <ng-template #defaultGroupByTemplate>\n        <div class=\"igx-group-label\">\n            <igx-icon fontSet=\"material\" class=\"igx-group-label__icon\">group_work</igx-icon>\n            <span class=\"igx-group-label__column-name\">\n            {{ groupRow.expression ? groupRow.expression.fieldName : '' }}:\n            </span>\n\n            <ng-container *ngIf=\"dataType === 'boolean' || dataType === 'string'; else default\" >\n                <span class=\"igx-group-label__text\">{{ groupRow.value }}</span>\n            </ng-container>\n            <ng-template #default>\n                <ng-container *ngIf=\"dataType === 'number'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | number }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"dataType === 'date'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | date }}</span>\n                </ng-container>\n            </ng-template>\n\n            <igx-badge [value]=\"groupRow.records ? groupRow.records.length : 0\" class='igx-group-label__count-badge'></igx-badge>\n        </div>\n    </ng-template>\n</ng-container>\n"
      }]
    }];
    /** @nocollapse */

    IgxGridGroupByRowComponent.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: IgxGridSelectionService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxGridGroupByRowComponent.propDecorators = {
      defaultGroupByExpandedTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultGroupByExpandedTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultGroupByCollapsedTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultGroupByCollapsedTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      isFocused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      index: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      gridID: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      groupRow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      groupContent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['groupContent', {
          "static": true
        }]
      }],
      expanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-expanded']
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      describedBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-describedby']
      }],
      dataRowIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.data-rowIndex']
      }],
      styleClasses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class']
      }],
      onFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus']
      }],
      onBlur: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['blur']
      }],
      onKeydown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var MoveDirection = {
      LEFT: 'left',
      RIGHT: 'right'
    };
    /**
     * @hidden
     */

    var IgxGridNavigationService =
    /*#__PURE__*/
    function () {
      function IgxGridNavigationService() {
        _classCallCheck(this, IgxGridNavigationService);
      }

      _createClass(IgxGridNavigationService, [{
        key: "horizontalScroll",

        /**
         * @param {?} rowIndex
         * @return {?}
         */
        value: function horizontalScroll(rowIndex) {
          /** @type {?} */
          var rowComp = this.grid.dataRowList.find(function (row) {
            return row.index === rowIndex;
          }) || this.grid.dataRowList.first;

          if (!rowComp) {
            rowComp = this.grid.summariesRowList.find(function (row) {
              return row.index === rowIndex;
            });
          }

          return rowComp.virtDirRow;
        }
        /**
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "getColumnUnpinnedIndex",
        value: function getColumnUnpinnedIndex(visibleColumnIndex) {
          /** @type {?} */
          var column = this.grid.unpinnedColumns.find(function (col) {
            return !col.columnGroup && col.visibleIndex === visibleColumnIndex;
          });
          return this.grid.pinnedColumns.length ? this.grid.unpinnedColumns.filter(function (c) {
            return !c.columnGroup;
          }).indexOf(column) : visibleColumnIndex;
        }
        /**
         * @param {?} columnIndex
         * @return {?}
         */

      }, {
        key: "isColumnFullyVisible",
        value: function isColumnFullyVisible(columnIndex) {
          return this.isColumnRightEdgeVisible(columnIndex) && this.isColumnLeftEdgeVisible(columnIndex);
        }
        /**
         * @param {?} columnIndex
         * @return {?}
         */

      }, {
        key: "isColumnRightEdgeVisible",
        value: function isColumnRightEdgeVisible(columnIndex) {
          /** @type {?} */
          var forOfDir = this.forOfDir();

          if (this.isColumnPinned(columnIndex, forOfDir)) {
            return true;
          }
          /** @type {?} */


          var index = this.getColumnUnpinnedIndex(columnIndex);
          return this.displayContainerWidth >= forOfDir.getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft;
        }
        /**
         * @param {?} columnIndex
         * @return {?}
         */

      }, {
        key: "isColumnLeftEdgeVisible",
        value: function isColumnLeftEdgeVisible(columnIndex) {
          /** @type {?} */
          var forOfDir = this.forOfDir();

          if (this.isColumnPinned(columnIndex, forOfDir)) {
            return true;
          }
          /** @type {?} */


          var index = this.getColumnUnpinnedIndex(columnIndex);
          return this.displayContainerScrollLeft <= forOfDir.getColumnScrollLeft(index);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "forOfDir",
        value: function forOfDir() {
          /** @type {?} */
          var forOfDir;

          if (this.grid.dataRowList.length > 0) {
            forOfDir = this.grid.dataRowList.first.virtDirRow;
          } else {
            forOfDir = this.grid.headerContainer;
          }

          return forOfDir;
        }
        /**
         * @private
         * @param {?} columnIndex
         * @param {?} forOfDir
         * @return {?}
         */

      }, {
        key: "isColumnPinned",
        value: function isColumnPinned(columnIndex, forOfDir) {
          /** @type {?} */
          var horizontalScroll = forOfDir.getScroll();
          /** @type {?} */

          var column = this.grid.columnList.filter(function (c) {
            return !c.columnGroup;
          }).find(function (col) {
            return col.visibleIndex === columnIndex;
          });
          return !horizontalScroll.clientWidth || column.pinned;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isRowInEditMode",

        /**
         * @param {?} rowIndex
         * @return {?}
         */
        value: function isRowInEditMode(rowIndex) {
          return this.grid.rowEditable && this.grid.rowInEditMode && this.grid.rowInEditMode.index === rowIndex;
        }
        /**
         * @param {?} direction
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "findNextEditable",
        value: function findNextEditable(direction, visibleColumnIndex) {
          // go trough all columns in one cycle instead of
          // splice().reverse().find()

          /** @type {?} */
          var gridColumns = this.gridOrderedColumns;
          /** @type {?} */

          var start = visibleColumnIndex;
          /** @type {?} */

          var end = 0;
          /** @type {?} */

          var step = 0;
          /** @type {?} */

          var result = -1;

          if (direction === MoveDirection.LEFT) {
            end = 0;
            step = -1;
          } else if (direction === MoveDirection.RIGHT) {
            end = gridColumns.length - 1;
            step = 1;
          }

          for (var c = start; c * step <= end; c += step) {
            /** @type {?} */
            var column = gridColumns[c];

            if (column.editable) {
              result = c;
              break;
            }
          }

          return result;
        }
        /**
         * @param {?} rowIndex
         * @param {?} visibleColumnIndex
         * @param {?=} isSummary
         * @return {?}
         */

      }, {
        key: "getCellElementByVisibleIndex",
        value: function getCellElementByVisibleIndex(rowIndex, visibleColumnIndex) {
          var isSummary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          /** @type {?} */
          var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
          return (
            /** @type {?} */
            this.grid.nativeElement.querySelector("".concat(cellSelector, "[data-rowindex=\"").concat(rowIndex, "\"][data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"))
          );
        }
        /**
         * @param {?} element
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "onKeydownArrowRight",
        value: function onKeydownArrowRight(element, selectedNode) {
          /** @type {?} */
          var rowIndex = selectedNode.row;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;
          /** @type {?} */

          var isSummary = selectedNode.isSummaryRow;

          if (this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
            return;
          }

          if (this.isColumnRightEdgeVisible(visibleColumnIndex + 1)) {
            // if next column is fully visible or is pinned
            if (element.classList.contains('igx-grid__td--pinned-last') || element.classList.contains('igx-grid-summary--pinned-last')) {
              if (this.isColumnLeftEdgeVisible(visibleColumnIndex + 1)) {
                element.nextElementSibling.firstElementChild.focus({
                  preventScroll: true
                });
              } else {
                this.getFocusableGrid().nativeElement.focus({
                  preventScroll: true
                });
                this.grid.parentVirtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
                  element.nextElementSibling.firstElementChild.focus({
                    preventScroll: true
                  });
                });
                this.horizontalScroll(rowIndex).scrollTo(0);
              }
            } else {
              element.nextElementSibling.focus({
                preventScroll: true
              });
            }
          } else {
            this.performHorizontalScrollToCell(rowIndex, visibleColumnIndex + 1, isSummary);
          }
        }
        /**
         * @param {?} element
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "onKeydownArrowLeft",
        value: function onKeydownArrowLeft(element, selectedNode) {
          /** @type {?} */
          var rowIndex = selectedNode.row;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;
          /** @type {?} */

          var isSummary = selectedNode.isSummaryRow;

          if (visibleColumnIndex === 0) {
            return;
          }
          /** @type {?} */


          var index = this.getColumnUnpinnedIndex(visibleColumnIndex - 1);

          if (!element.previousElementSibling && this.grid.pinnedColumns.length && index === -1) {
            element.parentNode.previousElementSibling.focus({
              preventScroll: true
            });
          } else if (!this.isColumnLeftEdgeVisible(visibleColumnIndex - 1)) {
            this.performHorizontalScrollToCell(rowIndex, visibleColumnIndex - 1, isSummary);
          } else {
            element.previousElementSibling.focus({
              preventScroll: true
            });
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?} currentColumnVisibleIndex
         * @return {?}
         */

      }, {
        key: "movePreviousEditable",
        value: function movePreviousEditable(rowIndex, currentColumnVisibleIndex) {
          /** @type {?} */
          var prevEditableColumnIndex = this.findNextEditable(MoveDirection.LEFT, currentColumnVisibleIndex - 1);

          if (prevEditableColumnIndex === -1) {
            if (this.grid.rowEditTabs.length) {
              //  TODO: make gridAPI visible for internal use and remove cast to any

              /** @type {?} */
              this.grid.gridAPI.submit_value();
              this.grid.rowEditTabs.last.element.nativeElement.focus();
              return;
            } else {
              // In case when row edit template is empty select last editable cell
              prevEditableColumnIndex = this.grid.lastEditableColumnIndex;
            }
          }

          this.focusEditableTarget(rowIndex, prevEditableColumnIndex);
        }
        /**
         * @param {?} rowIndex
         * @param {?} currentColumnVisibleIndex
         * @return {?}
         */

      }, {
        key: "moveNextEditable",
        value: function moveNextEditable(rowIndex, currentColumnVisibleIndex) {
          /** @type {?} */
          var nextEditableColumnIndex = this.findNextEditable(MoveDirection.RIGHT, currentColumnVisibleIndex + 1);

          if (nextEditableColumnIndex === -1) {
            if (this.grid.rowEditTabs.length) {
              //  TODO: make gridAPI visible for internal use and remove cast to any

              /** @type {?} */
              this.grid.gridAPI.submit_value();
              this.grid.rowEditTabs.first.element.nativeElement.focus();
              return;
            } else {
              // In case when row edit template is empty select first editable cell
              nextEditableColumnIndex = this.grid.firstEditableColumnIndex;
            }
          }

          this.focusEditableTarget(rowIndex, nextEditableColumnIndex);
        }
        /**
         * @param {?} rowIndex
         * @param {?} columnIndex
         * @return {?}
         */

      }, {
        key: "focusEditableTarget",
        value: function focusEditableTarget(rowIndex, columnIndex) {
          if (this.isColumnFullyVisible(columnIndex)) {
            this.getCellElementByVisibleIndex(rowIndex, columnIndex).focus();
          } else {
            this.performHorizontalScrollToCell(rowIndex, columnIndex);
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?=} isSummary
         * @return {?}
         */

      }, {
        key: "onKeydownHome",
        value: function onKeydownHome(rowIndex) {
          var isSummary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          /** @type {?} */
          var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
          /** @type {?} */

          var rowElement = rowList.find(function (row) {
            return row.index === rowIndex;
          });
          /** @type {?} */

          var cellSelector = this.getCellSelector(0, isSummary);

          if (!rowElement) {
            return;
          }

          rowElement = rowElement.nativeElement;
          /** @type {?} */

          var firstCell = rowElement.querySelector(cellSelector);

          if (this.grid.pinnedColumns.length || this.displayContainerScrollLeft === 0) {
            firstCell.focus({
              preventScroll: true
            });
          } else {
            this.getFocusableGrid().nativeElement.focus({
              preventScroll: true
            });
            this.grid.parentVirtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              firstCell = rowElement.querySelector(cellSelector);
              firstCell.focus({
                preventScroll: true
              });
            });
            this.horizontalScroll(rowIndex).scrollTo(0);
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?=} isSummary
         * @return {?}
         */

      }, {
        key: "onKeydownEnd",
        value: function onKeydownEnd(rowIndex) {
          var _this195 = this;

          var isSummary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          /** @type {?} */
          var index = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex;
          /** @type {?} */

          var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
          /** @type {?} */

          var rowElement = rowList.find(function (row) {
            return row.index === rowIndex;
          });

          if (!rowElement) {
            return;
          }

          rowElement = rowElement.nativeElement;

          if (this.isColumnRightEdgeVisible(index)) {
            /** @type {?} */
            var allCells = rowElement.querySelectorAll(this.getCellSelector(-1, isSummary));
            allCells[allCells.length - 1].focus({
              preventScroll: true
            });
          } else {
            this.getFocusableGrid().nativeElement.focus({
              preventScroll: true
            });
            this.grid.parentVirtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              /** @type {?} */
              var allCells = rowElement.querySelectorAll(_this195.getCellSelector(-1, isSummary));
              allCells[allCells.length - 1].focus({
                preventScroll: true
              });
            });
            this.horizontalScroll(rowIndex).scrollTo(this.getColumnUnpinnedIndex(index));
          }
        }
        /**
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "navigateTop",
        value: function navigateTop(visibleColumnIndex) {
          var _this196 = this;

          /** @type {?} */
          var targetIndex = this.findFirstDataRowIndex();
          /** @type {?} */

          var verticalScroll = this.grid.verticalScrollContainer.getScroll();
          /** @type {?} */

          var cellSelector = this.getCellSelector(visibleColumnIndex);
          /** @type {?} */

          var targetScr = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, false);

          if (targetScr >= verticalScroll.scrollTop) {
            /** @type {?} */
            var cells = this.grid.nativeElement.querySelectorAll("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));

            /** @type {?} */
            cells[0].focus();
          } else {
            this.getFocusableGrid().nativeElement.focus({
              preventScroll: true
            });
            this.grid.verticalScrollContainer.scrollTo(targetIndex !== -1 ? targetIndex : 0);
            this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              /** @type {?} */
              var cells = _this196.grid.nativeElement.querySelectorAll("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));

              if (cells.length > 0) {
                /** @type {?} */
                cells[0].focus();
              }
            });
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "findFirstDataRowIndex",
        value: function findFirstDataRowIndex() {
          var _this197 = this;

          /** @type {?} */
          var dv = this.grid.dataView;
          return dv.findIndex(function (rec) {
            return !_this197.grid.isGroupByRecord(rec);
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "findLastDataRowIndex",
        value: function findLastDataRowIndex() {
          /** @type {?} */
          var i = this.grid.dataView.length;

          while (i--) {
            /** @type {?} */
            var rec = this.grid.dataView[i];

            if (!this.grid.isGroupByRecord(rec)) {
              return i;
            }
          }
        }
        /**
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "navigateBottom",
        value: function navigateBottom(visibleColumnIndex) {
          var _this198 = this;

          /** @type {?} */
          var targetIndex = this.findLastDataRowIndex();
          /** @type {?} */

          var targetScr = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, true);
          /** @type {?} */

          var verticalScroll = this.grid.verticalScrollContainer.getScroll();
          /** @type {?} */

          var cellSelector = this.getCellSelector(visibleColumnIndex);

          if (verticalScroll.scrollHeight === 0 || verticalScroll.scrollTop === targetScr) {
            /** @type {?} */
            var cells = this.grid.nativeElement.querySelectorAll("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));

            /** @type {?} */
            cells[cells.length - 1].focus();
          } else {
            this.getFocusableGrid().nativeElement.focus({
              preventScroll: true
            });
            this.grid.verticalScrollContainer.scrollTo(targetIndex !== -1 ? targetIndex : this.grid.dataView.length - 1);
            this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              /** @type {?} */
              var cells = _this198.grid.nativeElement.querySelectorAll("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));

              if (cells.length > 0) {
                /** @type {?} */
                cells[cells.length - 1].focus();
              }
            });
          }
        }
        /**
         * @param {?} rowElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "navigateUp",
        value: function navigateUp(rowElement, selectedNode) {
          var _this199 = this;

          /** @type {?} */
          var currentRowIndex = selectedNode.row;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;

          if (currentRowIndex === 0) {
            return;
          }
          /** @type {?} */


          var containerTopOffset = parseInt(this.verticalDisplayContainerElement.style.top, 10);

          if (!rowElement.previousElementSibling || rowElement.previousElementSibling.offsetTop < Math.abs(containerTopOffset)) {
            this.getFocusableGrid().nativeElement.focus({
              preventScroll: true
            });
            this.grid.verticalScrollContainer.scrollTo(currentRowIndex - 1);
            this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              /** @type {?} */
              var tag = rowElement.tagName.toLowerCase();
              /** @type {?} */

              var rowSelector = _this199.getRowSelector();

              if (tag === rowSelector || tag === 'igx-grid-summary-row') {
                rowElement = _this199.getRowByIndex(currentRowIndex, tag);
              } else {
                rowElement = _this199.grid.nativeElement.querySelector("igx-grid-groupby-row[data-rowindex=\"".concat(currentRowIndex, "\"]"));
              }

              _this199.focusPreviousElement(rowElement, visibleColumnIndex);
            });
          } else {
            this.focusPreviousElement(rowElement, visibleColumnIndex);
          }
        }
        /**
         * @protected
         * @param {?} currentRowEl
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "focusPreviousElement",
        value: function focusPreviousElement(currentRowEl, visibleColumnIndex) {
          this.focusElem(currentRowEl.previousElementSibling, visibleColumnIndex);
        }
        /**
         * @param {?} rowElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "navigateDown",
        value: function navigateDown(rowElement, selectedNode) {
          var _this200 = this;

          /** @type {?} */
          var currentRowIndex = selectedNode.row;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;

          if (currentRowIndex === this.grid.dataView.length - 1 || currentRowIndex === 0 && rowElement.tagName.toLowerCase() === 'igx-grid-summary-row') {
            // check if this is rootSummary row
            return;
          }
          /** @type {?} */


          var rowHeight = this.grid.verticalScrollContainer.getSizeAt(currentRowIndex + 1);
          /** @type {?} */

          var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
          /** @type {?} */

          var targetEndTopOffset = rowElement.nextElementSibling ? rowElement.nextElementSibling.offsetTop + rowHeight + parseInt(this.verticalDisplayContainerElement.style.top, 10) : containerHeight + rowHeight;
          this.getFocusableGrid().nativeElement.focus({
            preventScroll: true
          });

          if (containerHeight && containerHeight < targetEndTopOffset) {
            /** @type {?} */
            var nextIndex = currentRowIndex + 1;
            this.grid.verticalScrollContainer.scrollTo(nextIndex);
            this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              rowElement = _this200.getNextRowByIndex(nextIndex);

              _this200.focusElem(rowElement, visibleColumnIndex);
            });
          } else {
            this.focusNextElement(rowElement, visibleColumnIndex);
          }
        }
        /**
         * @protected
         * @param {?} rowElement
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "focusElem",
        value: function focusElem(rowElement, visibleColumnIndex) {
          if (rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row') {
            rowElement.focus();
          } else {
            /** @type {?} */
            var isSummaryRow = rowElement.tagName.toLowerCase() === 'igx-grid-summary-row';

            if (this.isColumnFullyVisible(visibleColumnIndex)) {
              /** @type {?} */
              var cellSelector = this.getCellSelector(visibleColumnIndex, isSummaryRow);
              /** @type {?} */

              var cell = rowElement.querySelector("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));
              cell.focus();
              return cell;
            }

            this.performHorizontalScrollToCell(parseInt(rowElement.getAttribute('data-rowindex'), 10), visibleColumnIndex, isSummaryRow);
          }
        }
        /**
         * @protected
         * @param {?} rowElement
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "focusNextElement",
        value: function focusNextElement(rowElement, visibleColumnIndex) {
          return this.focusElem(rowElement.nextElementSibling, visibleColumnIndex);
        }
        /**
         * @return {?}
         */

      }, {
        key: "goToFirstCell",
        value: function goToFirstCell() {
          var _this201 = this;

          /** @type {?} */
          var targetIndex = this.findFirstDataRowIndex();
          /** @type {?} */

          var targetScr = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, false);
          /** @type {?} */

          var verticalScroll = this.grid.verticalScrollContainer.getScroll();

          if (verticalScroll.scrollTop === targetScr) {
            this.onKeydownHome(this.grid.dataRowList.first.index);
          } else {
            this.getFocusableGrid().nativeElement.focus({
              preventScroll: true
            });
            this.grid.verticalScrollContainer.scrollTo(targetIndex !== -1 ? targetIndex : 0);
            this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              _this201.onKeydownHome(_this201.grid.dataRowList.first.index);
            });
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "goToLastCell",
        value: function goToLastCell() {
          var _this202 = this;

          /** @type {?} */
          var targetIndex = this.findLastDataRowIndex();
          /** @type {?} */

          var targetScr = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, true);
          /** @type {?} */

          var verticalScroll = this.grid.verticalScrollContainer.getScroll();

          if (verticalScroll.scrollHeight === 0 || verticalScroll.scrollTop === targetScr) {
            /** @type {?} */
            var rows = this.getAllRows();
            /** @type {?} */

            var rowIndex = parseInt(rows[rows.length - 1].getAttribute('data-rowIndex'), 10);
            this.onKeydownEnd(rowIndex);
          } else {
            this.getFocusableGrid().nativeElement.focus({
              preventScroll: true
            });
            this.grid.verticalScrollContainer.scrollTo(targetIndex !== -1 ? targetIndex : this.grid.dataView.length - 1);
            this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              /** @type {?} */
              var rows = _this202.getAllRows();

              if (rows.length > 0) {
                /** @type {?} */
                var _rowIndex = parseInt(rows[rows.length - 1].getAttribute('data-rowIndex'), 10);

                _this202.onKeydownEnd(_rowIndex);
              }
            });
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "goToLastBodyElement",
        value: function goToLastBodyElement() {
          var _this203 = this;

          /** @type {?} */
          var verticalScroll = this.grid.verticalScrollContainer.getScroll();

          if (verticalScroll.scrollHeight === 0 || verticalScroll.scrollTop === verticalScroll.scrollHeight - this.grid.verticalScrollContainer.igxForContainerSize) {
            /** @type {?} */
            var rowIndex = this.grid.dataView.length - 1;
            /** @type {?} */

            var row =
            /** @type {?} */
            this.grid.nativeElement.querySelector("[data-rowindex=\"".concat(rowIndex, "\"]"));

            if (row && row.tagName.toLowerCase() === 'igx-grid-groupby-row') {
              row.focus();
              return;
            }
            /** @type {?} */


            var isSummary = row && row.tagName.toLowerCase() === 'igx-grid-summary-row' ? true : false;
            this.onKeydownEnd(rowIndex, isSummary);
          } else {
            this.grid.verticalScrollContainer.scrollTo(this.grid.dataView.length - 1);
            this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              /** @type {?} */
              var rowIndex = _this203.grid.dataView.length - 1;
              /** @type {?} */

              var row =
              /** @type {?} */
              _this203.grid.nativeElement.querySelector("[data-rowindex=\"".concat(rowIndex, "\"]"));

              if (row && row.tagName.toLowerCase() === 'igx-grid-groupby-row') {
                row.focus();
                return;
              }
              /** @type {?} */


              var isSummary = row && row.tagName.toLowerCase() === 'igx-grid-summary-row' ? true : false;

              _this203.onKeydownEnd(rowIndex, isSummary);
            });
          }
        }
        /**
         * @param {?} currentRowEl
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "performTab",
        value: function performTab(currentRowEl, selectedNode) {
          /** @type {?} */
          var rowIndex = selectedNode.row;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;
          /** @type {?} */

          var isSummaryRow = selectedNode.isSummaryRow;

          if (isSummaryRow && rowIndex === 0 && this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
            return;
          }

          if (this.isRowInEditMode(rowIndex)) {
            this.moveNextEditable(rowIndex, visibleColumnIndex);
            return;
          }

          if (this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
            /** @type {?} */
            var rowEl = this.grid.rowList.find(function (row) {
              return row.index === rowIndex + 1;
            }) ? this.grid.rowList.find(function (row) {
              return row.index === rowIndex + 1;
            }) : this.grid.summariesRowList.find(function (row) {
              return row.index === rowIndex + 1;
            });

            if (rowIndex === this.grid.dataView.length - 1 && this.grid.rootSummariesEnabled) {
              this.onKeydownHome(0, true);
              return;
            }

            if (rowEl) {
              this.navigateDown(currentRowEl, {
                row: rowIndex,
                column: 0
              });
            }
          } else {
            /** @type {?} */
            var cell = this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummaryRow);

            if (cell) {
              this.onKeydownArrowRight(cell, selectedNode);
            }
          }
        }
        /**
         * @param {?=} toStart
         * @return {?}
         */

      }, {
        key: "moveFocusToFilterCell",
        value: function moveFocusToFilterCell(toStart) {
          if (this.grid.filteringService.isFilterRowVisible) {
            this.grid.filteringService.focusFilterRowCloseButton();
            return;
          }
          /** @type {?} */


          var columns = this.grid.filteringService.unpinnedFilterableColumns;
          /** @type {?} */

          var targetIndex = toStart ? 0 : columns.length - 1;
          /** @type {?} */

          var visibleIndex = columns[targetIndex].visibleIndex;
          /** @type {?} */

          var isVisible = toStart ? this.isColumnLeftEdgeVisible(visibleIndex) : this.isColumnRightEdgeVisible(visibleIndex);

          if (isVisible) {
            this.grid.filteringService.focusFilterCellChip(columns[targetIndex], false);
          } else {
            this.grid.filteringService.scrollToFilterCell(columns[targetIndex], false);
          }
        }
        /**
         * @param {?} column
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "navigatePrevFilterCell",
        value: function navigatePrevFilterCell(column, eventArgs) {
          /** @type {?} */
          var cols = this.grid.filteringService.unpinnedFilterableColumns;
          /** @type {?} */

          var prevFilterableIndex = cols.indexOf(column) - 1;
          /** @type {?} */

          var visibleIndex = column.visibleIndex;

          if (visibleIndex === 0 || prevFilterableIndex < 0) {
            // prev is not filter cell

            /** @type {?} */
            var firstFiltarableCol = this.getFirstPinnedFilterableColumn();

            if (!firstFiltarableCol || column === firstFiltarableCol) {
              eventArgs.preventDefault();
            }

            return;
          }
          /** @type {?} */


          var prevColumn = cols[prevFilterableIndex];
          /** @type {?} */

          var prevVisibleIndex = prevColumn.visibleIndex;

          if (prevFilterableIndex >= 0 && visibleIndex > 0 && !this.isColumnLeftEdgeVisible(prevVisibleIndex) && !column.pinned) {
            eventArgs.preventDefault();
            this.grid.filteringService.scrollToFilterCell(prevColumn, false);
          }
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "navigateFirstCellIfPossible",
        value: function navigateFirstCellIfPossible(eventArgs) {
          if (this.grid.rowList.length > 0) {
            if (this.grid.rowList.filter(function (row) {
              return row instanceof IgxGridGroupByRowComponent;
            }).length > 0) {
              eventArgs.stopPropagation();
              return;
            }

            this.goToFirstCell();
          } else if (this.grid.rootSummariesEnabled) {
            this.onKeydownHome(0, true);
          }

          eventArgs.preventDefault();
        }
        /**
         * @param {?} column
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "navigateNextFilterCell",
        value: function navigateNextFilterCell(column, eventArgs) {
          /** @type {?} */
          var cols = this.grid.filteringService.unpinnedFilterableColumns;
          /** @type {?} */

          var nextFilterableIndex = cols.indexOf(column) + 1;

          if (nextFilterableIndex >= this.grid.filteringService.unpinnedFilterableColumns.length) {
            // next is not filter cell
            this.navigateFirstCellIfPossible(eventArgs);
            return;
          }
          /** @type {?} */


          var nextColumn = cols[nextFilterableIndex];
          /** @type {?} */

          var nextVisibleIndex = nextColumn.visibleIndex;

          if (!column.pinned && !this.isColumnRightEdgeVisible(nextVisibleIndex)) {
            eventArgs.preventDefault();
            this.grid.filteringService.scrollToFilterCell(nextColumn, true);
          } else if (column === this.getLastPinnedFilterableColumn() && !this.isColumnRightEdgeVisible(nextVisibleIndex)) {
            this.grid.filteringService.scrollToFilterCell(nextColumn, false);
            eventArgs.stopPropagation();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getLastPinnedFilterableColumn",
        value: function getLastPinnedFilterableColumn() {
          /** @type {?} */
          var pinnedFilterableColums = this.grid.pinnedColumns.filter(function (col) {
            return !col.columnGroup && col.filterable;
          });
          return pinnedFilterableColums[pinnedFilterableColums.length - 1];
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getFirstPinnedFilterableColumn",
        value: function getFirstPinnedFilterableColumn() {
          return this.grid.pinnedColumns.filter(function (col) {
            return !col.columnGroup && col.filterable;
          })[0];
        }
        /**
         * @param {?} currentRowEl
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "performShiftTabKey",
        value: function performShiftTabKey(currentRowEl, selectedNode) {
          /** @type {?} */
          var rowIndex = selectedNode.row;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;
          /** @type {?} */

          var isSummary = selectedNode.isSummaryRow;

          if (isSummary && rowIndex === 0 && visibleColumnIndex === 0 && this.grid.rowList.length) {
            this.goToLastBodyElement();
            return;
          }

          if (this.isRowInEditMode(rowIndex)) {
            this.movePreviousEditable(rowIndex, visibleColumnIndex);
            return;
          }

          if (visibleColumnIndex === 0) {
            if (rowIndex === 0 && this.grid.allowFiltering && this.grid.filterMode === FilterMode.quickFilter) {
              this.moveFocusToFilterCell();
            } else {
              this.navigateUp(currentRowEl, {
                row: rowIndex,
                column: this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex
              });
            }
          } else {
            /** @type {?} */
            var cell = this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary);

            if (cell) {
              this.onKeydownArrowLeft(cell, selectedNode);
            }
          }
        }
        /**
         * @param {?} targetRowIndex
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "shouldPerformVerticalScroll",
        value: function shouldPerformVerticalScroll(targetRowIndex, visibleColumnIndex) {
          /** @type {?} */
          var containerTopOffset = parseInt(this.verticalDisplayContainerElement.style.top, 10);
          /** @type {?} */

          var targetRow = this.grid.summariesRowList.filter(function (s) {
            return s.index !== 0;
          }).concat(this.grid.rowList.toArray()).find(function (r) {
            return r.index === targetRowIndex;
          });
          /** @type {?} */

          var rowHeight = this.grid.verticalScrollContainer.getSizeAt(targetRowIndex);
          /** @type {?} */

          var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
          /** @type {?} */

          var targetEndTopOffset = targetRow ? targetRow.nativeElement.offsetTop + rowHeight + containerTopOffset : containerHeight + rowHeight;

          if (!targetRow || targetRow.nativeElement.offsetTop < Math.abs(containerTopOffset) || containerHeight && containerHeight < targetEndTopOffset) {
            return true;
          } else {
            return false;
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?} visibleColIndex
         * @param {?=} cb
         * @return {?}
         */

      }, {
        key: "performVerticalScrollToCell",
        value: function performVerticalScrollToCell(rowIndex, visibleColIndex, cb) {
          this.grid.verticalScrollContainer.scrollTo(rowIndex);
          this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
            cb();
          });
        }
        /**
         * @param {?} rowIndex
         * @param {?} visibleColumnIndex
         * @param {?=} isSummary
         * @param {?=} cb
         * @return {?}
         */

      }, {
        key: "performHorizontalScrollToCell",
        value: function performHorizontalScrollToCell(rowIndex, visibleColumnIndex) {
          var _this204 = this;

          var isSummary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var cb = arguments.length > 3 ? arguments[3] : undefined;

          /** @type {?} */
          var unpinnedIndex = this.getColumnUnpinnedIndex(visibleColumnIndex);
          this.getFocusableGrid().nativeElement.focus({
            preventScroll: true
          });
          this.grid.parentVirtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
            if (cb) {
              cb();
            } else {
              /** @type {?} */
              var cellElement = _this204.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary);

              if (cellElement) {
                cellElement.focus({
                  preventScroll: true
                });
              }
            }
          });
          this.horizontalScroll(rowIndex).scrollTo(unpinnedIndex);
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "getFocusableGrid",
        value: function getFocusableGrid() {
          return this.grid;
        }
        /**
         * @protected
         * @param {?} index
         * @param {?=} selector
         * @return {?}
         */

      }, {
        key: "getRowByIndex",
        value: function getRowByIndex(index) {
          var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getRowSelector();
          return this.grid.nativeElement.querySelector("".concat(selector, "[data-rowindex=\"").concat(index, "\"]"));
        }
        /**
         * @protected
         * @param {?} nextIndex
         * @return {?}
         */

      }, {
        key: "getNextRowByIndex",
        value: function getNextRowByIndex(nextIndex) {
          return this.grid.tbody.nativeElement.querySelector("[data-rowindex=\"".concat(nextIndex, "\"]"));
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getAllRows",
        value: function getAllRows() {
          /** @type {?} */
          var selector = this.getRowSelector();
          return this.grid.nativeElement.querySelectorAll(selector);
        }
        /**
         * @protected
         * @param {?=} visibleIndex
         * @param {?=} isSummary
         * @return {?}
         */

      }, {
        key: "getCellSelector",
        value: function getCellSelector(visibleIndex) {
          var isSummary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return isSummary ? 'igx-grid-summary-cell' : 'igx-grid-cell';
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "getRowSelector",
        value: function getRowSelector() {
          return 'igx-grid-row';
        }
      }, {
        key: "displayContainerWidth",

        /**
         * @return {?}
         */
        get: function get() {
          return Math.round(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth);
        }
        /**
         * @return {?}
         */

      }, {
        key: "displayContainerScrollLeft",
        get: function get() {
          return Math.ceil(this.grid.headerContainer.scrollPosition);
        }
        /**
         * @return {?}
         */

      }, {
        key: "verticalDisplayContainerElement",
        get: function get() {
          return this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement;
        }
      }, {
        key: "gridOrderedColumns",
        get: function get() {
          return [].concat(_toConsumableArray(this.grid.pinnedColumns), _toConsumableArray(this.grid.unpinnedColumns)).filter(function (c) {
            return !c.columnGroup;
          });
        }
      }]);

      return IgxGridNavigationService;
    }();

    IgxGridNavigationService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /* tslint:disable */

    var icons = [{
      name: 'add_filter',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M19 15v-3h-2v3h-3v2h3v3h2v-3h3v-2h-3zM5 10h10v2H5zM2 5h16v2H2zM8 15h4v2H8z\"/>\n      </svg>"
    }, {
      name: 'contains',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"Layer_1\" data-name=\"Layer 1\" viewBox=\"0 0 24 24\">\n        <path d=\"M3 3v18h18V3zm16 16H5V5h14z\"/>\n        <path d=\"M12 11.3a4.39 4.39 0 0 0-2.54.63 2.07 2.07 0 0 0-.9 1.78 2.29 2.29 0 0 0 .66 1.74 2.63 2.63 0 0 0 1.89.63 2.39 2.39 0 0 0 1.32-.37 3.05 3.05 0 0 0 1-.93 3.72 3.72 0 0 0 .08.57c0 .19.1.38.16.58h1.79a4.51 4.51 0 0 1-.21-.88 5.57 5.57 0 0 1-.07-.93v-3.5a2.44 2.44 0 0 0-.84-2 3.34 3.34 0 0 0-2.22-.7 3.54 3.54 0 0 0-2.3.72A1.93 1.93 0 0 0 9 10.29h1.71a.93.93 0 0 1 .29-.71 1.5 1.5 0 0 1 1-.29 1.45 1.45 0 0 1 1 .35 1.3 1.3 0 0 1 .37 1v.69zm1.4 1.08v1.17a1.61 1.61 0 0 1-.71.77 2.27 2.27 0 0 1-1.21.34 1.18 1.18 0 0 1-.84-.27.92.92 0 0 1-.3-.72 1.16 1.16 0 0 1 .44-.9 1.76 1.76 0 0 1 1.22-.39z\"/>\n      </svg>"
    }, {
      name: 'does_not_contain',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21,19.74V3H4.26L2.89,1.63,1.63,2.92,3,4.29V21H19.73l1.37,1.37,1.27-1.26ZM5,19V6.28l5.28,5.27a3.19,3.19,0,0,0-.81.38,2.07,2.07,0,0,0-.9,1.78,2.29,2.29,0,0,0,.66,1.74,2.63,2.63,0,0,0,1.89.63,2.39,2.39,0,0,0,1.32-.37,3.05,3.05,0,0,0,1-.93,3.72,3.72,0,0,0,.08.57c0,.19.1.38.16.58h1L17.73,19Zm5.79-6.23a1.31,1.31,0,0,1,.45-.25l1.37,1.36.28.29a1.57,1.57,0,0,1-.19.15,2.27,2.27,0,0,1-1.21.34,1.18,1.18,0,0,1-.84-.27.92.92,0,0,1-.3-.72A1.16,1.16,0,0,1,10.79,12.77Zm2.6-1.47h-.83L10.94,9.68l.08-.1a1.5,1.5,0,0,1,1-.29,1.45,1.45,0,0,1,1,.35,1.3,1.3,0,0,1,.37,1ZM19,17.74l-3.85-3.85V10.62a2.44,2.44,0,0,0-.84-2,3.34,3.34,0,0,0-2.22-.7,3.64,3.64,0,0,0-2.24.67L6.26,5H19Z\"/>\n    </svg>"
    }, {
      name: 'all',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M2 14h8v2H2zM2 6h12v2H2zM16 17l-3-3-1.5 1.5L16 20l7-7-1.5-1.5L16 17zM2 10h12v2H2z\"/>\n      </svg>\n      "
    }, {
      name: 'empty',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5 17h2v2H5zM13 17h2v2h-2zM5 13h2v2H5zM17 17h2v2h-2zM13 5h2v2h-2zM9 17h2v2H9zM17 9h2v2h-2zM17 13h2v2h-2zM17 5h2v2h-2zM5 9h2v2H5zM5 5h2v2H5zM9 5h2v2H9z\"/>\n      </svg>"
    }, {
      name: 'end_expression',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M13.14 6.76L17.49 12l-4.35 5.24 1.54 1.28L20.09 12l-5.41-6.52-1.54 1.28z\"/>\n        <path d=\"M11.91 11h2v2h-2zM7.91 11h2v2h-2zM3.91 11h2v2h-2z\"/>\n      </svg>"
    }, {
      name: 'ends_with',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M3 14.5h2v2H3zM11 14.5h2v2h-2zM7 14.5h2v2H7zM20.8 14.8v-3A2.1 2.1 0 0 0 20 10a3 3 0 0 0-2-.6 3 3 0 0 0-2 .6 1.7 1.7 0 0 0-.7 1.5h1.5a.8.8 0 0 1 .3-.7 1.3 1.3 0 0 1 .9-.3 1.3 1.3 0 0 1 .9.4 1.1 1.1 0 0 1 .3.8v.6H18a3.8 3.8 0 0 0-2.2.6 1.8 1.8 0 0 0-.8 1.5 2 2 0 0 0 .6 1.6 2.3 2.3 0 0 0 1.6.6 2.1 2.1 0 0 0 1.2-.4 2.8 2.8 0 0 0 .8-.8 4.3 4.3 0 0 0 .1.5l.1.5H21a4.1 4.1 0 0 1-.2-.7 5.4 5.4 0 0 1 0-1zm-1.6-.5a1.5 1.5 0 0 1-.6.7 2 2 0 0 1-1 .2 1.1 1.1 0 0 1-.8-.2.8.8 0 0 1-.2-.6 1 1 0 0 1 .3-.8 1.5 1.5 0 0 1 1.1-.3h1.2z\"/>\n      </svg>"
    }, {
      name: 'equals',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5 13.5h14v2H5zM5 8.5h14v2H5z\"/>\n      </svg>"
    }, {
      name: 'greater_than_or_equal',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5.99 19h12.02v2H5.99zM18 9.47L6 3v2.11L15.09 10 6 14.9v2.11l12-6.47V9.47z\"/>\n      </svg>"
    }, {
      name: 'greater_than',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M6 7.11L15.09 12 6 16.89V19l12-6.46v-1.08L6 5v2.11z\"/>\n      </svg>\n      "
    }, {
      name: 'is_after',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M15 7h4v10h-4v2h6V5h-6v2zM11 3h2v18h-2zM7 5h2v2H7zM3 5h2v2H3zM3 17h2v2H3zM3 13h2v2H3zM3 9h2v2H3zM7 17h2v2H7z\"/>\n      </svg>"
    }, {
      name: 'is_before',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M3 19h6v-2H5V7h4V5H3v14zM11 3h2v18h-2zM15 5h2v2h-2zM19 5h2v2h-2zM19 13h2v2h-2zM15 17h2v2h-2zM19 17h2v2h-2zM19 9h2v2h-2z\"/>\n      </svg>"
    }, {
      name: 'is_false',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm4.31 9.79l-1.52 1.52L8 13.52l-2.79 2.79-1.52-1.52L6.48 12 3.69 9.21l1.52-1.52L8 10.48l2.79-2.79 1.52 1.52L9.52 12zM18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7z\"/>\n        <path d=\"M17.52 13.85l2.91-2.92-.78-.78-2.13 2.12-1.17-1.15-.38.37-.41.41.42.42L17 13.34l.52.51z\"/>\n      </svg>"
    }, {
      name: 'is_not_null',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M16.58 6.07l.79-1.36-1.74-1-.78 1.35a7.5 7.5 0 0 0-7.43 12.87l-.79 1.36 1.74 1 .78-1.35a7.5 7.5 0 0 0 7.43-12.87zM6.5 12A5.5 5.5 0 0 1 12 6.5a5.65 5.65 0 0 1 1.84.32l-5.41 9.36A5.49 5.49 0 0 1 6.5 12zm5.5 5.5a5.65 5.65 0 0 1-1.84-.32l5.41-9.36A5.5 5.5 0 0 1 12 17.5z\"/>\n      </svg>"
    }, {
      name: 'is_null',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M12 4.5a7.5 7.5 0 1 0 7.5 7.5A7.5 7.5 0 0 0 12 4.5zm0 13a5.5 5.5 0 1 1 5.5-5.5 5.5 5.5 0 0 1-5.5 5.5z\"/>\n      </svg>"
    }, {
      name: 'is_true',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M19.44 14.22zM16.56 14.22zM16.56 14.22L18 12.79l1.44 1.43.78-.78L18.79 12l1.43-1.44-.78-.78L18 11.21l-1.44-1.43-.78.78L17.21 12l-1.43 1.44.78.78z\"/>\n        <path d=\"M18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7zM8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm-.93 10.18l-3.38-3.37 1.13-1.12 2.25 2.25 4.11-4.12 1.13 1.12z\"/>\n      </svg>"
    }, {
      name: 'last_month',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M17.5 14a4.48 4.48 0 1 0 4.5 4.5 4.47 4.47 0 0 0-4.5-4.5zm3.5 5.5h-4v2l-3-3 3-3v2h4zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z\"/>\n        <path d=\"M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z\"/>\n      </svg>"
    }, {
      name: 'last_year',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21 10v11H7v2h14a2 2 0 0 0 2-2V10z\"/>\n        <path d=\"M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z\"/>\n        <path d=\"M8.87 9l-2.99 3 2.99 3v-2.25h5.26v-1.5H8.87V9z\"/>\n      </svg>"
    }, {
      name: 'less_than_or_equal',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5.99 19h12.02v2H5.99zM18 14.9L8.91 10 18 5.11V3L6 9.47v1.07l12 6.47V14.9z\"/>\n      </svg>"
    }, {
      name: 'less_than',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M6 12.54L18 19v-2.11L8.91 12 18 7.11V5L6 11.46v1.08z\"/>\n      </svg>"
    }, {
      name: 'next_month',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M20 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2 6.74v-2h-4v-2h4v-2l3 3zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z\"/>\n        <path d=\"M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z\"/>\n      </svg>"
    }, {
      name: 'next_year',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z\"/>\n        <path d=\"M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z\"/>\n        <path d=\"M11.13 11.25H5.88v1.5h5.25V15l3-3-3-3v2.25z\"/>\n      </svg>"
    }, {
      name: 'not_empty',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5 9h2v2H5zM9 17h2v2H9zM13 17h2v2h-2zM17 9h2v2h-2zM17 5h2v2h-2zM5 17h2v2H5zM13 5h2v2h-2zM5 13h2v2H5zM19 15v-2h-2v.47L18.53 15H19zM11 7V5H9v.46L10.54 7H11zM2.76 1.76L1.5 3.06 20.97 22.5l1.26-1.26-8.89-8.89L2.76 1.76z\"/>\n      </svg>"
    }, {
      name: 'not_equal',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M17.37 4.71l-1.74-1-2.76 4.79H5v2h6.71l-1.73 3H5v2h3.82l-2.19 3.79 1.74 1 2.76-4.79H19v-2h-6.71l1.73-3H19v-2h-3.82l2.19-3.79z\"/>\n      </svg>"
    }, {
      name: 'start_expression',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M18.1 11h2v2h-2zM10.1 11h2v2h-2z\"/>\n        <path d=\"M10.9 6.8L9.3 5.5 4 12l5.4 6.5 1.6-1.3L6.5 12 11 6.8zM14.1 11h2v2h-2z\"/>\n      </svg>"
    }, {
      name: 'starts_with',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path fill=\"none\" d=\"M4.97 13.23h3.06L6.5 9.12l-1.53 4.11z\"/>\n        <path d=\"M5.89 7.5L2 16.5h1.72l.73-1.8h4.1l.73 1.8H11l-3.89-9zM5 13.23l1.5-4.11L8 13.23zM12 14.5h2v2h-2zM20 14.5h2v2h-2zM16 14.5h2v2h-2z\"/>\n      </svg>"
    }, {
      name: 'this_month',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M6 9h2v2H6zM6 13h2v2H6zM11 13h2v2h-2zM6 17h2v2H6zM11 17h2v2h-2zM11 9h2v2h-2zM16 9h2v2h-2zM21 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2.94 5.41l-1.75-1.76.69-.71 1.05 1L20 16.83l.71.71z\"/>\n        <path d=\"M5 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H8V1H6v2H5a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H5z\"/>\n      </svg>"
    }, {
      name: 'this_year',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z\"/>\n        <path d=\"M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z\"/>\n        <path d=\"M8.85 13.15l-1.77-1.77-.88.89 2.65 2.65 4.95-4.96-.88-.88-4.07 4.07z\"/>\n      </svg>"
    }, {
      name: 'today',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z\"/>\n        <path d=\"M16.53 12.06L15.47 11l-4.88 4.88-2.12-2.12-1.06 1.06L10.59 18l5.94-5.94z\"/>\n      </svg>"
    }, {
      name: 'ungroup',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M15 15h5v5h-5zM6 13h5v5H6zM13 6h5v5h-5zM6 6h5v5H6z\"/>\n        <path d=\"M20 2H4a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h9v-2H4V4h16v9h2V4a2 2 0 0 0-2-2z\"/>\n      </svg>"
    }, {
      name: 'yesterday',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M10.68 15.38h6.13v-1.75h-6.13V11l-3.49 3.5 3.49 3.5v-2.62z\"/>\n        <path d=\"M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z\"/>\n      </svg>"
    }, {
      name: 'pin',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M15.18 2.25l7.07 7.07-2.83-.01-3.54 3.55.01 4.24-3.53-3.54-5.66 5.66H5.28V17.8l5.66-5.66L7.4 8.61l4.24.01 3.55-3.54-.01-2.83z\"/>\n      </svg>"
    }, {
      name: 'unpin',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path fill=\"none\" d=\"M0 0h24v25H0V0z\"/>\n        <path d=\"M11.84 14.08L6.7 19.22H5.28V17.8l5.14-5.14L2 4.26 3.29 3l18 18L20 22.21zm4-.49l-5-5h.73l3.55-3.54v-2.8l7.07 7.07h-2.77l-3.54 3.54z\" />\n      </svg>"
    }, {
      name: 'ungroup',
      value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n          <path d=\"M18,4.5H6A1.5,1.5,0,0,0,4.5,6V18A1.5,1.5,0,0,0,6,19.5h6.75V18H6V6H18v6.75h1.5V6A1.5,1.5,0,0,0,18,4.5Z\"/>\n          <rect x=\"7.5\" y=\"12.75\" width=\"3.75\" height=\"3.75\"/>\n          <rect x=\"14.25\" y=\"14.25\" width=\"3.75\" height=\"3.75\"/>\n          <rect x=\"7.5\" y=\"7.5\" width=\"3.75\" height=\"3.75\"/>\n          <rect x=\"12.75\" y=\"7.5\" width=\"3.75\" height=\"3.75\"/>\n        </svg>"
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var FILTERING_ICONS_FONT_SET = 'filtering-icons';
    /**
     * @hidden
     */

    var ExpressionUI = function ExpressionUI() {
      _classCallCheck(this, ExpressionUI);

      this.isSelected = false;
      this.isVisible = true;
    };
    /**
     * @hidden
     */


    var IgxFilteringService =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       * @param {?} iconService
       */
      function IgxFilteringService(gridAPI, iconService) {
        _classCallCheck(this, IgxFilteringService);

        this.gridAPI = gridAPI;
        this.iconService = iconService;
        this.columnsWithComplexFilter = new Set();
        this.areEventsSubscribed = false;
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.isFiltering = false;
        this.columnToExpressionsMap = new Map();
        this.columnStartIndex = -1;
        this._filterIconsRegistered = false;
        this.isFilterRowVisible = false;
        this.filteredColumn = null;
        this.selectedExpression = null;
        this.columnToFocus = null;
        this.shouldFocusNext = false;
        this.columnToMoreIconHidden = new Map();
      }
      /**
       * @return {?}
       */


      _createClass(IgxFilteringService, [{
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
        /**
         * @return {?}
         */

      }, {
        key: "subscribeToEvents",

        /**
         * Subscribe to grid's events.
         * @return {?}
         */
        value: function subscribeToEvents() {
          var _this205 = this;

          if (!this.areEventsSubscribed) {
            this.areEventsSubscribed = true;
            this.grid.onColumnResized.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (eventArgs) {
              _this205.updateFilteringCell(eventArgs.column);
            });
            this.grid.parentVirtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (eventArgs) {
              if (eventArgs.startIndex !== _this205.columnStartIndex) {
                _this205.columnStartIndex = eventArgs.startIndex;

                _this205.grid.filterCellList.forEach(function (filterCell) {
                  filterCell.updateFilterCellArea();
                });
              }

              if (_this205.columnToFocus) {
                _this205.focusFilterCellChip(_this205.columnToFocus, false);

                _this205.columnToFocus = null;
              }
            });
            this.grid.onColumnMovingEnd.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function () {
              _this205.grid.filterCellList.forEach(function (filterCell) {
                filterCell.updateFilterCellArea();
              });
            });
            this.grid.onColumnVisibilityChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (eventArgs) {
              if (_this205.grid.filteringRow && _this205.grid.filteringRow.column === eventArgs.column) {
                _this205.grid.filteringRow.close();
              }
            });
          }
        }
        /**
         * Internal method to create expressionsTree and filter grid used in both filter modes.
         * @param {?} field
         * @param {?=} expressions
         * @return {?}
         */

      }, {
        key: "filterInternal",
        value: function filterInternal(field) {
          var expressions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          this.isFiltering = true;
          /** @type {?} */

          var expressionsTree;

          if (expressions instanceof FilteringExpressionsTree) {
            expressionsTree = expressions;
          } else {
            expressionsTree = this.createSimpleFilteringTree(field, expressions);
          }

          if (expressionsTree.filteringOperands.length === 0) {
            this.clearFilter(field);
          } else {
            this.filter(field, null, expressionsTree);
          }

          this.isFiltering = false;
        }
        /**
         * Execute filtering on the grid.
         * @param {?} field
         * @param {?} value
         * @param {?=} conditionOrExpressionTree
         * @param {?=} ignoreCase
         * @return {?}
         */

      }, {
        key: "filter",
        value: function filter(field, value, conditionOrExpressionTree, ignoreCase) {
          var _this206 = this;

          /** @type {?} */
          var col = this.gridAPI.get_column_by_name(field);
          /** @type {?} */

          var filteringIgnoreCase = ignoreCase || (col ? col.filteringIgnoreCase : false);

          if (conditionOrExpressionTree) {
            this.gridAPI.filter(field, value, conditionOrExpressionTree, filteringIgnoreCase);
          } else {
            /** @type {?} */
            var expressionsTreeForColumn = this.grid.filteringExpressionsTree.find(field);

            if (!expressionsTreeForColumn) {
              throw new Error('Invalid condition or Expression Tree!');
            } else if (expressionsTreeForColumn instanceof FilteringExpressionsTree) {
              this.gridAPI.filter(field, value, expressionsTreeForColumn, filteringIgnoreCase);
            } else {
              /** @type {?} */
              var expressionForColumn =
              /** @type {?} */
              expressionsTreeForColumn;
              this.gridAPI.filter(field, value, expressionForColumn.condition, filteringIgnoreCase);
            }
          } // Wait for the change detection to update filtered data through the pipes and then emit the event.


          requestAnimationFrame(function () {
            return _this206.grid.onFilteringDone.emit(col.filteringExpressionsTree);
          });
        }
        /**
         * Clear the filter of a given column.
         * @param {?} field
         * @return {?}
         */

      }, {
        key: "clearFilter",
        value: function clearFilter(field) {
          var _this207 = this;

          if (field) {
            /** @type {?} */
            var column = this.gridAPI.get_column_by_name(field);

            if (!column) {
              return;
            }
          }

          this.isFiltering = true;
          this.gridAPI.clear_filter(field); // Wait for the change detection to update filtered data through the pipes and then emit the event.

          requestAnimationFrame(function () {
            return _this207.grid.onFilteringDone.emit(null);
          });

          if (field) {
            /** @type {?} */
            var expressions = this.getExpressions(field);
            expressions.length = 0;
          }

          this.isFiltering = false;
        }
        /**
         * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
         * @param {?} value
         * @param {?} condition
         * @param {?=} ignoreCase
         * @return {?}
         */

      }, {
        key: "filterGlobal",
        value: function filterGlobal(value, condition, ignoreCase) {
          var _this208 = this;

          this.gridAPI.filter_global(value, condition, ignoreCase); // Wait for the change detection to update filtered data through the pipes and then emit the event.

          requestAnimationFrame(function () {
            return _this208.grid.onFilteringDone.emit(_this208.grid.filteringExpressionsTree);
          });
        }
        /**
         * Register filtering SVG icons in the icon service.
         * @return {?}
         */

      }, {
        key: "registerSVGIcons",
        value: function registerSVGIcons() {
          if (!this._filterIconsRegistered) {
            var _iteratorNormalCompletion43 = true;
            var _didIteratorError43 = false;
            var _iteratorError43 = undefined;

            try {
              for (var _iterator43 = icons[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
                var icon = _step43.value;

                if (!this.iconService.isSvgIconCached(icon.name, FILTERING_ICONS_FONT_SET)) {
                  this.iconService.addSvgIconFromText(icon.name, icon.value, FILTERING_ICONS_FONT_SET);
                }
              }
            } catch (err) {
              _didIteratorError43 = true;
              _iteratorError43 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion43 && _iterator43["return"] != null) {
                  _iterator43["return"]();
                }
              } finally {
                if (_didIteratorError43) {
                  throw _iteratorError43;
                }
              }
            }

            this._filterIconsRegistered = true;
          }
        }
        /**
         * Returns the ExpressionUI array for a given column.
         * @param {?} columnId
         * @return {?}
         */

      }, {
        key: "getExpressions",
        value: function getExpressions(columnId) {
          if (!this.columnToExpressionsMap.has(columnId)) {
            /** @type {?} */
            var column = this.grid.columns.find(function (col) {
              return col.field === columnId;
            });
            /** @type {?} */

            var expressionUIs = new Array();

            if (column) {
              this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, expressionUIs);
              this.columnToExpressionsMap.set(columnId, expressionUIs);
            }

            return expressionUIs;
          }

          return this.columnToExpressionsMap.get(columnId);
        }
        /**
         * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
         * @return {?}
         */

      }, {
        key: "refreshExpressions",
        value: function refreshExpressions() {
          var _this209 = this;

          if (!this.isFiltering) {
            this.columnsWithComplexFilter.clear();
            this.columnToExpressionsMap.forEach(function (value, key) {
              /** @type {?} */
              var column = _this209.grid.columns.find(function (col) {
                return col.field === key;
              });

              if (column) {
                value.length = 0;

                _this209.generateExpressionsList(column.filteringExpressionsTree, _this209.grid.filteringExpressionsTree.operator, value);
                /** @type {?} */


                var isComplex = _this209.isFilteringTreeComplex(column.filteringExpressionsTree);

                if (isComplex) {
                  _this209.columnsWithComplexFilter.add(key);
                }

                _this209.updateFilteringCell(column);
              } else {
                _this209.columnToExpressionsMap["delete"](key);
              }
            });
          }
        }
        /**
         * Remove an ExpressionUI for a given column.
         * @param {?} columnId
         * @param {?} indexToRemove
         * @return {?}
         */

      }, {
        key: "removeExpression",
        value: function removeExpression(columnId, indexToRemove) {
          /** @type {?} */
          var expressionsList = this.getExpressions(columnId);

          if (indexToRemove === 0 && expressionsList.length > 1) {
            expressionsList[1].beforeOperator = null;
          } else if (indexToRemove === expressionsList.length - 1) {
            expressionsList[indexToRemove - 1].afterOperator = null;
          } else {
            expressionsList[indexToRemove - 1].afterOperator = expressionsList[indexToRemove + 1].beforeOperator;
            expressionsList[0].beforeOperator = null;
            expressionsList[expressionsList.length - 1].afterOperator = null;
          }

          expressionsList.splice(indexToRemove, 1);
        }
        /**
         * Generate filtering tree for a given column from existing ExpressionUIs.
         * @param {?} columnId
         * @param {?=} expressionUIList
         * @return {?}
         */

      }, {
        key: "createSimpleFilteringTree",
        value: function createSimpleFilteringTree(columnId) {
          var expressionUIList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          /** @type {?} */
          var expressionsList = expressionUIList ? expressionUIList : this.getExpressions(columnId);
          /** @type {?} */

          var expressionsTree = new FilteringExpressionsTree(FilteringLogic.Or, columnId);
          /** @type {?} */

          var currAndBranch;
          /** @type {?} */

          var currExpressionUI;

          for (var i = 0; i < expressionsList.length; i++) {
            currExpressionUI = expressionsList[i];

            if (!currExpressionUI.expression.condition.isUnary && currExpressionUI.expression.searchVal === null) {
              if (currExpressionUI.afterOperator === FilteringLogic.And && !currAndBranch) {
                currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                expressionsTree.filteringOperands.push(currAndBranch);
              }

              continue;
            }

            if ((currExpressionUI.beforeOperator === undefined || currExpressionUI.beforeOperator === null || currExpressionUI.beforeOperator === FilteringLogic.Or) && currExpressionUI.afterOperator === FilteringLogic.And) {
              currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
              expressionsTree.filteringOperands.push(currAndBranch);
              currAndBranch.filteringOperands.push(currExpressionUI.expression);
            } else if (currExpressionUI.beforeOperator === FilteringLogic.And) {
              currAndBranch.filteringOperands.push(currExpressionUI.expression);
            } else {
              expressionsTree.filteringOperands.push(currExpressionUI.expression);
              currAndBranch = null;
            }
          }

          return expressionsTree;
        }
        /**
         * Returns whether a complex filter is applied to a given column.
         * @param {?} columnId
         * @return {?}
         */

      }, {
        key: "isFilterComplex",
        value: function isFilterComplex(columnId) {
          if (this.columnsWithComplexFilter.has(columnId)) {
            return true;
          }
          /** @type {?} */


          var column = this.grid.columns.find(function (col) {
            return col.field === columnId;
          });
          /** @type {?} */

          var isComplex = column && this.isFilteringTreeComplex(column.filteringExpressionsTree);

          if (isComplex) {
            this.columnsWithComplexFilter.add(columnId);
          }

          return isComplex;
        }
        /**
         * Returns the string representation of the FilteringLogic operator.
         * @param {?} operator
         * @return {?}
         */

      }, {
        key: "getOperatorAsString",
        value: function getOperatorAsString(operator) {
          if (operator === 0) {
            return this.grid.resourceStrings.igx_grid_filter_operator_and;
          } else {
            return this.grid.resourceStrings.igx_grid_filter_operator_or;
          }
        }
        /**
         * Generate the label of a chip from a given filtering expression.
         * @param {?} expression
         * @return {?}
         */

      }, {
        key: "getChipLabel",
        value: function getChipLabel(expression) {
          if (expression.condition.isUnary) {
            return this.grid.resourceStrings["igx_grid_filter_".concat(expression.condition.name)] || expression.condition.name;
          } else if (expression.searchVal instanceof Date) {
            return this.datePipe.transform(expression.searchVal, this.grid.locale);
          } else {
            return expression.searchVal;
          }
        }
        /**
         * Updates the content of a filterCell.
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "updateFilteringCell",
        value: function updateFilteringCell(column) {
          /** @type {?} */
          var filterCell = column.filterCell;

          if (filterCell) {
            filterCell.updateFilterCellArea();
          }
        }
        /**
         * Focus a chip in a filterCell.
         * @param {?} column
         * @param {?} focusFirst
         * @return {?}
         */

      }, {
        key: "focusFilterCellChip",
        value: function focusFilterCellChip(column, focusFirst) {
          /** @type {?} */
          var filterCell = column.filterCell;

          if (filterCell) {
            filterCell.focusChip(focusFirst);
          }
        }
        /**
         * Focus the close button in the filtering row.
         * @return {?}
         */

      }, {
        key: "focusFilterRowCloseButton",
        value: function focusFilterRowCloseButton() {
          this.grid.filteringRow.closeButton.nativeElement.focus();
        }
        /**
         * @return {?}
         */

      }, {
        key: "scrollToFilterCell",

        /**
         * Scrolls to a filterCell.
         * @param {?} column
         * @param {?} shouldFocusNext
         * @return {?}
         */
        value: function scrollToFilterCell(column, shouldFocusNext) {
          this.grid.nativeElement.focus({
            preventScroll: true
          });
          this.columnToFocus = column;
          this.shouldFocusNext = shouldFocusNext;
          /** @type {?} */

          var currentColumnRight = 0;
          /** @type {?} */

          var currentColumnLeft = 0;

          for (var index = 0; index < this.unpinnedColumns.length; index++) {
            currentColumnRight += parseInt(this.unpinnedColumns[index].width, 10);

            if (this.unpinnedColumns[index] === column) {
              currentColumnLeft = currentColumnRight - parseInt(this.unpinnedColumns[index].width, 10);
              break;
            }
          }
          /** @type {?} */


          var forOfDir = this.grid.headerContainer;
          /** @type {?} */

          var width = this.displayContainerWidth + this.displayContainerScrollLeft;

          if (shouldFocusNext) {
            forOfDir.scrollPosition += currentColumnRight - width;
          } else {
            forOfDir.scrollPosition = currentColumnLeft;
          }
        }
        /**
         * @private
         * @param {?} expressions
         * @return {?}
         */

      }, {
        key: "isFilteringTreeComplex",
        value: function isFilteringTreeComplex(expressions) {
          if (!expressions) {
            return false;
          }

          if (expressions instanceof FilteringExpressionsTree) {
            /** @type {?} */
            var expressionsTree =
            /** @type {?} */
            expressions;

            if (expressionsTree.operator === FilteringLogic.Or) {
              /** @type {?} */
              var andOperatorsCount = this.getChildAndOperatorsCount(expressionsTree); // having more that 'And' and operator in the sub-tree means that the filter could not be represented without parentheses.

              return andOperatorsCount > 1;
            }
            /** @type {?} */


            var isComplex = false;

            for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
              isComplex = isComplex || this.isFilteringTreeComplex(expressionsTree.filteringOperands[i]);
            }

            return isComplex;
          }

          return false;
        }
        /**
         * @private
         * @param {?} expressions
         * @return {?}
         */

      }, {
        key: "getChildAndOperatorsCount",
        value: function getChildAndOperatorsCount(expressions) {
          /** @type {?} */
          var count = 0;
          /** @type {?} */

          var operand;

          for (var i = 0; i < expressions.filteringOperands.length; i++) {
            operand = expressions[i];

            if (operand instanceof FilteringExpressionsTree) {
              if (operand.operator === FilteringLogic.And) {
                count++;
              }

              count = count + this.getChildAndOperatorsCount(operand);
            }
          }

          return count;
        }
        /**
         * @param {?} expressions
         * @param {?} operator
         * @param {?} expressionsUIs
         * @return {?}
         */

      }, {
        key: "generateExpressionsList",
        value: function generateExpressionsList(expressions, operator, expressionsUIs) {
          this.generateExpressionsListRecursive(expressions, operator, expressionsUIs); // The beforeOperator of the first expression and the afterOperator of the last expression should be null

          if (expressionsUIs.length) {
            expressionsUIs[expressionsUIs.length - 1].afterOperator = null;
          }
        }
        /**
         * @private
         * @param {?} expressions
         * @param {?} operator
         * @param {?} expressionsUIs
         * @return {?}
         */

      }, {
        key: "generateExpressionsListRecursive",
        value: function generateExpressionsListRecursive(expressions, operator, expressionsUIs) {
          if (!expressions) {
            return;
          }

          if (expressions instanceof FilteringExpressionsTree) {
            /** @type {?} */
            var expressionsTree =
            /** @type {?} */
            expressions;

            for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
              this.generateExpressionsListRecursive(expressionsTree.filteringOperands[i], expressionsTree.operator, expressionsUIs);
            }

            if (expressionsUIs.length) {
              expressionsUIs[expressionsUIs.length - 1].afterOperator = operator;
            }
          } else {
            /** @type {?} */
            var exprUI = new ExpressionUI();
            exprUI.expression =
            /** @type {?} */
            expressions;
            exprUI.afterOperator = operator;
            /** @type {?} */

            var prevExprUI = expressionsUIs[expressionsUIs.length - 1];

            if (prevExprUI) {
              exprUI.beforeOperator = prevExprUI.afterOperator;
            }

            expressionsUIs.push(exprUI);
          }
        }
        /**
         * @param {?} expressionTree
         * @return {?}
         */

      }, {
        key: "isFilteringExpressionsTreeEmpty",
        value: function isFilteringExpressionsTreeEmpty(expressionTree) {
          if (FilteringExpressionsTree.empty(expressionTree)) {
            return true;
          }
          /** @type {?} */


          var expr;

          for (var i = 0; i < expressionTree.filteringOperands.length; i++) {
            expr = expressionTree.filteringOperands[i];

            if (expr instanceof FilteringExpressionsTree) {
              /** @type {?} */
              var exprTree =
              /** @type {?} */
              expr;

              if (exprTree.filteringOperands && exprTree.filteringOperands.length) {
                return false;
              }
            } else {
              return false;
            }
          }

          return true;
        }
      }, {
        key: "displayContainerWidth",
        get: function get() {
          return parseInt(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth, 10);
        }
        /**
         * @return {?}
         */

      }, {
        key: "displayContainerScrollLeft",
        get: function get() {
          return this.grid.headerContainer.scrollPosition;
        }
        /**
         * @return {?}
         */

      }, {
        key: "areAllColumnsInView",
        get: function get() {
          return parseInt(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth, 10) === 0;
        }
        /**
         * @return {?}
         */

      }, {
        key: "unpinnedFilterableColumns",
        get: function get() {
          return this.grid.unpinnedColumns.filter(function (col) {
            return !col.columnGroup && col.filterable;
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "unpinnedColumns",
        get: function get() {
          return this.grid.unpinnedColumns.filter(function (col) {
            return !col.columnGroup;
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "datePipe",
        get: function get() {
          if (!this._datePipe) {
            this._datePipe = new IgxDatePipeComponent(this.grid.locale);
          }

          return this._datePipe;
        }
      }, {
        key: "filteredData",
        get: function get() {
          return this.grid.filteredData;
        }
      }]);

      return IgxFilteringService;
    }();

    IgxFilteringService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /** @nocollapse */

    IgxFilteringService.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: IgxIconService
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxExcelStyleLoadingValuesTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxExcelStyleLoadingValuesTemplateDirective(template) {
      _classCallCheck(this, IgxExcelStyleLoadingValuesTemplateDirective);

      this.template = template;
    };

    IgxExcelStyleLoadingValuesTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxExcelStyleLoading]'
      }]
    }];
    /** @nocollapse */

    IgxExcelStyleLoadingValuesTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxExcelStyleSearchComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       */
      function IgxExcelStyleSearchComponent(cdr) {
        _classCallCheck(this, IgxExcelStyleSearchComponent);

        this.cdr = cdr;
      }
      /**
       * @return {?}
       */


      _createClass(IgxExcelStyleSearchComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          this.refreshSize();
        }
        /**
         * @return {?}
         */

      }, {
        key: "refreshSize",
        value: function refreshSize() {
          var _this210 = this;

          requestAnimationFrame(function () {
            _this210.virtDir.recalcUpdateSizes();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "clearInput",
        value: function clearInput() {
          this.searchValue = null;
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onCheckboxChange",
        value: function onCheckboxChange(eventArgs) {
          var _this211 = this;

          /** @type {?} */
          var selectedIndex = this.data.indexOf(eventArgs.checkbox.value);

          if (selectedIndex === 0) {
            this.data.forEach(function (element) {
              element.isSelected = eventArgs.checked;
              _this211.data[0].indeterminate = false;
            });
          } else {
            eventArgs.checkbox.value.isSelected = eventArgs.checked;

            if (!this.data.slice(1, this.data.length).find(function (el) {
              return el.isSelected === false;
            })) {
              this.data[0].indeterminate = false;
              this.data[0].isSelected = true;
            } else if (!this.data.slice(1, this.data.length).find(function (el) {
              return el.isSelected === true;
            })) {
              this.data[0].indeterminate = false;
              this.data[0].isSelected = false;
            } else {
              this.data[0].indeterminate = true;
            }
          }

          eventArgs.checkbox.nativeCheckbox.nativeElement.blur();
        }
        /**
         * @return {?}
         */

      }, {
        key: "isLoading",
        get: function get() {
          return this._isLoading;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._isLoading = value;

          if (!
          /** @type {?} */
          this.cdr.destroyed) {
            this.cdr.detectChanges();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "valuesLoadingTemplate",
        get: function get() {
          if (this.grid.excelStyleLoadingValuesTemplateDirective) {
            return this.grid.excelStyleLoadingValuesTemplateDirective.template;
          } else {
            return this.defaultExcelStyleLoadingValuesTemplate;
          }
        }
      }, {
        key: "itemSize",
        get: function get() {
          /** @type {?} */
          var itemSize = '40px';

          switch (this.displayDensity) {
            case DisplayDensity.cosy:
              itemSize = '32px';
              break;

            case DisplayDensity.compact:
              itemSize = '24px';
              break;

            default:
              break;
          }

          return itemSize;
        }
      }]);

      return IgxExcelStyleSearchComponent;
    }();

    IgxExcelStyleSearchComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-excel-style-search',
        template: "<igx-input-group\n            type=\"box\"\n            [displayDensity]=\"displayDensity\"\n            [supressInputAutofocus]=\"true\">\n    <igx-icon igxPrefix>search</igx-icon>\n    <input\n        #input\n        igxInput\n        tabindex=\"0\"\n        [(ngModel)]=\"searchValue\"\n        [placeholder]=\"column.grid.resourceStrings.igx_grid_excel_search_placeholder\"\n        autocomplete=\"off\"/>\n    <igx-icon\n        igxSuffix\n        *ngIf=\"searchValue || searchValue === 0\"\n        (click)=\"clearInput()\"\n        tabindex=\"0\">\n        clear\n    </igx-icon>\n</igx-input-group>\n\n<igx-list [displayDensity]=\"displayDensity\" [style.height.px]=\"250\" [isLoading]=\"isLoading\">\n    <div [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\">\n        <igx-list-item\n            *igxFor=\"let item of data | excelStyleSearchFilter: searchValue; scrollOrientation : 'vertical'; containerSize: '250px'; itemSize: itemSize\">\n            <igx-checkbox\n            [value]=\"item\"\n            tabindex=\"-1\"\n            [checked]=\"item.isSelected\"\n            [disableRipple]=\"true\"\n            [indeterminate]=\"item.indeterminate\"\n            [disableTransitions]=\"true\"\n            (change)=\"onCheckboxChange($event)\">\n                {{ column.formatter && !item.isSpecial ? column.formatter(item.label) : column.dataType === 'number' ? (item.label | igxdecimal:\n                    column.grid.locale) : column.dataType === 'date' ? (item.label | igxdate: column.grid.locale) : item.label }}\n            </igx-checkbox>\n        </igx-list-item>\n    </div>\n\n    <ng-template igxDataLoading>        \n        <div class=\"igx-excel-filter__loading\">\n            <ng-container *ngTemplateOutlet=\"valuesLoadingTemplate\">\n            </ng-container>\n        </div>\n    </ng-template>\n</igx-list>\n\n<ng-template #defaultExcelStyleLoadingValuesTemplate>\n    <igx-circular-bar [indeterminate]=\"true\">\n    </igx-circular-bar>\n</ng-template>\n"
      }]
    }];
    /** @nocollapse */

    IgxExcelStyleSearchComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxExcelStyleSearchComponent.propDecorators = {
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      searchInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['input', {
          read: IgxInputDirective,
          "static": true
        }]
      }],
      displayDensity: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      virtDir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxForOfDirective, {
          "static": true
        }]
      }],
      defaultExcelStyleLoadingValuesTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultExcelStyleLoadingValuesTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxExcelStyleDefaultExpressionComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       */
      function IgxExcelStyleDefaultExpressionComponent(cdr) {
        _classCallCheck(this, IgxExcelStyleDefaultExpressionComponent);

        this.cdr = cdr;
        this._dropDownOverlaySettings = {
          closeOnOutsideClick: true,
          modal: false,
          positionStrategy: new ConnectedPositioningStrategy(),
          scrollStrategy: new CloseScrollStrategy()
        };
        this.onExpressionRemoved = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onLogicOperatorChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * @protected
       * @return {?}
       */


      _createClass(IgxExcelStyleDefaultExpressionComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          this._dropDownOverlaySettings.outlet = this.column.grid.outletDirective;
          this._dropDownOverlaySettings.positionStrategy.settings.target = this.inputGroupConditions.element.nativeElement;
        }
        /**
         * @return {?}
         */

      }, {
        key: "focus",
        value: function focus() {
          var _this212 = this;

          // use requestAnimationFrame to focus the values input because when initializing the component
          // datepicker's input group is not yet fully initialized
          requestAnimationFrame(function () {
            return _this212.inputValuesElement.focus();
          });
        }
        /**
         * @param {?} conditionName
         * @return {?}
         */

      }, {
        key: "isConditionSelected",
        value: function isConditionSelected(conditionName) {
          return this.expressionUI.expression.condition && this.expressionUI.expression.condition.name === conditionName;
        }
        /**
         * @param {?} condition
         * @return {?}
         */

      }, {
        key: "getConditionName",
        value: function getConditionName(condition) {
          return condition ? this.translateCondition(condition.name) : null;
        }
        /**
         * @return {?}
         */

      }, {
        key: "getInputWidth",
        value: function getInputWidth() {
          return this.inputGroupConditions.element.nativeElement.offsetWidth + 'px';
        }
        /**
         * @return {?}
         */

      }, {
        key: "translateCondition",

        /**
         * @param {?} value
         * @return {?}
         */
        value: function translateCondition(value) {
          return this.grid.resourceStrings["igx_grid_filter_".concat(this.getCondition(value).name)] || value;
        }
        /**
         * @return {?}
         */

      }, {
        key: "getIconName",
        value: function getIconName() {
          if (this.column.dataType === DataType.Boolean && this.expressionUI.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
          } else if (!this.expressionUI.expression.condition) {
            return 'filter_list';
          } else {
            return this.expressionUI.expression.condition.iconName;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "toggleCustomDialogDropDown",
        value: function toggleCustomDialogDropDown() {
          this.dropdownConditions.toggle(this._dropDownOverlaySettings);
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "getCondition",
        value: function getCondition(value) {
          return this.column.filters.condition(value);
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onConditionsChanged",
        value: function onConditionsChanged(eventArgs) {
          /** @type {?} */
          var value =
          /** @type {?} */
          eventArgs.newSelection.value;
          this.expressionUI.expression.condition = this.getCondition(value);
          this.focus();
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onValuesInput",
        value: function onValuesInput(eventArgs) {
          this.expressionUI.expression.searchVal = DataUtil.parseValue(this.column.dataType, eventArgs.target.value);
        }
        /**
         * @param {?} eventArgs
         * @param {?} buttonIndex
         * @return {?}
         */

      }, {
        key: "onLogicOperatorButtonClicked",
        value: function onLogicOperatorButtonClicked(eventArgs, buttonIndex) {
          if (this.logicOperatorButtonGroup.selectedButtons.length === 0) {
            eventArgs.stopPropagation();
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
          } else {
            this.onLogicOperatorChanged.emit({
              target: this.expressionUI,
              newValue:
              /** @type {?} */
              buttonIndex
            });
          }
        }
        /**
         * @param {?} eventArgs
         * @param {?} buttonIndex
         * @return {?}
         */

      }, {
        key: "onLogicOperatorKeyDown",
        value: function onLogicOperatorKeyDown(eventArgs, buttonIndex) {
          if (eventArgs.key === "Enter"
          /* ENTER */
          ) {
              this.logicOperatorButtonGroup.selectButton(buttonIndex);
              this.onLogicOperatorChanged.emit({
                target: this.expressionUI,
                newValue:
                /** @type {?} */
                buttonIndex
              });
            }
        }
        /**
         * @return {?}
         */

      }, {
        key: "onRemoveButtonClick",
        value: function onRemoveButtonClick() {
          this.onExpressionRemoved.emit(this.expressionUI);
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onInputConditionsKeyDown",
        value: function onInputConditionsKeyDown(eventArgs) {
          if (eventArgs.altKey && (eventArgs.key === "ArrowDown"
          /* DOWN_ARROW */
          || eventArgs.key === "Down"
          /* DOWN_ARROW_IE */
          )) {
            this.toggleCustomDialogDropDown();
          }

          if (eventArgs.key === "Tab"
          /* TAB */
          && eventArgs.shiftKey && this.expressionsList[0] === this.expressionUI) {
            eventArgs.preventDefault();
          }

          event.stopPropagation();
        }
      }, {
        key: "inputValuesElement",
        get: function get() {
          return this.inputValuesDirective;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isLast",
        get: function get() {
          return this.expressionsList[this.expressionsList.length - 1] === this.expressionUI;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isSingle",
        get: function get() {
          return this.expressionsList.length === 1;
        }
        /**
         * @return {?}
         */

      }, {
        key: "inputConditionsPlaceholder",
        get: function get() {
          return this.grid.resourceStrings['igx_grid_filter_condition_placeholder'];
        }
        /**
         * @return {?}
         */

      }, {
        key: "inputValuePlaceholder",
        get: function get() {
          return this.grid.resourceStrings['igx_grid_filter_row_placeholder'];
        }
        /**
         * @return {?}
         */

      }, {
        key: "type",
        get: function get() {
          switch (this.column.dataType) {
            case DataType.Number:
              return 'number';

            default:
              return 'text';
          }
        }
      }, {
        key: "conditions",
        get: function get() {
          return this.column.filters.conditionList();
        }
      }]);

      return IgxExcelStyleDefaultExpressionComponent;
    }();

    IgxExcelStyleDefaultExpressionComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-excel-style-default-expression',
        template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    [displayDensity]=\"displayDensity\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\"\n    [supressInputAutofocus]=\"true\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        tabindex=\"0\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-input-group #inputGroupValues type=\"box\" [displayDensity]=\"displayDensity\" [supressInputAutofocus]=\"true\">\n    <input\n        #inputValues\n        igxInput\n        [type]=\"type\"\n        tabindex=\"0\"\n        [placeholder]=\"inputValuePlaceholder\"\n        [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"\n        autocomplete=\"off\"\n        [value]=\"expressionUI.expression.searchVal\"\n        (input)=\"onValuesInput($event)\"\n    />\n</igx-input-group>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\">\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #orButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
      }]
    }];
    /** @nocollapse */

    IgxExcelStyleDefaultExpressionComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxExcelStyleDefaultExpressionComponent.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      expressionUI: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      expressionsList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      displayDensity: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onExpressionRemoved: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onLogicOperatorChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      inputGroupConditions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['inputGroupConditions', {
          read: IgxInputGroupComponent,
          "static": true
        }]
      }],
      inputValuesDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['inputValues', {
          read: IgxInputDirective,
          "static": true
        }]
      }],
      dropdownConditions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['dropdownConditions', {
          read: IgxDropDownComponent,
          "static": true
        }]
      }],
      logicOperatorButtonGroup: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['logicOperatorButtonGroup', {
          read: IgxButtonGroupComponent,
          "static": false
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxExcelStyleDateExpressionComponent =
    /*#__PURE__*/
    function (_IgxExcelStyleDefault) {
      _inherits(IgxExcelStyleDateExpressionComponent, _IgxExcelStyleDefault);

      function IgxExcelStyleDateExpressionComponent() {
        _classCallCheck(this, IgxExcelStyleDateExpressionComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxExcelStyleDateExpressionComponent).apply(this, arguments));
      }

      _createClass(IgxExcelStyleDateExpressionComponent, [{
        key: "inputValuesElement",

        /**
         * @protected
         * @return {?}
         */
        get: function get() {
          return this.datePicker.getEditElement();
        }
        /**
         * @return {?}
         */

      }, {
        key: "inputDatePlaceholder",
        get: function get() {
          return this.grid.resourceStrings['igx_grid_filter_row_date_placeholder'];
        }
      }]);

      return IgxExcelStyleDateExpressionComponent;
    }(IgxExcelStyleDefaultExpressionComponent);

    IgxExcelStyleDateExpressionComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-excel-style-date-expression',
        template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    [displayDensity]=\"displayDensity\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\"\n    [supressInputAutofocus]=\"true\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        tabindex=\"0\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-date-picker #datePicker mode=\"dropdown\" [(ngModel)]=\"expressionUI.expression.searchVal\" [locale]=\"grid.locale\" [outlet]=\"grid.outletDirective\">\n    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"displayDensity\" [supressInputAutofocus]=\"true\">\n            <input #input\n                    igxInput\n                    tabindex=\"0\"\n                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                    [placeholder]=\"inputDatePlaceholder\"\n                    autocomplete=\"off\"\n                    [value]=\"value | igxdate: grid.locale\"\n                    [readonly]=\"true\"\n                    [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"/>\n        </igx-input-group>\n    </ng-template>\n</igx-date-picker>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\" >\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        tabindex=\"0\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #orButton\n        tabindex=\"0\"\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
      }]
    }];
    IgxExcelStyleDateExpressionComponent.propDecorators = {
      datePicker: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['datePicker', {
          read: IgxDatePickerComponent,
          "static": true
        }]
      }],
      displayDensity: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxExcelStyleCustomDialogComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       */
      function IgxExcelStyleCustomDialogComponent(cdr) {
        _classCallCheck(this, IgxExcelStyleCustomDialogComponent);

        this.cdr = cdr;
        this.expressionsList = new Array();
        this._customDialogPositionSettings = {
          verticalDirection: VerticalAlignment.Middle,
          horizontalDirection: HorizontalAlignment.Center,
          horizontalStartPoint: HorizontalAlignment.Center,
          verticalStartPoint: VerticalAlignment.Middle
        };
        this._customDialogOverlaySettings = {
          closeOnOutsideClick: true,
          modal: false,
          positionStrategy: new ConnectedPositioningStrategy(this._customDialogPositionSettings),
          scrollStrategy: new AbsoluteScrollStrategy()
        };
      }
      /**
       * @return {?}
       */


      _createClass(IgxExcelStyleCustomDialogComponent, [{
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this._customDialogOverlaySettings.outlet = this.grid.outlet;
        }
        /**
         * @return {?}
         */

      }, {
        key: "onCustomDialogOpening",

        /**
         * @return {?}
         */
        value: function onCustomDialogOpening() {
          if (this.selectedOperator) {
            this.createInitialExpressionUIElement();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "onCustomDialogOpened",
        value: function onCustomDialogOpened() {
          if (this.expressionComponents.first) {
            this.expressionComponents.first.focus();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "open",
        value: function open() {
          this._customDialogOverlaySettings.positionStrategy.settings.target = this.grid.rootGrid ? this.grid.rootGrid.nativeElement : this.grid.nativeElement;
          this.toggle.open(this._customDialogOverlaySettings);
        }
        /**
         * @return {?}
         */

      }, {
        key: "onClearButtonClick",
        value: function onClearButtonClick() {
          this.filteringService.clearFilter(this.column.field);
          this.createInitialExpressionUIElement();
          this.cdr.detectChanges();
        }
        /**
         * @return {?}
         */

      }, {
        key: "closeDialog",
        value: function closeDialog() {
          if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "onApplyButtonClick",
        value: function onApplyButtonClick() {
          this.expressionsList = this.expressionsList.filter(function (element) {
            return element.expression.condition && (element.expression.searchVal || element.expression.searchVal === 0 || element.expression.condition.isUnary);
          });

          if (this.expressionsList.length > 0) {
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
          }

          this.filteringService.filterInternal(this.column.field, this.expressionsList);
          this.closeDialog();
        }
        /**
         * @return {?}
         */

      }, {
        key: "onAddButtonClick",
        value: function onAddButtonClick() {
          /** @type {?} */
          var exprUI = new ExpressionUI();
          exprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
          };
          this.expressionsList[this.expressionsList.length - 1].afterOperator = FilteringLogic.And;
          exprUI.beforeOperator = this.expressionsList[this.expressionsList.length - 1].afterOperator;
          this.expressionsList.push(exprUI);
          this.markChildrenForCheck();
          this.scrollToBottom();
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onExpressionRemoved",
        value: function onExpressionRemoved(event) {
          /** @type {?} */
          var indexToRemove = this.expressionsList.indexOf(event);

          if (indexToRemove === 0 && this.expressionsList.length > 1) {
            this.expressionsList[1].beforeOperator = null;
          } else if (indexToRemove === this.expressionsList.length - 1) {
            this.expressionsList[indexToRemove - 1].afterOperator = null;
          } else {
            this.expressionsList[indexToRemove - 1].afterOperator = this.expressionsList[indexToRemove + 1].beforeOperator;
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
          }

          this.expressionsList.splice(indexToRemove, 1);
          this.cdr.detectChanges();
          this.markChildrenForCheck();
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onLogicOperatorChanged",
        value: function onLogicOperatorChanged(event) {
          /** @type {?} */
          var index = this.expressionsList.indexOf(event.target);
          event.target.afterOperator = event.newValue;

          if (index + 1 < this.expressionsList.length) {
            this.expressionsList[index + 1].beforeOperator = event.newValue;
          }
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onKeyDown",
        value: function onKeyDown(eventArgs) {
          eventArgs.stopPropagation();
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onApplyButtonKeyDown",
        value: function onApplyButtonKeyDown(eventArgs) {
          if (eventArgs.key === "Tab"
          /* TAB */
          && !eventArgs.shiftKey) {
            eventArgs.stopPropagation();
            eventArgs.preventDefault();
          }
        }
        /**
         * @private
         * @param {?} conditionName
         * @return {?}
         */

      }, {
        key: "createCondition",
        value: function createCondition(conditionName) {
          switch (this.column.dataType) {
            case DataType.Boolean:
              return IgxBooleanFilteringOperand.instance().condition(conditionName);

            case DataType.Number:
              return IgxNumberFilteringOperand.instance().condition(conditionName);

            case DataType.Date:
              return IgxDateFilteringOperand.instance().condition(conditionName);

            default:
              return IgxStringFilteringOperand.instance().condition(conditionName);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "markChildrenForCheck",
        value: function markChildrenForCheck() {
          this.expressionComponents.forEach(function (x) {
            return x.cdr.markForCheck();
          });
          this.expressionDateComponents.forEach(function (x) {
            return x.cdr.markForCheck();
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "createInitialExpressionUIElement",
        value: function createInitialExpressionUIElement() {
          this.expressionsList = [];
          /** @type {?} */

          var firstExprUI = new ExpressionUI();
          firstExprUI.expression = {
            condition: this.createCondition(this.selectedOperator),
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
          };
          firstExprUI.afterOperator = FilteringLogic.And;
          this.expressionsList.push(firstExprUI);
          /** @type {?} */

          var secondExprUI = new ExpressionUI();
          secondExprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
          };
          secondExprUI.beforeOperator = FilteringLogic.And;
          this.expressionsList.push(secondExprUI);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "scrollToBottom",
        value: function scrollToBottom() {
          var _this213 = this;

          requestAnimationFrame(function () {
            _this213.expressionsContainer.nativeElement.scrollTop = _this213.expressionsContainer.nativeElement.scrollHeight;
          });
        }
      }, {
        key: "template",
        get: function get() {
          if (this.column.dataType === DataType.Date) {
            return this.dateExpressionTemplate;
          }

          return this.defaultExpressionTemplate;
        }
        /**
         * @return {?}
         */

      }, {
        key: "grid",
        get: function get() {
          return this.filteringService.grid;
        }
      }]);

      return IgxExcelStyleCustomDialogComponent;
    }();

    IgxExcelStyleCustomDialogComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-excel-style-custom-dialog',
        template: "<article #toggle igxToggle\n    class=\"igx-excel-filter__secondary\"\n    [ngClass]=\"{\n        'igx-excel-filter__secondary--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__secondary--compact': grid.displayDensity === 'compact'\n    }\"\n    (keydown)=\"onKeyDown($event)\"\n    (onOpening)=\"onCustomDialogOpening()\"\n    (onOpened)=\"onCustomDialogOpened()\">\n    <header class=\"igx-excel-filter__secondary-header\">\n        <h4 class=\"igx-typography__h6\">\n            {{ grid.resourceStrings.igx_grid_excel_custom_dialog_header }}{{ column.header || column.field }}\n        </h4>\n    </header>\n\n    <article #expressionsContainer class=\"igx-excel-filter__secondary-main\">\n        <ng-container *ngIf=\"column.dataType === 'date'\">\n            <igx-excel-style-date-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-date-expression>\n        </ng-container>\n\n        <ng-container *ngIf=\"column.dataType !== 'date'\">\n            <igx-excel-style-default-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-default-expression>\n        </ng-container>\n\n        <button igxButton [displayDensity]=\"displayDensity\"\n            class=\"igx-excel-filter__add-filter\"\n            (click)=\"onAddButtonClick()\">\n            <igx-icon>add</igx-icon>\n            <span>{{ grid.resourceStrings.igx_grid_excel_custom_dialog_add }}</span>\n        </button>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\" (keydown)=\"onApplyButtonKeyDown($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n"
      }]
    }];
    /** @nocollapse */

    IgxExcelStyleCustomDialogComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxExcelStyleCustomDialogComponent.propDecorators = {
      expressionsList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selectedOperator: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filteringService: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      overlayComponentId: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      overlayService: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      displayDensity: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      expressionComponents: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxExcelStyleDefaultExpressionComponent]
      }],
      expressionDateComponents: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxExcelStyleDateExpressionComponent]
      }],
      toggle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['toggle', {
          read: IgxToggleDirective,
          "static": true
        }]
      }],
      defaultExpressionTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultExpressionTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      dateExpressionTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['dateExpressionTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      expressionsContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['expressionsContainer', {
          "static": true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxExcelStyleSortingComponent =
    /*#__PURE__*/
    function () {
      function IgxExcelStyleSortingComponent() {
        _classCallCheck(this, IgxExcelStyleSortingComponent);
      }
      /**
       * @param {?} sortDirection
       * @return {?}
       */


      _createClass(IgxExcelStyleSortingComponent, [{
        key: "onSortButtonClicked",
        value: function onSortButtonClicked(sortDirection) {
          if (this.sortButtonGroup.selectedIndexes.length === 0) {
            if (this.grid.isColumnGrouped(this.column.field)) {
              this.selectButton(sortDirection);
            } else {
              this.grid.clearSort(this.column.field);
            }
          } else {
            this.grid.sort({
              fieldName: this.column.field,
              dir: sortDirection,
              ignoreCase: true
            });
          }
        }
        /**
         * @param {?} sortDirection
         * @return {?}
         */

      }, {
        key: "selectButton",
        value: function selectButton(sortDirection) {
          if (sortDirection === 1) {
            this.sortButtonGroup.selectButton(0);
          } else {
            this.sortButtonGroup.selectButton(1);
          }
        }
      }]);

      return IgxExcelStyleSortingComponent;
    }();

    IgxExcelStyleSortingComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-excel-style-sorting',
        template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_sorting_header }}\n</header>\n<igx-buttongroup #sortButtonGroup [multiSelection]=\"false\">\n    <span tabindex=\"0\" igxButton type=\"button\" [displayDensity]=\"displayDensity\" [attr.data-togglable]=\"true\" (click)=\"onSortButtonClicked(1)\">\n        <igx-icon>arrow_upwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc  }}\n        </span>\n    </span>\n\n    <span tabindex=\"0\" igxButton type=\"button\" [displayDensity]=\"displayDensity\" [attr.data-togglable]=\"true\" (click)=\"onSortButtonClicked(2)\">\n        <igx-icon>arrow_downwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc\n         }}\n        </span>\n    </span>\n</igx-buttongroup>\n"
      }]
    }];
    /** @nocollapse */

    IgxExcelStyleSortingComponent.ctorParameters = function () {
      return [];
    };

    IgxExcelStyleSortingComponent.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      displayDensity: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      sortButtonGroup: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['sortButtonGroup', {
          read: IgxButtonGroupComponent,
          "static": true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var FilterListItem = function FilterListItem() {
      _classCallCheck(this, FilterListItem);

      this.isSpecial = false;
    };

    var IgxExcelStyleSortingTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxExcelStyleSortingTemplateDirective(template) {
      _classCallCheck(this, IgxExcelStyleSortingTemplateDirective);

      this.template = template;
    };

    IgxExcelStyleSortingTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxExcelStyleSorting]'
      }]
    }];
    /** @nocollapse */

    IgxExcelStyleSortingTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxExcelStyleMovingTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxExcelStyleMovingTemplateDirective(template) {
      _classCallCheck(this, IgxExcelStyleMovingTemplateDirective);

      this.template = template;
    };

    IgxExcelStyleMovingTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxExcelStyleMoving]'
      }]
    }];
    /** @nocollapse */

    IgxExcelStyleMovingTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxExcelStyleHidingTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxExcelStyleHidingTemplateDirective(template) {
      _classCallCheck(this, IgxExcelStyleHidingTemplateDirective);

      this.template = template;
    };

    IgxExcelStyleHidingTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxExcelStyleHiding]'
      }]
    }];
    /** @nocollapse */

    IgxExcelStyleHidingTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxExcelStylePinningTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxExcelStylePinningTemplateDirective(template) {
      _classCallCheck(this, IgxExcelStylePinningTemplateDirective);

      this.template = template;
    };

    IgxExcelStylePinningTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxExcelStylePinning]'
      }]
    }];
    /** @nocollapse */

    IgxExcelStylePinningTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxGridExcelStyleFilteringComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       */
      function IgxGridExcelStyleFilteringComponent(cdr) {
        _classCallCheck(this, IgxGridExcelStyleFilteringComponent);

        this.cdr = cdr;
        this.shouldOpenSubMenu = true;
        this.expressionsList = new Array();
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.containsNullOrEmpty = false;
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.filterValues = new Set();
        this.columnMoving = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"]();
        this.listData = new Array();
        this.uniqueValues = [];
        this._subMenuPositionSettings = {
          verticalStartPoint: VerticalAlignment.Top
        };
        this._subMenuOverlaySettings = {
          closeOnOutsideClick: true,
          modal: false,
          positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
          scrollStrategy: new AbsoluteScrollStrategy()
        };
        this.className = 'igx-excel-filter';
      }
      /**
       * @return {?}
       */


      _createClass(IgxGridExcelStyleFilteringComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          this.isColumnPinnable = this.column.pinnable;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this214 = this;

          this.expressionsList = new Array();
          this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);

          if (this.expressionsList && this.expressionsList.length && this.expressionsList[0].expression.condition.name !== 'in') {
            this.customDialog.expressionsList = this.expressionsList;
          }

          this.populateColumnData();

          if (this.excelStyleSorting) {
            /** @type {?} */
            var se = this.grid.sortingExpressions.find(function (expr) {
              return expr.fieldName === _this214.column.field;
            });

            if (se) {
              this.excelStyleSorting.selectButton(se.dir);
            }
          }

          requestAnimationFrame(function () {
            _this214.excelStyleSearch.searchInput.nativeElement.focus();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "clearFilterClass",
        value: function clearFilterClass() {
          if (this.column.filteringExpressionsTree) {
            return 'igx-excel-filter__actions-clear';
          }

          return 'igx-excel-filter__actions-clear--disabled';
        }
        /**
         * @return {?}
         */

      }, {
        key: "pinClass",
        value: function pinClass() {
          return this.isColumnPinnable ? 'igx-excel-filter__actions-pin' : 'igx-excel-filter__actions-pin--disabled';
        }
        /**
         * @param {?} column
         * @param {?} filteringService
         * @param {?} overlayService
         * @param {?} overlayComponentId
         * @return {?}
         */

      }, {
        key: "initialize",
        value: function initialize(column, filteringService, overlayService, overlayComponentId) {
          var _this215 = this;

          this.column = column;
          this.filteringService = filteringService;
          this.overlayService = overlayService;
          this.overlayComponentId = overlayComponentId;
          this._subMenuOverlaySettings.outlet = this.grid.outlet;
          this.columnMoving = this.grid.onColumnMoving.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function () {
            _this215.closeDropdown();
          });
        }
        /**
         * Returns the filtering operation condition for a given value.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "getCondition",
        value: function getCondition(value) {
          return this.column.filters.condition(value);
        }
        /**
         * Returns the translated condition name for a given value.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "translateCondition",
        value: function translateCondition(value) {
          return this.grid.resourceStrings["igx_grid_filter_".concat(this.getCondition(value).name)] || value;
        }
        /**
         * @return {?}
         */

      }, {
        key: "onPin",
        value: function onPin() {
          this.column.pinned = !this.column.pinned;
          this.closeDropdown();
        }
        /**
         * @return {?}
         */

      }, {
        key: "onHide",
        value: function onHide() {
          this.column.hidden = true;
          this.grid.onColumnVisibilityChanged.emit({
            column: this.column,
            newValue: true
          });
          this.closeDropdown();
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onTextFilterClick",
        value: function onTextFilterClick(eventArgs) {
          if (this.shouldOpenSubMenu) {
            this._subMenuOverlaySettings.positionStrategy.settings.target = eventArgs.currentTarget;
            /** @type {?} */

            var gridRect = this.grid.nativeElement.getBoundingClientRect();
            /** @type {?} */

            var dropdownRect = this.mainDropdown.nativeElement.getBoundingClientRect();
            /** @type {?} */

            var x = dropdownRect.left + dropdownRect.width;
            /** @type {?} */

            var x1 = gridRect.left + gridRect.width;
            x += window.pageXOffset;
            x1 += window.pageXOffset;

            if (Math.abs(x - x1) < 200) {
              this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Left;
              this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Left;
            } else {
              this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Right;
              this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Right;
            }

            this.subMenu.open(this._subMenuOverlaySettings);
            this.shouldOpenSubMenu = false;
          }
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onTextFilterKeyDown",
        value: function onTextFilterKeyDown(eventArgs) {
          if (eventArgs.key === "Enter"
          /* ENTER */
          ) {
              this.onTextFilterClick(eventArgs);
            }
        }
        /**
         * @return {?}
         */

      }, {
        key: "onSubMenuClosed",
        value: function onSubMenuClosed() {
          var _this216 = this;

          requestAnimationFrame(function () {
            _this216.shouldOpenSubMenu = true;
          });
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onSubMenuSelection",
        value: function onSubMenuSelection(eventArgs) {
          this.customDialog.selectedOperator = eventArgs.newSelection.value;
          eventArgs.cancel = true;
          this.mainDropdown.nativeElement.style.display = 'none';
          this.subMenu.close();
          this.customDialog.open();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "areExpressionsSelectable",
        value: function areExpressionsSelectable() {
          if (this.expressionsList.length === 1 && (this.expressionsList[0].expression.condition.name === 'equals' || this.expressionsList[0].expression.condition.name === 'true' || this.expressionsList[0].expression.condition.name === 'false' || this.expressionsList[0].expression.condition.name === 'empty' || this.expressionsList[0].expression.condition.name === 'in')) {
            return true;
          }
          /** @type {?} */


          var selectableExpressionsCount = this.expressionsList.filter(function (exp) {
            return (exp.beforeOperator === 1 || exp.afterOperator === 1) && (exp.expression.condition.name === 'equals' || exp.expression.condition.name === 'true' || exp.expression.condition.name === 'false' || exp.expression.condition.name === 'empty' || exp.expression.condition.name === 'in');
          }).length;
          return selectableExpressionsCount === this.expressionsList.length;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "areExpressionsValuesInTheList",
        value: function areExpressionsValuesInTheList() {
          if (this.column.dataType === DataType.Boolean) {
            return true;
          }

          if (this.filterValues.size === 1) {
            /** @type {?} */
            var firstValue = this.filterValues.values().next().value;

            if (!firstValue && firstValue !== 0) {
              return true;
            }
          }

          for (var index = 0; index < this.uniqueValues.length; index++) {
            if (this.filterValues.has(this.uniqueValues[index])) {
              return true;
            }
          }

          return false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "populateColumnData",
        value: function populateColumnData() {
          if (this.grid.uniqueColumnValuesStrategy) {
            this.renderColumnValuesRemotely();
          } else {
            this.renderColumnValuesFromData();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "renderColumnValuesRemotely",
        value: function renderColumnValuesRemotely() {
          var _this217 = this;

          this.excelStyleSearch.isLoading = true;
          /** @type {?} */

          var expressionsTree = this.getColumnFilterExpressionsTree();
          this.grid.uniqueColumnValuesStrategy(this.column, expressionsTree, function (colVals) {
            /** @type {?} */
            var columnValues = _this217.column.dataType === DataType.Date ? colVals.map(function (val) {
              return val ? val.toDateString() : val;
            }) : colVals;

            _this217.renderValues(columnValues);

            _this217.excelStyleSearch.isLoading = false;

            _this217.excelStyleSearch.refreshSize();
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "renderColumnValuesFromData",
        value: function renderColumnValuesFromData() {
          /** @type {?} */
          var data = this.column.gridAPI.get_all_data(this.grid.id);
          /** @type {?} */

          var expressionsTree = this.getColumnFilterExpressionsTree();

          if (expressionsTree.filteringOperands.length) {
            /** @type {?} */
            var state = {
              expressionsTree: expressionsTree
            };
            data = DataUtil.filter(cloneArray(data), state);
          }
          /** @type {?} */


          var columnField = this.column.field;
          /** @type {?} */

          var columnValues = this.column.dataType === DataType.Date ? data.map(function (record) {
            return record[columnField] ? record[columnField].toDateString() : record[columnField];
          }) : data.map(function (record) {
            return record[columnField];
          });
          this.renderValues(columnValues);
        }
        /**
         * @private
         * @param {?} columnValues
         * @return {?}
         */

      }, {
        key: "renderValues",
        value: function renderValues(columnValues) {
          this.generateUniqueValues(columnValues);
          this.generateFilterValues(this.column.dataType === DataType.Date);
          this.generateListData();
        }
        /**
         * @private
         * @param {?} columnValues
         * @return {?}
         */

      }, {
        key: "generateUniqueValues",
        value: function generateUniqueValues(columnValues) {
          this.uniqueValues = Array.from(new Set(columnValues));
        }
        /**
         * @private
         * @param {?=} isDateColumn
         * @return {?}
         */

      }, {
        key: "generateFilterValues",
        value: function generateFilterValues() {
          var isDateColumn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (isDateColumn) {
            this.filterValues = new Set(this.expressionsList.reduce(function (arr, e) {
              if (e.expression.condition.name === 'in') {
                return [].concat(_toConsumableArray(arr), _toConsumableArray(Array.from(
                /** @type {?} */
                e.expression.searchVal.values()).map(function (v) {
                  return new Date(v).toDateString();
                })));
              }

              return [].concat(_toConsumableArray(arr), [e.expression.searchVal ? e.expression.searchVal.toDateString() : e.expression.searchVal]);
            }, []));
          } else {
            this.filterValues = new Set(this.expressionsList.reduce(function (arr, e) {
              if (e.expression.condition.name === 'in') {
                return [].concat(_toConsumableArray(arr), _toConsumableArray(Array.from(
                /** @type {?} */
                e.expression.searchVal.values())));
              }

              return [].concat(_toConsumableArray(arr), [e.expression.searchVal]);
            }, []));
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "generateListData",
        value: function generateListData() {
          var _this218 = this;

          this.listData = new Array();
          /** @type {?} */

          var shouldUpdateSelection = this.areExpressionsSelectable() && this.areExpressionsValuesInTheList();

          if (this.column.dataType === DataType.Boolean) {
            this.addBooleanItems();
          } else {
            this.addItems(shouldUpdateSelection);
          }

          this.listData.sort(function (a, b) {
            return _this218.sortData(a, b);
          });

          if (this.column.dataType === DataType.Date) {
            this.uniqueValues = this.uniqueValues.map(function (value) {
              return new Date(value);
            });
          }

          if (this.containsNullOrEmpty) {
            this.addBlanksItem(shouldUpdateSelection);
          }

          this.addSelectAllItem();

          if (!
          /** @type {?} */
          this.cdr.destroyed) {
            this.cdr.detectChanges();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getColumnFilterExpressionsTree",
        value: function getColumnFilterExpressionsTree() {
          /** @type {?} */
          var gridExpressionsTree = this.grid.filteringExpressionsTree;
          /** @type {?} */

          var expressionsTree = new FilteringExpressionsTree(gridExpressionsTree.operator, gridExpressionsTree.fieldName);
          var _iteratorNormalCompletion44 = true;
          var _didIteratorError44 = false;
          var _iteratorError44 = undefined;

          try {
            for (var _iterator44 = gridExpressionsTree.filteringOperands[Symbol.iterator](), _step44; !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {
              var operand = _step44.value;

              if (operand instanceof FilteringExpressionsTree) {
                /** @type {?} */
                var columnExprTree =
                /** @type {?} */
                operand;

                if (columnExprTree.fieldName === this.column.field) {
                  break;
                }
              }

              expressionsTree.filteringOperands.push(operand);
            }
          } catch (err) {
            _didIteratorError44 = true;
            _iteratorError44 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion44 && _iterator44["return"] != null) {
                _iterator44["return"]();
              }
            } finally {
              if (_didIteratorError44) {
                throw _iteratorError44;
              }
            }
          }

          return expressionsTree;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "addBooleanItems",
        value: function addBooleanItems() {
          var _this219 = this;

          this.selectAllSelected = true;
          this.selectAllIndeterminate = false;
          this.uniqueValues.forEach(function (element) {
            /** @type {?} */
            var filterListItem = new FilterListItem();

            if (element !== undefined && element !== null && element !== '') {
              if (_this219.column.filteringExpressionsTree) {
                if (element === true && _this219.expressionsList.find(function (exp) {
                  return exp.expression.condition.name === 'true';
                })) {
                  filterListItem.isSelected = true;
                  _this219.selectAllIndeterminate = true;
                } else if (element === false && _this219.expressionsList.find(function (exp) {
                  return exp.expression.condition.name === 'false';
                })) {
                  filterListItem.isSelected = true;
                  _this219.selectAllIndeterminate = true;
                } else {
                  filterListItem.isSelected = false;
                }
              } else {
                filterListItem.isSelected = true;
              }

              filterListItem.value = element;
              filterListItem.label = element;
              filterListItem.indeterminate = false;

              _this219.listData.push(filterListItem);
            } else {
              _this219.containsNullOrEmpty = true;
            }
          });
        }
        /**
         * @private
         * @param {?} shouldUpdateSelection
         * @return {?}
         */

      }, {
        key: "addItems",
        value: function addItems(shouldUpdateSelection) {
          var _this220 = this;

          this.selectAllSelected = true;
          this.selectAllIndeterminate = false;
          this.uniqueValues.forEach(function (element) {
            if (element !== undefined && element !== null && element !== '') {
              /** @type {?} */
              var filterListItem = new FilterListItem();

              if (_this220.column.filteringExpressionsTree) {
                if (shouldUpdateSelection) {
                  if (_this220.filterValues.has(element)) {
                    filterListItem.isSelected = true;
                  } else {
                    filterListItem.isSelected = false;
                  }

                  _this220.selectAllIndeterminate = true;
                } else {
                  filterListItem.isSelected = false;
                  _this220.selectAllSelected = false;
                }
              } else {
                filterListItem.isSelected = true;
              }

              if (_this220.column.dataType === DataType.Date) {
                filterListItem.value = new Date(element);
                filterListItem.label = new Date(element);
              } else {
                filterListItem.value = element;
                filterListItem.label = element;
              }

              filterListItem.indeterminate = false;

              _this220.listData.push(filterListItem);
            } else {
              _this220.containsNullOrEmpty = true;
            }
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "addSelectAllItem",
        value: function addSelectAllItem() {
          /** @type {?} */
          var selectAll = new FilterListItem();
          selectAll.isSelected = this.selectAllSelected;
          selectAll.value = this.grid.resourceStrings.igx_grid_excel_select_all;
          selectAll.label = this.grid.resourceStrings.igx_grid_excel_select_all;
          selectAll.indeterminate = this.selectAllIndeterminate;
          selectAll.isSpecial = true;
          this.listData.unshift(selectAll);
        }
        /**
         * @private
         * @param {?} shouldUpdateSelection
         * @return {?}
         */

      }, {
        key: "addBlanksItem",
        value: function addBlanksItem(shouldUpdateSelection) {
          /** @type {?} */
          var blanks = new FilterListItem();

          if (this.column.filteringExpressionsTree) {
            if (shouldUpdateSelection) {
              if (this.filterValues.has(null)) {
                blanks.isSelected = true;
              } else {
                blanks.isSelected = false;
              }
            }
          } else {
            blanks.isSelected = true;
          }

          blanks.value = null;
          blanks.label = this.grid.resourceStrings.igx_grid_excel_blanks;
          blanks.indeterminate = false;
          blanks.isSpecial = true;
          this.listData.unshift(blanks);
        }
        /**
         * @private
         * @param {?} a
         * @param {?} b
         * @return {?}
         */

      }, {
        key: "sortData",
        value: function sortData(a, b) {
          /** @type {?} */
          var valueA = a.value;
          /** @type {?} */

          var valueB = b.value;

          if (typeof a === DataType.String) {
            valueA = a.value.toUpperCase();
            valueB = b.value.toUpperCase();
          }

          if (valueA < valueB) {
            return -1;
          } else if (valueA > valueB) {
            return 1;
          } else {
            return 0;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "selectAllFilterItems",
        value: function selectAllFilterItems() {
          this.listData.forEach(function (filterListItem) {
            filterListItem.isSelected = true;
            filterListItem.indeterminate = false;
          });
          this.excelStyleSearch.cdr.detectChanges();
        } // TODO: sort members by access modifier

        /**
         * @return {?}
         */

      }, {
        key: "applyFilter",

        /**
         * @return {?}
         */
        value: function applyFilter() {
          var _this221 = this;

          /** @type {?} */
          var filterTree = new FilteringExpressionsTree(FilteringLogic.Or, this.column.field);
          /** @type {?} */

          var selectedItems = this.listData.slice(1, this.listData.length).filter(function (el) {
            return el.isSelected === true;
          });
          /** @type {?} */

          var unselectedItem = this.listData.slice(1, this.listData.length).find(function (el) {
            return el.isSelected === false;
          });

          if (unselectedItem) {
            if (selectedItems.length <= IgxGridExcelStyleFilteringComponent.filterOptimizationThreshold) {
              selectedItems.forEach(function (element) {
                /** @type {?} */
                var condition = null;

                if (element.value !== null && element.value !== undefined) {
                  if (_this221.column.dataType === DataType.Boolean) {
                    condition = _this221.createCondition(element.value.toString());
                  } else {
                    condition = _this221.createCondition('equals');
                  }
                } else {
                  condition = _this221.createCondition('empty');
                }

                filterTree.filteringOperands.push({
                  condition: condition,
                  fieldName: _this221.column.field,
                  ignoreCase: _this221.column.filteringIgnoreCase,
                  searchVal: element.value
                });
              });
            } else {
              /** @type {?} */
              var blanksItemIndex = selectedItems.findIndex(function (e) {
                return e.value === null || e.value === undefined;
              });
              /** @type {?} */

              var blanksItem;

              if (blanksItemIndex >= 0) {
                blanksItem = selectedItems[blanksItemIndex];
                selectedItems.splice(blanksItemIndex, 1);
              }

              filterTree.filteringOperands.push({
                condition: this.createCondition('in'),
                fieldName: this.column.field,
                ignoreCase: this.column.filteringIgnoreCase,
                searchVal: new Set(this.column.dataType === DataType.Date ? selectedItems.map(function (d) {
                  return new Date(d.value.getFullYear(), d.value.getMonth(), d.value.getDate()).toISOString();
                }) : selectedItems.map(function (e) {
                  return e.value;
                }))
              });

              if (blanksItem) {
                filterTree.filteringOperands.push({
                  condition: this.createCondition('empty'),
                  fieldName: this.column.field,
                  ignoreCase: this.column.filteringIgnoreCase,
                  searchVal: blanksItem.value
                });
              }
            }

            this.expressionsList = new Array();
            this.filteringService.filterInternal(this.column.field, filterTree);
          } else {
            this.filteringService.clearFilter(this.column.field);
          }

          this.closeDropdown();
        }
        /**
         * @return {?}
         */

      }, {
        key: "closeDropdown",
        value: function closeDropdown() {
          if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
            this.overlayComponentId = null;
          }
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onKeyDown",
        value: function onKeyDown(eventArgs) {
          if (eventArgs.key === "Escape"
          /* ESCAPE */
          || eventArgs.key === "Esc"
          /* ESCAPE_IE */
          ) {
              this.closeDropdown();
            }

          eventArgs.stopPropagation();
        }
        /**
         * @return {?}
         */

      }, {
        key: "clearFilter",
        value: function clearFilter() {
          this.filteringService.clearFilter(this.column.field);
          this.selectAllFilterItems();
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onClearFilterKeyDown",
        value: function onClearFilterKeyDown(eventArgs) {
          if (eventArgs.key === "Enter"
          /* ENTER */
          ) {
              this.clearFilter();
            }
        }
        /**
         * @return {?}
         */

      }, {
        key: "showCustomFilterItem",
        value: function showCustomFilterItem() {
          /** @type {?} */
          var exprTree = this.column.filteringExpressionsTree;
          return exprTree && exprTree.filteringOperands && exprTree.filteringOperands.length && !(
          /** @type {?} */
          exprTree.filteringOperands[0].condition &&
          /** @type {?} */
          exprTree.filteringOperands[0].condition.name === 'in');
        }
        /**
         * @private
         * @param {?} conditionName
         * @return {?}
         */

      }, {
        key: "createCondition",
        value: function createCondition(conditionName) {
          switch (this.column.dataType) {
            case DataType.Boolean:
              return IgxBooleanFilteringOperand.instance().condition(conditionName);

            case DataType.Number:
              return IgxNumberFilteringOperand.instance().condition(conditionName);

            case DataType.Date:
              return IgxDateFilteringOperand.instance().condition(conditionName);

            default:
              return IgxStringFilteringOperand.instance().condition(conditionName);
          }
        }
      }, {
        key: "grid",
        get: function get() {
          return this.filteringService.grid;
        }
        /**
         * @return {?}
         */

      }, {
        key: "conditions",
        get: function get() {
          return this.column.filters.conditionList();
        }
        /**
         * @return {?}
         */

      }, {
        key: "subMenuText",
        get: function get() {
          switch (this.column.dataType) {
            case DataType.Boolean:
              return this.grid.resourceStrings.igx_grid_excel_boolean_filter;

            case DataType.Number:
              return this.grid.resourceStrings.igx_grid_excel_number_filter;

            case DataType.Date:
              return this.grid.resourceStrings.igx_grid_excel_date_filter;

            default:
              return this.grid.resourceStrings.igx_grid_excel_text_filter;
          }
        }
      }, {
        key: "sortingTemplate",
        get: function get() {
          if (this.grid.excelStyleSortingTemplateDirective) {
            return this.grid.excelStyleSortingTemplateDirective.template;
          } else {
            return this.defaultExcelStyleSortingTemplate;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "movingTemplate",
        get: function get() {
          if (this.grid.excelStyleMovingTemplateDirective) {
            return this.grid.excelStyleMovingTemplateDirective.template;
          } else {
            return this.defaultExcelStyleMovingTemplate;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "pinningTemplate",
        get: function get() {
          if (this.grid.excelStylePinningTemplateDirective) {
            return this.grid.excelStylePinningTemplateDirective.template;
          } else {
            return this.defaultExcelStylePinningTemplate;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "hidingTemplate",
        get: function get() {
          if (this.grid.excelStyleHidingTemplateDirective) {
            return this.grid.excelStyleHidingTemplateDirective.template;
          } else {
            return this.defaultExcelStyleHidingTemplate;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "applyButtonDisabled",
        get: function get() {
          return this.listData[0] && !this.listData[0].isSelected && !this.listData[0].indeterminate;
        }
      }]);

      return IgxGridExcelStyleFilteringComponent;
    }();

    IgxGridExcelStyleFilteringComponent.filterOptimizationThreshold = 2;
    IgxGridExcelStyleFilteringComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-excel-style-filtering',
        template: "<article #dropdown\n    class=\"igx-excel-filter__menu\"\n    [ngClass]=\"{\n        'igx-excel-filter__menu--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__menu--compact': grid.displayDensity === 'compact'\n    }\"\n    [id]=\"overlayComponentId\"\n    (keydown)=\"onKeyDown($event)\">\n\n    <header class=\"igx-excel-filter__menu-header\">\n        <h4>{{ column.header || column.field }}</h4>\n        <div *ngIf=\"grid.displayDensity!=='comfortable'\" class=\"igx-excel-filter__menu-header-actions\">\n            <button *ngIf=\"!column.disablePinning && !column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                [disabled]=\"!isColumnPinnable\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disablePinning && column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disableHiding\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                tabindex=\"0\"\n                (click)=\"onHide()\">\n                <igx-icon>visibility_off</igx-icon>\n            </button>\n        </div>\n    </header>\n\n    <ng-template #defaultExcelStyleSortingTemplate>\n        <igx-excel-style-sorting #excelStyleSorting\n            class=\"igx-excel-filter__sort\"\n            [column]=\"column\"\n            [grid]=\"grid\"\n            [displayDensity]=\"grid.displayDensity\">\n        </igx-excel-style-sorting>\n    </ng-template>\n\n    <div *ngIf=\"column.sortable\">\n        <ng-container *ngTemplateOutlet=\"sortingTemplate\"></ng-container>\n    </div>\n\n    <section class=\"igx-excel-filter__actions\">\n\n        <ng-template #defaultExcelStyleMovingTemplate>\n            <igx-excel-style-column-moving\n                class=\"igx-excel-filter__move\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [isColumnPinnable]=\"isColumnPinnable\"\n                [displayDensity]=\"grid.displayDensity\">\n            </igx-excel-style-column-moving>\n        </ng-template>\n\n        <div *ngIf=\"column.movable\">\n            <ng-container *ngTemplateOutlet=\"movingTemplate\"></ng-container>\n        </div>\n\n        <ng-template #defaultExcelStylePinningTemplate>\n            <div [ngClass]=\"pinClass()\"\n                (click)=\"onPin()\"\n                tabindex=\"0\"\n                *ngIf=\"!column.pinned\">\n                <span>{{ grid.resourceStrings.igx_grid_excel_pin }}</span>\n                <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n            </div>\n\n            <div class=\"igx-excel-filter__actions-unpin\"\n                (click)=\"onPin()\"\n                tabindex=\"0\"\n                *ngIf=\"column.pinned\">\n                <span>{{ grid.resourceStrings.igx_grid_excel_unpin }}</span>\n                <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n            </div>\n        </ng-template>\n\n        <div *ngIf=\"!column.disablePinning && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"pinningTemplate\"></ng-container>\n        </div>\n\n        <ng-template #defaultExcelStyleHidingTemplate>\n            <div class=\"igx-excel-filter__actions-hide\"\n                tabindex=\"0\"\n                (click)=\"onHide()\">\n                <span>{{ grid.resourceStrings.igx_grid_excel_hide }}</span>\n                <igx-icon>visibility_off</igx-icon>\n            </div>\n        </ng-template>\n\n        <div *ngIf=\"!column.disableHiding && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"hidingTemplate\"></ng-container>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            [ngClass]=\"clearFilterClass()\"\n            (keydown)=\"onClearFilterKeyDown($event)\"\n            (click)=\"clearFilter()\">\n            <span>{{ grid.resourceStrings.igx_grid_excel_filter_clear }}</span>\n            <igx-icon>clear</igx-icon>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            class=\"igx-excel-filter__actions-filter\"\n            (keydown)=\"onTextFilterKeyDown($event)\"\n            (click)=\"onTextFilterClick($event)\"\n            [igxDropDownItemNavigation]=\"subMenu\" >\n            <span>{{ subMenuText }}</span>\n            <igx-icon>keyboard_arrow_right</igx-icon>\n        </div>\n    </section>\n\n    <igx-excel-style-search\n        class=\"igx-excel-filter__menu-main\"\n        #excelStyleSearch\n        [column]=\"column\"\n        [data]=\"listData\"\n        [grid]=\"grid\"\n        [displayDensity]=\"grid.displayDensity\">\n    </igx-excel-style-search>\n\n    <footer class=\"igx-excel-filter__menu-footer\">\n        <button igxButton [displayDensity]=\"grid.displayDensity\" (click)=\"closeDropdown()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n        <button igxButton=\"raised\" [displayDensity]=\"grid.displayDensity\" [disabled]=\"applyButtonDisabled\" (click)=\"applyFilter()\">{{ grid.resourceStrings.igx_grid_excel_apply }}</button>\n    </footer>\n</article>\n\n<igx-drop-down [maxHeight]=\"'397px'\" [displayDensity]=\"grid.displayDensity\" #subMenu (onSelection)=\"onSubMenuSelection($event)\" (onClosed)=\"onSubMenuClosed()\">\n    <div>\n        <igx-drop-down-item\n            *ngFor=\"let condition of conditions\"\n            [value]=\"condition\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n        </igx-drop-down-item>\n        <igx-drop-down-item *ngIf=\"showCustomFilterItem()\">\n            <igx-icon>filter_list</igx-icon>\n            <span style=\"margin-left: 16px\">{{ grid.resourceStrings.igx_grid_excel_custom_filter }}</span>\n        </igx-drop-down-item>\n    </div>\n</igx-drop-down>\n\n<igx-excel-style-custom-dialog\n    #customDialog\n    [column]=\"column\"\n    [filteringService]=\"filteringService\"\n    [overlayComponentId]=\"overlayComponentId\"\n    [overlayService]=\"overlayService\"\n    [displayDensity]=\"grid.displayDensity\">\n</igx-excel-style-custom-dialog>\n"
      }]
    }];
    /** @nocollapse */

    IgxGridExcelStyleFilteringComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxGridExcelStyleFilteringComponent.propDecorators = {
      className: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-excel-filter']
      }],
      mainDropdown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['dropdown', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": true
        }]
      }],
      subMenu: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['subMenu', {
          read: IgxDropDownComponent,
          "static": true
        }]
      }],
      customDialog: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['customDialog', {
          read: IgxExcelStyleCustomDialogComponent,
          "static": true
        }]
      }],
      excelStyleSearch: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['excelStyleSearch', {
          read: IgxExcelStyleSearchComponent,
          "static": true
        }]
      }],
      excelStyleSorting: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['excelStyleSorting', {
          read: IgxExcelStyleSortingComponent,
          "static": false
        }]
      }],
      defaultExcelStyleSortingTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultExcelStyleSortingTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultExcelStyleHidingTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultExcelStyleHidingTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultExcelStyleMovingTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultExcelStyleMovingTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultExcelStylePinningTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultExcelStylePinningTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxGridHeaderComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       * @param {?} colResizingService
       * @param {?} cdr
       * @param {?} elementRef
       * @param {?} zone
       * @param {?} _filteringService
       * @param {?} _moduleRef
       * @param {?} _overlayService
       */
      function IgxGridHeaderComponent(gridAPI, colResizingService, cdr, elementRef, zone, _filteringService, _moduleRef, _overlayService) {
        _classCallCheck(this, IgxGridHeaderComponent);

        this.gridAPI = gridAPI;
        this.colResizingService = colResizingService;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.zone = zone;
        this._filteringService = _filteringService;
        this._moduleRef = _moduleRef;
        this._overlayService = _overlayService;
        this._destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.hostRole = 'columnheader';
        this.tabindex = -1;
        this.sortDirection = SortingDirection.None;
      }
      /**
       * @return {?}
       */


      _createClass(IgxGridHeaderComponent, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          this.initFilteringSettings();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          this.getSortDirection();
          this.cdr.markForCheck();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroy$.next(true);

          this._destroy$.complete();

          if (this._componentOverlayId) {
            this._overlayService.hide(this._componentOverlayId);
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onClick",
        value: function onClick(event) {
          if (!this.colResizingService.isColumnResizing) {
            event.stopPropagation();

            if (this.grid.filteringService.isFilterRowVisible) {
              if (this.column.filterable && !this.column.columnGroup && !this.grid.filteringService.isFilterComplex(this.column.field)) {
                this.grid.filteringService.filteredColumn = this.column;
              }
            } else if (this.column.sortable) {
              this.triggerSort();
            }
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onFilteringIconClick",
        value: function onFilteringIconClick(event) {
          event.stopPropagation();
          this.toggleFilterDropdown();
        }
        /**
         * @return {?}
         */

      }, {
        key: "getSortDirection",

        /**
         * @protected
         * @return {?}
         */
        value: function getSortDirection() {
          var _this222 = this;

          /** @type {?} */
          var expr = this.gridAPI.grid.sortingExpressions.find(function (x) {
            return x.fieldName === _this222.column.field;
          });
          this.sortDirection = expr ? expr.dir : SortingDirection.None;
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onSortingIconClick",
        value: function onSortingIconClick(event) {
          if (this.grid.filteringService.isFilterRowVisible) {
            event.stopPropagation();
            this.triggerSort();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "triggerSort",
        value: function triggerSort() {
          var _this223 = this;

          /** @type {?} */
          var groupingExpr = this.grid.groupingExpressions ? this.grid.groupingExpressions.find(function (expr) {
            return expr.fieldName === _this223.column.field;
          }) : null;
          /** @type {?} */

          var sortDir = groupingExpr ? this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.Asc : SortingDirection.Desc : this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.None : this.sortDirection + 1;
          this.sortDirection = sortDir;
          this.grid.sort({
            fieldName: this.column.field,
            dir: this.sortDirection,
            ignoreCase: this.column.sortingIgnoreCase,
            strategy: this.column.sortStrategy
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "toggleFilterDropdown",
        value: function toggleFilterDropdown() {
          if (!this._componentOverlayId) {
            /** @type {?} */
            var headerTarget = this.elementRef.nativeElement;
            /** @type {?} */

            var filterIconTarget = headerTarget.querySelector('.' + this.filterIconClassName);
            this._filterMenuOverlaySettings.positionStrategy.settings.target = filterIconTarget;
            this._filterMenuOverlaySettings.outlet = this.grid.outlet;
            this._componentOverlayId = this._overlayService.attach(IgxGridExcelStyleFilteringComponent, this._filterMenuOverlaySettings, this._moduleRef);

            this._overlayService.show(this._componentOverlayId, this._filterMenuOverlaySettings);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "initFilteringSettings",
        value: function initFilteringSettings() {
          var _this224 = this;

          this._filterMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeIn, {
              params: {
                duration: '250ms'
              }
            }),
            closeAnimation: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeOut, {
              params: {
                duration: '200ms'
              }
            })
          };
          this._filterMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._filterMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
          };

          this._overlayService.onOpening.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function (overlay) {
            return overlay.id === _this224._componentOverlayId;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function (eventArgs) {
            _this224.onOverlayOpening(eventArgs);
          });

          this._overlayService.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function (overlay) {
            return overlay.id === _this224._componentOverlayId;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function () {
            _this224.onOverlayClosed();
          });
        }
        /**
         * @private
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onOverlayOpening",
        value: function onOverlayOpening(eventArgs) {
          /** @type {?} */
          var instance =
          /** @type {?} */
          eventArgs.componentRef.instance;

          if (instance) {
            instance.initialize(this.column, this._filteringService, this._overlayService, eventArgs.id);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "onOverlayClosed",
        value: function onOverlayClosed() {
          this._componentOverlayId = null;
        }
      }, {
        key: "styleClasses",
        get: function get() {
          /** @type {?} */
          var defaultClasses = ['igx-grid__th--fw', this.column.headerClasses];
          /** @type {?} */

          var classList = {
            'igx-grid__th': !this.column.columnGroup,
            'asc': this.ascending,
            'desc': this.descending,
            'igx-grid__th--number': this.column.dataType === DataType.Number,
            'igx-grid__th--sortable': this.column.sortable,
            'igx-grid__th--filtrable': this.column.filterable && this.grid.filteringService.isFilterRowVisible,
            'igx-grid__th--sorted': this.sorted
          };

          for (var _i17 = 0, _Object$keys5 = Object.keys(classList); _i17 < _Object$keys5.length; _i17++) {
            var klass = _Object$keys5[_i17];

            if (classList[klass]) {
              defaultClasses.push(klass);
            }
          }

          return defaultClasses.join(' ');
        }
        /**
         * @return {?}
         */

      }, {
        key: "height",
        get: function get() {
          if (this.grid.hasColumnGroups) {
            return (this.grid.maxLevelHeaderDepth + 1 - this.column.level) * this.grid.defaultRowHeight / this.grid._baseFontSize;
          }

          return null;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ascending",
        get: function get() {
          return this.sortDirection === SortingDirection.Asc;
        }
        /**
         * @return {?}
         */

      }, {
        key: "descending",
        get: function get() {
          return this.sortDirection === SortingDirection.Desc;
        }
        /**
         * @return {?}
         */

      }, {
        key: "sortingIcon",
        get: function get() {
          if (this.sortDirection !== SortingDirection.None) {
            // arrow_downward and arrow_upward
            // are material icons ligature strings
            return this.sortDirection === SortingDirection.Asc ? 'arrow_upward' : 'arrow_downward';
          }

          return 'arrow_upward';
        }
        /**
         * @return {?}
         */

      }, {
        key: "sorted",
        get: function get() {
          return this.sortDirection !== SortingDirection.None;
        }
        /**
         * @return {?}
         */

      }, {
        key: "filterIconClassName",
        get: function get() {
          return this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
        }
        /**
         * @return {?}
         */

      }, {
        key: "headerID",
        get: function get() {
          return "".concat(this.gridID, "_").concat(this.column.field);
        }
      }, {
        key: "grid",
        get: function get() {
          return this.gridAPI.grid;
        }
      }]);

      return IgxGridHeaderComponent;
    }();

    IgxGridHeaderComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-header',
        template: "<ng-template #defaultColumn>\n    <span [attr.title]=\"column.header || column.field\">{{ column.header || column.field }}</span>\n</ng-template>\n\n<span class=\"igx-grid__th-title\">\n    <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<div class=\"igx-grid__th-icons\" *ngIf=\"!column.columnGroup\">\n    <igx-icon [attr.draggable]=\"false\"\n        class=\"sort-icon\"\n        *ngIf=\"column.sortable\"\n        (click)=\"onSortingIconClick($event)\">\n        {{sortingIcon}}\n    </igx-icon>\n\n    <igx-icon [ngClass]=\"filterIconClassName\" [attr.draggable]=\"false\" (click)=\"onFilteringIconClick($event)\"\n        *ngIf=\"grid.allowFiltering == true && column.filterable && grid.filterMode == 'excelStyleFilter'\">\n        filter_list\n    </igx-icon>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxGridHeaderComponent.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: IgxColumnResizingService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: IgxFilteringService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModuleRef"]
      }, {
        type: IgxOverlayService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxOverlayService]
        }]
      }];
    };

    IgxGridHeaderComponent.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      gridID: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      styleClasses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class']
      }],
      height: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.height.rem']
      }],
      hostRole: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      headerID: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxGridFilteringCellComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       * @param {?} filteringService
       * @param {?} navService
       */
      function IgxGridFilteringCellComponent(cdr, filteringService, navService) {
        _classCallCheck(this, IgxGridFilteringCellComponent);

        this.cdr = cdr;
        this.filteringService = filteringService;
        this.navService = navService;
        this.baseClass = 'igx-grid__filtering-cell-indicator';
        this.currentTemplate = null;
        this.moreFiltersCount = 0;
        this.cssClass = 'igx-grid__filtering-cell';
        this.filteringService.subscribeToEvents();
      }
      /**
       * @return {?}
       */


      _createClass(IgxGridFilteringCellComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.updateFilterCellArea();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          this.updateFilterCellArea();
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onTabKeyDown",
        value: function onTabKeyDown(eventArgs) {
          if (this.isLastElementFocused()) {
            this.filteringService.grid.navigation.navigateNextFilterCell(this.column, eventArgs);
          }

          eventArgs.stopPropagation();
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onShiftTabKeyDown",
        value: function onShiftTabKeyDown(eventArgs) {
          if (this.isFirstElementFocused()) {
            this.filteringService.grid.navigation.navigatePrevFilterCell(this.column, eventArgs);
          }

          eventArgs.stopPropagation();
        }
        /**
         * Returns whether a chip with a given index is visible or not.
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "isChipVisible",
        value: function isChipVisible(index) {
          /** @type {?} */
          var expression = this.expressionsList[index];
          return !!(expression && expression.isVisible);
        }
        /**
         * Updates the filtering cell area.
         * @return {?}
         */

      }, {
        key: "updateFilterCellArea",
        value: function updateFilterCellArea() {
          this.expressionsList = this.filteringService.getExpressions(this.column.field);
          this.updateVisibleFilters();
        }
        /**
         * @return {?}
         */

      }, {
        key: "onChipClicked",

        /**
         * Chip clicked event handler.
         * @param {?=} expression
         * @return {?}
         */
        value: function onChipClicked(expression) {
          if (expression) {
            this.expressionsList.forEach(function (item) {
              item.isSelected = item.expression === expression;
            });
          } else if (this.expressionsList.length > 0) {
            this.expressionsList.forEach(function (item) {
              item.isSelected = false;
            });
            this.expressionsList[0].isSelected = true;
          }
          /** @type {?} */


          var index = this.filteringService.unpinnedFilterableColumns.indexOf(this.column);

          if (index >= 0 && !this.isColumnRightVisible(index)) {
            this.filteringService.scrollToFilterCell(this.filteringService.unpinnedFilterableColumns[index], true);
          } else if (index >= 0 && !this.isColumnLeftVisible(index)) {
            this.filteringService.scrollToFilterCell(this.filteringService.unpinnedFilterableColumns[index], false);
          }

          this.filteringService.filteredColumn = this.column;
          this.filteringService.isFilterRowVisible = true;
          this.filteringService.selectedExpression = expression;
        }
        /**
         * Chip removed event handler.
         * @param {?} eventArgs
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "onChipRemoved",
        value: function onChipRemoved(eventArgs, item) {
          /** @type {?} */
          var indexToRemove = this.expressionsList.indexOf(item);
          this.removeExpression(indexToRemove);
          this.focusChip();
        }
        /**
         * Clears the filtering.
         * @return {?}
         */

      }, {
        key: "clearFiltering",
        value: function clearFiltering() {
          this.filteringService.clearFilter(this.column.field);
          this.cdr.detectChanges();
        }
        /**
         * Chip keydown event handler.
         * @param {?} eventArgs
         * @param {?=} expression
         * @return {?}
         */

      }, {
        key: "onChipKeyDown",
        value: function onChipKeyDown(eventArgs, expression) {
          if (eventArgs.key === "Enter"
          /* ENTER */
          ) {
              eventArgs.preventDefault();
              this.onChipClicked(expression);
            }
        }
        /**
         * Returns the filtering indicator class.
         * @return {?}
         */

      }, {
        key: "filteringIndicatorClass",
        value: function filteringIndicatorClass() {
          var _ref5;

          return _ref5 = {}, _defineProperty(_ref5, this.baseClass, !this.isMoreIconHidden()), _defineProperty(_ref5, "".concat(this.baseClass, "--hidden"), this.isMoreIconHidden()), _ref5;
        }
        /**
         * Focus a chip depending on the current visible template.
         * @param {?=} focusFirst
         * @return {?}
         */

      }, {
        key: "focusChip",
        value: function focusChip() {
          var focusFirst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (this.currentTemplate === this.defaultFilter) {
            if (focusFirst) {
              this.focusFirstElement();
            } else {
              this.focusElement();
            }
          } else if (this.currentTemplate === this.emptyFilter) {
            this.ghostChip.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
          } else if (this.currentTemplate === this.complexFilter) {
            this.complexChip.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
          }
        }
        /**
         * @private
         * @param {?} indexToRemove
         * @return {?}
         */

      }, {
        key: "removeExpression",
        value: function removeExpression(indexToRemove) {
          if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
          }

          this.filteringService.removeExpression(this.column.field, indexToRemove);
          this.updateVisibleFilters();
          this.filteringService.filterInternal(this.column.field);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "isMoreIconHidden",
        value: function isMoreIconHidden() {
          return this.filteringService.columnToMoreIconHidden.get(this.column.field);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "updateVisibleFilters",
        value: function updateVisibleFilters() {
          this.expressionsList.forEach(function (ex) {
            return ex.isVisible = true;
          });

          if (this.moreIcon) {
            this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
          }

          this.cdr.detectChanges();

          if (this.chipsArea && this.expressionsList.length > 1) {
            /** @type {?} */
            var areaWidth = this.chipsArea.element.nativeElement.offsetWidth;
            /** @type {?} */

            var viewWidth = 0;
            /** @type {?} */

            var chipsAreaElements = this.chipsArea.element.nativeElement.children;
            /** @type {?} */

            var visibleChipsCount = 0;
            /** @type {?} */

            var moreIconWidth = this.moreIcon.nativeElement.offsetWidth - parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);

            for (var index = 0; index < chipsAreaElements.length - 1; index++) {
              if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {
                viewWidth += chipsAreaElements[index].offsetWidth;

                if (index % 2 === 0) {
                  visibleChipsCount++;
                } else {
                  viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);
                  viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);
                }
              } else {
                if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {
                  visibleChipsCount--;
                } else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {
                  visibleChipsCount--;
                }

                this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;
                this.filteringService.columnToMoreIconHidden.set(this.column.field, false);
                break;
              }
            }

            for (var i = visibleChipsCount; i < this.expressionsList.length; i++) {
              this.expressionsList[i].isVisible = false;
            }

            this.cdr.detectChanges();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "isFirstElementFocused",
        value: function isFirstElementFocused() {
          return !(this.chipsArea && this.chipsArea.chipsList.length > 0 && this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(".igx-chip__item") !== document.activeElement);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "isLastElementFocused",
        value: function isLastElementFocused() {
          if (this.chipsArea) {
            if (this.isMoreIconHidden() && this.chipsArea.chipsList.last.elementRef.nativeElement.querySelector(".igx-chip__remove") !== document.activeElement) {
              return false;
            } else if (!this.isMoreIconHidden() && this.moreIcon.nativeElement !== document.activeElement) {
              return false;
            }
          }

          return true;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "focusFirstElement",
        value: function focusFirstElement() {
          if (this.chipsArea.chipsList.length > 0) {
            this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
          } else {
            this.moreIcon.nativeElement.focus();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "focusElement",
        value: function focusElement() {
          if (this.filteringService.shouldFocusNext) {
            if (!this.isMoreIconHidden() && this.chipsArea.chipsList.length === 0) {
              this.moreIcon.nativeElement.focus();
            } else {
              this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
            }
          } else {
            if (!this.isMoreIconHidden()) {
              this.moreIcon.nativeElement.focus();
            } else {
              this.chipsArea.chipsList.last.elementRef.nativeElement.querySelector(".igx-chip__remove").focus();
            }
          }
        }
        /**
         * @private
         * @param {?} columnIndex
         * @return {?}
         */

      }, {
        key: "isColumnRightVisible",
        value: function isColumnRightVisible(columnIndex) {
          if (this.filteringService.areAllColumnsInView) {
            return true;
          }
          /** @type {?} */


          var currentColumnRight = 0;

          for (var index = 0; index < this.filteringService.unpinnedColumns.length; index++) {
            currentColumnRight += parseInt(this.filteringService.unpinnedColumns[index].width, 10);

            if (this.filteringService.unpinnedColumns[index] === this.filteringService.unpinnedFilterableColumns[columnIndex]) {
              break;
            }
          }
          /** @type {?} */


          var width = this.filteringService.displayContainerWidth + this.filteringService.displayContainerScrollLeft;
          return currentColumnRight <= width;
        }
        /**
         * @private
         * @param {?} columnIndex
         * @return {?}
         */

      }, {
        key: "isColumnLeftVisible",
        value: function isColumnLeftVisible(columnIndex) {
          if (this.filteringService.areAllColumnsInView) {
            return true;
          }
          /** @type {?} */


          var currentColumnLeft = 0;

          for (var index = 0; index < this.filteringService.unpinnedColumns.length; index++) {
            if (this.filteringService.unpinnedColumns[index] === this.filteringService.unpinnedFilterableColumns[columnIndex]) {
              break;
            }

            currentColumnLeft += parseInt(this.filteringService.unpinnedColumns[index].width, 10);
          }

          return currentColumnLeft >= this.filteringService.displayContainerScrollLeft;
        }
      }, {
        key: "template",
        get: function get() {
          if (!this.column.filterable) {
            this.currentTemplate = null;
            return null;
          }

          if (this.column.filterCellTemplate) {
            this.currentTemplate = this.column.filterCellTemplate;
            return this.column.filterCellTemplate;
          }
          /** @type {?} */


          var expressionTree = this.column.filteringExpressionsTree;

          if (!expressionTree || expressionTree.filteringOperands.length === 0) {
            this.currentTemplate = this.emptyFilter;
            return this.emptyFilter;
          }

          if (this.filteringService.isFilterComplex(this.column.field)) {
            this.currentTemplate = this.complexFilter;
            return this.complexFilter;
          }

          this.currentTemplate = this.defaultFilter;
          return this.defaultFilter;
        }
        /**
         * Gets the context passed to the filter template.
         * \@memberof IgxGridFilteringCellComponent
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          return {
            column: this.column
          };
        }
      }]);

      return IgxGridFilteringCellComponent;
    }();

    IgxGridFilteringCellComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-filtering-cell',
        template: "<ng-template #emptyFilter>\n        <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n            <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" (keydown)=\"onChipKeyDown($event)\" [displayDensity]=\"'cosy'\">\n                <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n                <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n            </igx-chip>\n        </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip\n                *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                [displayDensity]=\"'cosy'\"\n                (click)=\"onChipClicked(item.expression)\"\n                (keydown)=\"onChipKeyDown($event, item.expression)\"\n                (onRemove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    fontSet=\"filtering-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\" (keydown)=\"onChipKeyDown($event)\" tabindex=\"0\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"'cosy'\" (onRemove)=\"clearFiltering()\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n"
      }]
    }];
    /** @nocollapse */

    IgxGridFilteringCellComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxFilteringService
      }, {
        type: IgxGridNavigationService
      }];
    };

    IgxGridFilteringCellComponent.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      emptyFilter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['emptyFilter', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultFilter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultFilter', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      complexFilter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['complexFilter', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      chipsArea: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['chipsArea', {
          read: IgxChipsAreaComponent,
          "static": false
        }]
      }],
      moreIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['moreIcon', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      ghostChip: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['ghostChip', {
          read: IgxChipComponent,
          "static": false
        }]
      }],
      complexChip: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['complexChip', {
          read: IgxChipComponent,
          "static": false
        }]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__filtering-cell']
      }],
      onTabKeyDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.tab', ['$event']]
      }],
      onShiftTabKeyDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.shift.tab', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var Z_INDEX = 9999;
    /**
     * @hidden
     */

    var IgxGridHeaderGroupComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} cdr
       * @param {?} gridAPI
       * @param {?} element
       * @param {?} colResizingService
       * @param {?} filteringService
       */
      function IgxGridHeaderGroupComponent(cdr, gridAPI, element, colResizingService, filteringService) {
        _classCallCheck(this, IgxGridHeaderGroupComponent);

        this.cdr = cdr;
        this.gridAPI = gridAPI;
        this.element = element;
        this.colResizingService = colResizingService;
        this.filteringService = filteringService;
      }
      /**
       * @return {?}
       */


      _createClass(IgxGridHeaderGroupComponent, [{
        key: "onMouseDown",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function onMouseDown(event) {
          // hack for preventing text selection in IE and Edge while dragging the resizer
          event.preventDefault();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          this.cdr.markForCheck();
        }
      }, {
        key: "gridRowSpan",
        get: function get() {
          return this.column.gridRowSpan;
        }
        /**
         * @return {?}
         */

      }, {
        key: "gridColumnSpan",
        get: function get() {
          return this.column.gridColumnSpan;
        }
        /**
         * @return {?}
         */

      }, {
        key: "rowEnd",
        get: function get() {
          return this.column.rowEnd;
        }
        /**
         * @return {?}
         */

      }, {
        key: "colEnd",
        get: function get() {
          return this.column.colEnd;
        }
        /**
         * @return {?}
         */

      }, {
        key: "rowStart",
        get: function get() {
          return this.column.rowStart;
        }
        /**
         * @return {?}
         */

      }, {
        key: "colStart",
        get: function get() {
          return this.column.colStart;
        }
        /**
         * Gets the width of the header group.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */

      }, {
        key: "width",
        get: function get() {
          return this.grid.getHeaderGroupWidth(this.column);
        }
        /**
         * Gets the style classes of the header group.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */

      }, {
        key: "styleClasses",
        get: function get() {
          /** @type {?} */
          var defaultClasses = ['igx-grid__thead-item', this.column.headerGroupClasses];
          /** @type {?} */

          var classList = {
            'igx-grid__th--pinned': this.isPinned,
            'igx-grid__th--pinned-last': this.isLastPinned,
            'igx-grid__drag-col-header': this.isHeaderDragged,
            'igx-grid__th--filtering': this.isFiltered
          };

          for (var _i18 = 0, _Object$keys6 = Object.keys(classList); _i18 < _Object$keys6.length; _i18++) {
            var className = _Object$keys6[_i18];

            if (classList[className]) {
              defaultClasses.push(className);
            }
          }

          return defaultClasses.join(' ');
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "zIndex",
        get: function get() {
          if (!this.column.pinned) {
            return null;
          }

          return Z_INDEX - this.grid.pinnedColumns.indexOf(this.column);
        }
        /**
         * Gets the grid of the header group.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */

      }, {
        key: "grid",
        get: function get() {
          return this.gridAPI.grid;
        }
        /**
         * Gets whether the header group belongs to a column that is filtered.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */

      }, {
        key: "isFiltered",
        get: function get() {
          return this.filteringService.filteredColumn === this.column;
        }
        /**
         * Gets whether the header group is stored in the last column in the pinned area.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */

      }, {
        key: "isLastPinned",
        get: function get() {
          return !this.grid.hasColumnLayouts ? this.column.isLastPinned : false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "groupDisplayStyle",
        get: function get() {
          return this.grid.hasColumnLayouts && this.column.children && !isIE() ? 'flex' : '';
        }
        /**
         * Gets whether the header group is stored in a pinned column.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */

      }, {
        key: "isPinned",
        get: function get() {
          return this.column.pinned;
        }
        /**
         * Gets whether the header group belongs to a column that is moved.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */

      }, {
        key: "isHeaderDragged",
        get: function get() {
          return this.grid.draggedColumn === this.column;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hasLastPinnedChildColumn",
        get: function get() {
          return this.column.allChildren.some(function (child) {
            return child.isLastPinned;
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "height",
        get: function get() {
          return this.element.nativeElement.getBoundingClientRect().height;
        }
      }]);

      return IgxGridHeaderGroupComponent;
    }();

    IgxGridHeaderGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-header-group',
        template: "<ng-container *ngIf=\"grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-group igx-grid__mrl-block\"\n     [ngClass]=\"{'igx-grid__th--pinned-last': hasLastPinnedChildColumn}\"\n     [ngStyle]=\"{'grid-template-rows':column.getGridTemplate(true, false),\n     'grid-template-columns':column.getGridTemplate(false, false),\n     '-ms-grid-rows':column.getGridTemplate(true, true),\n     '-ms-grid-columns':column.getGridTemplate(false, true)}\">\n        <ng-container *ngFor=\"let child of column.children\" >\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                [column]=\"child\"\n                [gridID]=\"child.gridID\"\n                [igxColumnMovingDrag]=\"child\"\n                [ghostHost]=\"grid.outletDirective.nativeElement\"\n                [attr.droppable]=\"true\"\n                [igxColumnMovingDrop]=\"child\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-template #defaultColumn>\n    <span [attr.title]=\"column.header\">{{column.header}}</span>\n</ng-template>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-title\"\n        [ngClass]=\"{'igx-grid__th--pinned-last': hasLastPinnedChildColumn}\"\n        [igxColumnMovingDrag]=\"column\"\n        [ghostHost]=\"grid.outletDirective.nativeElement\"\n        [attr.droppable]=\"true\"\n        [igxColumnMovingDrop]=\"column\">\n        <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n        </ng-container>\n    </div>\n    <div class=\"igx-grid__thead-group\">\n        <ng-container *ngFor=\"let child of column.children\">\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                                [column]=\"child\"\n                                [gridID]=\"child.grid.id\"\n                                [style.min-width.px]=\"grid.getHeaderGroupWidth(child)\"\n                                [style.flex-basis.px]=\"grid.getHeaderGroupWidth(child)\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-container *ngIf=\"!column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <igx-grid-header [igxColumnMovingDrag]=\"column\" [ghostHost]=\"grid.outletDirective.nativeElement\" [attr.droppable]=\"true\" [igxColumnMovingDrop]=\"column\" [gridID]=\"column.grid.id\" [column]=\"column\"></igx-grid-header>\n    <igx-grid-filtering-cell *ngIf=\"grid.allowFiltering && grid.filterMode == 'quickFilter'\" [column]=\"column\" [attr.draggable]=\"false\"></igx-grid-filtering-cell>\n    <span *ngIf=\"!column.columnGroup && column.resizable\" class=\"igx-grid__th-resize-handle\"\n          [igxResizeHandle]=\"column\"\n          [attr.draggable]=\"false\"\n          [style.cursor]=\"colResizingService.resizeCursor\">\n    </span>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n"
      }]
    }];
    /** @nocollapse */

    IgxGridHeaderGroupComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: IgxColumnResizingService
      }, {
        type: IgxFilteringService
      }];
    };

    IgxGridHeaderGroupComponent.propDecorators = {
      gridRowSpan: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.-ms-grid-row-span']
      }],
      gridColumnSpan: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.-ms-grid-column-span']
      }],
      rowEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.grid-row-end']
      }],
      colEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.grid-column-end']
      }],
      rowStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.-ms-grid-row']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.grid-row-start']
      }],
      colStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.-ms-grid-column']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.grid-column-start']
      }],
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      gridID: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      headerCell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxGridHeaderComponent, {
          "static": false
        }]
      }],
      filterCell: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxGridFilteringCellComponent, {
          "static": false
        }]
      }],
      children: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxGridHeaderGroupComponent;
        }), {
          read: IgxGridHeaderGroupComponent
        }]
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.min-width']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.flex-basis']
      }],
      styleClasses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class']
      }],
      zIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.z-index']
      }],
      groupDisplayStyle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.display']
      }],
      onMouseDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['mousedown', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var GridResourceStringsEN = {
      igx_grid_groupByArea_message: 'Drag a column header and drop it here to group by that column.',
      igx_grid_emptyFilteredGrid_message: 'No records found.',
      igx_grid_emptyGrid_message: 'Grid has no data.',
      igx_grid_filter: 'Filter',
      igx_grid_filter_row_close: 'Close',
      igx_grid_filter_row_reset: 'Reset',
      igx_grid_filter_row_placeholder: 'Add filter value',
      igx_grid_filter_row_boolean_placeholder: 'All',
      igx_grid_filter_row_date_placeholder: 'Pick up date',
      igx_grid_filter_operator_and: 'And',
      igx_grid_filter_operator_or: 'Or',
      igx_grid_complex_filter: 'Complex Filter',
      igx_grid_filter_contains: 'Contains',
      igx_grid_filter_doesNotContain: 'Does Not Contain',
      igx_grid_filter_startsWith: 'Starts With',
      igx_grid_filter_endsWith: 'Ends With',
      igx_grid_filter_equals: 'Equals',
      igx_grid_filter_doesNotEqual: 'Does Not Equal',
      igx_grid_filter_empty: 'Empty',
      igx_grid_filter_notEmpty: 'Not Empty',
      igx_grid_filter_null: 'Null',
      igx_grid_filter_notNull: 'Not Null',
      igx_grid_filter_before: 'Before',
      igx_grid_filter_after: 'After',
      igx_grid_filter_today: 'Today',
      igx_grid_filter_yesterday: 'Yesterday',
      igx_grid_filter_thisMonth: 'This Month',
      igx_grid_filter_lastMonth: 'Last Month',
      igx_grid_filter_nextMonth: 'Next Month',
      igx_grid_filter_thisYear: 'This Year',
      igx_grid_filter_lastYear: 'Last Year',
      igx_grid_filter_nextYear: 'Next Year',
      igx_grid_filter_greaterThan: 'Greater Than',
      igx_grid_filter_lessThan: 'Less Than',
      igx_grid_filter_greaterThanOrEqualTo: 'Greater Than Or Equal To',
      igx_grid_filter_lessThanOrEqualTo: 'Less Than Or Equal To',
      igx_grid_filter_true: 'True',
      igx_grid_filter_false: 'False',
      igx_grid_filter_all: 'All',
      igx_grid_filter_condition_placeholder: 'Select filter',
      igx_grid_summary_count: 'Count',
      igx_grid_summary_min: 'Min',
      igx_grid_summary_max: 'Max',
      igx_grid_summary_sum: 'Sum',
      igx_grid_summary_average: 'Avg',
      igx_grid_summary_earliest: 'Earliest',
      igx_grid_summary_latest: 'Latest',
      igx_grid_excel_filter_moving_left: 'move left',
      igx_grid_excel_filter_moving_left_short: 'left',
      igx_grid_excel_filter_moving_right: 'move right',
      igx_grid_excel_filter_moving_right_short: 'right',
      igx_grid_excel_filter_moving_header: 'move',
      igx_grid_excel_filter_sorting_asc: 'ascending',
      igx_grid_excel_filter_sorting_asc_short: 'asc',
      igx_grid_excel_filter_sorting_desc: 'descending',
      igx_grid_excel_filter_sorting_desc_short: 'desc',
      igx_grid_excel_filter_sorting_header: 'sort',
      igx_grid_excel_filter_clear: 'Clear column filters',
      igx_grid_excel_custom_dialog_add: 'add filter',
      igx_grid_excel_custom_dialog_clear: 'Clear filter',
      igx_grid_excel_custom_dialog_header: 'Custom auto-filter on column: ',
      igx_grid_excel_cancel: 'cancel',
      igx_grid_excel_apply: 'apply',
      igx_grid_excel_search_placeholder: 'Search',
      igx_grid_excel_select_all: 'Select All',
      igx_grid_excel_blanks: '(Blanks)',
      igx_grid_excel_hide: 'Hide column',
      igx_grid_excel_pin: 'Pin column',
      igx_grid_excel_unpin: 'Unpin column',
      igx_grid_excel_text_filter: 'Text filter',
      igx_grid_excel_number_filter: 'Number filter',
      igx_grid_excel_date_filter: 'Date filter',
      igx_grid_excel_boolean_filter: 'Boolean filter',
      igx_grid_excel_custom_filter: 'Custom filter...',
      igx_grid_advanced_filter_title: 'Advanced Filtering',
      igx_grid_advanced_filter_and_group: '"And" Group',
      igx_grid_advanced_filter_or_group: '"Or" Group',
      igx_grid_advanced_filter_end_group: 'End Group',
      igx_grid_advanced_filter_create_and_group: 'Create "And" Group',
      igx_grid_advanced_filter_create_or_group: 'Create "Or" Group',
      igx_grid_advanced_filter_and_label: 'and',
      igx_grid_advanced_filter_or_label: 'or',
      igx_grid_advanced_filter_add_condition: 'Condition',
      igx_grid_advanced_filter_ungroup: 'Ungroup',
      igx_grid_advanced_filter_delete: 'Delete',
      igx_grid_advanced_filter_delete_filters: 'Delete filters',
      igx_grid_advanced_filter_initial_text: 'Start with creating a group of conditions linked with "And" or "Or"',
      igx_grid_advanced_filter_column_placeholder: 'Select column',
      igx_grid_advanced_filter_value_placeholder: 'Value'
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var TimePickerResourceStringsEN = {
      igx_time_picker_ok: 'OK',
      igx_time_picker_cancel: 'Cancel'
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var PaginatorResourceStringsEN = {
      igx_paginator_label: 'Items per page'
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @type {?}
     */

    var CurrentResourceStrings = {
      GridResStrings: cloneValue(GridResourceStringsEN),
      TimePickerResStrings: cloneValue(TimePickerResourceStringsEN),
      PaginatorResStrings: cloneValue(PaginatorResourceStringsEN)
    };
    /**
     * @param {?} currentStrings
     * @param {?} newStrings
     * @return {?}
     */

    function updateResourceStrings(currentStrings, newStrings) {
      for (var _i19 = 0, _Object$keys7 = Object.keys(newStrings); _i19 < _Object$keys7.length; _i19++) {
        var key = _Object$keys7[_i19];

        if (key in currentStrings) {
          currentStrings[key] = newStrings[key];
        }
      }
    }
    /**
     * Changes the resource strings for all components in the application
     * ```
     * @param {?} resourceStrings to be applied
     * @return {?}
     */


    function changei18n(resourceStrings) {
      for (var _i20 = 0, _Object$keys8 = Object.keys(CurrentResourceStrings); _i20 < _Object$keys8.length; _i20++) {
        var key = _Object$keys8[_i20];
        updateResourceStrings(CurrentResourceStrings[key], resourceStrings);
      }
    }
    /**
     * Returns current resource strings for all components
     * @return {?}
     */


    function getCurrentResourceStrings() {
      return Object.assign({}, CurrentResourceStrings.GridResStrings, CurrentResourceStrings.TimePickerResStrings);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var IgxGridSummaryService =
    /*#__PURE__*/
    function () {
      function IgxGridSummaryService() {
        _classCallCheck(this, IgxGridSummaryService);

        this.summaryCacheMap = new Map();
        this.rootSummaryID = 'igxGridRootSummary';
        this.summaryHeight = 0;
        this.maxSummariesLenght = 0;
        this.groupingExpressions = [];
        this.retriggerRootPipe = 0;
        this.deleteOperation = false;
      }
      /**
       * @return {?}
       */


      _createClass(IgxGridSummaryService, [{
        key: "recalculateSummaries",
        value: function recalculateSummaries() {
          this.resetSummaryHeight();
          this.grid.notifyChanges(true);
        }
        /**
         * @param {?=} args
         * @return {?}
         */

      }, {
        key: "clearSummaryCache",
        value: function clearSummaryCache(args) {
          if (!this.summaryCacheMap.size) {
            return;
          }

          if (!args) {
            this.summaryCacheMap.clear();

            if (this.grid && this.grid.rootSummariesEnabled) {
              this.retriggerRootPipe++;
            }

            return;
          }

          if (args.data) {
            /** @type {?} */
            var rowID = this.grid.primaryKey ? args.data[this.grid.primaryKey] : args.data;
            this.removeSummaries(rowID);
          }

          if (args.rowID !== undefined && args.rowID !== null) {
            /** @type {?} */
            var columnName = args.cellID ? this.grid.columnList.find(function (col) {
              return col.index === args.cellID.columnID;
            }).field : undefined;

            if (columnName && this.grid.rowEditable) {
              return;
            }
            /** @type {?} */


            var isGroupedColumn = this.grid.groupingExpressions && this.grid.groupingExpressions.map(function (expr) {
              return expr.fieldName;
            }).indexOf(columnName) !== -1;

            if (columnName && isGroupedColumn) {
              columnName = undefined;
            }

            this.removeSummaries(args.rowID, columnName);
          }
        }
        /**
         * @param {?} rowID
         * @param {?=} columnName
         * @return {?}
         */

      }, {
        key: "removeSummaries",
        value: function removeSummaries(rowID, columnName) {
          var _this225 = this;

          this.deleteSummaryCache(this.rootSummaryID, columnName);

          if (this.summaryCacheMap.size === 1 && this.summaryCacheMap.has(this.rootSummaryID)) {
            return;
          }

          if (this.isTreeGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
              this.deleteOperation = false; // TODO: this.removeChildRowSummaries(rowID, columnName);

              this.summaryCacheMap.clear();
              return;
            }

            this.removeAllTreeGridSummaries(rowID, columnName);
          } else if (this.isHierarchicalGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
              this.deleteOperation = false;
              this.summaryCacheMap.clear();
            }
          } else {
            /** @type {?} */
            var summaryIds = this.getSummaryID(rowID, this.grid.groupingExpressions);
            summaryIds.forEach(function (id) {
              _this225.deleteSummaryCache(id, columnName);
            });
          }
        }
        /**
         * @param {?} columnName
         * @return {?}
         */

      }, {
        key: "removeSummariesCachePerColumn",
        value: function removeSummariesCachePerColumn(columnName) {
          this.summaryCacheMap.forEach(function (cache) {
            if (cache.get(columnName)) {
              cache["delete"](columnName);
            }
          });

          if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "calcMaxSummaryHeight",
        value: function calcMaxSummaryHeight() {
          if (this.summaryHeight) {
            return this.summaryHeight;
          }

          if (!this.grid.data) {
            return this.summaryHeight = 0;
          }
          /** @type {?} */


          var maxSummaryLength = 0;
          this.grid.columnList.filter(function (col) {
            return col.hasSummary && !col.hidden;
          }).forEach(function (column) {
            /** @type {?} */
            var getCurrentSummaryColumn = column.summaries.operate([], [], column.field).length;

            if (getCurrentSummaryColumn) {
              if (maxSummaryLength < getCurrentSummaryColumn) {
                maxSummaryLength = getCurrentSummaryColumn;
              }
            }
          });
          this.maxSummariesLenght = maxSummaryLength;
          this.summaryHeight = maxSummaryLength * this.grid.defaultSummaryHeight;
          return this.summaryHeight;
        }
        /**
         * @param {?} rowID
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "calculateSummaries",
        value: function calculateSummaries(rowID, data) {
          /** @type {?} */
          var rowSummaries = this.summaryCacheMap.get(rowID);

          if (!rowSummaries) {
            rowSummaries = new Map();
            this.summaryCacheMap.set(rowID, rowSummaries);
          }

          if (!this.hasSummarizedColumns || !data) {
            return rowSummaries;
          }

          this.grid.columnList.filter(function (col) {
            return col.hasSummary;
          }).forEach(function (column) {
            if (!rowSummaries.get(column.field)) {
              rowSummaries.set(column.field, column.summaries.operate(data.map(function (r) {
                return r[column.field];
              }), data, column.field));
            }
          });
          return rowSummaries;
        }
        /**
         * @return {?}
         */

      }, {
        key: "resetSummaryHeight",
        value: function resetSummaryHeight() {
          this.summaryHeight = 0;
          /** @type {?} */this.grid._summaryPipeTrigger++;

          if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
          }
        }
        /**
         * @param {?} groupingArgs
         * @return {?}
         */

      }, {
        key: "updateSummaryCache",
        value: function updateSummaryCache(groupingArgs) {
          if (this.summaryCacheMap.size === 0 || !this.hasSummarizedColumns) {
            return;
          }

          if (this.groupingExpressions.length === 0) {
            this.groupingExpressions = groupingArgs.expressions.map(function (record) {
              return record.fieldName;
            });
            return;
          }

          if (groupingArgs.length === 0) {
            this.groupingExpressions = [];
            this.clearSummaryCache();
            return;
          }

          this.compareGroupingExpressions(this.groupingExpressions, groupingArgs);
          this.groupingExpressions = groupingArgs.expressions.map(function (record) {
            return record.fieldName;
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "deleteSummaryCache",

        /**
         * @private
         * @param {?} id
         * @param {?} columnName
         * @return {?}
         */
        value: function deleteSummaryCache(id, columnName) {
          if (this.summaryCacheMap.get(id)) {
            /** @type {?} */
            var filteringApplied = columnName && this.grid.filteringExpressionsTree && this.grid.filteringExpressionsTree.filteringOperands.map(function (expr) {
              return expr.fieldName;
            }).indexOf(columnName) !== -1;

            if (columnName && this.summaryCacheMap.get(id).get(columnName) && !filteringApplied) {
              this.summaryCacheMap.get(id)["delete"](columnName);
            } else {
              this.summaryCacheMap["delete"](id);
            }

            if (id === this.rootSummaryID && this.grid.rootSummariesEnabled) {
              this.retriggerRootPipe++;
            }
          }
        }
        /**
         * @private
         * @param {?} rowID
         * @param {?} groupingExpressions
         * @return {?}
         */

      }, {
        key: "getSummaryID",
        value: function getSummaryID(rowID, groupingExpressions) {
          var _this226 = this;

          if (groupingExpressions.length === 0) {
            return [];
          }
          /** @type {?} */


          var summaryIDs = [];
          /** @type {?} */

          var data = this.grid.data;

          if (this.grid.transactions.enabled) {
            data = DataUtil.mergeTransactions(cloneArray(this.grid.data), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey);
          }
          /** @type {?} */


          var rowData = this.grid.primaryKey ? data.find(function (rec) {
            return rec[_this226.grid.primaryKey] === rowID;
          }) : rowID;
          /** @type {?} */

          var id = '{ ';
          groupingExpressions.forEach(function (expr) {
            id += "'".concat(expr.fieldName, "': '").concat(rowData[expr.fieldName], "'");
            summaryIDs.push(id.concat(' }'));
            id += ', ';
          });
          return summaryIDs;
        }
        /**
         * @private
         * @param {?} rowID
         * @param {?=} columnName
         * @return {?}
         */

      }, {
        key: "removeAllTreeGridSummaries",
        value: function removeAllTreeGridSummaries(rowID, columnName) {
          /** @type {?} */
          var row = this.grid.records.get(rowID);

          if (!row) {
            return;
          }

          row = row.children ? row : row.parent;

          while (row) {
            rowID = row.rowID;
            this.deleteSummaryCache(rowID, columnName);
            row = row.parent;
          }
        } // TODO: remove only deleted rows

        /**
         * @private
         * @param {?} rowID
         * @param {?=} columnName
         * @return {?}
         */

      }, {
        key: "removeChildRowSummaries",
        value: function removeChildRowSummaries(rowID, columnName) {}
        /**
         * @private
         * @param {?} current
         * @param {?} groupingArgs
         * @return {?}
         */

      }, {
        key: "compareGroupingExpressions",
        value: function compareGroupingExpressions(current, groupingArgs) {
          var _this227 = this;

          /** @type {?} */
          var newExpressions = groupingArgs.expressions.map(function (record) {
            return record.fieldName;
          });
          /** @type {?} */

          var removedCols = groupingArgs.ungroupedColumns;

          if (current.length <= newExpressions.length) {
            /** @type {?} */
            var newExpr = newExpressions.slice(0, current.length).toString();

            if (current.toString() !== newExpr) {
              this.clearSummaryCache();
            }
          } else {
            /** @type {?} */
            var currExpr = current.slice(0, newExpressions.length).toString();

            if (currExpr !== newExpressions.toString()) {
              this.clearSummaryCache();
              return;
            }

            removedCols.map(function (col) {
              return col.field;
            }).forEach(function (colName) {
              _this227.summaryCacheMap.forEach(function (cache, id) {
                if (id.indexOf(colName) !== -1) {
                  _this227.summaryCacheMap["delete"](id);
                }
              });
            });
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "hasSummarizedColumns",
        get: function get() {
          /** @type {?} */
          var summarizedColumns = this.grid.columnList.filter(function (col) {
            return col.hasSummary && !col.hidden;
          });
          return summarizedColumns.length > 0;
        }
      }, {
        key: "isTreeGrid",
        get: function get() {
          return this.grid.nativeElement.tagName.toLowerCase() === 'igx-tree-grid';
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "isHierarchicalGrid",
        get: function get() {
          return this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
        }
      }]);

      return IgxGridSummaryService;
    }();

    IgxGridSummaryService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxSummaryCellComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       */
      function IgxSummaryCellComponent(element) {
        _classCallCheck(this, IgxSummaryCellComponent);

        this.element = element;
        this.firstCellIndentation = 0;
        this.hasSummary = false;
        this.tabindex = 0;
      }
      /**
       * @return {?}
       */


      _createClass(IgxSummaryCellComponent, [{
        key: "onFocus",

        /**
         * @return {?}
         */
        value: function onFocus() {
          this.focused = true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur() {
          this.focused = false;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "dispatchEvent",

        /**
         * @param {?} event
         * @return {?}
         */
        value: function dispatchEvent(event) {
          // TODO: Refactor

          /** @type {?} */
          var key = event.key.toLowerCase();
          /** @type {?} */

          var ctrl = event.ctrlKey;
          /** @type {?} */

          var shift = event.shiftKey;

          if (!SUPPORTED_KEYS.has(key)) {
            return;
          }

          event.stopPropagation();
          /** @type {?} */

          var args = {
            targetType: 'summaryCell',
            target: this,
            event: event,
            cancel: false
          };
          this.grid.onGridKeydown.emit(args);

          if (args.cancel) {
            return;
          }

          event.preventDefault();

          if (!this.isKeySupportedInCell(key, ctrl)) {
            return;
          }

          this.grid.selectionService.keyboardState.shift = shift && !(key === 'tab');
          /** @type {?} */

          var row = this.getRowElementByIndex(this.rowIndex);

          switch (key) {
            case 'tab':
              if (shift) {
                this.grid.navigation.performShiftTabKey(row, this.selectionNode);
                break;
              }

              this.grid.navigation.performTab(row, this.selectionNode);
              break;

            case 'arrowleft':
            case 'home':
            case 'left':
              if (ctrl || key === 'home') {
                this.grid.navigation.onKeydownHome(this.rowIndex, true);
                break;
              }

              this.grid.navigation.onKeydownArrowLeft(this.nativeElement, this.selectionNode);
              break;

            case 'end':
            case 'arrowright':
            case 'right':
              if (ctrl || key === 'end') {
                this.grid.navigation.onKeydownEnd(this.rowIndex, true);
                break;
              }

              this.grid.navigation.onKeydownArrowRight(this.nativeElement, this.selectionNode);
              break;

            case 'arrowup':
            case 'up':
              this.grid.navigation.navigateUp(row, this.selectionNode);
              break;

            case 'arrowdown':
            case 'down':
              this.grid.navigation.navigateDown(row, this.selectionNode);
              break;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "getRowElementByIndex",

        /**
         * @private
         * @param {?} rowIndex
         * @return {?}
         */
        value: function getRowElementByIndex(rowIndex) {
          /** @type {?} */
          var summaryRows = this.grid.summariesRowList.toArray();
          return summaryRows.find(function (sr) {
            return sr.dataRowIndex === rowIndex;
          }).nativeElement;
        }
        /**
         * @private
         * @param {?} key
         * @param {?} ctrl
         * @return {?}
         */

      }, {
        key: "isKeySupportedInCell",
        value: function isKeySupportedInCell(key, ctrl) {
          if (ctrl) {
            return ['arrowup', 'arrowdown', 'up', 'down', 'end', 'home'].indexOf(key) === -1;
          }

          return ['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright', 'home', 'end', 'tab'].indexOf(key) !== -1;
        }
        /**
         * @param {?} summary
         * @return {?}
         */

      }, {
        key: "translateSummary",
        value: function translateSummary(summary) {
          return this.grid.resourceStrings["igx_grid_summary_".concat(summary.key)] || summary.label;
        }
      }, {
        key: "visibleColumnIndex",
        get: function get() {
          return this.column.visibleIndex;
        }
        /**
         * @return {?}
         */

      }, {
        key: "describeby",
        get: function get() {
          return "Summary_".concat(this.column.field);
        }
      }, {
        key: "selectionNode",
        get: function get() {
          return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            isSummaryRow: true
          };
        }
      }, {
        key: "width",
        get: function get() {
          return this.column.getCellWidth();
        }
        /**
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
        /**
         * @return {?}
         */

      }, {
        key: "columnDatatype",
        get: function get() {
          return this.column.dataType;
        }
        /**
         * @return {?}
         */

      }, {
        key: "itemHeight",
        get: function get() {
          return this.column.grid.defaultSummaryHeight;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "grid",
        get: function get() {
          return (
            /** @type {?} */
            this.column.grid
          );
        }
      }]);

      return IgxSummaryCellComponent;
    }();

    IgxSummaryCellComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-summary-cell',
        template: "<ng-container *ngIf=\"hasSummary\">\n    <ng-container *ngFor=\"let summary of summaryResults\">\n            <div class=\"igx-grid-summary__item\" [style.height.px]=\"itemHeight\">\n\n                <ng-container *ngIf=\"visibleColumnIndex === 0 && firstCellIndentation >= 0\">\n                    <div class=\"igx-grid__tree-cell--padding-level-{{firstCellIndentation}}\"></div>\n\n                    <div #indicator class=\"igx-grid__tree-grouping-indicator\" style=\"visibility: hidden\">\n                        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n                    </div>\n                </ng-container>\n\n                <span class=\"igx-grid-summary__label\" title=\"{{ summary.label }}\">{{ translateSummary(summary) }}</span>\n                <span class=\"igx-grid-summary__result\" title=\"{{ summary.summaryResult }}\">\n                    {{ columnDatatype === 'number' ? (summary.summaryResult | igxdecimal: grid.locale) : columnDatatype === 'date' ? (summary.summaryResult | igxdate: grid.locale) : (summary.summaryResult) }}\n                </span>\n            </div>\n    </ng-container>\n</ng-container>\n"
      }]
    }];
    /** @nocollapse */

    IgxSummaryCellComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxSummaryCellComponent.propDecorators = {
      summaryResults: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      firstCellIndentation: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hasSummary: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      density: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.data-rowIndex']
      }],
      visibleColumnIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.data-visibleIndex']
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      describeby: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-describedby']
      }],
      focused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid-summary--active']
      }],
      onFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus']
      }],
      onBlur: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['blur']
      }],
      dispatchEvent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown', ['$event']]
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.min-width']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.max-width']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.flex-basis']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxSummaryRowComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       * @param {?} element
       * @param {?} cdr
       */
      function IgxSummaryRowComponent(gridAPI, element, cdr) {
        _classCallCheck(this, IgxSummaryRowComponent);

        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        this.firstCellIndentation = -1;
      }
      /**
       * @return {?}
       */


      _createClass(IgxSummaryRowComponent, [{
        key: "ngDoCheck",

        /**
         * @return {?}
         */
        value: function ngDoCheck() {
          this.cdr.markForCheck();
        }
        /**
         * @return {?}
         */

      }, {
        key: "getColumnSummaries",

        /**
         * @param {?} columnName
         * @return {?}
         */
        value: function getColumnSummaries(columnName) {
          if (!this.summaries.get(columnName)) {
            return [];
          }

          return this.summaries.get(columnName);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "dataRowIndex",
        get: function get() {
          return this.index;
        }
        /**
         * @return {?}
         */

      }, {
        key: "minHeight",
        get: function get() {
          return this.grid.summaryService.calcMaxSummaryHeight() - 1;
        }
      }, {
        key: "grid",
        get: function get() {
          return this.gridAPI.grid;
        }
        /**
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
      }, {
        key: "pinnedColumns",
        get: function get() {
          return this.grid.pinnedColumns;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "unpinnedColumns",
        get: function get() {
          return this.grid.unpinnedColumns;
        }
      }]);

      return IgxSummaryRowComponent;
    }();

    IgxSummaryRowComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-summary-row',
        template: "<ng-container *ngIf=\"summaries.size\">\n    <ng-container *ngIf=\"grid.summariesMargin\">\n        <div\n        class=\"igx-grid__summaries-patch\"\n        [style.min-width.px]=\"grid.summariesMargin\"\n        [style.flex-basis.px]=\"grid.summariesMargin\"\n        ></div>\n    </ng-container>\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <igx-grid-summary-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [rowIndex]=\"index\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\">\n        </igx-grid-summary-cell>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\" [igxForSizePropName]='\"calcPixelWidth\"' #igxDirRef>\n        <igx-grid-summary-cell\n            class=\"igx-grid-summary igx-grid-summary--fw\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [column]=\"col\"\n            [rowIndex]=\"index\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\">\n        </igx-grid-summary-cell>\n    </ng-template>\n</ng-container>\n",
        providers: [IgxForOfSyncService]
      }]
    }];
    /** @nocollapse */

    IgxSummaryRowComponent.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxSummaryRowComponent.propDecorators = {
      summaries: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      gridID: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      index: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      firstCellIndentation: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dataRowIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.data-rowIndex']
      }],
      summaryCells: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxSummaryCellComponent, {
          read: IgxSummaryCellComponent
        }]
      }],
      virtDirRow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['igxDirRef', {
          read: IgxGridForOfDirective,
          "static": false
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var DragScrollDirection = {
      NONE: 0,
      LEFT: 1,
      TOP: 2,
      RIGHT: 3,
      BOTTOM: 4,
      TOPLEFT: 5,
      TOPRIGHT: 6,
      BOTTOMLEFT: 7,
      BOTTOMRIGHT: 8
    };
    DragScrollDirection[DragScrollDirection.NONE] = 'NONE';
    DragScrollDirection[DragScrollDirection.LEFT] = 'LEFT';
    DragScrollDirection[DragScrollDirection.TOP] = 'TOP';
    DragScrollDirection[DragScrollDirection.RIGHT] = 'RIGHT';
    DragScrollDirection[DragScrollDirection.BOTTOM] = 'BOTTOM';
    DragScrollDirection[DragScrollDirection.TOPLEFT] = 'TOPLEFT';
    DragScrollDirection[DragScrollDirection.TOPRIGHT] = 'TOPRIGHT';
    DragScrollDirection[DragScrollDirection.BOTTOMLEFT] = 'BOTTOMLEFT';
    DragScrollDirection[DragScrollDirection.BOTTOMRIGHT] = 'BOTTOMRIGHT';

    var IgxGridDragSelectDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} ref
       * @param {?} zone
       */
      function IgxGridDragSelectDirective(ref, zone) {
        var _this228 = this;

        _classCallCheck(this, IgxGridDragSelectDirective);

        this.ref = ref;
        this.zone = zone;
        this.onDragStop = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onDragScroll = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.end$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.lastDirection = DragScrollDirection.NONE;

        this.startDragSelection = function (ev) {
          if (!_this228.activeDrag) {
            return;
          }
          /** @type {?} */


          var x = ev.clientX;
          /** @type {?} */

          var y = ev.clientY;
          /** @type {?} */

          var direction = _this228._measureDimensions(x, y);

          if (direction === _this228.lastDirection) {
            return;
          }

          _this228.unsubscribe();

          _this228._sub = _this228._interval$.subscribe(function () {
            return _this228.onDragScroll.emit(direction);
          });
          _this228.lastDirection = direction;
        };

        this.stopDragSelection = function () {
          if (!_this228.activeDrag) {
            return;
          }

          _this228.onDragStop.emit(false);

          _this228.unsubscribe();

          _this228.lastDirection = DragScrollDirection.NONE;
        };

        this._interval$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(100).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.end$), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function () {
          return _this228.activeDrag;
        }));
      }
      /**
       * @return {?}
       */


      _createClass(IgxGridDragSelectDirective, [{
        key: "ngOnInit",

        /**
         * @return {?}
         */
        value: function ngOnInit() {
          var _this229 = this;

          this.zone.runOutsideAngular(function () {
            _this229.nativeElement.addEventListener('pointerover', _this229.startDragSelection);

            _this229.nativeElement.addEventListener('pointerleave', _this229.stopDragSelection);
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _this230 = this;

          this.zone.runOutsideAngular(function () {
            _this230.nativeElement.removeEventListener('pointerover', _this230.startDragSelection);

            _this230.nativeElement.removeEventListener('pointerleave', _this230.stopDragSelection);
          });
          this.unsubscribe();
          this.end$.complete();
        }
        /**
         * @param {?} x
         * @param {?} y
         * @return {?}
         */

      }, {
        key: "_measureDimensions",
        value: function _measureDimensions(x, y) {
          /** @type {?} */
          var direction;
          /** @type {?} */

          var rect = this.clientRect;
          /** @type {?} */

          var RATIO = 0.15;
          /** @type {?} */

          var offsetX = Math.trunc(x - rect.left);
          /** @type {?} */

          var offsetY = Math.trunc(y - rect.top);
          /** @type {?} */

          var left = offsetX <= rect.width * RATIO;
          /** @type {?} */

          var right = offsetX >= rect.width * (1 - RATIO);
          /** @type {?} */

          var top = offsetY <= rect.height * RATIO;
          /** @type {?} */

          var bottom = offsetY >= rect.height * (1 - RATIO);

          if (top && left) {
            direction = DragScrollDirection.TOPLEFT;
          } else if (top && right) {
            direction = DragScrollDirection.TOPRIGHT;
          } else if (bottom && left) {
            direction = DragScrollDirection.BOTTOMLEFT;
          } else if (bottom && right) {
            direction = DragScrollDirection.BOTTOMRIGHT;
          } else if (top) {
            direction = DragScrollDirection.TOP;
          } else if (bottom) {
            direction = DragScrollDirection.BOTTOM;
          } else if (left) {
            direction = DragScrollDirection.LEFT;
          } else if (right) {
            direction = DragScrollDirection.RIGHT;
          } else {
            direction = DragScrollDirection.NONE;
          }

          return direction;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "unsubscribe",
        value: function unsubscribe() {
          if (this._sub) {
            this._sub.unsubscribe();
          }
        }
      }, {
        key: "activeDrag",
        get: function get() {
          return this._activeDrag;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (val !== this._activeDrag) {
            this.unsubscribe();
            this._activeDrag = val;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.ref.nativeElement;
        }
        /**
         * @return {?}
         */

      }, {
        key: "clientRect",
        get: function get() {
          return this.nativeElement.getBoundingClientRect();
        }
      }]);

      return IgxGridDragSelectDirective;
    }();

    IgxGridDragSelectDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxGridDragSelect]'
      }]
    }];
    /** @nocollapse */

    IgxGridDragSelectDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };

    IgxGridDragSelectDirective.propDecorators = {
      activeDrag: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxGridDragSelect']
      }],
      onDragStop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onDragScroll: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxTemplateOutletDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _viewContainerRef
       * @param {?} _zone
       * @param {?} cdr
       */
      function IgxTemplateOutletDirective(_viewContainerRef, _zone, cdr) {
        _classCallCheck(this, IgxTemplateOutletDirective);

        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this.cdr = cdr;
        /**
         * The embedded views cache. Collection is key-value paired.
         * Key is the template id, value is the embedded view for the related template.
         */

        this._embeddedViewsMap = new Map();
        this.onViewCreated = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onViewMoved = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onCachedViewLoaded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onBeforeViewDetach = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * @param {?} changes
       * @return {?}
       */


      _createClass(IgxTemplateOutletDirective, [{
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          /** @type {?} */
          var actionType = this._getActionType(changes);

          switch (actionType) {
            case TemplateOutletAction.CreateView:
              this._recreateView();

              break;

            case TemplateOutletAction.MoveView:
              this._moveView();

              break;

            case TemplateOutletAction.UseCachedView:
              this._useCachedView();

              break;

            case TemplateOutletAction.UpdateViewContext:
              this._updateExistingContext(this.igxTemplateOutletContext);

              break;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "cleanCache",
        value: function cleanCache() {
          this._embeddedViewsMap.forEach(function (item) {
            if (!item.destroyed) {
              item.destroy();
            }
          });

          this._embeddedViewsMap.clear();
        }
        /**
         * @param {?} tmplID
         * @return {?}
         */

      }, {
        key: "cleanView",
        value: function cleanView(tmplID) {
          /** @type {?} */
          var embView = this._embeddedViewsMap.get(tmplID);

          if (embView) {
            embView.destroy();

            this._embeddedViewsMap["delete"](tmplID);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_recreateView",
        value: function _recreateView() {
          // detach old and create new
          if (this._viewRef) {
            this.onBeforeViewDetach.emit({
              owner: this,
              view: this._viewRef,
              context: this.igxTemplateOutletContext
            });

            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
          }

          if (this.igxTemplateOutlet) {
            this._viewRef = this._viewContainerRef.createEmbeddedView(this.igxTemplateOutlet, this.igxTemplateOutletContext);
            this.onViewCreated.emit({
              owner: this,
              view: this._viewRef,
              context: this.igxTemplateOutletContext
            });
            /** @type {?} */

            var tmplId = this.igxTemplateOutletContext['templateID'];

            if (tmplId) {
              // if context contains a template id, check if we have a view for that template already stored in the cache
              // if not create a copy and add it to the cache in detached state.
              // Note: Views in detached state do not appear in the DOM, however they remain stored in memory.

              /** @type {?} */
              var res = this._embeddedViewsMap.get(this.igxTemplateOutletContext['templateID']);

              if (!res) {
                this._embeddedViewsMap.set(this.igxTemplateOutletContext['templateID'], this._viewRef);
              }
            }
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_moveView",
        value: function _moveView() {
          // using external view and inserting it in current view.

          /** @type {?} */
          var view = this.igxTemplateOutletContext['moveView'];
          /** @type {?} */

          var owner = this.igxTemplateOutletContext['owner'];

          if (view !== this._viewRef) {
            if (owner._viewContainerRef.indexOf(view) !== -1) {
              // detach in case view it is attached somewhere else at the moment.
              this.onBeforeViewDetach.emit({
                owner: this,
                view: this._viewRef,
                context: this.igxTemplateOutletContext
              });

              owner._viewContainerRef.detach(owner._viewContainerRef.indexOf(view));
            }

            if (this._viewRef && this._viewContainerRef.indexOf(this._viewRef) !== -1) {
              this.onBeforeViewDetach.emit({
                owner: this,
                view: this._viewRef,
                context: this.igxTemplateOutletContext
              });

              this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
            }

            this._viewRef = view;

            this._viewContainerRef.insert(view, 0);

            this._updateExistingContext(this.igxTemplateOutletContext);

            this.onViewMoved.emit({
              owner: this,
              view: this._viewRef,
              context: this.igxTemplateOutletContext
            });
          } else {
            this._updateExistingContext(this.igxTemplateOutletContext);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_useCachedView",
        value: function _useCachedView() {
          // use view for specific template cached in the current template outlet

          /** @type {?} */
          var tmplID = this.igxTemplateOutletContext['templateID'];
          /** @type {?} */

          var cachedView = tmplID ? this._embeddedViewsMap.get(tmplID) : null; // if view exists, but template has been changed and there is a view in the cache with the related template
          // then detach old view and insert the stored one with the matching template
          // after that update its context.

          this.onBeforeViewDetach.emit({
            owner: this,
            view: this._viewRef,
            context: this.igxTemplateOutletContext
          });

          this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));

          this._viewRef = cachedView;
          /** @type {?} */

          var oldContext = this._cloneContext(cachedView.context);

          this._viewContainerRef.insert(this._viewRef, 0);

          this._updateExistingContext(this.igxTemplateOutletContext);

          this.onCachedViewLoaded.emit({
            owner: this,
            view: this._viewRef,
            context: this.igxTemplateOutletContext,
            oldContext: oldContext
          });
        }
        /**
         * @private
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "_shouldRecreateView",
        value: function _shouldRecreateView(changes) {
          /** @type {?} */
          var ctxChange = changes['igxTemplateOutletContext'];
          return !!changes['igxTemplateOutlet'] || ctxChange && this._hasContextShapeChanged(ctxChange);
        }
        /**
         * @private
         * @param {?} ctxChange
         * @return {?}
         */

      }, {
        key: "_hasContextShapeChanged",
        value: function _hasContextShapeChanged(ctxChange) {
          /** @type {?} */
          var prevCtxKeys = Object.keys(ctxChange.previousValue || {});
          /** @type {?} */

          var currCtxKeys = Object.keys(ctxChange.currentValue || {});

          if (prevCtxKeys.length === currCtxKeys.length) {
            var _iteratorNormalCompletion45 = true;
            var _didIteratorError45 = false;
            var _iteratorError45 = undefined;

            try {
              for (var _iterator45 = currCtxKeys[Symbol.iterator](), _step45; !(_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done); _iteratorNormalCompletion45 = true) {
                var propName = _step45.value;

                if (prevCtxKeys.indexOf(propName) === -1) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError45 = true;
              _iteratorError45 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion45 && _iterator45["return"] != null) {
                  _iterator45["return"]();
                }
              } finally {
                if (_didIteratorError45) {
                  throw _iteratorError45;
                }
              }
            }

            return false;
          } else {
            return true;
          }
        }
        /**
         * @private
         * @param {?} ctx
         * @return {?}
         */

      }, {
        key: "_updateExistingContext",
        value: function _updateExistingContext(ctx) {
          for (var _i21 = 0, _Object$keys9 = Object.keys(ctx); _i21 < _Object$keys9.length; _i21++) {
            var propName = _Object$keys9[_i21];

            /** @type {?} */
            this._viewRef.context[propName] =
            /** @type {?} */
            this.igxTemplateOutletContext[propName];
          }
        }
        /**
         * @private
         * @param {?} ctx
         * @return {?}
         */

      }, {
        key: "_cloneContext",
        value: function _cloneContext(ctx) {
          /** @type {?} */
          var clone = {};

          for (var _i22 = 0, _Object$keys10 = Object.keys(ctx); _i22 < _Object$keys10.length; _i22++) {
            var propName = _Object$keys10[_i22];
            clone[propName] = ctx[propName];
          }

          return clone;
        }
        /**
         * @private
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "_getActionType",
        value: function _getActionType(changes) {
          /** @type {?} */
          var movedView = this.igxTemplateOutletContext['moveView'];
          /** @type {?} */

          var tmplID = this.igxTemplateOutletContext['templateID'];
          /** @type {?} */

          var cachedView = tmplID ? this._embeddedViewsMap.get(tmplID) : null;
          /** @type {?} */

          var shouldRecreate = this._shouldRecreateView(changes);

          if (movedView) {
            // view is moved from external source
            return TemplateOutletAction.MoveView;
          } else if (shouldRecreate && cachedView) {
            // should recreate (template or context change) and there is a matching template in cache
            return TemplateOutletAction.UseCachedView;
          } else if (!this._viewRef || shouldRecreate) {
            // no view or should recreate
            return TemplateOutletAction.CreateView;
          } else if (this.igxTemplateOutletContext) {
            // has context, update context
            return TemplateOutletAction.UpdateViewContext;
          }
        }
      }]);

      return IgxTemplateOutletDirective;
    }();

    IgxTemplateOutletDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxTemplateOutlet]'
      }]
    }];
    /** @nocollapse */

    IgxTemplateOutletDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxTemplateOutletDirective.propDecorators = {
      igxTemplateOutletContext: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      igxTemplateOutlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onViewCreated: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onViewMoved: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onCachedViewLoaded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onBeforeViewDetach: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /** @enum {number} */

    var TemplateOutletAction = {
      CreateView: 0,
      MoveView: 1,
      UseCachedView: 2,
      UpdateViewContext: 3
    };
    TemplateOutletAction[TemplateOutletAction.CreateView] = 'CreateView';
    TemplateOutletAction[TemplateOutletAction.MoveView] = 'MoveView';
    TemplateOutletAction[TemplateOutletAction.UseCachedView] = 'UseCachedView';
    TemplateOutletAction[TemplateOutletAction.UpdateViewContext] = 'UpdateViewContext';
    /**
     * @hidden
     */

    var IgxTemplateOutletModule = function IgxTemplateOutletModule() {
      _classCallCheck(this, IgxTemplateOutletModule);
    };

    IgxTemplateOutletModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxTemplateOutletDirective],
        entryComponents: [],
        exports: [IgxTemplateOutletDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxGridColumnResizerComponent =
    /**
     * @param {?} colResizingService
     */
    function IgxGridColumnResizerComponent(colResizingService) {
      _classCallCheck(this, IgxGridColumnResizerComponent);

      this.colResizingService = colResizingService;
    };

    IgxGridColumnResizerComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-column-resizer',
        template: "<div class=\"igx-grid__th-resize-line\"\n    [style.left.px]=\"-99999\" igxResizer\n    [style.height.px]=\"colResizingService.resizerHeight\"\n    [restrictHResizeMax]=\"colResizingService.restrictResizeMax\"\n    [restrictHResizeMin]=\"colResizingService.restrictResizeMin\"\n    (resizeEnd)=\"colResizingService.resizeColumn($event)\">\n</div>"
      }]
    }];
    /** @nocollapse */

    IgxGridColumnResizerComponent.ctorParameters = function () {
      return [{
        type: IgxColumnResizingService
      }];
    };

    IgxGridColumnResizerComponent.propDecorators = {
      resizer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxColumnResizerDirective, {
          "static": true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxGridFilteringRowComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} filteringService
       * @param {?} element
       * @param {?} cdr
       */
      function IgxGridFilteringRowComponent(filteringService, element, cdr) {
        _classCallCheck(this, IgxGridFilteringRowComponent);

        this.filteringService = filteringService;
        this.element = element;
        this.cdr = cdr;
        this._positionSettings = {
          horizontalStartPoint: HorizontalAlignment.Left,
          verticalStartPoint: VerticalAlignment.Bottom
        };
        this._conditionsOverlaySettings = {
          excludePositionTarget: true,
          closeOnOutsideClick: true,
          modal: false,
          scrollStrategy: new AbsoluteScrollStrategy(),
          positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this._operatorsOverlaySettings = {
          excludePositionTarget: true,
          closeOnOutsideClick: true,
          modal: false,
          scrollStrategy: new AbsoluteScrollStrategy(),
          positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this.chipAreaScrollOffset = 0;
        this._column = null;
        this.isKeyPressed = false;
        this.isComposing = false;
        this._cancelChipClick = false;
        this.cssClass = 'igx-grid__filtering-row';
      }
      /**
       * @return {?}
       */


      _createClass(IgxGridFilteringRowComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          this._conditionsOverlaySettings.outlet = this.column.grid.outletDirective;
          this._operatorsOverlaySettings.outlet = this.column.grid.outletDirective;
          /** @type {?} */

          var selectedItem = this.expressionsList.find(function (expr) {
            return expr.isSelected === true;
          });

          if (selectedItem) {
            this.expression = selectedItem.expression;
          }

          this.input.nativeElement.focus();
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onTabKeydown",
        value: function onTabKeydown(event) {
          event.stopPropagation();

          if (document.activeElement === this.closeButton.nativeElement && !event.shiftKey) {
            this.filteringService.grid.navigation.navigateFirstCellIfPossible(event);
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onEscKeydown",
        value: function onEscKeydown(event) {
          event.preventDefault();
          event.stopPropagation();
          this.close();
        }
        /**
         * @return {?}
         */

      }, {
        key: "onPrefixKeyDown",

        /**
         * Event handler for keydown on the input group's prefix.
         * @param {?} event
         * @return {?}
         */
        value: function onPrefixKeyDown(event) {
          if ((event.key === "Enter"
          /* ENTER */
          || event.key === " "
          /* SPACE */
          || event.key === "Spacebar"
          /* SPACE_IE */
          ) && this.dropDownConditions.collapsed) {
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            event.stopImmediatePropagation();
          } else if (event.key === "Tab"
          /* TAB */
          ) {
              if (event.shiftKey) {
                event.preventDefault();
                event.stopPropagation();
              } else if (!this.dropDownConditions.collapsed) {
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
              }
            }
        }
        /**
         * Event handler for keydown on the input.
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onInputKeyDown",
        value: function onInputKeyDown(event) {
          this.isKeyPressed = true;

          if (this.column.dataType === DataType.Boolean) {
            if (event.key === "Enter"
            /* ENTER */
            || event.key === " "
            /* SPACE */
            || event.key === "Spacebar"
            /* SPACE_IE */
            ) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                event.stopPropagation();
                return;
              }
          }

          if (event.key === "Enter"
          /* ENTER */
          ) {
              if (this.isComposing) {
                return;
              }

              this.commitInput();
            } else if (event.altKey && (event.key === "ArrowDown"
          /* DOWN_ARROW */
          || event.key === "Down"
          /* DOWN_ARROW_IE */
          )) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
          } else if (event.key === "Escape"
          /* ESCAPE */
          || event.key === "Esc"
          /* ESCAPE_IE */
          ) {
              event.preventDefault();
              this.close();
            }

          event.stopPropagation();
        }
        /**
         * Event handler for keyup on the input.
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onInputKeyUp",
        value: function onInputKeyUp(eventArgs) {
          this.isKeyPressed = false;
        }
        /**
         * Event handler for input on the input.
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onInput",
        value: function onInput(eventArgs) {
          // The 'iskeyPressed' flag is needed for a case in IE, because the input event is fired on focus and for some reason,
          // when you have a japanese character as a placeholder, on init the value here is empty string .
          if (isEdge() || this.isKeyPressed || eventArgs.target.value) {
            this.value = eventArgs.target.value;
          }
        }
        /**
         * Event handler for compositionstart on the input.
         * @return {?}
         */

      }, {
        key: "onCompositionStart",
        value: function onCompositionStart() {
          this.isComposing = true;
        }
        /**
         * Event handler for compositionend on the input.
         * @return {?}
         */

      }, {
        key: "onCompositionEnd",
        value: function onCompositionEnd() {
          this.isComposing = false;
        }
        /**
         * Event handler for input click event.
         * @return {?}
         */

      }, {
        key: "onInputClick",
        value: function onInputClick() {
          if (this.column.dataType === DataType.Boolean && this.dropDownConditions.collapsed) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
          }
        }
        /**
         * Event handler for datepicker's close.
         * @return {?}
         */

      }, {
        key: "datePickerClose",
        value: function datePickerClose() {
          this.input.nativeElement.focus();
        }
        /**
         * Returns the filtering operation condition for a given value.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "getCondition",
        value: function getCondition(value) {
          return this.column.filters.condition(value);
        }
        /**
         * Returns the translated condition name for a given value.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "translateCondition",
        value: function translateCondition(value) {
          return this.filteringService.grid.resourceStrings["igx_grid_filter_".concat(this.getCondition(value).name)] || value;
        }
        /**
         * Returns the icon name of the current condition.
         * @return {?}
         */

      }, {
        key: "getIconName",
        value: function getIconName() {
          if (this.column.dataType === DataType.Boolean && this.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
          } else {
            return this.expression.condition.iconName;
          }
        }
        /**
         * Returns whether a given condition is selected in dropdown.
         * @param {?} conditionName
         * @return {?}
         */

      }, {
        key: "isConditionSelected",
        value: function isConditionSelected(conditionName) {
          if (this.expression.condition) {
            return this.expression.condition.name === conditionName;
          } else {
            return false;
          }
        }
        /**
         * Clears the current filtering.
         * @return {?}
         */

      }, {
        key: "clearFiltering",
        value: function clearFiltering() {
          this.filteringService.clearFilter(this.column.field);
          this.resetExpression();

          if (this.input) {
            this.input.nativeElement.focus();
          }

          this.cdr.detectChanges();
          this.chipAreaScrollOffset = 0;
          this.transform(this.chipAreaScrollOffset);
        }
        /**
         * Commits the value of the input.
         * @return {?}
         */

      }, {
        key: "commitInput",
        value: function commitInput() {
          /** @type {?} */
          var selectedItem = this.expressionsList.filter(function (ex) {
            return ex.isSelected === true;
          });
          selectedItem.forEach(function (e) {
            return e.isSelected = false;
          });
          /** @type {?} */

          var indexToDeselect = -1;

          for (var index = 0; index < this.expressionsList.length; index++) {
            /** @type {?} */
            var expression = this.expressionsList[index].expression;

            if (expression.searchVal === null && !expression.condition.isUnary) {
              indexToDeselect = index;
            }
          }

          if (indexToDeselect !== -1) {
            this.removeExpression(indexToDeselect, this.expression);
          }

          this.resetExpression();
          this.scrollChipsWhenAddingExpression();
        }
        /**
         * Clears the value of the input.
         * @return {?}
         */

      }, {
        key: "clearInput",
        value: function clearInput() {
          this.value = null;
        }
        /**
         * Event handler for keydown on clear button.
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onClearKeyDown",
        value: function onClearKeyDown(eventArgs) {
          if (eventArgs.key === "Enter"
          /* ENTER */
          || eventArgs.key === " "
          /* SPACE */
          || eventArgs.key === "Spacebar"
          /* SPACE_IE */
          ) {
              eventArgs.preventDefault();
              this.clearInput();
              this.input.nativeElement.focus();
            }
        }
        /**
         * Event handler for click on clear button.
         * @return {?}
         */

      }, {
        key: "onClearClick",
        value: function onClearClick() {
          this.clearInput();
          this.input.nativeElement.focus();
        }
        /**
         * Event handler for keydown on commit button.
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onCommitKeyDown",
        value: function onCommitKeyDown(eventArgs) {
          if (eventArgs.key === "Enter"
          /* ENTER */
          || eventArgs.key === " "
          /* SPACE */
          || eventArgs.key === "Spacebar"
          /* SPACE_IE */
          ) {
              eventArgs.preventDefault();
              this.commitInput();
              this.input.nativeElement.focus();
            }
        }
        /**
         * Event handler for click on commit button.
         * @return {?}
         */

      }, {
        key: "onCommitClick",
        value: function onCommitClick() {
          this.commitInput();
          this.input.nativeElement.focus();
        }
        /**
         * Event handler for focusout on the input group.
         * @return {?}
         */

      }, {
        key: "onInputGroupFocusout",
        value: function onInputGroupFocusout() {
          var _this231 = this;

          if (!this.value && this.value !== 0 && this.expression.condition && !this.expression.condition.isUnary) {
            return;
          }

          requestAnimationFrame(function () {
            /** @type {?} */
            var focusedElement = document.activeElement;

            if (focusedElement.className === 'igx-chip__remove') {
              return;
            }

            if (!(focusedElement && _this231.inputGroup.nativeElement.contains(focusedElement)) && _this231.dropDownConditions.collapsed) {
              _this231.commitInput();
            }
          });
        }
        /**
         * Closes the filtering edit row.
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          var _this232 = this;

          if (this.expressionsList.length === 1 && this.expressionsList[0].expression.searchVal === null && this.expressionsList[0].expression.condition.isUnary === false) {
            this.filteringService.getExpressions(this.column.field).pop();
          } else {
            this.expressionsList.forEach(function (item) {
              if (item.expression.searchVal === null && !item.expression.condition.isUnary) {
                _this232.filteringService.removeExpression(_this232.column.field, _this232.expressionsList.indexOf(item));
              }
            });
          }

          this.filteringService.isFilterRowVisible = false;
          this.filteringService.updateFilteringCell(this.column);
          this.filteringService.focusFilterCellChip(this.column, true);
          this.filteringService.filteredColumn = null;
          this.filteringService.selectedExpression = null;
          this.chipAreaScrollOffset = 0;
          this.transform(this.chipAreaScrollOffset);
        }
        /*
            * noop
            */

        /**
         * @return {?}
         */

      }, {
        key: "noop",
        value: function noop() {}
        /**
         *  Event handler for date picker's selection.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "onDateSelected",
        value: function onDateSelected(value) {
          this.value = value;
          this.commitInput();
        }
        /**
         * Opens the conditions dropdown.
         * @param {?} target
         * @return {?}
         */

      }, {
        key: "toggleConditionsDropDown",
        value: function toggleConditionsDropDown(target) {
          this._conditionsOverlaySettings.positionStrategy.settings.target = target;
          this.dropDownConditions.toggle(this._conditionsOverlaySettings);
        }
        /**
         * Opens the logic operators dropdown.
         * @param {?} eventArgs
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "toggleOperatorsDropDown",
        value: function toggleOperatorsDropDown(eventArgs, index) {
          this._operatorsOverlaySettings.positionStrategy.settings.target = eventArgs.target.parentElement;
          this.dropDownOperators.toArray()[index].toggle(this._operatorsOverlaySettings);
        }
        /**
         * Event handler for change event in conditions dropdown.
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onConditionsChanged",
        value: function onConditionsChanged(eventArgs) {
          var _this233 = this;

          /** @type {?} */
          var value =
          /** @type {?} */
          eventArgs.newSelection.value;
          this.expression.condition = this.getCondition(value);

          if (this.expression.condition.isUnary) {
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(function () {
              return _this233.unaryConditionChangedCallback();
            });
          } else {
            requestAnimationFrame(function () {
              return _this233.conditionChangedCallback();
            });
          }

          if (this.input) {
            // Add requestAnimationFrame becasue of an issue in IE, where you are still able to write in the input,
            // if it has been focused and then set to readonly.
            requestAnimationFrame(function () {
              return _this233.input.nativeElement.focus();
            });
          }
        }
        /**
         * @param {?} args
         * @param {?} chip
         * @return {?}
         */

      }, {
        key: "onChipPointerdown",
        value: function onChipPointerdown(args, chip) {
          /** @type {?} */
          var activeElement = document.activeElement;
          this._cancelChipClick = chip.selected && activeElement && this.inputGroup.nativeElement.contains(activeElement);
        }
        /**
         * @param {?} args
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "onChipClick",
        value: function onChipClick(args, item) {
          if (this._cancelChipClick) {
            return;
          }

          this._cancelChipClick = false;
          this.expressionsList.forEach(function (ex) {
            return ex.isSelected = false;
          });
          this.toggleChip(item);
        }
        /**
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "toggleChip",
        value: function toggleChip(item) {
          item.isSelected = !item.isSelected;

          if (item.isSelected) {
            this.expression = item.expression;

            if (this.input) {
              this.input.nativeElement.focus();
            }
          }
        }
        /**
         * Event handler for chip keydown event.
         * @param {?} eventArgs
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "onChipKeyDown",
        value: function onChipKeyDown(eventArgs, item) {
          if (eventArgs.key === "Enter"
          /* ENTER */
          ) {
              eventArgs.preventDefault();
              this.toggleChip(item);
            }
        }
        /**
         * Scrolls the first chip into view if the tab key is pressed on the left arrow.
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onLeftArrowKeyDown",
        value: function onLeftArrowKeyDown(event) {
          if (event.key === "Tab"
          /* TAB */
          ) {
              this.chipAreaScrollOffset = 0;
              this.transform(this.chipAreaScrollOffset);
            }
        }
        /**
         * Event handler for chip removed event.
         * @param {?} eventArgs
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "onChipRemoved",
        value: function onChipRemoved(eventArgs, item) {
          /** @type {?} */
          var indexToRemove = this.expressionsList.indexOf(item);
          this.removeExpression(indexToRemove, item.expression);
          this.scrollChipsOnRemove();
        }
        /**
         * Event handler for logic operator changed event.
         * @param {?} eventArgs
         * @param {?} expression
         * @return {?}
         */

      }, {
        key: "onLogicOperatorChanged",
        value: function onLogicOperatorChanged(eventArgs, expression) {
          var _this234 = this;

          if (eventArgs.oldSelection) {
            expression.afterOperator =
            /** @type {?} */
            eventArgs.newSelection.value;
            this.expressionsList[this.expressionsList.indexOf(expression) + 1].beforeOperator = expression.afterOperator; // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times

            requestAnimationFrame(function () {
              return _this234.filter();
            });
          }
        }
        /**
         * Scrolls the chips into the chip area when left or right arrows are pressed.
         * @param {?} arrowPosition
         * @return {?}
         */

      }, {
        key: "scrollChipsOnArrowPress",
        value: function scrollChipsOnArrowPress(arrowPosition) {
          /** @type {?} */
          var count = 0;
          /** @type {?} */

          var chipAraeChildren = this.chipsArea.element.nativeElement.children;
          /** @type {?} */

          var containerRect = this.container.nativeElement.getBoundingClientRect();

          if (arrowPosition === 'right') {
            for (var index = 0; index < chipAraeChildren.length; index++) {
              if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.right)) {
                count++;
              }
            }

            if (count < chipAraeChildren.length) {
              this.chipAreaScrollOffset -= Math.ceil(chipAraeChildren[count].getBoundingClientRect().right) - Math.ceil(containerRect.right) + 1;
              this.transform(this.chipAreaScrollOffset);
            }
          }

          if (arrowPosition === 'left') {
            for (var _index = 0; _index < chipAraeChildren.length; _index++) {
              if (Math.ceil(chipAraeChildren[_index].getBoundingClientRect().left) < Math.ceil(containerRect.left)) {
                count++;
              }
            }

            if (count > 0) {
              this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[count - 1].getBoundingClientRect().left) + 1;
              this.transform(this.chipAreaScrollOffset);
            }
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "showHideArrowButtons",
        value: function showHideArrowButtons() {
          var _this235 = this;

          requestAnimationFrame(function () {
            if (_this235.filteringService.isFilterRowVisible) {
              /** @type {?} */
              var containerWidth = _this235.container.nativeElement.getBoundingClientRect().width;

              _this235.chipsAreaWidth = _this235.chipsArea.element.nativeElement.getBoundingClientRect().width;
              _this235.showArrows = _this235.chipsAreaWidth >= containerWidth && _this235.isColumnFiltered; // TODO: revise the cdr.detectChanges() usage here

              if (!
              /** @type {?} */
              _this235.cdr.destroyed) {
                _this235.cdr.detectChanges();
              }
            }
          });
        }
        /**
         * @private
         * @param {?} isSelected
         * @return {?}
         */

      }, {
        key: "addExpression",
        value: function addExpression(isSelected) {
          /** @type {?} */
          var exprUI = new ExpressionUI();
          exprUI.expression = this.expression;
          exprUI.beforeOperator = this.expressionsList.length > 0 ? FilteringLogic.And : null;
          exprUI.isSelected = isSelected;
          this.expressionsList.push(exprUI);
          /** @type {?} */

          var length = this.expressionsList.length;

          if (this.expressionsList[length - 2]) {
            this.expressionsList[length - 2].afterOperator = this.expressionsList[length - 1].beforeOperator;
          }

          this.showHideArrowButtons();
        }
        /**
         * @private
         * @param {?} indexToRemove
         * @param {?} expression
         * @return {?}
         */

      }, {
        key: "removeExpression",
        value: function removeExpression(indexToRemove, expression) {
          if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
          }

          this.filteringService.removeExpression(this.column.field, indexToRemove);
          this.filter();

          if (this.expression === expression) {
            this.resetExpression();
          }

          this.showHideArrowButtons();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "resetExpression",
        value: function resetExpression() {
          this.expression = {
            fieldName: this.column.field,
            condition: null,
            searchVal: null,
            ignoreCase: this.column.filteringIgnoreCase
          };

          if (this.column.dataType !== DataType.Boolean) {
            this.expression.condition = this.getCondition(this.conditions[0]);
          }

          if (this.column.dataType === DataType.Date && this.input) {
            this.input.nativeElement.value = null;
          }

          this.showHideArrowButtons();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "scrollChipsWhenAddingExpression",
        value: function scrollChipsWhenAddingExpression() {
          /** @type {?} */
          var chipAraeChildren = this.chipsArea.element.nativeElement.children;

          if (!chipAraeChildren || chipAraeChildren.length === 0) {
            return;
          }
          /** @type {?} */


          var containerRectRight = Math.ceil(this.container.nativeElement.getBoundingClientRect().right);
          /** @type {?} */

          var lastChipRectRight = Math.ceil(chipAraeChildren[chipAraeChildren.length - 1].getBoundingClientRect().right);

          if (lastChipRectRight >= containerRectRight) {
            this.chipAreaScrollOffset -= lastChipRectRight - containerRectRight;
            this.transform(this.chipAreaScrollOffset);
          }
        }
        /**
         * @hidden
         * Resets the chips area
         * \@memberof IgxGridFilteringRowComponent
         * @return {?}
         */

      }, {
        key: "resetChipsArea",
        value: function resetChipsArea() {
          this.chipAreaScrollOffset = 0;
          this.transform(this.chipAreaScrollOffset);
          this.showHideArrowButtons();
        }
        /**
         * @private
         * @param {?} offset
         * @return {?}
         */

      }, {
        key: "transform",
        value: function transform(offset) {
          var _this236 = this;

          requestAnimationFrame(function () {
            _this236.chipsArea.element.nativeElement.style.transform = "translate(".concat(offset, "px)");
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "scrollChipsOnRemove",
        value: function scrollChipsOnRemove() {
          /** @type {?} */
          var count = 0;
          /** @type {?} */

          var chipAraeChildren = this.chipsArea.element.nativeElement.children;
          /** @type {?} */

          var containerRect = this.container.nativeElement.getBoundingClientRect();

          for (var index = 0; index < chipAraeChildren.length; index++) {
            if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.left)) {
              count++;
            }
          }

          if (count <= 2) {
            this.chipAreaScrollOffset = 0;
          } else {
            /** @type {?} */
            var dif = chipAraeChildren[count].id === 'chip' ? count - 2 : count - 1;
            this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[dif].getBoundingClientRect().left) + 1;
          }

          this.transform(this.chipAreaScrollOffset);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "conditionChangedCallback",
        value: function conditionChangedCallback() {
          if (!!this.expression.searchVal || this.expression.searchVal === 0) {
            this.filter();
          } else if (this.value) {
            this.value = null;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "unaryConditionChangedCallback",
        value: function unaryConditionChangedCallback() {
          var _this237 = this;

          if (this.value) {
            this.value = null;
          }

          if (this.expressionsList.find(function (item) {
            return item.expression === _this237.expression;
          }) === undefined) {
            this.addExpression(true);
          }

          this.filter();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "filter",
        value: function filter() {
          this.filteringService.filterInternal(this.column.field);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "column",
        get: function get() {
          return this._column;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (this._column) {
            this.expressionsList.forEach(function (exp) {
              return exp.isSelected = false;
            });
          }

          if (val) {
            this._column = val;
            this.expressionsList = this.filteringService.getExpressions(this._column.field);
            this.resetExpression();
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this.expression ? this.expression.searchVal : null;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          var _this238 = this;

          if (!val && val !== 0) {
            this.expression.searchVal = null;
            this.showHideArrowButtons();
          } else {
            this.expression.searchVal = DataUtil.parseValue(this.column.dataType, val);

            if (this.expressionsList.find(function (item) {
              return item.expression === _this238.expression;
            }) === undefined) {
              this.addExpression(true);
            }
          }

          this.filter();
        }
      }, {
        key: "disabled",
        get: function get() {
          return !(this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0);
        }
        /**
         * @return {?}
         */

      }, {
        key: "template",
        get: function get() {
          if (this.column.dataType === DataType.Date) {
            return this.defaultDateUI;
          }

          return this.defaultFilterUI;
        }
        /**
         * @return {?}
         */

      }, {
        key: "type",
        get: function get() {
          switch (this.column.dataType) {
            case DataType.String:
            case DataType.Boolean:
              return 'text';

            case DataType.Number:
              return 'number';
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "conditions",
        get: function get() {
          return this.column.filters.conditionList();
        }
        /**
         * @return {?}
         */

      }, {
        key: "isUnaryCondition",
        get: function get() {
          if (this.expression.condition) {
            return this.expression.condition.isUnary;
          } else {
            return true;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "placeholder",
        get: function get() {
          if (this.expression.condition && this.expression.condition.isUnary) {
            return this.filteringService.getChipLabel(this.expression);
          } else if (this.column.dataType === DataType.Date) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_date_placeholder;
          } else if (this.column.dataType === DataType.Boolean) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_boolean_placeholder;
          } else {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_placeholder;
          }
        }
      }, {
        key: "isColumnFiltered",
        get: function get() {
          return this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0;
        }
      }]);

      return IgxGridFilteringRowComponent;
    }();

    IgxGridFilteringRowComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-filtering-row',
        template: "<!-- Have to apply styles inline because of the overlay outlet ... -->\n<igx-drop-down #inputGroupConditions [height]=\"'200px'\" (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item\n        *ngFor=\"let condition of conditions\"\n        [value]=\"condition\"\n        [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<ng-template #defaultFilterUI>\n    <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\" (focusout)=\"onInputGroupFocusout()\">\n        <igx-prefix #inputGroupPrefix\n                    (click)=\"toggleConditionsDropDown(inputGroupPrefix)\"\n                    (keydown)=\"onPrefixKeyDown($event)\"\n                    tabindex=\"0\"\n                    [igxDropDownItemNavigation]=\"inputGroupConditions\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        </igx-prefix>\n        <input\n            #input\n            igxInput\n            tabindex=\"0\"\n            [placeholder]=\"placeholder\"\n            autocomplete=\"off\"\n            [value]=\"value\"\n            (input)=\"onInput($event)\"\n            [type]=\"type\"\n            [readonly]=\"isUnaryCondition\"\n            (click)=\"onInputClick()\"\n            (compositionstart)=\"onCompositionStart()\"\n            (compositionend)=\"onCompositionEnd()\"\n            (keydown)=\"onInputKeyDown($event)\"\n            (keyup)=\"onInputKeyUp($event)\"/>\n            <igx-suffix *ngIf=\"value || value === 0\" >\n                <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"onClearClick()\" tabindex=\"0\">clear</igx-icon>\n            </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-template #defaultDateUI>\n    <igx-date-picker\n        tabindex=\"0\"\n        mode=\"dropdown\"\n        [value]=\"value\"\n        [outlet]=\"filteringService.grid.outletDirective\"\n        [locale]=\"filteringService.grid.locale\"\n        (onSelection)=\"onDateSelected($event)\"\n        (onClose)=\"datePickerClose()\">\n        <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\">\n            <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\" (focusout)=\"onInputGroupFocusout()\">\n                <igx-prefix #inputGroupPrefix\n                            tabindex=\"0\"\n                            (click)=\"toggleConditionsDropDown(inputGroupPrefix)\"\n                            (keydown)=\"onPrefixKeyDown($event)\"\n                            [igxDropDownItemNavigation]=\"inputGroupConditions\">\n                    <igx-icon fontSet=\"filtering-icons\" [name]=\"expression.condition.iconName\"></igx-icon>\n                </igx-prefix>\n                <input #input\n                       igxInput\n                       tabindex=\"0\"\n                       (click)=\"expression.condition.isUnary ? noop() : openDialog(inputGroup.element.nativeElement)\"\n                       [placeholder]=\"placeholder\"\n                       autocomplete=\"off\"\n                       [value]=\"value | igxdate: filteringService.grid.locale\"\n                       [readonly]=\"true\"\n                       (keydown)=\"onInputKeyDown($event)\"/>\n                <igx-suffix *ngIf=\"value\" (keydown)=\"onClearKeyDown($event)\" (click)=\"clearInput()\" tabindex=\"0\">\n                    <igx-icon>clear</igx-icon>\n                </igx-suffix>\n            </igx-input-group>\n            </ng-template>\n    </igx-date-picker>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-start\" *ngIf=\"showArrows\" (keydown)=\"onLeftArrowKeyDown($event)\" (click)=\"scrollChipsOnArrowPress('left')\">\n    <igx-icon>navigate_before</igx-icon>\n</button>\n\n<div #container class=\"igx-grid__filtering-row-main\">\n    <div>\n         <igx-chips-area #chipsArea>\n            <ng-container *ngFor=\"let item of expressionsList; index as i; let last = last;\" tabindex=\"0\">\n                <igx-chip #chip id='chip'\n                    (pointerdown)=\"onChipPointerdown($event, chip)\"\n                    (click)=\"onChipClick($event, item)\"\n                    (keydown)=\"onChipKeyDown($event, item)\"\n                    (onRemove)=\"onChipRemoved($event, item)\"\n                    [selectable]=\"false\"\n                    [selected]=\"item.isSelected\"\n                    [displayDensity]=\"'cosy'\"\n                    [removable]=\"true\">\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"filtering-icons\"\n                        [name]=\"item.expression.condition.iconName\">\n                    </igx-icon>\n                    <span>{{filteringService.getChipLabel(item.expression)}}</span>\n                </igx-chip>\n\n                <span id='operand' *ngIf=\"!last\">\n                    <button igxButton (click)=\"toggleOperatorsDropDown($event, i)\" [igxDropDownItemNavigation]=\"operators\">\n                        <igx-icon>expand_more</igx-icon>\n                        <span>{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n                    </button>\n                    <igx-drop-down #operators (onSelection)=\"onLogicOperatorChanged($event, item)\">\n                            <igx-drop-down-item [value]=\"0\" [selected]=\"item.afterOperator === 0\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_and}}</igx-drop-down-item>\n                            <igx-drop-down-item [value]=\"1\" [selected]=\"item.afterOperator === 1\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_or}}</igx-drop-down-item>\n                    </igx-drop-down>\n                </span>\n            </ng-container>\n        </igx-chips-area>\n    </div>\n</div>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-end\" *ngIf=\"showArrows\" (click)=\"scrollChipsOnArrowPress('right')\">\n    <igx-icon>navigate_next</igx-icon>\n</button>\n\n<div #buttonsContainer class=\"igx-grid__filtering-row-editing-buttons\">\n    <button igxButton igxRipple (click)=\"clearFiltering()\" [disabled]=\"disabled\" [tabindex]=\"disabled\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_reset}}</button>\n    <button #closeButton igxButton igxRipple (click)=\"close()\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_close}}</button>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxGridFilteringRowComponent.ctorParameters = function () {
      return [{
        type: IgxFilteringService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxGridFilteringRowComponent.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      defaultFilterUI: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultFilterUI', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultDateUI: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultDateUI', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      input: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['input', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      dropDownConditions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['inputGroupConditions', {
          read: IgxDropDownComponent,
          "static": true
        }]
      }],
      chipsArea: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['chipsArea', {
          read: IgxChipsAreaComponent,
          "static": true
        }]
      }],
      dropDownOperators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: ['operators', {
          read: IgxDropDownComponent
        }]
      }],
      inputGroup: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['inputGroup', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      inputGroupPrefix: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['inputGroupPrefix', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      container: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['container', {
          "static": true
        }]
      }],
      operand: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['operand', {
          "static": false
        }]
      }],
      closeButton: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['closeButton', {
          "static": true
        }]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__filtering-row']
      }],
      onTabKeydown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.shift.tab', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.tab', ['$event']]
      }],
      onEscKeydown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.esc', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxSelectItemComponent =
    /*#__PURE__*/
    function (_IgxDropDownItemCompo2) {
      _inherits(IgxSelectItemComponent, _IgxDropDownItemCompo2);

      function IgxSelectItemComponent() {
        _classCallCheck(this, IgxSelectItemComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxSelectItemComponent).apply(this, arguments));
      }

      _createClass(IgxSelectItemComponent, [{
        key: "ngDoCheck",

        /**
         * @return {?}
         */
        value: function ngDoCheck() {}
      }, {
        key: "text",

        /**
         * An \@Input property that gets/sets the item's text to be displayed in the select component's input when the item is selected.
         *
         * ```typescript
         *  //get
         *  let mySelectedItem = this.dropDown.selectedItem;
         *  let selectedItemText = mySelectedItem.text;
         * ```
         * ```html
         * // set
         * <igx-select-item [text]="'London'"></igx-select-item>
         * ```
         * @return {?}
         */
        get: function get() {
          return this._text;
        }
        /**
         * @param {?} text
         * @return {?}
         */
        ,
        set: function set(text) {
          this._text = text;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "itemText",
        get: function get() {
          if (this._text !== undefined) {
            return this._text;
          } // If text @Input is undefined, try extract a meaningful item text out of the item template


          return this.elementRef.nativeElement.textContent.trim();
        }
        /**
         * Sets/Gets if the item is the currently selected one in the select
         *
         * ```typescript
         *  let mySelectedItem = this.select.selectedItem;
         *  let isMyItemSelected = mySelectedItem.selected; // true
         * ```
         * @return {?}
         */

      }, {
        key: "selected",
        get: function get() {
          return !this.isHeader && !this.disabled && this.selection.is_item_selected(this.dropDown.id, this);
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value && !this.isHeader && !this.disabled) {
            this.dropDown.selectItem(this);
          }
        }
      }]);

      return IgxSelectItemComponent;
    }(IgxDropDownItemComponent);

    IgxSelectItemComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-select-item',
        template: '<ng-content></ng-content>'
      }]
    }];
    IgxSelectItemComponent.propDecorators = {
      text: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */

    var Direction$2 = {
      Top: -1,
      Bottom: 1,
      None: 0
    };
    Direction$2[Direction$2.Top] = 'Top';
    Direction$2[Direction$2.Bottom] = 'Bottom';
    Direction$2[Direction$2.None] = 'None';
    /**
     * @hidden \@internal
     */

    var SelectPositioningStrategy =
    /*#__PURE__*/
    function (_ConnectedPositioning3) {
      _inherits(SelectPositioningStrategy, _ConnectedPositioning3);

      /**
       * @param {?} select
       * @param {?=} settings
       */
      function SelectPositioningStrategy(select, settings) {
        var _this239;

        _classCallCheck(this, SelectPositioningStrategy);

        _this239 = _possibleConstructorReturn(this, _getPrototypeOf(SelectPositioningStrategy).call(this));
        _this239.select = select;
        _this239._selectDefaultSettings = {
          target: null,
          horizontalDirection: HorizontalAlignment.Right,
          verticalDirection: VerticalAlignment.Bottom,
          horizontalStartPoint: HorizontalAlignment.Left,
          verticalStartPoint: VerticalAlignment.Top,
          openAnimation: fadeIn,
          closeAnimation: fadeOut
        };
        _this239.defaultWindowToListOffset = 5;
        _this239.viewPort = Util.getViewportRect(document);
        _this239.settings = Object.assign({}, _this239._selectDefaultSettings, settings);
        return _this239;
      }
      /**
       * @private
       * @param {?} contentElement
       * @param {?} outBoundsAmount
       * @return {?}
       */


      _createClass(SelectPositioningStrategy, [{
        key: "positionAndScrollBottom",
        value: function positionAndScrollBottom(contentElement, outBoundsAmount) {
          contentElement.style.top = "".concat(this.viewPort.bottom - this.listContainerBoundRect.height - this.defaultWindowToListOffset, "px");
          contentElement.firstElementChild.scrollTop -= outBoundsAmount - this.defaultWindowToListOffset;
          this.deltaY = this.viewPort.bottom - this.listContainerBoundRect.height - this.defaultWindowToListOffset -
          /** @type {?} */
          this.select.input.nativeElement.getBoundingClientRect().top;
        }
        /**
         * @private
         * @param {?} contentElement
         * @param {?} CURRENT_POSITION_Y
         * @return {?}
         */

      }, {
        key: "positionNoScroll",
        value: function positionNoScroll(contentElement, CURRENT_POSITION_Y) {
          contentElement.style.top = "".concat(CURRENT_POSITION_Y - this.itemTextToInputTextDiff, "px");
          this.deltaY = CURRENT_POSITION_Y -
          /** @type {?} */
          this.select.input.nativeElement.getBoundingClientRect().top - this.itemTextToInputTextDiff;
        }
        /**
         * @private
         * @param {?} contentElement
         * @param {?} outBoundsAmount
         * @return {?}
         */

      }, {
        key: "positionAndScrollTop",
        value: function positionAndScrollTop(contentElement, outBoundsAmount) {
          contentElement.style.top = "".concat(this.viewPort.top + this.defaultWindowToListOffset, "px");
          contentElement.firstElementChild.scrollTop += outBoundsAmount + this.itemTextToInputTextDiff + this.defaultWindowToListOffset;
          this.deltaY = this.viewPort.top + this.defaultWindowToListOffset -
          /** @type {?} */
          this.select.input.nativeElement.getBoundingClientRect().top;
        }
        /**
         * @private
         * @param {?} contentElement
         * @param {?} itemHeight
         * @return {?}
         */

      }, {
        key: "getItemsOutOfView",
        value: function getItemsOutOfView(contentElement, itemHeight) {
          if (contentElement.firstElementChild.scrollHeight <= contentElement.firstElementChild.clientHeight) {
            return {
              'currentScroll': 0,
              'remainingScroll': 0
            };
          }
          /** @type {?} */


          var currentScroll = contentElement.firstElementChild.scrollTop;
          /** @type {?} */

          var remainingScroll = this.select.items.length * itemHeight - currentScroll - this.listContainerBoundRect.height;
          return {
            'currentScroll': currentScroll,
            'remainingScroll': remainingScroll
          };
        }
        /**
         * @private
         * @param {?} elementContainer
         * @param {?} document
         * @return {?}
         */

      }, {
        key: "listOutOfBounds",
        value: function listOutOfBounds(elementContainer, document) {
          /** @type {?} */
          var container = {
            TOP: elementContainer.top,
            BOTTOM: elementContainer.bottom
          };
          /** @type {?} */

          var viewPort = Util.getViewportRect(document);
          /** @type {?} */

          var documentElement = {
            TOP: viewPort.top,
            BOTTOM: viewPort.bottom
          };
          /** @type {?} */

          var returnVals = {
            Direction: Direction$2.None,
            Amount: 0
          };

          if (documentElement.TOP + this.defaultWindowToListOffset > container.TOP) {
            returnVals.Direction = Direction$2.Top;
            returnVals.Amount = documentElement.TOP - container.TOP;
          } else if (documentElement.BOTTOM - this.defaultWindowToListOffset < container.BOTTOM) {
            returnVals.Direction = Direction$2.Bottom;
            returnVals.Amount = container.BOTTOM - documentElement.BOTTOM;
          } else {
            return null;
          }

          return returnVals;
        }
        /**
         * @param {?} contentElement
         * @param {?} size
         * @param {?=} document
         * @param {?=} initialCall
         * @return {?}
         */

      }, {
        key: "position",
        value: function position(contentElement, size, document, initialCall) {
          /** @type {?} */
          var inputElement = this.select.input.nativeElement;
          /** @type {?} */

          var inputRect =
          /** @type {?} */
          inputElement.getBoundingClientRect();
          this.listContainerBoundRect =
          /** @type {?} */
          contentElement.getBoundingClientRect();
          /** @type {?} */

          var LIST_HEIGHT = this.listContainerBoundRect.height;

          if (!initialCall) {
            this.deltaX = inputRect.left - this.itemTextPadding - this.itemTextIndent;
            /** @type {?} */

            var point = new Point(this.deltaX, inputRect.top + this.deltaY);
            this.settings.target = point;

            _get(_getPrototypeOf(SelectPositioningStrategy.prototype), "position", this).call(this, contentElement, size);

            return;
          }
          /** @type {?} */


          var START = {
            X: inputRect.left,
            Y: inputRect.top
          };
          /** @type {?} */

          var itemElement;

          if (this.select.selectedItem) {
            itemElement = this.select.selectedItem.element.nativeElement; // D.P. Feb 22 2019, #3921 Force item scroll before measuring in IE11, due to base scrollToItem delay

            if (isIE()) {
              contentElement.firstElementChild.scrollTop = this.select.calculateScrollPosition(this.select.selectedItem);
            }
          } else {
            itemElement = this.select.getFirstItemElement();
          }
          /** @type {?} */


          var inputHeight = inputRect.height;
          /** @type {?} */

          var itemBoundRect =
          /** @type {?} */
          itemElement.getBoundingClientRect();
          /** @type {?} */

          var itemTopListOffset = itemBoundRect.top - this.listContainerBoundRect.top;
          /** @type {?} */

          var itemHeight = itemBoundRect.height;
          /** @type {?} */

          var inputFontSize = window.getComputedStyle(inputElement).fontSize;
          /** @type {?} */

          var numericInputFontSize = parseInt(inputFontSize.slice(0, inputFontSize.indexOf('p')), 10) || 0;
          /** @type {?} */

          var itemFontSize = window.getComputedStyle(itemElement).fontSize;
          /** @type {?} */

          var numericItemFontSize = parseInt(itemFontSize.slice(0, itemFontSize.indexOf('p')), 10) || 0;
          /** @type {?} */

          var inputTextToInputTop = (inputHeight - numericInputFontSize) / 2;
          /** @type {?} */

          var itemTextToItemTop = (itemHeight - numericItemFontSize) / 2;
          this.itemTextToInputTextDiff = itemTextToItemTop - inputTextToInputTop;
          /** @type {?} */

          var CURRENT_POSITION_Y = START.Y - itemTopListOffset;
          /** @type {?} */

          var CURRENT_BOTTOM_Y = CURRENT_POSITION_Y + this.listContainerBoundRect.height;
          /** @type {?} */

          var OUT_OF_BOUNDS = this.listOutOfBounds({
            top: CURRENT_POSITION_Y,
            bottom: CURRENT_BOTTOM_Y
          }, document);

          if (OUT_OF_BOUNDS) {
            if (OUT_OF_BOUNDS.Direction === Direction$2.Top) {
              CURRENT_POSITION_Y = START.Y;
            } else {
              CURRENT_POSITION_Y = -1 * (LIST_HEIGHT - (itemHeight - (itemHeight - inputHeight) / 2));
              CURRENT_POSITION_Y += START.Y;
            }
          }
          /** @type {?} */


          var selectItemPaddingHorizontal = 24;
          /** @type {?} */

          var itemLeftPadding = window.getComputedStyle(itemElement).paddingLeft;
          /** @type {?} */

          var itemTextIndent = window.getComputedStyle(itemElement).textIndent;
          /** @type {?} */

          var numericLeftPadding = parseInt(itemLeftPadding.slice(0, itemLeftPadding.indexOf('p')), 10) || 0;
          /** @type {?} */

          var numericTextIndent = parseInt(itemTextIndent.slice(0, itemTextIndent.indexOf('r')), 10) || 0;
          this.itemTextPadding = numericLeftPadding;
          this.itemTextIndent = numericTextIndent;
          contentElement.style.left += "".concat(START.X - numericLeftPadding - numericTextIndent, "px");
          contentElement.style.width = inputRect.width + 24 + selectItemPaddingHorizontal * 2 + 'px';
          this.deltaX = START.X - numericLeftPadding - numericTextIndent;
          /** @type {?} */

          var currentScroll = this.getItemsOutOfView(contentElement, itemHeight)['currentScroll'];
          /** @type {?} */

          var remainingScroll = this.getItemsOutOfView(contentElement, itemHeight)['remainingScroll']; // (5 items or less) no scroll and respectively no remaining scroll

          if (remainingScroll === 0 && currentScroll === 0) {
            this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
          } // (more than 5 items) there is scroll OR remaining scroll


          if (remainingScroll !== 0 || currentScroll !== 0) {
            if (remainingScroll !== 0 && !OUT_OF_BOUNDS) {
              this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
            } // (more than 5 items) and container getting out of the visible port


            if (remainingScroll !== 0 && OUT_OF_BOUNDS) {
              // if there is enough remaining scroll to scroll the item
              if (remainingScroll > itemHeight) {
                if (OUT_OF_BOUNDS.Direction === Direction$2.Top) {
                  this.positionAndScrollTop(contentElement, OUT_OF_BOUNDS.Amount);
                  return;
                }

                if (OUT_OF_BOUNDS.Direction === Direction$2.Bottom) {
                  // (more than 5 items) and no current scroll
                  if (currentScroll === 0) {
                    this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
                    return; // (more than 5 items) and current scroll
                  } else {
                    this.positionAndScrollBottom(contentElement, OUT_OF_BOUNDS.Amount);
                    return;
                  }
                }
              } // if there is no enough remaining scroll to scroll the item


              if (remainingScroll < itemHeight) {
                if (OUT_OF_BOUNDS.Direction === Direction$2.Top) {
                  this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
                }

                if (OUT_OF_BOUNDS.Direction === Direction$2.Bottom) {
                  this.positionAndScrollBottom(contentElement, OUT_OF_BOUNDS.Amount);
                }
              }
            } // (more than 5 items) and no remaining scroll


            if (remainingScroll === 0 && currentScroll !== 0) {
              if (OUT_OF_BOUNDS) {
                if (OUT_OF_BOUNDS.Direction === Direction$2.Bottom) {
                  this.positionAndScrollBottom(contentElement, OUT_OF_BOUNDS.Amount);
                  return;
                }
              }

              this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
            }
          }
        }
      }]);

      return SelectPositioningStrategy;
    }(ConnectedPositioningStrategy);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden \@internal
     */


    var IgxSelectToggleIconDirective = function IgxSelectToggleIconDirective() {
      _classCallCheck(this, IgxSelectToggleIconDirective);
    };

    IgxSelectToggleIconDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxSelectToggleIcon]'
      }]
    }];
    /** @type {?} */

    var noop$5 = function noop$5() {};
    /**
     * **Ignite UI for Angular Select** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/select.html)
     *
     * The `igxSelect` provides an input with dropdown list allowing selection of a single item.
     *
     * Example:
     * ```html
     * <igx-select #select1 [placeholder]="'Pick One'">
     *   <label igxLabel>Select Label</label>
     *   <igx-select-item *ngFor="let item of items" [value]="item.field">
     *     {{ item.field }}
     *   </igx-select-item>
     * </igx-select>
     * ```
     */


    var IgxSelectComponent =
    /*#__PURE__*/
    function (_IgxDropDownComponent2) {
      _inherits(IgxSelectComponent, _IgxDropDownComponent2);

      /**
       * @param {?} elementRef
       * @param {?} cdr
       * @param {?} selection
       * @param {?} _displayDensityOptions
       * @param {?} _injector
       */
      function IgxSelectComponent(elementRef, cdr, selection, _displayDensityOptions, _injector) {
        var _this240;

        _classCallCheck(this, IgxSelectComponent);

        _this240 = _possibleConstructorReturn(this, _getPrototypeOf(IgxSelectComponent).call(this, elementRef, cdr, selection, _displayDensityOptions));
        _this240.elementRef = elementRef;
        _this240.cdr = cdr;
        _this240.selection = selection;
        _this240._displayDensityOptions = _displayDensityOptions;
        _this240._injector = _injector;
        _this240.ngControl = null;
        /**
         * @hidden \@internal do not use the drop-down container class
         */

        _this240.cssClass = false;
        /**
         * @hidden \@internal
         */

        _this240.allowItemsFocus = false;
        /**
         * An \@Input property that disables the `IgxSelectComponent`.
         * ```html
         * <igx-select [disabled]="'true'"></igx-select>
         * ```
         */

        _this240.disabled = false;
        /**
         * @hidden \@internal
         */

        _this240.maxHeight = '256px';
        /**
         * An \@Input property that sets how the select will be styled.
         * The allowed values are `line`, `box` and `border`. The default is `line`.
         * ```html
         * <igx-select [type]="'box'"></igx-select>
         * ```
         */

        _this240.type = 'line';
        /**
         * The custom template, if any, that should be used when rendering the select TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-select>
         * ```
         */

        _this240.toggleIconTemplate = null; //#region ControlValueAccessor

        /**
         * @hidden \@internal
         */

        _this240._onChangeCallback = noop$5;
        /**
         * @hidden \@internal
         */

        _this240._onTouchedCallback = noop$5;
        /**
         * @hidden \@internal
         */

        _this240.writeValue = function (value) {
          _this240.value = value;
        };

        return _this240;
      }
      /**
       * An \@Input property that gets/sets the component value.
       *
       * ```typescript
       * // get
       * let selectValue = this.select.value;
       * ```
       *
       * ```typescript
       * // set
       * this.select.value = 'London';
       * ```
       * ```html
       * <igx-select [value]="value"></igx-select>
       * ```
       * @return {?}
       */


      _createClass(IgxSelectComponent, [{
        key: "registerOnChange",

        /**
         * @hidden \@internal
         * @param {?} fn
         * @return {?}
         */
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden \@internal
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
        /**
         * @hidden \@internal
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        } //#endregion

        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "getEditElement",
        value: function getEditElement() {
          return this.input.nativeElement;
        }
        /**
         * @hidden \@internal
         * @param {?} newSelection
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "selectItem",
        value: function selectItem(newSelection, event) {
          /** @type {?} */
          var oldSelection = this.selectedItem;

          if (event) {
            this.toggleDirective.close();
          }

          if (newSelection === null || newSelection === oldSelection || newSelection.disabled || newSelection.isHeader) {
            return;
          }
          /** @type {?} */


          var args = {
            oldSelection: oldSelection,
            newSelection: newSelection,
            cancel: false
          };
          this.onSelection.emit(args);

          if (args.cancel) {
            return;
          }

          this.setSelection(newSelection);
          this._value = newSelection.value;
          this.cdr.detectChanges();

          this._onChangeCallback(this.value);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "getFirstItemElement",
        value: function getFirstItemElement() {
          return this.children.first.element.nativeElement;
        }
        /**
         * Opens the select
         *
         * ```typescript
         * this.select.open();
         * ```
         * @param {?=} overlaySettings
         * @return {?}
         */

      }, {
        key: "open",
        value: function open(overlaySettings) {
          if (this.disabled || this.items.length === 0) {
            return;
          }

          if (!this.selectedItem) {
            this.navigateFirst();
          }

          _get(_getPrototypeOf(IgxSelectComponent.prototype), "open", this).call(this, Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this241 = this;

          this._overlayDefaults = {
            modal: false,
            closeOnOutsideClick: false,
            positionStrategy: new SelectPositioningStrategy(this, {
              target: this.inputGroup.element.nativeElement
            }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            excludePositionTarget: true
          };
          this.children.changes.subscribe(function () {
            _this241.setSelection(_this241.items.find(function (x) {
              return x.value === _this241.value;
            }));

            _this241.cdr.detectChanges();
          });
          Promise.resolve().then(function () {
            return _this241.children.notifyOnChanges();
          });
        }
        /**
         * @hidden \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onToggleOpening",
        value: function onToggleOpening(event) {
          this.onOpening.emit(event);

          if (event.cancel) {
            return;
          }

          this.scrollToItem(this.selectedItem);
        }
        /**
         * @protected
         * @param {?} direction
         * @param {?=} currentIndex
         * @return {?}
         */

      }, {
        key: "navigate",
        value: function navigate(direction, currentIndex) {
          if (this.collapsed && this.selectedItem) {
            this.navigateItem(this.selectedItem.itemIndex);
          }

          _get(_getPrototypeOf(IgxSelectComponent.prototype), "navigate", this).call(this, direction, currentIndex);
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "manageRequiredAsterisk",
        value: function manageRequiredAsterisk() {
          if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.

            /** @type {?} */
            var error = this.ngControl.control.validator(
            /** @type {?} */
            {});
            this.inputGroup.isRequired = error && error.required;
            this.cdr.markForCheck();
          }
        }
        /**
         * @private
         * @param {?} item
         * @return {?}
         */

      }, {
        key: "setSelection",
        value: function setSelection(item) {
          if (item && item.value !== undefined && item.value !== null) {
            this.selection.set(this.id, new Set([item]));
          } else {
            this.selection.clear(this.id);
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur() {
          this._onTouchedCallback();

          if (this.ngControl && !this.ngControl.valid) {
            this.input.valid = IgxInputState.INVALID;
          } else {
            this.input.valid = IgxInputState.INITIAL;
          }

          if (!this.collapsed) {
            this.toggleDirective.close();
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus() {
          this._onTouchedCallback();
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "onStatusChanged",
        value: function onStatusChanged() {
          if ((this.ngControl.control.touched || this.ngControl.control.dirty) && (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
            if (this.inputGroup.isFocused) {
              this.input.valid = this.ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            } else {
              this.input.valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
          }

          this.manageRequiredAsterisk();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this.ngControl = this._injector.get(
          /** @type {?} */
          _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NgControl"], null);
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          if (this.ngControl) {
            this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            this.manageRequiredAsterisk();
          }

          this.cdr.detectChanges();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.selection.clear(this.id);

          if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
          }
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * @param {?} v
         * @return {?}
         */
        ,
        set: function set(v) {
          var _this242 = this;

          if (this._value === v) {
            return;
          }

          this._value = v;
          this.setSelection(this.items.find(function (x) {
            return x.value === _this242.value;
          }));
          this.cdr.detectChanges();
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "selectionValue",
        get: function get() {
          /** @type {?} */
          var selectedItem = this.selectedItem;
          return selectedItem ? selectedItem.itemText : '';
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "selectedItem",
        get: function get() {
          return this.selection.first_item(this.id);
        }
      }]);

      return IgxSelectComponent;
    }(IgxDropDownComponent);

    IgxSelectComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-select',
        template: "<igx-input-group #inputGroup class=\"input-group\" [disabled]=\"disabled\" (click)=\"toggle()\" [type]=\"type\" [displayDensity]=\"displayDensity\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n    </ng-container>\n        <input #input class=\"input\" type=\"text\" igxInput [igxSelectItemNavigation]=\"this\"\n            readonly=\"true\"\n            [attr.placeholder]=\"this.placeholder\"\n            [value]=\"this.selectionValue\"\n            role=\"combobox\"\n            aria-haspopup=\"listbox\"\n            [attr.aria-labelledby]=\"this.label ? this.label.id : ''\"\n            [attr.aria-expanded]=\"!this.collapsed\"\n            [attr.aria-owns]=\"this.listId\"\n            [attr.aria-activedescendant]=\"!this.collapsed ? this.focusedItem?.id : null\"\n            (blur)=\"onBlur()\"\n            (focus)=\"onFocus()\"\n            />\n        <ng-container ngProjectAs=\"igx-suffix\">\n                <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n            </ng-container>\n        <igx-suffix>\n            <ng-container *ngIf=\"toggleIconTemplate\">\n                <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n                </ng-container>\n            <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">{{ collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n    <div class=\"igx-drop-down__list--select\" igxToggle [style.maxHeight]=\"maxHeight\"\n        (onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n        (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\"\n        [attr.id]=\"this.listId\" role=\"listbox\">\n        <ng-content select=\"igx-select-item, igx-select-item-group\">\n        </ng-content>\n    </div>\n",
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxSelectComponent,
          multi: true
        }, {
          provide: IGX_DROPDOWN_BASE,
          useExisting: IgxSelectComponent
        }],
        styles: ["\n        :host {\n            display: block;\n        }\n    "]
      }]
    }];
    /** @nocollapse */

    IgxSelectComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: IgxSelectionAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"]
      }];
    };

    IgxSelectComponent.propDecorators = {
      inputGroup: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['inputGroup', {
          read: IgxInputGroupComponent,
          "static": true
        }]
      }],
      input: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['input', {
          read: IgxInputDirective,
          "static": true
        }]
      }],
      children: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxSelectItemComponent;
        }), {
          descendants: true
        }]
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxLabelDirective;
        }), {
          "static": true
        }]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      placeholder: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      overlaySettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      maxHeight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.maxHeight']
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      toggleIconTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxSelectToggleIconDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var ExpressionItem =
    /**
     * @param {?=} parent
     */
    function ExpressionItem(parent) {
      _classCallCheck(this, ExpressionItem);

      this.parent = parent;
    };
    /**
     * @hidden
     */


    var ExpressionGroupItem =
    /*#__PURE__*/
    function (_ExpressionItem) {
      _inherits(ExpressionGroupItem, _ExpressionItem);

      /**
       * @param {?} operator
       * @param {?=} parent
       */
      function ExpressionGroupItem(operator, parent) {
        var _this243;

        _classCallCheck(this, ExpressionGroupItem);

        _this243 = _possibleConstructorReturn(this, _getPrototypeOf(ExpressionGroupItem).call(this, parent));
        _this243.operator = operator;
        _this243.children = [];
        return _this243;
      }

      return ExpressionGroupItem;
    }(ExpressionItem);
    /**
     * @hidden
     */


    var ExpressionOperandItem =
    /*#__PURE__*/
    function (_ExpressionItem2) {
      _inherits(ExpressionOperandItem, _ExpressionItem2);

      /**
       * @param {?} expression
       * @param {?} parent
       */
      function ExpressionOperandItem(expression, parent) {
        var _this244;

        _classCallCheck(this, ExpressionOperandItem);

        _this244 = _possibleConstructorReturn(this, _getPrototypeOf(ExpressionOperandItem).call(this, parent));
        _this244.expression = expression;
        return _this244;
      }

      return ExpressionOperandItem;
    }(ExpressionItem);
    /**
     * @hidden
     */


    var IgxAdvancedFilteringDialogComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} element
       * @param {?} cdr
       */
      function IgxAdvancedFilteringDialogComponent(element, cdr) {
        _classCallCheck(this, IgxAdvancedFilteringDialogComponent);

        this.element = element;
        this.cdr = cdr;
        this.selectedExpressions = [];
        this.selectedGroups = [];
        this._positionSettings = {
          horizontalStartPoint: HorizontalAlignment.Right,
          verticalStartPoint: VerticalAlignment.Top
        };
        this._overlaySettings = {
          closeOnOutsideClick: false,
          modal: false,
          positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
          scrollStrategy: new CloseScrollStrategy()
        };
        this.columnSelectOverlaySettings = {
          scrollStrategy: new AbsoluteScrollStrategy(),
          modal: false,
          closeOnOutsideClick: false,
          excludePositionTarget: true
        };
        this.conditionSelectOverlaySettings = {
          scrollStrategy: new AbsoluteScrollStrategy(),
          modal: false,
          closeOnOutsideClick: false,
          excludePositionTarget: true
        };
        this.display = 'block';
        this.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._dblClickDelay = 200;
        this._preventChipClick = false;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(IgxAdvancedFilteringDialogComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          var _this245 = this;

          this._overlaySettings.outlet = this.overlayOutlet;
          this.columnSelectOverlaySettings.outlet = this.overlayOutlet;
          this.conditionSelectOverlaySettings.outlet = this.overlayOutlet;
          this.contextMenuToggle.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (args) {
            _this245.contextualGroup = null;
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.destroy$.next(true);
          this.destroy$.complete();
        }
        /**
         * @return {?}
         */

      }, {
        key: "dragStart",

        /**
         * @param {?} dragArgs
         * @return {?}
         */
        value: function dragStart(dragArgs) {
          if (!this.contextMenuToggle.collapsed) {
            this.contextMenuToggle.element.style.display = 'none';
          }
        }
        /**
         * @param {?} dragArgs
         * @return {?}
         */

      }, {
        key: "dragEnd",
        value: function dragEnd(dragArgs) {
          if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
            this.contextMenuToggle.element.style.display = '';
          }
        }
        /**
         * @param {?} parent
         * @param {?=} afterExpression
         * @return {?}
         */

      }, {
        key: "addCondition",
        value: function addCondition(parent, afterExpression) {
          this.cancelOperandAdd();
          /** @type {?} */

          var operandItem = new ExpressionOperandItem({
            fieldName: null,
            condition: null,
            ignoreCase: true,
            searchVal: null
          }, parent);

          if (afterExpression) {
            /** @type {?} */
            var index = parent.children.indexOf(afterExpression);
            parent.children.splice(index + 1, 0, operandItem);
          } else {
            parent.children.push(operandItem);
          }

          this.enterExpressionEdit(operandItem);
        }
        /**
         * @param {?=} parent
         * @param {?=} afterExpression
         * @return {?}
         */

      }, {
        key: "addAndGroup",
        value: function addAndGroup(parent, afterExpression) {
          this.addGroup(FilteringLogic.And, parent, afterExpression);
        }
        /**
         * @param {?=} parent
         * @param {?=} afterExpression
         * @return {?}
         */

      }, {
        key: "addOrGroup",
        value: function addOrGroup(parent, afterExpression) {
          this.addGroup(FilteringLogic.Or, parent, afterExpression);
        }
        /**
         * @param {?} groupItem
         * @return {?}
         */

      }, {
        key: "endGroup",
        value: function endGroup(groupItem) {
          this.currentGroup = groupItem.parent;
        }
        /**
         * @return {?}
         */

      }, {
        key: "commitOperandEdit",
        value: function commitOperandEdit() {
          if (this.editedExpression) {
            this.editedExpression.expression.fieldName = this.selectedColumn.field;
            this.editedExpression.expression.condition = this.selectedColumn.filters.condition(this.selectedCondition);
            this.editedExpression.expression.searchVal = DataUtil.parseValue(this.selectedColumn.dataType, this.searchValue);
            this.editedExpression.columnHeader = this.selectedColumn.header;
            this.editedExpression.inEditMode = false;
            this.editedExpression = null;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "cancelOperandAdd",
        value: function cancelOperandAdd() {
          if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
            this.addModeExpression = null;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "cancelOperandEdit",
        value: function cancelOperandEdit() {
          if (this.editedExpression) {
            this.editedExpression.inEditMode = false;

            if (!this.editedExpression.expression.fieldName) {
              this.deleteItem(this.editedExpression);
            }

            this.editedExpression = null;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "operandCanBeCommitted",
        value: function operandCanBeCommitted() {
          return this.selectedColumn && this.selectedCondition && (!!this.searchValue || this.selectedColumn.filters.condition(this.selectedCondition).isUnary);
        }
        /**
         * @return {?}
         */

      }, {
        key: "exitOperandEdit",
        value: function exitOperandEdit() {
          if (!this.editedExpression) {
            return;
          }

          if (this.operandCanBeCommitted()) {
            this.commitOperandEdit();
          } else {
            this.cancelOperandEdit();
          }
        }
        /**
         * @param {?} expression
         * @return {?}
         */

      }, {
        key: "isExpressionGroup",
        value: function isExpressionGroup(expression) {
          return expression instanceof ExpressionGroupItem;
        }
        /**
         * @private
         * @param {?} operator
         * @param {?=} parent
         * @param {?=} afterExpression
         * @return {?}
         */

      }, {
        key: "addGroup",
        value: function addGroup(operator, parent, afterExpression) {
          this.cancelOperandAdd();
          /** @type {?} */

          var groupItem = new ExpressionGroupItem(operator, parent);

          if (parent) {
            if (afterExpression) {
              /** @type {?} */
              var index = parent.children.indexOf(afterExpression);
              parent.children.splice(index + 1, 0, groupItem);
            } else {
              parent.children.push(groupItem);
            }
          } else {
            this.rootGroup = groupItem;
          }

          this.addCondition(groupItem);
          this.currentGroup = groupItem;
        }
        /**
         * @private
         * @param {?} expressionTree
         * @param {?=} parent
         * @return {?}
         */

      }, {
        key: "createExpressionGroupItem",
        value: function createExpressionGroupItem(expressionTree, parent) {
          /** @type {?} */
          var groupItem;

          if (expressionTree) {
            groupItem = new ExpressionGroupItem(expressionTree.operator, parent);
            var _iteratorNormalCompletion46 = true;
            var _didIteratorError46 = false;
            var _iteratorError46 = undefined;

            try {
              for (var _iterator46 = expressionTree.filteringOperands[Symbol.iterator](), _step46; !(_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done); _iteratorNormalCompletion46 = true) {
                var expr = _step46.value;

                if (expr instanceof FilteringExpressionsTree) {
                  groupItem.children.push(this.createExpressionGroupItem(expr, groupItem));
                } else {
                  /** @type {?} */
                  var filteringExpr =
                  /** @type {?} */
                  expr;
                  /** @type {?} */

                  var exprCopy = {
                    fieldName: filteringExpr.fieldName,
                    condition: filteringExpr.condition,
                    searchVal: filteringExpr.searchVal,
                    ignoreCase: filteringExpr.ignoreCase
                  };
                  /** @type {?} */

                  var operandItem = new ExpressionOperandItem(exprCopy, groupItem);
                  /** @type {?} */

                  var column = this.grid.getColumnByName(filteringExpr.fieldName);
                  operandItem.columnHeader = column.header;
                  groupItem.children.push(operandItem);
                }
              }
            } catch (err) {
              _didIteratorError46 = true;
              _iteratorError46 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion46 && _iterator46["return"] != null) {
                  _iterator46["return"]();
                }
              } finally {
                if (_didIteratorError46) {
                  throw _iteratorError46;
                }
              }
            }
          }

          return groupItem;
        }
        /**
         * @private
         * @param {?} groupItem
         * @return {?}
         */

      }, {
        key: "createExpressionsTreeFromGroupItem",
        value: function createExpressionsTreeFromGroupItem(groupItem) {
          if (!groupItem) {
            return null;
          }
          /** @type {?} */


          var expressionsTree = new FilteringExpressionsTree(groupItem.operator);
          var _iteratorNormalCompletion47 = true;
          var _didIteratorError47 = false;
          var _iteratorError47 = undefined;

          try {
            for (var _iterator47 = groupItem.children[Symbol.iterator](), _step47; !(_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done); _iteratorNormalCompletion47 = true) {
              var item = _step47.value;

              if (item instanceof ExpressionGroupItem) {
                /** @type {?} */
                var subTree = this.createExpressionsTreeFromGroupItem(
                /** @type {?} */
                item);
                expressionsTree.filteringOperands.push(subTree);
              } else {
                expressionsTree.filteringOperands.push(
                /** @type {?} */
                item.expression);
              }
            }
          } catch (err) {
            _didIteratorError47 = true;
            _iteratorError47 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion47 && _iterator47["return"] != null) {
                _iterator47["return"]();
              }
            } finally {
              if (_didIteratorError47) {
                throw _iteratorError47;
              }
            }
          }

          return expressionsTree;
        }
        /**
         * @param {?} expressionItem
         * @return {?}
         */

      }, {
        key: "onChipRemove",
        value: function onChipRemove(expressionItem) {
          this.deleteItem(expressionItem);
        }
        /**
         * @param {?} expressionItem
         * @return {?}
         */

      }, {
        key: "onChipClick",
        value: function onChipClick(expressionItem) {
          var _this246 = this;

          this._clickTimer = setTimeout(function () {
            if (!_this246._preventChipClick) {
              _this246.onToggleExpression(expressionItem);
            }

            _this246._preventChipClick = false;
          }, this._dblClickDelay);
        }
        /**
         * @param {?} expressionItem
         * @return {?}
         */

      }, {
        key: "onChipDblClick",
        value: function onChipDblClick(expressionItem) {
          clearTimeout(this._clickTimer);
          this._preventChipClick = true;
          this.enterExpressionEdit(expressionItem);
        }
        /**
         * @param {?} expressionItem
         * @return {?}
         */

      }, {
        key: "enterExpressionEdit",
        value: function enterExpressionEdit(expressionItem) {
          this.clearSelection();
          this.exitOperandEdit();
          this.cancelOperandAdd();

          if (this.editedExpression) {
            this.editedExpression.inEditMode = false;
          }

          expressionItem.hovered = false;
          this.selectedColumn = expressionItem.expression.fieldName ? this.grid.getColumnByName(expressionItem.expression.fieldName) : null;
          this.selectedCondition = expressionItem.expression.condition ? expressionItem.expression.condition.name : null;
          this.searchValue = expressionItem.expression.searchVal;
          expressionItem.inEditMode = true;
          this.editedExpression = expressionItem;
          this.cdr.detectChanges();
          this.columnSelectOverlaySettings.positionStrategy = new AutoPositionStrategy({
            target: this.columnSelect.element
          });
          this.conditionSelectOverlaySettings.positionStrategy = new AutoPositionStrategy({
            target: this.conditionSelect.element
          });

          if (!this.selectedColumn) {
            this.columnSelect.input.nativeElement.focus();
          } else if (this.selectedColumn.filters.condition(this.selectedCondition).isUnary) {
            this.conditionSelect.input.nativeElement.focus();
          } else {
            this.searchValueInput.nativeElement.focus();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "clearSelection",
        value: function clearSelection() {
          var _iteratorNormalCompletion48 = true;
          var _didIteratorError48 = false;
          var _iteratorError48 = undefined;

          try {
            for (var _iterator48 = this.selectedGroups[Symbol.iterator](), _step48; !(_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done); _iteratorNormalCompletion48 = true) {
              var group = _step48.value;
              group.selected = false;
            }
          } catch (err) {
            _didIteratorError48 = true;
            _iteratorError48 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion48 && _iterator48["return"] != null) {
                _iterator48["return"]();
              }
            } finally {
              if (_didIteratorError48) {
                throw _iteratorError48;
              }
            }
          }

          this.selectedGroups = [];
          var _iteratorNormalCompletion49 = true;
          var _didIteratorError49 = false;
          var _iteratorError49 = undefined;

          try {
            for (var _iterator49 = this.selectedExpressions[Symbol.iterator](), _step49; !(_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done); _iteratorNormalCompletion49 = true) {
              var expr = _step49.value;
              expr.selected = false;
            }
          } catch (err) {
            _didIteratorError49 = true;
            _iteratorError49 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion49 && _iterator49["return"] != null) {
                _iterator49["return"]();
              }
            } finally {
              if (_didIteratorError49) {
                throw _iteratorError49;
              }
            }
          }

          this.selectedExpressions = [];
          this.toggleContextMenu();
        }
        /**
         * @param {?} expressionItem
         * @return {?}
         */

      }, {
        key: "enterExpressionAdd",
        value: function enterExpressionAdd(expressionItem) {
          this.clearSelection();
          this.exitOperandEdit();

          if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
          }

          expressionItem.inAddMode = true;
          this.addModeExpression = expressionItem;

          if (expressionItem.selected) {
            this.toggleExpression(expressionItem);
          }
        }
        /**
         * @private
         * @param {?} expressionItem
         * @return {?}
         */

      }, {
        key: "onToggleExpression",
        value: function onToggleExpression(expressionItem) {
          this.exitOperandEdit();
          this.toggleExpression(expressionItem);
          this.toggleContextMenu();
        }
        /**
         * @private
         * @param {?} expressionItem
         * @return {?}
         */

      }, {
        key: "toggleExpression",
        value: function toggleExpression(expressionItem) {
          expressionItem.selected = !expressionItem.selected;

          if (expressionItem.selected) {
            this.selectedExpressions.push(expressionItem);
          } else {
            /** @type {?} */
            var index = this.selectedExpressions.indexOf(expressionItem);
            this.selectedExpressions.splice(index, 1);
            this.deselectParentRecursive(expressionItem);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "toggleContextMenu",
        value: function toggleContextMenu() {
          /** @type {?} */
          var contextualGroup = this.findSingleSelectedGroup();

          if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;

            if (contextualGroup) {
              this.filteringLogics = [{
                label: this.grid.resourceStrings.igx_grid_filter_operator_and,
                selected: contextualGroup.operator === FilteringLogic.And
              }, {
                label: this.grid.resourceStrings.igx_grid_filter_operator_or,
                selected: contextualGroup.operator === FilteringLogic.Or
              }];
            }
          } else {
            this.contextMenuToggle.close();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "findSingleSelectedGroup",
        value: function findSingleSelectedGroup() {
          var _this247 = this;

          var _iteratorNormalCompletion50 = true;
          var _didIteratorError50 = false;
          var _iteratorError50 = undefined;

          try {
            var _loop5 = function _loop5() {
              var group = _step50.value;

              /** @type {?} */
              var containsAllSelectedExpressions = _this247.selectedExpressions.every(function (op) {
                return _this247.isInsideGroup(op, group);
              });

              if (containsAllSelectedExpressions) {
                return {
                  v: group
                };
              }
            };

            for (var _iterator50 = this.selectedGroups[Symbol.iterator](), _step50; !(_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done); _iteratorNormalCompletion50 = true) {
              var _ret2 = _loop5();

              if (typeof _ret2 === "object") return _ret2.v;
            }
          } catch (err) {
            _didIteratorError50 = true;
            _iteratorError50 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion50 && _iterator50["return"] != null) {
                _iterator50["return"]();
              }
            } finally {
              if (_didIteratorError50) {
                throw _iteratorError50;
              }
            }
          }

          return null;
        }
        /**
         * @private
         * @param {?} item
         * @param {?} group
         * @return {?}
         */

      }, {
        key: "isInsideGroup",
        value: function isInsideGroup(item, group) {
          if (!item) {
            return false;
          }

          if (item.parent === group) {
            return true;
          }

          return this.isInsideGroup(item.parent, group);
        }
        /**
         * @private
         * @param {?} expressionItem
         * @return {?}
         */

      }, {
        key: "deleteItem",
        value: function deleteItem(expressionItem) {
          if (!expressionItem.parent) {
            this.rootGroup = null;
            this.currentGroup = null;
            return;
          }

          if (expressionItem === this.currentGroup) {
            this.currentGroup = this.currentGroup.parent;
          }
          /** @type {?} */


          var children = expressionItem.parent.children;
          /** @type {?} */

          var index = children.indexOf(expressionItem);
          children.splice(index, 1);

          if (!children.length) {
            this.deleteItem(expressionItem.parent);
          }
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "onKeyDown",
        value: function onKeyDown(eventArgs) {
          eventArgs.stopPropagation();

          if (!this.contextMenuToggle.collapsed && (eventArgs.key === "Escape"
          /* ESCAPE */
          || eventArgs.key === "Esc"
          /* ESCAPE_IE */
          )) {
            this.clearSelection();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "createAndGroup",
        value: function createAndGroup() {
          this.createGroup(FilteringLogic.And);
        }
        /**
         * @return {?}
         */

      }, {
        key: "createOrGroup",
        value: function createOrGroup() {
          this.createGroup(FilteringLogic.Or);
        }
        /**
         * @private
         * @param {?} operator
         * @return {?}
         */

      }, {
        key: "createGroup",
        value: function createGroup(operator) {
          /** @type {?} */
          var chips = this.chips.toArray();
          /** @type {?} */

          var minIndex = this.selectedExpressions.reduce(function (i, e) {
            return Math.min(i, chips.findIndex(function (c) {
              return c.data === e;
            }));
          }, Number.MAX_VALUE);
          /** @type {?} */

          var firstExpression = chips[minIndex].data;
          /** @type {?} */

          var parent = firstExpression.parent;
          /** @type {?} */

          var groupItem = new ExpressionGroupItem(operator, parent);
          /** @type {?} */

          var index = parent.children.indexOf(firstExpression);
          parent.children.splice(index, 0, groupItem);
          var _iteratorNormalCompletion51 = true;
          var _didIteratorError51 = false;
          var _iteratorError51 = undefined;

          try {
            for (var _iterator51 = this.selectedExpressions[Symbol.iterator](), _step51; !(_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done); _iteratorNormalCompletion51 = true) {
              var expr = _step51.value;
              this.deleteItem(expr);
              groupItem.children.push(expr);
              expr.parent = groupItem;
            }
          } catch (err) {
            _didIteratorError51 = true;
            _iteratorError51 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion51 && _iterator51["return"] != null) {
                _iterator51["return"]();
              }
            } finally {
              if (_didIteratorError51) {
                throw _iteratorError51;
              }
            }
          }

          this.clearSelection();
        }
        /**
         * @return {?}
         */

      }, {
        key: "deleteFilters",
        value: function deleteFilters() {
          var _iteratorNormalCompletion52 = true;
          var _didIteratorError52 = false;
          var _iteratorError52 = undefined;

          try {
            for (var _iterator52 = this.selectedExpressions[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
              var expr = _step52.value;
              this.deleteItem(expr);
            }
          } catch (err) {
            _didIteratorError52 = true;
            _iteratorError52 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion52 && _iterator52["return"] != null) {
                _iterator52["return"]();
              }
            } finally {
              if (_didIteratorError52) {
                throw _iteratorError52;
              }
            }
          }

          this.clearSelection();
        }
        /**
         * @param {?} groupItem
         * @return {?}
         */

      }, {
        key: "onGroupClick",
        value: function onGroupClick(groupItem) {
          this.toggleGroup(groupItem);
        }
        /**
         * @private
         * @param {?} groupItem
         * @return {?}
         */

      }, {
        key: "toggleGroup",
        value: function toggleGroup(groupItem) {
          this.exitOperandEdit();

          if (groupItem.children && groupItem.children.length) {
            this.toggleGroupRecursive(groupItem, !groupItem.selected);

            if (!groupItem.selected) {
              this.deselectParentRecursive(groupItem);
            }

            this.toggleContextMenu();
          }
        }
        /**
         * @private
         * @param {?} groupItem
         * @param {?} selected
         * @return {?}
         */

      }, {
        key: "toggleGroupRecursive",
        value: function toggleGroupRecursive(groupItem, selected) {
          if (groupItem.selected !== selected) {
            groupItem.selected = selected;

            if (groupItem.selected) {
              this.selectedGroups.push(groupItem);
            } else {
              /** @type {?} */
              var index = this.selectedGroups.indexOf(groupItem);
              this.selectedGroups.splice(index, 1);
            }
          }

          var _iteratorNormalCompletion53 = true;
          var _didIteratorError53 = false;
          var _iteratorError53 = undefined;

          try {
            for (var _iterator53 = groupItem.children[Symbol.iterator](), _step53; !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {
              var expr = _step53.value;

              if (expr instanceof ExpressionGroupItem) {
                this.toggleGroupRecursive(expr, selected);
              } else {
                /** @type {?} */
                var operandExpression =
                /** @type {?} */
                expr;

                if (operandExpression.selected !== selected) {
                  this.toggleExpression(operandExpression);
                }
              }
            }
          } catch (err) {
            _didIteratorError53 = true;
            _iteratorError53 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion53 && _iterator53["return"] != null) {
                _iterator53["return"]();
              }
            } finally {
              if (_didIteratorError53) {
                throw _iteratorError53;
              }
            }
          }
        }
        /**
         * @private
         * @param {?} expressionItem
         * @return {?}
         */

      }, {
        key: "deselectParentRecursive",
        value: function deselectParentRecursive(expressionItem) {
          /** @type {?} */
          var parent = expressionItem.parent;

          if (parent) {
            if (parent.selected) {
              parent.selected = false;
              /** @type {?} */

              var index = this.selectedGroups.indexOf(parent);
              this.selectedGroups.splice(index, 1);
            }

            this.deselectParentRecursive(parent);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "calculateContextMenuTarget",
        value: function calculateContextMenuTarget() {
          var _this248 = this;

          /** @type {?} */
          var containerRect = this.expressionsContainer.nativeElement.getBoundingClientRect();
          /** @type {?} */

          var chips = this.chips.filter(function (c) {
            return _this248.selectedExpressions.indexOf(c.data) !== -1;
          });
          /** @type {?} */

          var minTop = chips.reduce(function (t, c) {
            return Math.min(t, c.elementRef.nativeElement.getBoundingClientRect().top);
          }, Number.MAX_VALUE);
          minTop = Math.max(containerRect.top, minTop);
          minTop = Math.min(containerRect.bottom, minTop);
          /** @type {?} */

          var maxRight = chips.reduce(function (r, c) {
            return Math.max(r, c.elementRef.nativeElement.getBoundingClientRect().right);
          }, 0);
          maxRight = Math.max(maxRight, containerRect.left);
          maxRight = Math.min(maxRight, containerRect.right);
          this._overlaySettings.positionStrategy.settings.target = new Point(maxRight, minTop);
        }
        /**
         * @private
         * @param {?} target
         * @return {?}
         */

      }, {
        key: "scrollElementIntoView",
        value: function scrollElementIntoView(target) {
          /** @type {?} */
          var container = this.expressionsContainer.nativeElement;
          /** @type {?} */

          var targetOffset = target.offsetTop - container.offsetTop;
          /** @type {?} */

          var delta = 10;

          if (container.scrollTop + delta > targetOffset) {
            container.scrollTop = targetOffset - delta;
          } else if (container.scrollTop + container.clientHeight < targetOffset + target.offsetHeight + delta) {
            container.scrollTop = targetOffset + target.offsetHeight + delta - container.clientHeight;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ungroup",
        value: function ungroup() {
          /** @type {?} */
          var selectedGroup = this.contextualGroup;
          /** @type {?} */

          var parent = selectedGroup.parent;

          if (parent) {
            var _parent$children;

            /** @type {?} */
            var index = parent.children.indexOf(selectedGroup);

            (_parent$children = parent.children).splice.apply(_parent$children, [index, 1].concat(_toConsumableArray(selectedGroup.children)));

            var _iteratorNormalCompletion54 = true;
            var _didIteratorError54 = false;
            var _iteratorError54 = undefined;

            try {
              for (var _iterator54 = selectedGroup.children[Symbol.iterator](), _step54; !(_iteratorNormalCompletion54 = (_step54 = _iterator54.next()).done); _iteratorNormalCompletion54 = true) {
                var expr = _step54.value;
                expr.parent = parent;
              }
            } catch (err) {
              _didIteratorError54 = true;
              _iteratorError54 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion54 && _iterator54["return"] != null) {
                  _iterator54["return"]();
                }
              } finally {
                if (_didIteratorError54) {
                  throw _iteratorError54;
                }
              }
            }
          }

          this.clearSelection();
        }
        /**
         * @return {?}
         */

      }, {
        key: "deleteGroup",
        value: function deleteGroup() {
          /** @type {?} */
          var selectedGroup = this.contextualGroup;
          /** @type {?} */

          var parent = selectedGroup.parent;

          if (parent) {
            /** @type {?} */
            var index = parent.children.indexOf(selectedGroup);
            parent.children.splice(index, 1);
          } else {
            this.rootGroup = null;
          }

          this.clearSelection();
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "selectFilteringLogic",
        value: function selectFilteringLogic(event) {
          this.contextualGroup.operator =
          /** @type {?} */
          event.index;
        }
        /**
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "getConditionFriendlyName",
        value: function getConditionFriendlyName(name) {
          return this.grid.resourceStrings["igx_grid_filter_".concat(name)] || name;
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isDate",
        value: function isDate(value) {
          return value instanceof Date;
        }
        /**
         * @return {?}
         */

      }, {
        key: "onExpressionsScrolled",
        value: function onExpressionsScrolled() {
          if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
          }
        }
        /**
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "invokeClick",
        value: function invokeClick(eventArgs) {
          if (eventArgs.key === "Enter"
          /* ENTER */
          || eventArgs.key === " "
          /* SPACE */
          || eventArgs.key === "Spacebar"
          /* SPACE_IE */
          ) {
              eventArgs.preventDefault();

              /** @type {?} */
              eventArgs.currentTarget.click();
            }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onOutletPointerDown",
        value: function onOutletPointerDown(event) {
          // This prevents closing the select's dropdown when clicking the scroll
          event.preventDefault();
        }
        /**
         * @return {?}
         */

      }, {
        key: "getConditionList",
        value: function getConditionList() {
          return this.selectedColumn ? this.selectedColumn.filters.conditionList() : [];
        }
        /**
         * @param {?} filteringService
         * @param {?} overlayService
         * @param {?} overlayComponentId
         * @return {?}
         */

      }, {
        key: "initialize",
        value: function initialize(filteringService, overlayService, overlayComponentId) {
          var _this249 = this;

          this.filteringService = filteringService;
          this.overlayService = overlayService;
          this.overlayComponentId = overlayComponentId;
          this.filteringService.registerSVGIcons(); // Set pointer-events to none of the overlay content element which blocks the grid interaction after dragging

          this.overlayService.onOpened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
            if (_this249.element.nativeElement.parentElement) {
              _this249.element.nativeElement.parentElement.style['pointer-events'] = 'none';
            }
          });

          if (this.grid.advancedFilteringExpressionsTree) {
            this.rootGroup = this.createExpressionGroupItem(this.grid.advancedFilteringExpressionsTree);
            this.currentGroup = this.rootGroup;
          }
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "setAddButtonFocus",
        value: function setAddButtonFocus() {
          if (this.addRootAndGroupButton) {
            this.addRootAndGroupButton.nativeElement.focus();
          } else if (this.addConditionButton) {
            this.addConditionButton.nativeElement.focus();
          }
        }
        /**
         * @param {?} expression
         * @param {?=} afterExpression
         * @return {?}
         */

      }, {
        key: "context",
        value: function context(expression, afterExpression) {
          return {
            $implicit: expression,
            afterExpression: afterExpression
          };
        }
        /**
         * @return {?}
         */

      }, {
        key: "onClearButtonClick",
        value: function onClearButtonClick() {
          this.clearSelection();
          this.cancelOperandAdd();
          this.cancelOperandEdit();
          this.currentGroup = null;
          this.rootGroup = null;
          this.grid.advancedFilteringExpressionsTree = null;
        }
        /**
         * @return {?}
         */

      }, {
        key: "closeDialog",
        value: function closeDialog() {
          if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "applyChanges",
        value: function applyChanges() {
          this.exitOperandEdit();
          this.grid.advancedFilteringExpressionsTree = this.createExpressionsTreeFromGroupItem(this.rootGroup);
        }
        /**
         * @return {?}
         */

      }, {
        key: "onApplyButtonClick",
        value: function onApplyButtonClick() {
          this.applyChanges();
          this.closeDialog();
        }
        /**
         * @return {?}
         */

      }, {
        key: "onChipSelectionEnd",
        value: function onChipSelectionEnd() {
          /** @type {?} */
          var contextualGroup = this.findSingleSelectedGroup();

          if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;
            this.calculateContextMenuTarget();

            if (this.contextMenuToggle.collapsed) {
              this.contextMenuToggle.open(this._overlaySettings);
            } else {
              this.contextMenuToggle.reposition();
            }
          }
        }
      }, {
        key: "editingInputsContainer",
        set: function set(value) {
          var _this250 = this;

          if (value && !this._editingInputsContainer || value && this._editingInputsContainer && this._editingInputsContainer.nativeElement !== value.nativeElement) {
            requestAnimationFrame(function () {
              _this250.scrollElementIntoView(value.nativeElement);
            });
          }

          this._editingInputsContainer = value;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._editingInputsContainer;
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "addModeContainer",
        set: function set(value) {
          var _this251 = this;

          if (value && !this._addModeContainer || value && this._addModeContainer && this._addModeContainer.nativeElement !== value.nativeElement) {
            requestAnimationFrame(function () {
              _this251.scrollElementIntoView(value.nativeElement);
            });
          }

          this._addModeContainer = value;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._addModeContainer;
        }
        /**
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "currentGroupButtonsContainer",
        set: function set(value) {
          var _this252 = this;

          if (value && !this._currentGroupButtonsContainer || value && this._currentGroupButtonsContainer && this._currentGroupButtonsContainer.nativeElement !== value.nativeElement) {
            requestAnimationFrame(function () {
              _this252.scrollElementIntoView(value.nativeElement);
            });
          }

          this._currentGroupButtonsContainer = value;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._currentGroupButtonsContainer;
        }
      }, {
        key: "displayDensity",
        get: function get() {
          return this.grid.displayDensity;
        }
        /**
         * @return {?}
         */

      }, {
        key: "selectedColumn",
        get: function get() {
          return this._selectedColumn;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          /** @type {?} */
          var oldValue = this._selectedColumn;

          if (this._selectedColumn !== value) {
            this._selectedColumn = value;

            if (oldValue && this._selectedColumn && this._selectedColumn.dataType !== oldValue.dataType) {
              this.selectedCondition = null;
              this.searchValue = null;
              this.cdr.detectChanges();
            }
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "grid",
        get: function get() {
          return this.filteringService.grid;
        }
        /**
         * @return {?}
         */

      }, {
        key: "filterableColumns",
        get: function get() {
          return this.grid.columns.filter(function (col) {
            return !col.columnGroup && col.filterable;
          });
        }
      }]);

      return IgxAdvancedFilteringDialogComponent;
    }();

    IgxAdvancedFilteringDialogComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-advanced-filtering-dialog',
        template: "<article\n    class=\"igx-advanced-filter\"\n    igxDrag\n    [ghost]=\"false\"\n    [dragTolerance]=\"0\"\n    (dragStart)=\"dragStart($event)\"\n    (dragEnd)=\"dragEnd($event)\"\n    (keydown)=\"onKeyDown($event)\"\n    [ngClass]=\"{\n        'igx-advanced-filter--cosy': grid.displayDensity === 'cosy',\n        'igx-advanced-filter--compact': grid.displayDensity === 'compact'\n    }\"\n>\n    <header class=\"igx-advanced-filter__header\" igxDragHandle>\n        <h4 class=\"igx-typography__h6\" style=\"pointer-events: none;\">\n            {{ grid.resourceStrings.igx_grid_advanced_filter_title }}\n        </h4>\n        <div class=\"igx-filter-legend\">\n            <div class=\"igx-filter-legend__item--and\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_and_label }}</span>\n            </div>\n            <div class=\"igx-filter-legend__item--or\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_or_label }}</span>\n            </div>\n        </div>\n    </header>\n\n    <article #expressionsContainer\n             class=\"igx-advanced-filter__main\"\n             (scroll)=\"onExpressionsScrolled()\">\n        <ng-container *ngIf=\"!rootGroup\">\n\n            <button #addRootAndGroupButton\n                igxButton=\"outlined\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"addAndGroup()\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\" [displayDensity]=\"displayDensity\" (click)=\"addOrGroup()\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n            <div class=\"igx-filter-empty\">\n                <h6 class=\"igx-filter-empty__title\">\n                    {{grid.resourceStrings.igx_grid_advanced_filter_initial_text}}\n                </h6>\n            </div>\n        </ng-container>\n\n        <ng-template #addExpressionsTemplate let-expressionItem let-afterExpression=\"afterExpression\">\n            <button #addConditionButton\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addCondition(expressionItem, afterExpression)\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_add_condition}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addAndGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addOrGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n        </ng-template>\n\n        <ng-template #filterOperandTemplate let-expressionItem>\n            <div *ngIf=\"!expressionItem.inEditMode\"\n                class=\"igx-filter-tree__expression-item\"\n                (mouseenter)=\"expressionItem.hovered = true\"\n                (mouseleave)=\"expressionItem.hovered = false\"\n                >\n                <igx-chip [data]=\"expressionItem\"\n                          [displayDensity]=\"displayDensity === 'compact' ? 'cosy' : displayDensity\"\n                          [removable]=\"true\"\n                          [selected]=\"expressionItem.selected\"\n                          (keydown)=\"invokeClick($event)\"\n                          (click)=\"onChipClick(expressionItem)\"\n                          (dblclick)=\"onChipDblClick(expressionItem)\"\n                          (onRemove)=\"onChipRemove(expressionItem)\"\n                          (onSelectionDone)=\"onChipSelectionEnd()\"\n                    >\n                    <span igxPrefix class=\"igx-filter-tree__expression-column\">{{ expressionItem.columnHeader || expressionItem.expression.fieldName }}</span>\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"filtering-icons\"\n                        [name]=\"expressionItem.expression.condition.iconName\"\n                    >\n                    </igx-icon>\n                    <span class=\"igx-filter-tree__expression-condition\">\n                        {{ getConditionFriendlyName(expressionItem.expression.condition.name) }}\n                    </span>\n                    <span igxSuffix *ngIf=\"!expressionItem.expression.condition.isUnary\">\n                        {{ isDate(expressionItem.expression.searchVal) ? (expressionItem.expression.searchVal | igxdate:grid.locale) : expressionItem.expression.searchVal }}\n                    </span>\n                </igx-chip>\n                <div class=\"igx-filter-tree__expression-actions\"\n                *ngIf=\"(expressionItem.selected && selectedExpressions.length === 1) || expressionItem.hovered\">\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionEdit(expressionItem)\">\n                        edit\n                    </igx-icon>\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionAdd(expressionItem)\"\n                        *ngIf=\"!expressionItem.inAddMode && (expressionItem.parent !== currentGroup || expressionItem !== currentGroup.children[currentGroup.children.length - 1])\"\n                    >\n                        add\n                    </igx-icon>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inEditMode\"\n                #editingInputsContainer\n                class=\"igx-filter-tree__inputs\"\n            >\n                <igx-select #columnSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"columnSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_column_placeholder\"\n                            [(ngModel)]=\"selectedColumn\">\n                    <igx-select-item *ngFor=\"let column of filterableColumns\" [value]=\"column\">\n                        {{column.header || column.field}}\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-select #conditionSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"conditionSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_filter_condition_placeholder\"\n                            [(ngModel)]=\"selectedCondition\"\n                            [disabled]=\"!selectedColumn\">\n                    <igx-icon *ngIf=\"selectedColumn && conditionSelect.value && selectedColumn.filters.condition(conditionSelect.value)\"\n                              igxPrefix\n                              fontSet=\"filtering-icons\"\n                              [name]=\"selectedColumn.filters.condition(conditionSelect.value).iconName\">\n                    </igx-icon>\n                    <igx-select-item *ngFor=\"let condition of getConditionList()\" [value]=\"condition\">\n                        <igx-icon fontSet=\"filtering-icons\"\n                                  [name]=\"selectedColumn.filters.condition(condition).iconName\">\n                        </igx-icon>\n                        <span>{{getConditionFriendlyName(condition)}}</span>\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-input-group *ngIf=\"!selectedColumn || selectedColumn.dataType !== 'date'\"\n                                 type=\"box\"\n                                 [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"\n                                 [displayDensity]=\"'compact'\">\n                    <input #searchValueInput\n                           igxInput\n                           [type]=\"selectedColumn && selectedColumn.dataType === 'number' ? 'number' : 'text'\"\n                           [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_value_placeholder\"\n                           [(ngModel)]=\"searchValue\"/>\n                </igx-input-group>\n\n                <igx-date-picker *ngIf=\"selectedColumn && selectedColumn.dataType === 'date'\"\n                                 mode=\"dropdown\"\n                                 [(ngModel)]=\"searchValue\"\n                                 [locale]=\"grid.locale\"\n                                 [outlet]=\"grid.outletDirective\">\n                    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n                        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\">\n                            <input #searchValueInput\n                                    igxInput\n                                    tabindex=\"0\"\n                                    (keydown)=\"invokeClick($event)\"\n                                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                                    [placeholder]=\"grid.resourceStrings.igx_grid_filter_row_date_placeholder\"\n                                    autocomplete=\"off\"\n                                    [value]=\"value | igxdate: grid.locale\"\n                                    [readonly]=\"true\"\n                                    [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"/>\n                        </igx-input-group>\n                    </ng-template>\n                </igx-date-picker>\n\n                <div class=\"igx-filter-tree__inputs-actions\">\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            [disabled]=\"!operandCanBeCommitted()\"\n                            (click)=\"commitOperandEdit()\">\n                        <igx-icon fontSet=\"material\">check</igx-icon>\n                    </button>\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            (click)=\"cancelOperandEdit()\">\n                        <igx-icon fontSet=\"material\">close</igx-icon>\n                    </button>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inAddMode\"\n                #addModeContainer\n                class=\"igx-filter-tree__buttons\"\n            >\n                <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem.parent, expressionItem)\"></ng-container>\n                <button igxButton=\"icon\"\n                        [displayDensity]=\"displayDensity\"\n                        (click)=\"cancelOperandAdd()\">\n                    <igx-icon fontSet=\"material\">close</igx-icon>\n                </button>\n            </div>\n\n        </ng-template>\n\n        <ng-template #expressionTreeTemplate let-expressionItem>\n            <div class=\"igx-filter-tree\">\n                <div tabindex=\"0\"\n                     class=\"igx-filter-tree__line\"\n                     [ngClass]=\"{\n                         'igx-filter-tree__line--and': expressionItem.operator === 0,\n                         'igx-filter-tree__line--or': expressionItem.operator === 1,\n                         'igx-filter-tree__line--selected': expressionItem.selected\n                     }\"\n                     (keydown)=\"invokeClick($event)\"\n                     (click)=\"onGroupClick(expressionItem)\"\n                ></div>\n\n                <div class=\"igx-filter-tree__expression\">\n                    <ng-container *ngFor=\"let expr of expressionItem.children\">\n                        <ng-container *ngTemplateOutlet=\"isExpressionGroup(expr) ? expressionTreeTemplate : filterOperandTemplate; context: context(expr)\"></ng-container>\n                    </ng-container>\n                    <div *ngIf=\"currentGroup === expressionItem\"\n                        #currentGroupButtonsContainer\n                        class=\"igx-filter-tree__buttons\">\n                        <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem)\"></ng-container>\n                        <button igxButton=\"outlined\"\n                                *ngIf=\"expressionItem !== rootGroup\"\n                                [displayDensity]=\"displayDensity\"\n                                [disabled]=\"editedExpression || expressionItem.children.length < 2\"\n                                (click)=\"endGroup(expressionItem)\">\n                            <span>{{grid.resourceStrings.igx_grid_advanced_filter_end_group}}</span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n        </ng-template>\n\n        <ng-container *ngIf=\"rootGroup\">\n            <ng-container *ngTemplateOutlet=\"expressionTreeTemplate; context: context(rootGroup)\"></ng-container>\n        </ng-container>\n\n        <div igxToggle\n            class=\"igx-filter-contextual-menu\"\n            (keydown)=\"onKeyDown($event)\"\n            [ngClass]=\"{\n                'igx-filter-contextual-menu--cosy': displayDensity === 'cosy',\n                'igx-filter-contextual-menu--compact': displayDensity === 'compact'\n            }\"\n        >\n            <button igxButton=\"icon\"\n                    class=\"igx-filter-contextual-menu__close-btn\"\n                    (click)=\"clearSelection()\"\n            >\n                <igx-icon>close</igx-icon>\n            </button>\n\n            <ng-container *ngIf=\"contextualGroup\">\n                <igx-buttongroup [displayDensity]=\"displayDensity\"\n                                 [multiSelection]=\"false\"\n                                 [values]=\"filteringLogics\"\n                                 type=\"outline\"\n                                 (onSelect)=\"selectFilteringLogic($event)\">\n                </igx-buttongroup>\n\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"!contextualGroup.parent\"\n                    (click)=\"ungroup()\"\n                >\n                    <igx-icon fontSet=\"filtering-icons\" name=\"ungroup\"></igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_ungroup}}</span>\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteGroup()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    <igx-icon>delete</igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_delete}}</span>\n                </button>\n            </ng-container>\n            <ng-container *ngIf=\"!contextualGroup\">\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createAndGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_and_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createOrGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_or_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteFilters()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_delete_filters}}\n                </button>\n            </ng-container>\n        </div>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n<div #overlayOutlet\n     igxOverlayOutlet\n     class=\"igx-advanced-filter__outlet\"\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxAdvancedFilteringDialogComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxAdvancedFilteringDialogComponent.propDecorators = {
      filteringService: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      overlayComponentId: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      overlayService: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['columnSelect', {
          read: IgxSelectComponent,
          "static": false
        }]
      }],
      conditionSelect: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['conditionSelect', {
          read: IgxSelectComponent,
          "static": false
        }]
      }],
      searchValueInput: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['searchValueInput', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      addRootAndGroupButton: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['addRootAndGroupButton', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      addConditionButton: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['addConditionButton', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      editingInputsContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['editingInputsContainer', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      addModeContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['addModeContainer', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      currentGroupButtonsContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['currentGroupButtonsContainer', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      contextMenuToggle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxToggleDirective, {
          "static": true
        }]
      }],
      chips: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxChipComponent]
      }],
      expressionsContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['expressionsContainer', {
          "static": true
        }]
      }],
      overlayOutlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['overlayOutlet', {
          read: IgxOverlayOutletDirective,
          "static": true
        }]
      }],
      display: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.display']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxRowSelectorDirective =
    /**
     * @param {?} templateRef
     */
    function IgxRowSelectorDirective(templateRef) {
      _classCallCheck(this, IgxRowSelectorDirective);

      this.templateRef = templateRef;
    };

    IgxRowSelectorDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRowSelector]'
      }]
    }];
    /** @nocollapse */

    IgxRowSelectorDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxHeadSelectorDirective =
    /**
     * @param {?} templateRef
     */
    function IgxHeadSelectorDirective(templateRef) {
      _classCallCheck(this, IgxHeadSelectorDirective);

      this.templateRef = templateRef;
    };

    IgxHeadSelectorDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxHeadSelector]'
      }]
    }];
    /** @nocollapse */

    IgxHeadSelectorDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxRowSelectorsModule = function IgxRowSelectorsModule() {
      _classCallCheck(this, IgxRowSelectorsModule);
    };

    IgxRowSelectorsModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxRowSelectorDirective, IgxHeadSelectorDirective],
        exports: [IgxRowSelectorDirective, IgxHeadSelectorDirective]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxGroupByRowTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxGroupByRowTemplateDirective(template) {
      _classCallCheck(this, IgxGroupByRowTemplateDirective);

      this.template = template;
    };

    IgxGroupByRowTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxGroupByRow]'
      }]
    }];
    /** @nocollapse */

    IgxGroupByRowTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @hidden
     */


    var IgxRowExpandedIndicatorDirective = function IgxRowExpandedIndicatorDirective() {
      _classCallCheck(this, IgxRowExpandedIndicatorDirective);
    };

    IgxRowExpandedIndicatorDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRowExpandedIndicator]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxRowCollapsedIndicatorDirective = function IgxRowCollapsedIndicatorDirective() {
      _classCallCheck(this, IgxRowCollapsedIndicatorDirective);
    };

    IgxRowCollapsedIndicatorDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRowCollapsedIndicator]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxHeaderExpandIndicatorDirective = function IgxHeaderExpandIndicatorDirective() {
      _classCallCheck(this, IgxHeaderExpandIndicatorDirective);
    };

    IgxHeaderExpandIndicatorDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxHeaderExpandedIndicator]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxHeaderCollapseIndicatorDirective = function IgxHeaderCollapseIndicatorDirective() {
      _classCallCheck(this, IgxHeaderCollapseIndicatorDirective);
    };

    IgxHeaderCollapseIndicatorDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxHeaderCollapsedIndicator]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxGroupAreaDropDirective =
    /*#__PURE__*/
    function (_IgxDropDirective2) {
      _inherits(IgxGroupAreaDropDirective, _IgxDropDirective2);

      /**
       * @param {?} elementRef
       * @param {?} renderer
       * @param {?} zone
       */
      function IgxGroupAreaDropDirective(elementRef, renderer, zone) {
        var _this253;

        _classCallCheck(this, IgxGroupAreaDropDirective);

        _this253 = _possibleConstructorReturn(this, _getPrototypeOf(IgxGroupAreaDropDirective).call(this, elementRef, renderer, zone));
        _this253.elementRef = elementRef;
        _this253.renderer = renderer;
        _this253.zone = zone;
        _this253.hovered = false;
        return _this253;
      }
      /**
       * @param {?} event
       * @return {?}
       */


      _createClass(IgxGroupAreaDropDirective, [{
        key: "onDragEnter",
        value: function onDragEnter(event) {
          /** @type {?} */
          var drag = event.detail.owner;
          /** @type {?} */

          var column = drag.column;

          if (!this.columnBelongsToGrid(column)) {
            return;
          }
          /** @type {?} */


          var grid =
          /** @type {?} */
          column.grid;
          /** @type {?} */

          var isGrouped = grid.groupingExpressions.findIndex(function (item) {
            return item.fieldName === column.field;
          }) !== -1;

          if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
            drag.icon.innerText = 'group_work';
            this.hovered = true;
          } else {
            drag.icon.innerText = 'block';
            this.hovered = false;
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragLeave",
        value: function onDragLeave(event) {
          /** @type {?} */
          var drag = event.detail.owner;
          /** @type {?} */

          var column = drag.column;

          if (!this.columnBelongsToGrid(column)) {
            return;
          }

          event.detail.owner.icon.innerText = 'block';
          this.hovered = false;
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onDragDrop",
        value: function onDragDrop(event) {
          /** @type {?} */
          var drag = event.detail.owner;

          if (drag instanceof IgxColumnMovingDragDirective) {
            /** @type {?} */
            var column = drag.column;

            if (!this.columnBelongsToGrid(column)) {
              return;
            }
            /** @type {?} */


            var grid =
            /** @type {?} */
            column.grid;
            /** @type {?} */

            var isGrouped = grid.groupingExpressions.findIndex(function (item) {
              return item.fieldName === column.field;
            }) !== -1;

            if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
              grid.groupBy({
                fieldName: column.field,
                dir: SortingDirection.Asc,
                ignoreCase: column.sortingIgnoreCase,
                strategy: column.sortStrategy,
                groupingComparer: column.groupingComparer
              });
            }
          }
        }
        /**
         * @private
         * @param {?} elem
         * @param {?} attr
         * @return {?}
         */

      }, {
        key: "closestParentByAttr",
        value: function closestParentByAttr(elem, attr) {
          return elem.hasAttribute(attr) ? elem : this.closestParentByAttr(elem.parentElement, attr);
        }
        /**
         * @private
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "columnBelongsToGrid",
        value: function columnBelongsToGrid(column) {
          /** @type {?} */
          var elem = this.elementRef.nativeElement;
          /** @type {?} */

          var closestGridID = this.closestParentByAttr(elem, 'igxGroupAreaDrop').getAttribute('gridId');

          if (!column) {
            return false;
          } else {
            /** @type {?} */
            var grid =
            /** @type {?} */
            column.grid;

            if (!grid || grid.id !== closestGridID) {
              return false;
            }

            return true;
          }
        }
      }]);

      return IgxGroupAreaDropDirective;
    }(IgxDropDirective);

    IgxGroupAreaDropDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxGroupAreaDrop]'
      }]
    }];
    /** @nocollapse */

    IgxGroupAreaDropDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };

    IgxGroupAreaDropDirective.propDecorators = {
      hovered: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-drop-area--hover']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var ghostBackgroundClass = 'igx-grid__tr--ghost';
    /** @type {?} */

    var gridCellClass = 'igx-grid__td';
    /** @type {?} */

    var rowSelectedClass = 'igx-grid__tr--selected';
    /** @type {?} */

    var cellSelectedClass = 'igx-grid__td--selected';
    /** @type {?} */

    var cellActiveClass = 'igx-grid__td--active';
    /**
     * @hidden
     */

    var IgxRowDragDirective =
    /*#__PURE__*/
    function (_IgxDragDirective2) {
      _inherits(IgxRowDragDirective, _IgxDragDirective2);

      function IgxRowDragDirective() {
        var _this254;

        _classCallCheck(this, IgxRowDragDirective);

        _this254 = _possibleConstructorReturn(this, _getPrototypeOf(IgxRowDragDirective).apply(this, arguments));
        _this254._rowDragStarted = false;

        _this254.transitionEndEvent = function (evt) {
          if (_this254.ghostElement) {
            _this254.ghostElement.removeEventListener('transitionend', _this254.transitionEndEvent, false);
          }

          _this254.endDragging();
        };

        return _this254;
      }
      /**
       * @param {?} val
       * @return {?}
       */


      _createClass(IgxRowDragDirective, [{
        key: "onPointerDown",

        /**
         * @param {?} event
         * @return {?}
         */
        value: function onPointerDown(event) {
          event.preventDefault();
          this._rowDragStarted = false;
          this._removeOnDestroy = false;

          _get(_getPrototypeOf(IgxRowDragDirective.prototype), "onPointerDown", this).call(this, event);
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onPointerMove",
        value: function onPointerMove(event) {
          var _this255 = this;

          _get(_getPrototypeOf(IgxRowDragDirective.prototype), "onPointerMove", this).call(this, event);

          if (this._dragStarted && !this._rowDragStarted) {
            this._rowDragStarted = true;
            /** @type {?} */

            var args = {
              dragDirective: this,
              dragData: this.row,
              cancel: false,
              owner: this.row.grid
            };
            this.row.grid.onRowDragStart.emit(args);

            if (args.cancel) {
              this.ghostElement.parentNode.removeChild(this.ghostElement);
              this.ghostElement = null;
              this._dragStarted = false;
              this._clicked = false;
              return;
            }

            this.row.dragging = true;
            this.row.grid.rowDragging = true;
            this.row.grid.markForCheck();
            this.subscription$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.row.grid.document.defaultView, 'keydown').subscribe(function (ev) {
              if (ev.key === "Escape"
              /* ESCAPE */
              || ev.key === "Esc"
              /* ESCAPE_IE */
              ) {
                  _this255._lastDropArea = false;

                  _this255.onPointerUp(event);
                }
            });
          }
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onPointerUp",
        value: function onPointerUp(event) {
          var _this256 = this;

          if (!this._clicked) {
            return;
          }
          /** @type {?} */


          var args = {
            dragDirective: this,
            dragData: this.row,
            animation: false,
            owner: this.row.grid
          };
          this.zone.run(function () {
            _this256.row.grid.onRowDragEnd.emit(args);
          });
          /** @type {?} */

          var dropArea = this._lastDropArea;

          _get(_getPrototypeOf(IgxRowDragDirective.prototype), "onPointerUp", this).call(this, event);

          if (!dropArea && this.ghostElement) {
            this.ghostElement.addEventListener('transitionend', this.transitionEndEvent, false);
          } else {
            this.endDragging();
          }
        }
        /**
         * @protected
         * @param {?} pageX
         * @param {?} pageY
         * @return {?}
         */

      }, {
        key: "createGhost",
        value: function createGhost(pageX, pageY) {
          this.row.grid.endEdit(true);
          this.row.grid.markForCheck();
          this.ghostContext = {
            $implicit: this.row.rowData,
            data: this.row.rowData,
            grid: this.row.grid
          };

          _get(_getPrototypeOf(IgxRowDragDirective.prototype), "createGhost", this).call(this, pageX, pageY, this.row.nativeElement); // check if there is an expander icon and create the ghost at the corresponding position


          if (this.isHierarchicalGrid) {
            /** @type {?} */
            var row =
            /** @type {?} */
            this.row;

            if (row.expander) {
              /** @type {?} */
              var expanderWidth = row.expander.nativeElement.getBoundingClientRect().width;
              this._ghostHostX += expanderWidth;
            }
          }
          /** @type {?} */


          var ghost = this.ghostElement;
          /** @type {?} */

          var gridRect = this.row.grid.nativeElement.getBoundingClientRect();
          /** @type {?} */

          var rowRect = this.row.nativeElement.getBoundingClientRect();
          ghost.style.overflow = 'hidden';
          ghost.style.width = gridRect.width + 'px';
          ghost.style.height = rowRect.height + 'px';
          this.renderer.addClass(ghost, ghostBackgroundClass);
          this.renderer.removeClass(ghost, rowSelectedClass);
          /** @type {?} */

          var ghostCells = ghost.getElementsByClassName(gridCellClass);

          for (var index = 0; index < ghostCells.length; index++) {
            this.renderer.removeClass(ghostCells[index], cellSelectedClass);
            this.renderer.removeClass(ghostCells[index], cellActiveClass);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          if (this.subscription$ && !this.subscription$.closed) {
            this.subscription$.unsubscribe();
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "endDragging",
        value: function endDragging() {
          this.onTransitionEnd(null);
          this.row.dragging = false;
          this.row.grid.rowDragging = false;
          this.row.grid.markForCheck();

          this._unsubscribe();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "data",
        set: function set(val) {
          this.row = val;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.row;
        }
      }, {
        key: "isHierarchicalGrid",
        get: function get() {
          return this.row.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
        }
      }]);

      return IgxRowDragDirective;
    }(IgxDragDirective);

    IgxRowDragDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRowDrag]'
      }]
    }];
    IgxRowDragDirective.propDecorators = {
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxRowDrag']
      }]
    };
    /**
     * @hidden
     */

    var IgxDragIndicatorIconDirective = function IgxDragIndicatorIconDirective() {
      _classCallCheck(this, IgxDragIndicatorIconDirective);
    };

    IgxDragIndicatorIconDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxDragIndicatorIcon]'
      }]
    }];
    /**
     * @hidden
     */

    var IgxRowDragGhostDirective =
    /**
     * @param {?} templateRef
     */
    function IgxRowDragGhostDirective(templateRef) {
      _classCallCheck(this, IgxRowDragGhostDirective);

      this.templateRef = templateRef;
    };

    IgxRowDragGhostDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRowDragGhost]'
      }]
    }];
    /** @nocollapse */

    IgxRowDragGhostDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxRowDragModule = function IgxRowDragModule() {
      _classCallCheck(this, IgxRowDragModule);
    };

    IgxRowDragModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
        entryComponents: [],
        exports: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
        imports: []
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var MINIMUM_COLUMN_WIDTH = 136;
    /** @type {?} */

    var FILTER_ROW_HEIGHT = 50; // By default row editing overlay outlet is inside grid body so that overlay is hidden below grid header when scrolling.
    // In cases when grid has 1-2 rows there isn't enough space in grid body and row editing overlay should be shown above header.
    // Default row editing overlay height is higher then row height that is why the case is valid also for row with 2 rows.
    // More accurate calculation is not possible, cause row editing overlay is still not shown and we don't know its height,
    // but in the same time we need to set row editing overlay outlet before opening the overlay itself.

    /** @type {?} */

    var MIN_ROW_EDITING_COUNT_THRESHOLD = 2;
    /** @type {?} */

    var IgxGridTransaction = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('IgxGridTransaction');
    /**
     * @abstract
     */

    var IgxGridBaseComponent =
    /*#__PURE__*/
    function (_DisplayDensityBase8) {
      _inherits(IgxGridBaseComponent, _DisplayDensityBase8);

      /**
       * @param {?} selectionService
       * @param {?} crudService
       * @param {?} colResizingService
       * @param {?} gridAPI
       * @param {?} _transactions
       * @param {?} elementRef
       * @param {?} zone
       * @param {?} document
       * @param {?} cdr
       * @param {?} resolver
       * @param {?} differs
       * @param {?} viewRef
       * @param {?} navigation
       * @param {?} filteringService
       * @param {?} overlayService
       * @param {?} summaryService
       * @param {?} _displayDensityOptions
       */
      function IgxGridBaseComponent(selectionService, crudService, colResizingService, gridAPI, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        var _this257;

        _classCallCheck(this, IgxGridBaseComponent);

        _this257 = _possibleConstructorReturn(this, _getPrototypeOf(IgxGridBaseComponent).call(this, _displayDensityOptions));
        _this257.selectionService = selectionService;
        _this257.crudService = crudService;
        _this257.colResizingService = colResizingService;
        _this257.gridAPI = gridAPI;
        _this257._transactions = _transactions;
        _this257.elementRef = elementRef;
        _this257.zone = zone;
        _this257.document = document;
        _this257.cdr = cdr;
        _this257.resolver = resolver;
        _this257.differs = differs;
        _this257.viewRef = viewRef;
        _this257.navigation = navigation;
        _this257.filteringService = filteringService;
        _this257.overlayService = overlayService;
        _this257.summaryService = summaryService;
        _this257._displayDensityOptions = _displayDensityOptions;
        _this257._init = true;
        _this257._cdrRequests = false;
        _this257._cdrRequestRepaint = false;
        _this257._resourceStrings = CurrentResourceStrings.GridResStrings;
        _this257._emptyGridMessage = null;
        _this257._emptyFilteredGridMessage = null;
        _this257._isLoading = false;
        _this257._locale = null;
        _this257._destroyed = false;
        _this257.overlayIDs = [];
        _this257._advancedFilteringPositionSettings = {
          verticalDirection: VerticalAlignment.Middle,
          horizontalDirection: HorizontalAlignment.Center,
          horizontalStartPoint: HorizontalAlignment.Center,
          verticalStartPoint: VerticalAlignment.Middle
        };
        _this257._advancedFilteringOverlaySettings = {
          closeOnOutsideClick: false,
          modal: false,
          positionStrategy: new ConnectedPositioningStrategy(_this257._advancedFilteringPositionSettings)
        };
        /**
         * An \@Input property that autogenerates the `IgxGridComponent` columns.
         * The default value is false.
         * \@remarks
         * When set to true, it will override all columns declared through code or in markup.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.autoGenerate = false;
        /**
         * @hidden
         */

        _this257.filteringExpressionsTreeChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted after advanced filtering is performed.
         * Returns the advanced filtering expressions tree.
         * ```typescript
         * advancedFilteringExprTreeChange(event: IFilteringExpressionsTree){
         *     const filteringTree = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
         *           (advancedFilteringExpressionsTreeChange)="advancedFilteringExprTreeChange($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.advancedFilteringExpressionsTreeChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this257.pageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this257.perPageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         * \@internal
         */

        _this257.rowDragging = false;
        /**
         * An \@Input property that adds styling classes applied to all even `IgxGridRowComponent`s in the grid.
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-even-class'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.evenRowCSS = 'igx-grid__tr--even';
        /**
         * An \@Input property that adds styling classes applied to all odd `IgxGridRowComponent`s in the grid.
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-odd-class'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.oddRowCSS = 'igx-grid__tr--odd';
        /**
         * An \@Input property that sets the title to be displayed in the built-in column hiding UI.
         * ```html
         * <igx-grid [showToolbar]="true" [columnHiding]="true" columnHidingTitle="Column Hiding"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.columnHidingTitle = '';
        /**
         * An \@Input property that sets the title to be displayed in the UI of the column pinning.
         * ```html
         * <igx-grid #grid [data]="localData" [columnPinning]="'true" [columnPinningTitle]="'Column Hiding'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.columnPinningTitle = '';
        /**
         * Emitted when `IgxGridCellComponent` is clicked. Returns the `IgxGridCellComponent`.
         * ```html
         * <igx-grid #grid (onCellClick)="onCellClick($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onCellClick(e){
         *     alert("The cell has been clicked!");
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onCellClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxGridCellComponent` is selected. Returns the `IgxGridCellComponent`.
         * ```html
         * <igx-grid #grid (onSelection)="onCellSelect($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onCellSelect(e){
         *     alert("The cell has been selected!");
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         *  Emitted when `IgxGridRowComponent` is selected.
         * ```html
         * <igx-grid #grid (onRowSelectionChange)="onCellClickChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onCellClickChange(e){
         *     alert("The selected row has been changed!");
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onRowSelectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` is pinned.
         * The index that the column is inserted at may be changed through the `insertAtIndex` property.
         * ```typescript
         * public columnPinning(event) {
         *     if (event.column.field === "Name") {
         *       event.insertAtIndex = 0;
         *     }
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onColumnPinning = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when `IgxGridCellComponent`
         * editing has been performed in the grid and the values have **not** been submitted (e.g. `Esc` key was pressed).
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      cellID: {
         *          columnID: int,
         *          rowID: int,
         *          rowIndex: int
         *      }
         *      newValue: object,
         *      oldValue: object,
         *      rowID: int
         *  }
         *
         * ```typescript
         * editCancel(event: IGridEditEventArgs){
         *    const rowID: IgxColumnComponent = event.rowID;
         * }
         * ```
         * ```html
         * <igx-grid #grid3 (onCellEditCancel)="editCancel($event)" [data]="remote | async" [primaryKey]="'ProductID'">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */

        _this257.onCellEditCancel = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when `IgxGridCellComponent` enters edit mode.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      cellID: {
         *          columnID: int,
         *          rowID: int,
         *          rowIndex: int
         *      }
         *      oldValue: object,
         *      rowID: int
         *  }
         *
         * ```typescript
         * editStart(event: IGridEditEventArgs){
         *    const value: IgxColumnComponent = event.newValue;
         * }
         * ```
         * ```html
         * <igx-grid #grid3 (onCellEditEnter)="editStart($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */

        _this257.onCellEditEnter = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when `IgxGridCellComponent` editing has been performed in the grid.
         * Event is fired after editing is completed, when the cell is exiting edit mode.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      cellID: {
         *          columnID: int,
         *          rowID: int,
         *          rowIndex: int
         *      }
         *      newValue: object,
         *      oldValue: object,
         *      rowID: int
         *  }
         *
         * ```typescript
         * editDone(event: IGridEditEventArgs){
         *    const value: IgxColumnComponent = event.newValue;
         * }
         * ```
         * ```html
         * <igx-grid #grid3 (onCellEdit)="editDone($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onCellEdit = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when [rowEditable]="true" a row enters edit mode.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      oldValue: <rowObj>,
         *      rowID: int
         *  }
         *
         * Bind to the event in markup as follows:
         * ```html
         * <igx-grid #grid3 (onRowEditEnter)="editStart($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowEditable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * ```typescript
         *      editStart(event: IGridEditEventArgs) {
         *          const editedRowObj = event.oldValue;
         *          const cancelValue = event.cancel;
         *          const rowID = event.rowID;
         *      }
         * ```
         * \@memberof IgxGridComponent
         */

        _this257.onRowEditEnter = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when [rowEditable]="true" & `endEdit(true)` is called.
         * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
         * performing paging operation, column resizing, pinning, moving or hitting  `Done`
         * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      newValue: <rowObj>,
         *      oldValue: <rowObj>,
         *      rowID: int
         *  }
         *
         * Bind to the event in markup as follows:
         * ```html
         * <igx-grid #grid3 (onRowEdit)="editDone($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowEditable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         *
         * ```typescript
         *      editDone(event: IGridEditEventArgs) {
         *          const originalRowObj = event.oldValue;
         *          const updatedRowObj = event.newValue;
         *          const cancelValue = event.cancel;
         *          const rowID = event.rowID;
         *      }
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onRowEdit = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Output property emitting an event when [rowEditable]="true" & `endEdit(false)` is called.
         * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button
         * in the row editing overlay.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      newValue: <rowObj>,
         *      oldValue: <rowObj>,
         *      rowID: int
         *  }
         *
         * Bind to the event in markup as follows:
         * ```html
         * <igx-grid #grid3 (onRowEditCancel)="editCancel($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowEditable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * ```typescript
         *      editCancel(emitted: { row: IgxGridRowComponent, newValue: any, oldValue: any }): void {
         *          const originalRowObj = event.oldValue;
         *          const updatedRowObj = event.newValue;
         *          const cancelValue = event.cancel;
         *          const rowID = event.rowID;
         *      }
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onRowEditCancel = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a grid column is initialized. Returns the column object.
         * ```html
         * <igx-grid #grid [data]="localData" [onColumnInit]="initColumns($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * initColumns(event: IgxColumnComponent) {
         * const column: IgxColumnComponent = event;
         *       column.filterable = true;
         *       column.sortable = true;
         *       column.editable = true;
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onColumnInit = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when sorting is performed through the UI. Returns the sorting expression.
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSortingDone)="sortingDone($event)"></igx-grid>
         * ```
         * ```typescript
         * sortingDone(event: SortingDirection){
         *     const sortingDirection = event;
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onSortingDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when filtering is performed through the UI.
         * Returns the filtering expressions tree of the column for which filtering was performed.
         * ```typescript
         * filteringDone(event: IFilteringExpressionsTree){
         *     const filteringTree = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onFilteringDone)="filteringDone($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onFilteringDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when paging is performed. Returns an object consisting of the previous and next pages.
         * ```typescript
         * pagingDone(event: IPageEventArgs){
         *     const paging = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onPagingDone)="pagingDone($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onPagingDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a `IgxGridRowComponent` is being added to the `IgxGridComponent` through the API.
         * Returns the data for the new `IgxGridRowComponent` object.
         * ```typescript
         * rowAdded(event: IRowDataEventArgs){
         *    const rowInfo = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onRowAdded)="rowAdded($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onRowAdded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a `IgxGridRowComponent` is deleted through the `IgxGridComponent` API.
         * Returns an `IRowDataEventArgs` object.
         * ```typescript
         * rowDeleted(event: IRowDataEventArgs){
         *    const rowInfo = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onRowDeleted)="rowDeleted($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onRowDeleted = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a new chunk of data is loaded from virtualization.
         * ```typescript
         *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (onDataPreLoad)='handleDataPreloadEvent()'></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onDataPreLoad = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` is resized.
         * Returns the `IgxColumnComponent` object's old and new width.
         * ```typescript
         * resizing(event: IColumnResizeEventArgs){
         *     const grouping = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onColumnResized)="resizing($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onColumnResized = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a `IgxGridCellComponent` is right clicked. Returns the `IgxGridCellComponent` object.
         * ```typescript
         * contextMenu(event: IGridCellEventArgs){
         *     const resizing = event;
         *     console.log(resizing);
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onContextMenu)="contextMenu($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onContextMenu = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a `IgxGridCellComponent` is double clicked. Returns the `IgxGridCellComponent` object.
         * ```typescript
         * dblClick(event: IGridCellEventArgs){
         *     const dblClick = event;
         *     console.log(dblClick);
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onDoubleClick)="dblClick($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onDoubleClick = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` visibility is changed. Args: { column: any, newValue: boolean }
         * ```typescript
         * visibilityChanged(event: IColumnVisibilityChangedEventArgs){
         *    const visiblity = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnVisibilityChanged)="visibilityChanged($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onColumnVisibilityChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` moving starts. Returns the moved `IgxColumnComponent` object.
         * ```typescript
         * movingStart(event: IColumnMovingStartEventArgs){
         *     const movingStarts = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingStart)="movingStart($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onColumnMovingStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted throughout the `IgxColumnComponent` moving operation.
         * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.
         * ```typescript
         * moving(event: IColumnMovingEventArgs){
         *     const moving = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMoving)="moving($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onColumnMoving = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when `IgxColumnComponent` moving ends.
         * Returns the source and target `IgxColumnComponent` objects.
         * ```typescript
         * movingEnds(event: IColumnMovingEndEventArgs){
         *     const movingEnds = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingEnd)="movingEnds($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onColumnMovingEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when keydown is triggered over element inside grid's body.
         * This event is fired only if the key combination is supported in the grid.
         * Return the target type, target object and the original event. This event is cancelable.
         * ```typescript
         * customKeydown(args: IGridKeydownEventArgs) {
         *  const keydownEvent = args.event;
         * }
         * ```
         * ```html
         *  <igx-grid (onGridKeydown)="customKeydown($event)"></igx-grid>
         * ```
         */

        _this257.onGridKeydown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when start dragging a row.
         * Return the dragged row.
         */

        _this257.onRowDragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when dropping a row.
         * Return the dropped row.
         */

        _this257.onRowDragEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a copy operation is executed.
         * Fired only if copy behavior is enabled through the [`clipboardOptions`]{\@link IgxGridBaseComponent#clipboardOptions}.
         */

        _this257.onGridCopy = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this257.columnList = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */

        _this257.tmpOutlets = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * The custom template, if any, that should be used when rendering a row expand indicator.
         */

        _this257.rowExpandedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a row collapse indicator.
         */

        _this257.rowCollapsedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header expand indicator.
         */

        _this257.headerExpandIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header collapse indicator.
         */

        _this257.headerCollapseIndicatorTemplate = null;
        /**
         * @hidden
         */

        _this257.tabindex = 0;
        /**
         * @hidden
         */

        _this257.hostRole = 'grid';
        /**
         * @hidden
         */

        _this257.sortingExpressionsChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this257.columnsWithNoSetWidths = null;
        /* Toolbar related definitions */

        _this257._showToolbar = false;
        _this257._exportExcel = false;
        _this257._exportCsv = false;
        _this257._toolbarTitle = null;
        _this257._exportText = null;
        _this257._exportExcelText = null;
        _this257._exportCsvText = null;
        _this257._rowEditable = false;
        _this257._filteredSortedData = null;
        /**
         * Provides access to the `IgxToolbarComponent`.
         * ```typescript
         * const gridToolbar = this.grid.toolbar;
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.toolbar = null;
        _this257.toolbarHtml = null;
        /**
         * Controls the copy behavior of the grid.
         */

        _this257.clipboardOptions = {
          /**
           * Enables/disables the copy behavior
           */
          enabled: true,

          /**
           * Include the columns headers in the clipboard output.
           */
          copyHeaders: true,

          /**
           * Apply the columns formatters (if any) on the data in the clipboard output.
           */
          copyFormatters: true,

          /**
           * The separator used for formatting the copy output. Defaults to `\t`.
           */
          separator: '\t'
        };
        /**
         * Emitted when an export process is initiated by the user.
         * ```typescript
         * toolbarExporting(event: IGridToolbarExportEventArgs){
         *     const toolbarExporting = event;
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */

        _this257.onToolbarExporting = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /* End of toolbar related definitions */

        /**
         * Emitted when making a range selection either through
         * drag selection or through keyboard selection.
         */

        _this257.onRangeSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this257.calcHeight = 0;
        /**
         * @hidden
         */

        _this257.chipsGoupingExpressions = [];
        /**
         * @hidden
         */

        _this257.disableTransitions = false;
        /**
         * @hidden
         */

        _this257.lastSearchInfo = {
          searchText: '',
          caseSensitive: false,
          exactMatch: false,
          activeMatchIndex: 0,
          matchInfoCache: []
        };
        /**
         * @hidden
         */

        _this257.columnWidthSetByUser = false;
        /**
         * @hidden
         */

        _this257.destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */

        _this257._perPage = 15;
        /**
         * @hidden
         */

        _this257._page = 0;
        /**
         * @hidden
         */

        _this257._paging = false;
        /**
         * @hidden
         */

        _this257._hideRowSelectors = false;
        /**
         * @hidden
         */

        _this257._rowDrag = false;
        /**
         * @hidden
         */

        _this257._pipeTrigger = 0;
        /**
         * @hidden
         */

        _this257._filteringPipeTrigger = 0;
        /**
         * @hidden
         */

        _this257._summaryPipeTrigger = 0;
        /**
         * @hidden
         */

        _this257._columns = [];
        /**
         * @hidden
         */

        _this257._pinnedColumns = [];
        /**
         * @hidden
         */

        _this257._unpinnedColumns = [];
        /**
         * @hidden
         */

        _this257._filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
        /**
         * @hidden
         */

        _this257._sortingExpressions = [];
        /**
         * @hidden
         */

        _this257._maxLevelHeaderDepth = null;
        /**
         * @hidden
         */

        _this257._columnHiding = false;
        /**
         * @hidden
         */

        _this257._columnPinning = false;
        _this257._allowFiltering = false;
        _this257._allowAdvancedFiltering = false;
        _this257._filterMode = FilterMode.quickFilter;
        _this257.observer = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](function () {});
        _this257.resizeNotify = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        _this257._hiddenColumnsText = '';
        _this257._pinnedColumnsText = '';
        _this257._height = '100%';
        _this257._width = '100%';
        _this257._horizontalForOfs = [];
        _this257._multiRowLayoutRowSize = 1; // Caches

        _this257._totalWidth = NaN;
        _this257._pinnedVisible = [];
        _this257._unpinnedVisible = [];
        _this257._pinnedWidth = NaN;
        _this257._unpinnedWidth = NaN;
        _this257._visibleColumns = [];
        _this257._columnGroups = false;
        _this257._defaultTargetRecordNumber = 10;
        _this257._summaryPosition = GridSummaryPosition.bottom;
        _this257._summaryCalculationMode = GridSummaryCalculationMode.rootAndChildLevels;
        _this257._cellSelectionMode = GridSelectionMode.multiple;
        _this257._rowSelectionMode = GridSelectionMode.none;
        _this257.rowEditPositioningStrategy = new RowEditPositionStrategy({
          horizontalDirection: HorizontalAlignment.Right,
          verticalDirection: VerticalAlignment.Bottom,
          horizontalStartPoint: HorizontalAlignment.Left,
          verticalStartPoint: VerticalAlignment.Bottom,
          closeAnimation: null
        });
        _this257.rowEditSettings = {
          scrollStrategy: new AbsoluteScrollStrategy(),
          modal: false,
          closeOnOutsideClick: false,
          outlet: _this257.rowOutletDirective,
          positionStrategy: _this257.rowEditPositioningStrategy
        };

        _this257.verticalScrollHandler = function (event) {
          _this257.verticalScrollContainer.onScroll(event);

          if (isEdge()) {
            _this257.wheelHandler(false);
          }

          _this257.disableTransitions = true;

          _this257.zone.run(function () {
            _this257.zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              _this257.verticalScrollContainer.onChunkLoad.emit(_this257.verticalScrollContainer.state);
            });

            if (_this257.rowEditable) {
              _this257.changeRowEditingOverlayStateOnScroll(_this257.rowInEditMode);
            }

            _this257.disableTransitions = false;
          });

          _this257.hideOverlays();
        };

        _this257.horizontalScrollHandler = function (event) {
          /** @type {?} */
          var scrollLeft = event.target.scrollLeft;

          if (isEdge()) {
            _this257.wheelHandler(true);
          }

          _this257.headerContainer.onHScroll(scrollLeft);

          _this257._horizontalForOfs.forEach(function (vfor) {
            return vfor.onHScroll(scrollLeft);
          });

          _this257.cdr.markForCheck();

          _this257.zone.run(function () {
            _this257.zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              _this257.parentVirtDir.onChunkLoad.emit(_this257.headerContainer.state);
            });
          });

          _this257.hideOverlays();
        };

        _this257.keydownHandler = function (event) {
          /** @type {?} */
          var key = event.key.toLowerCase();

          if (isNavigationKey(key) && event.keyCode !== 32 || key === 'tab' || key === 'pagedown' || key === 'pageup') {
            event.preventDefault();

            if (key === 'pagedown') {
              _this257.verticalScrollContainer.scrollNextPage();

              _this257.nativeElement.focus();
            } else if (key === 'pageup') {
              _this257.verticalScrollContainer.scrollPrevPage();

              _this257.nativeElement.focus();
            }
          }
        };
        /**
         * @hidden
         */


        _this257.scrollHandler = function (event) {
          _this257.headerContainer.scrollPosition += event.target.scrollLeft;
          _this257.verticalScrollContainer.scrollPosition += event.target.scrollTop;
          event.target.scrollLeft = 0;
          event.target.scrollTop = 0;
        };
        /**
         * @hidden
         */


        _this257.wheelHandler = function () {
          var isScroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (_this257.document.activeElement && ( // tslint:disable-next-line:no-bitwise
          _this257.document.activeElement.compareDocumentPosition(_this257.tbody.nativeElement) & Node.DOCUMENT_POSITION_CONTAINS || // tslint:disable-next-line:no-bitwise
          _this257.document.activeElement.compareDocumentPosition(_this257.tfoot.nativeElement) & Node.DOCUMENT_POSITION_CONTAINS && isScroll)) {
            /** @type {?} */
            _this257.document.activeElement.blur();
          }
        };
        /**
         * @hidden
         */


        _this257.rowEditingWheelHandler = function (event) {
          if (event.deltaY > 0) {
            _this257.verticalScrollContainer.scrollNext();
          } else {
            _this257.verticalScrollContainer.scrollPrev();
          }
        };

        _this257.cdr.detach();

        return _this257;
      }
      /**
       * @return {?}
       */


      _createClass(IgxGridBaseComponent, [{
        key: "hideOverlays",

        /**
         * @hidden
         * \@internal
         * @return {?}
         */
        value: function hideOverlays() {
          var _this258 = this;

          this.overlayIDs.forEach(function (overlayID) {
            _this258.overlayService.hide(overlayID);

            _this258.overlayService.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function (o) {
              return o.id === overlayID;
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(_this258.destroy$)).subscribe(function () {
              _this258.nativeElement.focus();
            });
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "_setupServices",
        value: function _setupServices() {
          this.gridAPI.grid = this;
          this.crudService.grid = this;
          this.selectionService.grid = this;
          this.navigation.grid = this;
          this.filteringService.grid = this;
          this.summaryService.grid = this;
        }
        /**
         * @return {?}
         */

      }, {
        key: "_setupListeners",
        value: function _setupListeners() {
          var _this259 = this;

          /** @type {?} */
          var destructor = Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$);
          this.onRowAdded.pipe(destructor).subscribe(function (args) {
            return _this259.refreshGridState(args);
          });
          this.onRowDeleted.pipe(destructor).subscribe(function (args) {
            _this259.summaryService.deleteOperation = true;

            _this259.summaryService.clearSummaryCache(args);
          });
          this.transactions.onStateUpdate.pipe(destructor).subscribe(function () {
            _this259.selectionService.clearHeaderCBState();

            _this259.summaryService.clearSummaryCache();

            _this259._pipeTrigger++;

            _this259.notifyChanges();

            if (_this259.transactions.getAggregatedChanges(false).length === 0) {
              // Needs better check, calling 'transactions.clear()' will also trigger this
              if (_this259.gridAPI.atInexistingPage()) {
                _this259.page--;
              }
            }
          });
          this.resizeNotify.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function () {
            return !_this259._init;
          }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttleTime"])(100)).subscribe(function () {
            _this259.zone.run(function () {
              _this259.notifyChanges(true);
            });
          });
          this.onPagingDone.pipe(destructor).subscribe(function () {
            _this259.endEdit(true);

            _this259.selectionService.clear(true);
          });
          this.onColumnMoving.pipe(destructor).subscribe(function () {
            return _this259.endEdit(true);
          });
          this.onColumnResized.pipe(destructor).subscribe(function () {
            return _this259.endEdit(true);
          });
          this.overlayService.onOpening.pipe(destructor).subscribe(function (event) {
            if (_this259._advancedFilteringOverlayId === event.id) {
              /** @type {?} */
              var instance =
              /** @type {?} */
              event.componentRef.instance;

              if (instance) {
                instance.initialize(_this259.filteringService, _this259.overlayService, event.id);
              }
            }
          });
          this.overlayService.onOpened.pipe(destructor).subscribe(function (event) {
            // do not hide the advanced filtering overlay on scroll
            if (_this259._advancedFilteringOverlayId === event.id) {
              /** @type {?} */
              var instance =
              /** @type {?} */
              event.componentRef.instance;

              if (instance) {
                instance.setAddButtonFocus();
              }

              return;
            }

            if (_this259.overlayService.getOverlayById(event.id).settings.outlet === _this259.outletDirective && _this259.overlayIDs.indexOf(event.id) < 0) {
              _this259.overlayIDs.push(event.id);
            }
          });
          this.overlayService.onClosed.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function () {
            return !_this259._init;
          })).subscribe(function (event) {
            if (_this259._advancedFilteringOverlayId === event.id) {
              _this259._advancedFilteringOverlayId = null;
              return;
            }
            /** @type {?} */


            var ind = _this259.overlayIDs.indexOf(event.id);

            if (ind !== -1) {
              _this259.overlayIDs.splice(ind, 1);
            }
          });
          this.verticalScrollContainer.onDataChanging.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function () {
            return !_this259._init;
          })).subscribe(function ($event) {
            /** @type {?} */
            var shouldRecalcSize = _this259.isPercentHeight && (!_this259.calcHeight || _this259.calcHeight === _this259.getDataBasedBodyHeight() || _this259.calcHeight === _this259.renderedRowHeight * _this259._defaultTargetRecordNumber);

            if (shouldRecalcSize) {
              _this259.calculateGridHeight();

              $event.containerSize = _this259.calcHeight;
            }

            _this259.evaluateLoadingState();
          });
          this.verticalScrollContainer.onScrollbarVisibilityChanged.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function () {
            return !_this259._init;
          })).subscribe(function () {
            // called to recalc all widths that may have changes as a result of
            // the vert. scrollbar showing/hiding
            _this259.notifyChanges(true);
          });
          this.verticalScrollContainer.onContentSizeChange.pipe(destructor, Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["filter"])(function () {
            return !_this259._init;
          })).subscribe(function ($event) {
            _this259.calculateGridSizes();
          });
          this.onDensityChanged.pipe(destructor).subscribe(function () {
            _this259.summaryService.summaryHeight = 0;

            _this259.endEdit(true);

            _this259.cdr.markForCheck();
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          _get(_getPrototypeOf(IgxGridBaseComponent.prototype), "ngOnInit", this).call(this);

          this._setupServices();

          this._setupListeners();

          this.columnListDiffer = this.differs.find([]).create(null);
          this.calcWidth = this.width && this.width.indexOf('%') === -1 ? parseInt(this.width, 10) : 0;
          this.shouldGenerate = this.autoGenerate;
          this._scrollWidth = this.getScrollWidth();
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "setupColumns",
        value: function setupColumns() {
          var _this260 = this;

          if (this.autoGenerate) {
            this.autogenerateColumns();
          }

          this.initColumns(this.columnList, function (col) {
            return _this260.onColumnInit.emit(col);
          });
          this.columnListDiffer.diff(this.columnList);
          this.columnList.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (change) {
            _this260.onColumnsChanged(change);
          });
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "resetColumnsCaches",
        value: function resetColumnsCaches() {
          this.columnList.forEach(function (column) {
            return column.resetCaches();
          });
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "resetForOfCache",
        value: function resetForOfCache() {
          /** @type {?} */
          var firstVirtRow = this.dataRowList.first;

          if (firstVirtRow) {
            if (this._cdrRequests) {
              firstVirtRow.virtDirRow.cdr.detectChanges();
            }

            firstVirtRow.virtDirRow.assumeMaster();
          }
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "resetColumnCollections",
        value: function resetColumnCollections() {
          this._visibleColumns.length = 0;
          this._pinnedVisible.length = 0;
          this._unpinnedVisible.length = 0;
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "resetCachedWidths",
        value: function resetCachedWidths() {
          this._unpinnedWidth = NaN;
          this._pinnedWidth = NaN;
          this._totalWidth = NaN;
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "resetCaches",
        value: function resetCaches() {
          this.resetForOfCache();
          this.resetColumnsCaches();
          this.resetColumnCollections();
          this.resetCachedWidths();
          this.hasVisibleColumns = undefined;
          this._columnGroups = this.columnList.some(function (col) {
            return col.columnGroup;
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          this.setupColumns();
        }
        /**
         * @return {?}
         */

      }, {
        key: "_setupRowObservers",
        value: function _setupRowObservers() {
          var _this261 = this;

          /** @type {?} */
          var elementFilter = function elementFilter(item) {
            return _this261.isDefined(item.nativeElement.parentElement);
          };
          /** @type {?} */


          var extractForOfs = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["pipe"])(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["map"])(function (collection) {
            return collection.filter(elementFilter).map(function (item) {
              return item.virtDirRow;
            });
          }));
          /** @type {?} */

          var rowListObserver = extractForOfs(this._dataRowList.changes);
          /** @type {?} */

          var summaryRowObserver = extractForOfs(this._summaryRowList.changes);
          Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["combineLatest"])([rowListObserver, summaryRowObserver]).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (_ref6) {
            var _ref7 = _slicedToArray(_ref6, 2),
                row = _ref7[0],
                summary = _ref7[1];

            return _this261._horizontalForOfs = [].concat(_toConsumableArray(row), _toConsumableArray(summary));
          });
          this._horizontalForOfs = [].concat(_toConsumableArray(this._dataRowList.filter(elementFilter).map(function (item) {
            return item.virtDirRow;
          })), _toConsumableArray(this._summaryRowList.filter(elementFilter).map(function (item) {
            return item.virtDirRow;
          })));
        }
        /**
         * @return {?}
         */

      }, {
        key: "_zoneBegoneListeners",
        value: function _zoneBegoneListeners() {
          var _this262 = this;

          this.zone.runOutsideAngular(function () {
            _this262.nativeElement.addEventListener('keydown', _this262.keydownHandler);

            _this262.verticalScrollContainer.getScroll().addEventListener('scroll', _this262.verticalScrollHandler);

            _this262.headerContainer.getScroll().addEventListener('scroll', _this262.horizontalScrollHandler);

            _this262.observer = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](function () {
              return _this262.resizeNotify.next();
            });

            _this262.observer.observe(_this262.nativeElement);
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this263 = this;

          this.initPinning();
          this.calculateGridSizes();
          this._init = false;
          this.cdr.reattach();

          this._setupRowObservers();

          this._zoneBegoneListeners();
          /** @type {?} */


          var vertScrDC = this.verticalScrollContainer.displayContainer;
          vertScrDC.addEventListener('scroll', this.scrollHandler);
          vertScrDC.addEventListener('wheel', function () {
            return _this263.wheelHandler();
          });
        }
        /**
         * @param {?=} repaint
         * @return {?}
         */

      }, {
        key: "notifyChanges",
        value: function notifyChanges() {
          var repaint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          this._cdrRequests = true;
          this._cdrRequestRepaint = repaint;
          this.cdr.markForCheck();
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "resetNotifyChanges",
        value: function resetNotifyChanges() {
          this._cdrRequestRepaint = false;
          this._cdrRequests = false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          _get(_getPrototypeOf(IgxGridBaseComponent.prototype), "ngDoCheck", this).call(this);

          if (this._init) {
            return;
          }

          if (this._cdrRequestRepaint) {
            this.resetNotifyChanges();
            this.calculateGridSizes();
            this.refreshSearch(true);
            return;
          }

          if (this._cdrRequests) {
            this.resetNotifyChanges();
            this.cdr.detectChanges();
          }
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "getDragGhostCustomTemplate",
        value: function getDragGhostCustomTemplate() {
          if (this.dragGhostCustomTemplates && this.dragGhostCustomTemplates.first) {
            return this.dragGhostCustomTemplates.first;
          }

          return null;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _this264 = this;

          this.tmpOutlets.forEach(function (tmplOutlet) {
            tmplOutlet.cleanCache();
          });
          this.destroy$.next(true);
          this.destroy$.complete();
          this._destroyed = true;

          if (this._advancedFilteringOverlayId) {
            this.overlayService.hide(this._advancedFilteringOverlayId);
          }

          this.zone.runOutsideAngular(function () {
            _this264.observer.disconnect();

            _this264.nativeElement.removeEventListener('keydown', _this264.keydownHandler);

            _this264.verticalScrollContainer.getScroll().removeEventListener('scroll', _this264.verticalScrollHandler);

            _this264.headerContainer.getScroll().removeEventListener('scroll', _this264.horizontalScrollHandler);
            /** @type {?} */


            var vertScrDC = _this264.verticalScrollContainer.displayContainer;
            vertScrDC.removeEventListener('scroll', _this264.scrollHandler);
            vertScrDC.removeEventListener('wheel', function () {
              return _this264.wheelHandler();
            });
          });
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "dataLoading",
        value: function dataLoading(event) {
          this.onDataPreLoad.emit(event);
        }
        /**
         * Toggles the specified column's visibility.
         * ```typescript
         * this.grid1.toggleColumnVisibility({
         *       column: this.grid1.columns[0],
         *       newValue: true
         * });
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "toggleColumnVisibility",
        value: function toggleColumnVisibility(args) {
          /** @type {?} */
          var col = args.column ? this.columnList.find(function (c) {
            return c === args.column;
          }) : undefined;

          if (!col) {
            return;
          }

          col.hidden = args.newValue;
          this.onColumnVisibilityChanged.emit(args);
        }
        /**
         * Returns the native element of the `IgxGridComponent`.
         * ```typescript
         * const nativeEl = this.grid.nativeElement.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "paginatorClassName",

        /**
         * @return {?}
         */
        value: function paginatorClassName() {
          switch (this.displayDensity) {
            case DisplayDensity.cosy:
              return 'igx-paginator--cosy';

            case DisplayDensity.compact:
              return 'igx-paginator--compact';

            default:
              return 'igx-paginator';
          }
        }
        /**
         * Returns the maximum width of the container for the pinned `IgxColumnComponent`s.
         * The width is 80% of the total grid width.
         * ```typescript
         * const maxPinnedColWidth = this.grid.calcPinnedContainerMaxWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "getHeaderGroupWidth",

        /**
         * Returns the `width` to be set on `IgxGridHeaderGroupComponent`.
         * \@memberof IgxGridBaseComponent
         * @param {?} column
         * @return {?}
         */
        value: function getHeaderGroupWidth(column) {
          if (this.hasColumnLayouts) {
            return '';
          }
          /** @type {?} */


          var colWidth = column.width;
          /** @type {?} */

          var minWidth = this.defaultHeaderGroupMinWidth;
          /** @type {?} */

          var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;

          if (!isPercentageWidth && parseInt(column.width, 10) < minWidth) {
            return minWidth.toString();
          }

          return column.width;
        }
        /**
         * Returns the `IgxColumnComponent` by field name.
         * ```typescript
         * const myCol = this.grid1.getColumnByName("ID");
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} name
         * @return {?}
         */

      }, {
        key: "getColumnByName",
        value: function getColumnByName(name) {
          return this.columnList.find(function (col) {
            return col.field === name;
          });
        }
        /**
         * Returns the `IgxRowComponent` by index.
         * ```typescript
         * const myRow = this.grid1.getRowByIndex(1);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "getRowByIndex",
        value: function getRowByIndex(index) {
          return this.gridAPI.get_row_by_index(index);
        }
        /**
         * Returns `IgxGridRowComponent` object by the specified primary key .
         * Requires that the `primaryKey` property is set.
         * ```typescript
         * const myRow = this.grid1.getRowByKey("cell5");
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} keyValue
         * @return {?}
         */

      }, {
        key: "getRowByKey",
        value: function getRowByKey(keyValue) {
          return this.gridAPI.get_row_by_key(keyValue);
        }
        /**
         * Returns an array of visible `IgxColumnComponent`s.
         * ```typescript
         * const visibleColumns = this.grid.visibleColumns.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "getCellByColumn",

        /**
         * Returns the `IgxGridCellComponent` that matches the conditions.
         * ```typescript
         * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} rowIndex
         * @param {?} columnField
         * @return {?}
         */
        value: function getCellByColumn(rowIndex, columnField) {
          /** @type {?} */
          var columnId = this.columnList.map(function (column) {
            return column.field;
          }).indexOf(columnField);

          if (columnId !== -1) {
            return this.gridAPI.get_cell_by_index(rowIndex, columnId);
          }
        }
        /**
         * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
         * Requires that the primaryKey property is set.
         * ```typescript
         * grid.getCellByKey(1, 'index');
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} rowSelector match any rowID
         * @param {?} columnField
         * @return {?}
         */

      }, {
        key: "getCellByKey",
        value: function getCellByKey(rowSelector, columnField) {
          return this.gridAPI.get_cell_by_key(rowSelector, columnField);
        }
        /**
         * Returns the total number of pages.
         * ```typescript
         * const totalPages = this.grid.totalPages;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "nextPage",

        /**
         * Goes to the next page of the `IgxGridComponent`, if the grid is not already at the last page.
         * ```typescript
         * this.grid1.nextPage();
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        value: function nextPage() {
          if (!this.isLastPage) {
            this.page += 1;
          }
        }
        /**
         * Goes to the previous page of the `IgxGridComponent`, if the grid is not already at the first page.
         * ```typescript
         * this.grid1.previousPage();
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "previousPage",
        value: function previousPage() {
          if (!this.isFirstPage) {
            this.page -= 1;
          }
        }
        /**
         * Returns the total number of records.
         * Only functions when paging is enabled.
         * ```typescript
         * const totalRecords = this.grid.totalRecords;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "_moveColumns",

        /**
         * @hidden
         * @protected
         * @param {?} from
         * @param {?} to
         * @param {?} pos
         * @return {?}
         */
        value: function _moveColumns(from, to, pos) {
          /** @type {?} */
          var list = this.columnList.toArray();
          /** @type {?} */

          var fromIndex = list.indexOf(from);
          /** @type {?} */

          var toIndex = list.indexOf(to);

          if (pos === DropPosition.BeforeDropTarget) {
            toIndex--;

            if (toIndex < 0) {
              toIndex = 0;
            }
          }

          if (pos === DropPosition.AfterDropTarget) {
            toIndex++;
          }

          list.splice.apply(list, [toIndex, 0].concat(_toConsumableArray(list.splice(fromIndex, 1))));
          /** @type {?} */

          var newList = this._resetColumnList(list);

          this.columnList.reset(newList);
          this.columnList.notifyOnChanges();
          this._columns = this.columnList.toArray();
        }
        /**
         * @hidden
         * @protected
         * @param {?=} list
         * @return {?}
         */

      }, {
        key: "_resetColumnList",
        value: function _resetColumnList(list) {
          if (!list) {
            list = this.columnList.toArray();
          }
          /** @type {?} */


          var newList = [];
          list.filter(function (c) {
            return c.level === 0;
          }).forEach(function (p) {
            newList.push(p);

            if (p.columnGroup) {
              newList = newList.concat(p.allChildren);
            }
          });
          return newList;
        }
        /**
         * @hidden
         * @protected
         * @param {?} from
         * @param {?} to
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "_reorderPinnedColumns",
        value: function _reorderPinnedColumns(from, to, position) {
          /** @type {?} */
          var pinned = this._pinnedColumns;
          /** @type {?} */

          var dropIndex = pinned.indexOf(to);

          if (to.columnGroup) {
            dropIndex += to.allChildren.length;
          }

          if (position === DropPosition.BeforeDropTarget) {
            dropIndex--;
          }

          if (position === DropPosition.AfterDropTarget) {
            dropIndex++;
          }

          pinned.splice.apply(pinned, [dropIndex, 0].concat(_toConsumableArray(pinned.splice(pinned.indexOf(from), 1))));
        }
        /**
         * @hidden
         * @protected
         * @param {?} parent
         * @param {?} from
         * @param {?} to
         * @param {?} pos
         * @return {?}
         */

      }, {
        key: "_moveChildColumns",
        value: function _moveChildColumns(parent, from, to, pos) {
          /** @type {?} */
          var buffer = parent.children.toArray();
          /** @type {?} */

          var fromIndex = buffer.indexOf(from);
          /** @type {?} */

          var toIndex = buffer.indexOf(to);

          if (pos === DropPosition.BeforeDropTarget) {
            toIndex--;
          }

          if (pos === DropPosition.AfterDropTarget) {
            toIndex++;
          }

          buffer.splice.apply(buffer, [toIndex, 0].concat(_toConsumableArray(buffer.splice(fromIndex, 1))));
          parent.children.reset(buffer);
        }
        /**
         * Moves a column to the specified drop target.
         * ```typescript
         * grid.moveColumn(compName, persDetails);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} column
         * @param {?} dropTarget
         * @param {?=} pos
         * @return {?}
         */

      }, {
        key: "moveColumn",
        value: function moveColumn(column, dropTarget) {
          var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DropPosition.None;

          /** @type {?} */
          var position = pos;
          /** @type {?} */

          var fromIndex = column.visibleIndex;
          /** @type {?} */

          var toIndex = dropTarget.visibleIndex;

          if (pos === DropPosition.BeforeDropTarget && fromIndex < toIndex) {
            position = DropPosition.BeforeDropTarget;
          } else if (pos === DropPosition.AfterDropTarget && fromIndex > toIndex) {
            position = DropPosition.AfterDropTarget;
          } else {
            position = DropPosition.None;
          }

          if (column.level !== dropTarget.level || column.topLevelParent !== dropTarget.topLevelParent) {
            return;
          }

          this.endEdit(true);

          if (column.level) {
            this._moveChildColumns(column.parent, column, dropTarget, position);
          }

          if (dropTarget.pinned && column.pinned) {
            this._reorderPinnedColumns(column, dropTarget, position);
          }

          if (dropTarget.pinned && !column.pinned) {
            column.pin();

            this._reorderPinnedColumns(column, dropTarget, position);
          }

          if (!dropTarget.pinned && column.pinned) {
            column.unpin();
            /** @type {?} */

            var list = this.columnList.toArray();
            /** @type {?} */

            var fi = list.indexOf(column);
            /** @type {?} */

            var ti = list.indexOf(dropTarget);

            if (pos === DropPosition.BeforeDropTarget && fi < ti) {
              position = DropPosition.BeforeDropTarget;
            } else if (pos === DropPosition.AfterDropTarget && fi > ti) {
              position = DropPosition.AfterDropTarget;
            } else {
              position = DropPosition.None;
            }
          }

          this._moveColumns(column, dropTarget, position);

          this.notifyChanges();

          if (this.hasColumnLayouts) {
            this.columns.filter(function (x) {
              return x.columnLayout;
            }).forEach(function (x) {
              return x.populateVisibleIndexes();
            });
          }
          /** @type {?} */


          var args = {
            source: column,
            target: dropTarget
          };
          this.onColumnMovingEnd.emit(args);
        }
        /**
         * Goes to the desired page index.
         * ```typescript
         * this.grid1.paginate(1);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "paginate",
        value: function paginate(val) {
          if (val < 0 || val > this.totalPages - 1) {
            return;
          }

          this.page = val;
        }
        /**
         * Manually marks the `IgxGridComponent` for change detection.
         * ```typescript
         * this.grid1.markForCheck();
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "markForCheck",
        value: function markForCheck() {
          this.cdr.detectChanges();
        }
        /**
         * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
         * ```typescript
         * const record = {
         *     ID: this.grid1.data[this.grid1.data.length - 1].ID + 1,
         *     Name: this.newRecord
         * };
         * this.grid1.addRow(record);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "addRow",
        value: function addRow(data) {
          // commit pending states prior to adding a row
          this.endEdit(true);
          this.gridAPI.addRowToData(data);
          this.onRowAdded.emit({
            data: data
          });
          this._pipeTrigger++;
          this.notifyChanges();
        }
        /**
         * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
         * Requires that the `primaryKey` property is set.
         * The method accept rowSelector as a parameter, which is the rowID.
         * ```typescript
         * this.grid1.deleteRow(0);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} rowSelector
         * @return {?}
         */

      }, {
        key: "deleteRow",
        value: function deleteRow(rowSelector) {
          if (this.primaryKey !== undefined && this.primaryKey !== null) {
            this.deleteRowById(rowSelector);
          }
        }
        /**
         * @hidden
         * @param {?} rowId
         * @return {?}
         */

      }, {
        key: "deleteRowById",
        value: function deleteRowById(rowId) {
          this.gridAPI.deleteRowById(rowId);
        }
        /**
         * @hidden
         * @protected
         * @param {?} rowID
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "deleteRowFromData",
        value: function deleteRowFromData(rowID, index) {
          //  if there is a row (index !== 0) delete it
          //  if there is a row in ADD or UPDATE state change it's state to DELETE
          if (index !== -1) {
            if (this.transactions.enabled) {
              /** @type {?} */
              var transaction = {
                id: rowID,
                type: TransactionType.DELETE,
                newValue: null
              };
              this.transactions.add(transaction, this.data[index]);
            } else {
              this.data.splice(index, 1);
            }
          } else {
            /** @type {?} */
            var state = this.transactions.getState(rowID);
            this.transactions.add({
              id: rowID,
              type: TransactionType.DELETE,
              newValue: null
            }, state && state.recordRef);
          }
        }
        /**
         * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
         * Requires that the `primaryKey` property is set.
         * ```typescript
         * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value the new value which is to be set.
         * @param {?} rowSelector corresponds to rowID.
         * @param {?} column corresponds to column field.
         * @return {?}
         */

      }, {
        key: "updateCell",
        value: function updateCell(value, rowSelector, column) {
          if (this.isDefined(this.primaryKey)) {
            /** @type {?} */
            var col = this.columnList.toArray().find(function (c) {
              return c.field === column;
            });

            if (col) {
              // Simplify

              /** @type {?} */
              var rowData = this.gridAPI.getRowData(rowSelector);
              /** @type {?} */

              var index = this.gridAPI.get_row_index_in_data(rowSelector); // If row passed is invalid

              if (index < 0) {
                return;
              }
              /** @type {?} */


              var id = {
                rowID: rowSelector,
                columnID: col.index,
                rowIndex: index
              };
              /** @type {?} */

              var cell = new IgxCell(id, index, col, rowData[col.field], rowData[col.field], rowData);
              /** @type {?} */

              var args = this.gridAPI.update_cell(cell, value);

              if (this.crudService.cell && this.crudService.sameCell(cell)) {
                if (args.cancel) {
                  return;
                }

                this.gridAPI.escape_editMode();
              }

              this.cdr.detectChanges();
            }
          }
        }
        /**
         * Updates the `IgxGridRowComponent`, which is specified by
         * rowSelector parameter and the data source record with the passed value.
         * This method will apply requested update only if primary key is specified in the grid.
         * ```typescript
         * grid.updateRow({
         *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
         *   }, 1);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @param {?} rowSelector correspond to rowID
         * @return {?}
         */

      }, {
        key: "updateRow",
        value: function updateRow(value, rowSelector) {
          if (this.isDefined(this.primaryKey)) {
            /** @type {?} */
            var editableCell = this.crudService.cell;

            if (editableCell && editableCell.id.rowID === rowSelector) {
              this.gridAPI.escape_editMode();
            }
            /** @type {?} */


            var row = new IgxRow(rowSelector, -1, this.gridAPI.getRowData(rowSelector));
            this.gridAPI.update_row(row, value); // TODO: fix for #5934 and probably break for #5763
            // consider adding of third optional boolean parameter in updateRow.
            // If developer set this parameter to true we should call notifyChanges(true), and
            // vise-versa if developer set it to false we should call notifyChanges(false).
            // The parameter should default to false

            this.notifyChanges();
          }
        }
        /**
         * Sort a single `IgxColumnComponent`.
         * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
         * ```typescript
         * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} expression
         * @return {?}
         */

      }, {
        key: "sort",
        value: function sort(expression) {
          this.endEdit(false);

          if (expression instanceof Array) {
            this.gridAPI.sort_multiple(expression);
          } else {
            this.gridAPI.sort(expression);
          }

          this.onSortingDone.emit(expression);
        }
        /**
         * Filters a single `IgxColumnComponent`.
         * ```typescript
         * public filter(term) {
         *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} name
         * @param {?} value
         * @param {?=} conditionOrExpressionTree
         * @param {?=} ignoreCase
         * @return {?}
         */

      }, {
        key: "filter",
        value: function filter(name, value, conditionOrExpressionTree, ignoreCase) {
          this.filteringService.filter(name, value, conditionOrExpressionTree, ignoreCase);
        }
        /**
         * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
         * ```typescript
         * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @param {?} condition
         * @param {?=} ignoreCase
         * @return {?}
         */

      }, {
        key: "filterGlobal",
        value: function filterGlobal(value, condition, ignoreCase) {
          this.filteringService.filterGlobal(value, condition, ignoreCase);
        }
        /**
         * Enables summaries for the specified column and applies your customSummary.
         * If you do not provide the customSummary, then the default summary for the column data type will be applied.
         * ```typescript
         * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
         * ```
         * Enable summaries for the listed columns.
         * ```typescript
         * grid.enableSummaries('ProductName');
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {...?} rest
         * @return {?}
         */

      }, {
        key: "enableSummaries",
        value: function enableSummaries() {
          if (arguments.length === 1 && Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {
            this._multipleSummaries(arguments.length <= 0 ? undefined : arguments[0], true);
          } else {
            this._summaries(arguments.length <= 0 ? undefined : arguments[0], true, arguments.length <= 1 ? undefined : arguments[1]);
          }
        }
        /**
         * Disable summaries for the specified column.
         * ```typescript
         * grid.disableSummaries('ProductName');
         * ```
         *
         * Disable summaries for the listed columns.
         * ```typescript
         * grid.disableSummaries([{ fieldName: 'ProductName' }]);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {...?} rest
         * @return {?}
         */

      }, {
        key: "disableSummaries",
        value: function disableSummaries() {
          if (arguments.length === 1 && Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {
            this._disableMultipleSummaries(arguments.length <= 0 ? undefined : arguments[0]);
          } else {
            this._summaries(arguments.length <= 0 ? undefined : arguments[0], false);
          }
        }
        /**
         * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`,
         * otherwise clears the filtering state of all `IgxColumnComponent`s.
         * ```typescript
         * this.grid.clearFilter();
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?=} name
         * @return {?}
         */

      }, {
        key: "clearFilter",
        value: function clearFilter(name) {
          this.filteringService.clearFilter(name);
        }
        /**
         * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`,
         * otherwise clears the sorting state of all `IgxColumnComponent`.
         * ```typescript
         * this.grid.clearSort();
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?=} name
         * @return {?}
         */

      }, {
        key: "clearSort",
        value: function clearSort(name) {
          if (!name) {
            this.sortingExpressions = [];
            return;
          }

          if (!this.gridAPI.get_column_by_name(name)) {
            return;
          }

          this.gridAPI.clear_sort(name);
        }
        /**
         * @hidden
         * @param {?=} args
         * @return {?}
         */

      }, {
        key: "refreshGridState",
        value: function refreshGridState(args) {
          this.endEdit(true);
          this.selectionService.clearHeaderCBState();
          this.summaryService.clearSummaryCache(args);
        } // TODO: We have return values here. Move them to event args ??

        /**
         * Pins a column by field name. Returns whether the operation is successful.
         * ```typescript
         * this.grid.pinColumn("ID");
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} columnName
         * @param {?=} index
         * @return {?}
         */

      }, {
        key: "pinColumn",
        value: function pinColumn(columnName, index) {
          /** @type {?} */
          var col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
          return col.pin(index);
        }
        /**
         * Unpins a column by field name. Returns whether the operation is successful.
         * ```typescript
         * this.grid.pinColumn("ID");
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} columnName
         * @param {?=} index
         * @return {?}
         */

      }, {
        key: "unpinColumn",
        value: function unpinColumn(columnName, index) {
          /** @type {?} */
          var col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
          return col.unpin(index);
        }
        /**
         * Recalculates grid width/height dimensions. Should be run when changing DOM elements dimentions manually that affect the grid's size.
         * ```typescript
         * this.grid.reflow();
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "reflow",
        value: function reflow() {
          this.calculateGridSizes();
        }
        /**
         * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
         * Returns how many times the grid contains the string.
         * ```typescript
         * this.grid.findNext("financial");
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} text the string to search.
         * @param {?=} caseSensitive optionally, if the search should be case sensitive (defaults to false).
         * @param {?=} exactMatch optionally, if the text should match the entire value  (defaults to false).
         * @return {?}
         */

      }, {
        key: "findNext",
        value: function findNext(text, caseSensitive, exactMatch) {
          return this.find(text, 1, caseSensitive, exactMatch);
        }
        /**
         * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
         * Returns how many times the grid contains the string.
         * ```typescript
         * this.grid.findPrev("financial");
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} text the string to search.
         * @param {?=} caseSensitive optionally, if the search should be case sensitive (defaults to false).
         * @param {?=} exactMatch optionally, if the text should match the entire value (defaults to false).
         * @return {?}
         */

      }, {
        key: "findPrev",
        value: function findPrev(text, caseSensitive, exactMatch) {
          return this.find(text, -1, caseSensitive, exactMatch);
        }
        /**
         * Reapplies the existing search.
         * Returns how many times the grid contains the last search.
         * ```typescript
         * this.grid.refreshSearch();
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?=} updateActiveInfo
         * @return {?}
         */

      }, {
        key: "refreshSearch",
        value: function refreshSearch(updateActiveInfo) {
          var _this265 = this;

          if (this.lastSearchInfo.searchText) {
            this.rebuildMatchCache();

            if (updateActiveInfo) {
              /** @type {?} */
              var activeInfo = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
              this.lastSearchInfo.matchInfoCache.forEach(function (match, i) {
                if (match.column === activeInfo.column && match.row === activeInfo.row && match.index === activeInfo.index) {
                  _this265.lastSearchInfo.activeMatchIndex = i;
                }
              });
            }

            return this.find(this.lastSearchInfo.searchText, 0, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch, false);
          } else {
            return 0;
          }
        }
        /**
         * Removes all the highlights in the cell.
         * ```typescript
         * this.grid.clearSearch();
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "clearSearch",
        value: function clearSearch() {
          this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
          };
          this.rowList.forEach(function (row) {
            if (row.cells) {
              row.cells.forEach(function (c) {
                c.clearHighlight();
              });
            }
          });
        }
        /**
         * Returns if the `IgxGridComponent` has sortable columns.
         * ```typescript
         * const sortableGrid = this.grid.hasSortableColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "_derivePossibleWidth",

        /**
         * @hidden
         * Sets columns defaultWidth property
         * @protected
         * @return {?}
         */
        value: function _derivePossibleWidth() {
          var _this266 = this;

          if (!this.columnWidthSetByUser) {
            this._columnWidth = this.width !== null ? this.getPossibleColumnWidth() : MINIMUM_COLUMN_WIDTH + 'px';
          }

          this.columnList.forEach(function (column) {
            if (_this266.hasColumnLayouts && parseInt(_this266._columnWidth, 10)) {
              /** @type {?} */
              var columnWidthCombined = parseInt(_this266._columnWidth, 10) * (column.colEnd ? column.colEnd - column.colStart : 1);
              column.defaultWidth = columnWidthCombined + 'px';
            } else {
              column.defaultWidth = _this266._columnWidth;
              column.resetCaches();
            }
          });
          this.resetCachedWidths();
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "calcGridHeadRow",

        /**
         * @hidden
         * \@internal
         * @protected
         * @return {?}
         */
        value: function calcGridHeadRow() {
          if (this.maxLevelHeaderDepth) {
            this._baseFontSize = parseFloat(getComputedStyle(this.document.documentElement).getPropertyValue('font-size'));
            /** @type {?} */

            var minSize = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight / this._baseFontSize;

            if (this._allowFiltering && this._filterMode === FilterMode.quickFilter) {
              minSize += (FILTER_ROW_HEIGHT + 1) / this._baseFontSize;
            }

            this.theadRow.nativeElement.style.minHeight = "".concat(minSize, "rem");
          }
        }
        /**
         * @hidden
         * Sets TBODY height i.e. this.calcHeight
         * @protected
         * @return {?}
         */

      }, {
        key: "calculateGridHeight",
        value: function calculateGridHeight() {
          this.calcGridHeadRow();
          this.summariesHeight = 0;

          if (this.hasSummarizedColumns && this.rootSummariesEnabled) {
            this.summariesHeight = this.summaryService.calcMaxSummaryHeight();
          }

          this.calcHeight = this._calculateGridBodyHeight();
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "getGroupAreaHeight",
        value: function getGroupAreaHeight() {
          return 0;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "getToolbarHeight",
        value: function getToolbarHeight() {
          /** @type {?} */
          var toolbarHeight = 0;

          if (this.showToolbar && this.toolbarHtml != null) {
            toolbarHeight = this.toolbarHtml.nativeElement.firstElementChild ? this.toolbarHtml.nativeElement.offsetHeight : 0;
          }

          return toolbarHeight;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "getPagingHeight",
        value: function getPagingHeight() {
          /** @type {?} */
          var pagingHeight = 0;

          if (this.paging && this.footer) {
            pagingHeight = this.footer.nativeElement.firstElementChild ? this.footer.nativeElement.offsetHeight : 0;
          }

          return pagingHeight;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "getFilterCellHeight",
        value: function getFilterCellHeight() {
          /** @type {?} */
          var headerGroupNativeEl = this.headerGroupsList.length !== 0 ? this.headerGroupsList[0].element.nativeElement : null;
          /** @type {?} */

          var filterCellNativeEl = headerGroupNativeEl ? headerGroupNativeEl.querySelector('igx-grid-filtering-cell') : null;
          return filterCellNativeEl ? filterCellNativeEl.offsetHeight : 0;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "_calculateGridBodyHeight",
        value: function _calculateGridBodyHeight() {
          if (!this._height) {
            return null;
          }
          /** @type {?} */


          var actualTheadRow = !this.allowFiltering || this.allowFiltering && this.filterMode !== FilterMode.quickFilter ? this.theadRow.nativeElement.offsetHeight - this.getFilterCellHeight() : this.theadRow.nativeElement.offsetHeight;
          /** @type {?} */

          var footerHeight = this.summariesHeight || this.tfoot.nativeElement.offsetHeight - this.tfoot.nativeElement.clientHeight;
          /** @type {?} */

          var toolbarHeight = this.getToolbarHeight();
          /** @type {?} */

          var pagingHeight = this.getPagingHeight();
          /** @type {?} */

          var groupAreaHeight = this.getGroupAreaHeight();
          /** @type {?} */

          var renderedHeight = toolbarHeight + actualTheadRow + footerHeight + pagingHeight + groupAreaHeight + this.scr.nativeElement.clientHeight;
          /** @type {?} */

          var computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('height');
          /** @type {?} */

          var gridHeight = 0;

          if (this.isPercentHeight) {
            /** @type {?} */
            var autoSize = this._shouldAutoSize(renderedHeight);

            if (autoSize || computed.indexOf('%') !== -1) {
              /** @type {?} */
              var bodyHeight = this.getDataBasedBodyHeight();
              return bodyHeight > 0 ? bodyHeight : null;
            }

            gridHeight = parseInt(computed, 10);
          } else {
            gridHeight = parseInt(this._height, 10);
          }
          /** @type {?} */


          var height = Math.abs(gridHeight - renderedHeight);

          if (height === 0 || isNaN(gridHeight)) {
            /** @type {?} */
            var _bodyHeight = this.defaultTargetBodyHeight;
            return _bodyHeight > 0 ? _bodyHeight : null;
          }

          return height;
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "checkContainerSizeChange",
        value: function checkContainerSizeChange() {
          /** @type {?} */
          var origHeight = this.nativeElement.parentElement.offsetHeight;
          this.nativeElement.style.display = 'none';
          /** @type {?} */

          var height = this.nativeElement.parentElement.offsetHeight;
          this.nativeElement.style.display = '';
          return origHeight !== height;
        }
        /**
         * @protected
         * @param {?} renderedHeight
         * @return {?}
         */

      }, {
        key: "_shouldAutoSize",
        value: function _shouldAutoSize(renderedHeight) {
          this.tbody.nativeElement.style.display = 'none';
          /** @type {?} */

          var res = !this.nativeElement.parentElement || this.nativeElement.parentElement.clientHeight === 0 || this.nativeElement.parentElement.clientHeight === renderedHeight;

          if (!isChromium()) {
            // If grid causes the parent container to extend (for example when container is flex)
            // we should always auto-size since the actual size of the container will continuously change as the grid renders elements.
            res = this.checkContainerSizeChange();
          }

          this.tbody.nativeElement.style.display = '';
          return res;
        }
        /**
         * @return {?}
         */

      }, {
        key: "getVisibleContentHeight",

        /**
         * @hidden
         * Gets the visible content height that includes header + tbody + footer.
         * @return {?}
         */
        value: function getVisibleContentHeight() {
          /** @type {?} */
          var height = this.theadRow.nativeElement.clientHeight + this.tbody.nativeElement.clientHeight;

          if (this.hasSummarizedColumns) {
            height += this.tfoot.nativeElement.clientHeight;
          }

          return height;
        }
        /**
         * @hidden
         * @param {?=} baseWidth
         * @return {?}
         */

      }, {
        key: "getPossibleColumnWidth",
        value: function getPossibleColumnWidth() {
          var baseWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          /** @type {?} */
          var computedWidth;

          if (baseWidth !== null) {
            computedWidth = baseWidth;
          } else {
            computedWidth = this.calcWidth || parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);
          }

          computedWidth -= this.getFeatureColumnsWidth();

          if (this.showDragIcons) {
            computedWidth -= this.headerDragContainer ? this.headerDragContainer.nativeElement.offsetWidth : 0;
          }
          /** @type {?} */


          var visibleChildColumns = this.visibleColumns.filter(function (c) {
            return !c.columnGroup;
          }); // Column layouts related

          /** @type {?} */

          var visibleCols = [];
          /** @type {?} */

          var columnBlocks = this.visibleColumns.filter(function (c) {
            return c.columnGroup;
          });
          /** @type {?} */

          var colsPerBlock = columnBlocks.map(function (block) {
            return block.getInitialChildColumnSizes(block.children);
          });
          /** @type {?} */

          var combinedBlocksSize = colsPerBlock.reduce(function (acc, item) {
            return acc + item.length;
          }, 0);
          colsPerBlock.forEach(function (blockCols) {
            return visibleCols = visibleCols.concat(blockCols);
          }); //

          /** @type {?} */

          var columnsWithSetWidths = this.hasColumnLayouts ? visibleCols.filter(function (c) {
            return c.widthSetByUser;
          }) : visibleChildColumns.filter(function (c) {
            return c.widthSetByUser;
          });
          /** @type {?} */

          var columnsToSize = this.hasColumnLayouts ? combinedBlocksSize - columnsWithSetWidths.length : visibleChildColumns.length - columnsWithSetWidths.length;
          /** @type {?} */

          var sumExistingWidths = columnsWithSetWidths.reduce(function (prev, curr) {
            /** @type {?} */
            var colWidth = curr.width;
            /** @type {?} */

            var widthValue = parseInt(colWidth, 10);
            /** @type {?} */

            var currWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1 ? widthValue / 100 * computedWidth : widthValue;
            return prev + currWidth;
          }, 0); // When all columns are hidden, return 0px width

          if (!sumExistingWidths && !columnsToSize) {
            return '0px';
          }
          /** @type {?} */


          var columnWidth = Math.floor(!Number.isFinite(sumExistingWidths) ? Math.max(computedWidth / columnsToSize, MINIMUM_COLUMN_WIDTH) : Math.max((computedWidth - sumExistingWidths) / columnsToSize, MINIMUM_COLUMN_WIDTH));
          return columnWidth.toString();
        }
        /**
         * @hidden
         * Sets grid width i.e. this.calcWidth
         * @protected
         * @return {?}
         */

      }, {
        key: "calculateGridWidth",
        value: function calculateGridWidth() {
          /** @type {?} */
          var width;
          /** @type {?} */

          var computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width');

          if (this.isPercentWidth) {
            /* width in %*/
            width = computed.indexOf('%') === -1 ? parseInt(computed, 10) : null;
          } else {
            width = parseInt(this.width, 10);
          }

          if (!width && this.nativeElement) {
            width = this.nativeElement.offsetWidth;
          }

          if (this.width === null || !width) {
            width = this.getColumnWidthSum();
          }

          if (this.hasVerticalSroll() && this.width !== null) {
            width -= this.scrollWidth;
          }

          if ((Number.isFinite(width) || width === null) && width !== this.calcWidth) {
            this.calcWidth = width;
          }

          this._derivePossibleWidth();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getColumnWidthSum",
        value: function getColumnWidthSum() {
          /** @type {?} */
          var colSum = 0;
          /** @type {?} */

          var cols = this.hasColumnLayouts ? this.visibleColumns.filter(function (x) {
            return x.columnLayout;
          }) : this.visibleColumns.filter(function (x) {
            return !x.columnGroup;
          });
          cols.forEach(function (item) {
            /** @type {?} */
            var isWidthInPercent = item.width && typeof item.width === 'string' && item.width.indexOf('%') !== -1;

            if (isWidthInPercent) {
              item.width = item.calcWidth || MINIMUM_COLUMN_WIDTH + 'px';
            }

            colSum += parseInt(item.width || item.defaultWidth, 10) || MINIMUM_COLUMN_WIDTH;
          });

          if (!colSum) {
            return null;
          }

          this.cdr.detectChanges();
          colSum += this.getFeatureColumnsWidth();
          return colSum;
        }
        /**
         * @return {?}
         */

      }, {
        key: "hasVerticalSroll",
        value: function hasVerticalSroll() {
          if (this._init) {
            return false;
          }
          /** @type {?} */


          var isScrollable = this.verticalScrollContainer ? this.verticalScrollContainer.isScrollable() : false;
          return !!(this.calcWidth && this.dataView && this.dataView.length > 0 && isScrollable);
        }
        /**
         * @hidden \@internal
         * @protected
         * @return {?}
         */

      }, {
        key: "getDataBasedBodyHeight",
        value: function getDataBasedBodyHeight() {
          return !this.data || this.data.length < this._defaultTargetRecordNumber ? 0 : this.defaultTargetBodyHeight;
        }
        /**
         * @hidden
         * @protected
         * @param {?} change
         * @return {?}
         */

      }, {
        key: "onColumnsChanged",
        value: function onColumnsChanged(change) {
          var _this267 = this;

          /** @type {?} */
          var diff = this.columnListDiffer.diff(change);

          if (diff) {
            /** @type {?} */
            var added = false;
            /** @type {?} */

            var removed = false;
            this.initColumns(this.columnList);
            diff.forEachAddedItem(function (record) {
              _this267.onColumnInit.emit(record.item);

              added = true;
            });
            diff.forEachRemovedItem(function (record) {
              /** @type {?} */
              var isColumnGroup = record.item instanceof IgxColumnGroupComponent;

              if (!isColumnGroup) {
                // Clear Grouping
                _this267.gridAPI.clear_groupby(record.item.field); // Clear Filtering


                _this267.gridAPI.clear_filter(record.item.field); // Close filter row


                if (_this267.filteringService.isFilterRowVisible && _this267.filteringService.filteredColumn && _this267.filteringService.filteredColumn.field === record.item.field) {
                  _this267.filteringRow.close();
                } // Clear Sorting


                _this267.gridAPI.clear_sort(record.item.field);
              }

              removed = true;
            });
            this.resetCaches();

            if (added || removed) {
              this.summaryService.clearSummaryCache();
              Promise.resolve().then(function () {
                // `onColumnsChanged` can be executed midway a current detectChange cycle and markForCheck will be ignored then.
                // This ensures that we will wait for the current cycle to end so we can trigger a new one and ngDoCheck to fire.
                _this267.notifyChanges(true);
              });
            }
          }
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "calculateGridSizes",
        value: function calculateGridSizes() {
          var _this268 = this;

          /*
              TODO: (R.K.) This layered lasagne should be refactored
              ASAP. The reason I have to reset the caches so many times is because
              after teach `detectChanges` call they are filled with invalid
              state. Of course all of this happens midway through the grid
              sizing process which of course, uses values from the caches, thus resulting
              in a broken layout.
          */
          this.resetCaches();
          this.cdr.detectChanges();
          /** @type {?} */

          var hasScroll = this.hasVerticalSroll();
          this.calculateGridWidth();
          this.resetCaches();
          this.cdr.detectChanges();
          this.calculateGridHeight();

          if (this.rowEditable) {
            this.repositionRowEditingOverlay(this.rowInEditMode);
          }

          if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.resetChipsArea();
          }

          this.cdr.detectChanges(); // in case scrollbar has appeared recalc to size correctly.

          if (hasScroll !== this.hasVerticalSroll()) {
            this.calculateGridWidth();
            this.cdr.detectChanges();
          }

          if (this.zone.isStable) {
            this.zone.run(function () {
              _this268._applyWidthHostBinding();

              _this268.cdr.detectChanges();
            });
          } else {
            this.zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              _this268.zone.run(function () {
                _this268._applyWidthHostBinding();
              });
            });
          }

          this.resetCaches();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_applyWidthHostBinding",
        value: function _applyWidthHostBinding() {
          /** @type {?} */
          var width = this._width;

          if (width === null) {
            /** @type {?} */
            var currentWidth = this.calcWidth;

            if (this.hasVerticalSroll()) {
              currentWidth += this.scrollWidth;
            }

            width = currentWidth + 'px';
            this.resetCaches();
          }

          this._hostWidth = width;
          this.cdr.markForCheck();
        }
        /**
         * @hidden
         * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
         * Method used to override the calculations.
         * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
         * @return {?}
         */

      }, {
        key: "getFeatureColumnsWidth",
        value: function getFeatureColumnsWidth() {
          /** @type {?} */
          var width = 0;

          if (this.isRowSelectable) {
            width += this.headerSelectorContainer ? this.headerSelectorContainer.nativeElement.getBoundingClientRect().width : 0;
          }

          if (this.rowDraggable) {
            width += this.headerDragContainer ? this.headerDragContainer.nativeElement.getBoundingClientRect().width : 0;
          }

          return width;
        }
        /**
         * Gets calculated width of the pinned area.
         * ```typescript
         * const pinnedWidth = this.grid.getPinnedWidth();
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
         * @return {?}
         */

      }, {
        key: "getPinnedWidth",
        value: function getPinnedWidth() {
          var takeHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          /** @type {?} */
          var fc = takeHidden ? this._pinnedColumns : this.pinnedColumns;
          /** @type {?} */

          var sum = 0;
          var _iteratorNormalCompletion55 = true;
          var _didIteratorError55 = false;
          var _iteratorError55 = undefined;

          try {
            for (var _iterator55 = fc[Symbol.iterator](), _step55; !(_iteratorNormalCompletion55 = (_step55 = _iterator55.next()).done); _iteratorNormalCompletion55 = true) {
              var col = _step55.value;

              if (col.level === 0) {
                sum += parseInt(col.calcWidth, 10);
              }
            }
          } catch (err) {
            _didIteratorError55 = true;
            _iteratorError55 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion55 && _iterator55["return"] != null) {
                _iterator55["return"]();
              }
            } finally {
              if (_didIteratorError55) {
                throw _iteratorError55;
              }
            }
          }

          sum += this.featureColumnsWidth;
          return sum;
        }
        /**
         * @hidden
         * Gets calculated width of the unpinned area
         * \@memberof IgxGridBaseComponent
         * @protected
         * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
         * @return {?}
         */

      }, {
        key: "getUnpinnedWidth",
        value: function getUnpinnedWidth() {
          var takeHidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          /** @type {?} */
          var width = this.isPercentWidth ? this.calcWidth : parseInt(this.width, 10) || parseInt(this.hostWidth, 10) || this.calcWidth;

          if (this.hasVerticalSroll() && !this.isPercentWidth) {
            width -= this.scrollWidth;
          }

          return width - this.getPinnedWidth(takeHidden);
        }
        /**
         * @hidden
         * @protected
         * @param {?} fieldName
         * @param {?} hasSummary
         * @param {?=} summaryOperand
         * @return {?}
         */

      }, {
        key: "_summaries",
        value: function _summaries(fieldName, hasSummary, summaryOperand) {
          /** @type {?} */
          var column = this.gridAPI.get_column_by_name(fieldName);

          if (column) {
            column.hasSummary = hasSummary;

            if (summaryOperand) {
              if (this.rootSummariesEnabled) {
                this.summaryService.retriggerRootPipe++;
              }

              column.summaries = summaryOperand;
            }
          }
        }
        /**
         * @hidden
         * @protected
         * @param {?} expressions
         * @param {?} hasSummary
         * @return {?}
         */

      }, {
        key: "_multipleSummaries",
        value: function _multipleSummaries(expressions, hasSummary) {
          var _this269 = this;

          expressions.forEach(function (element) {
            _this269._summaries(element.fieldName, hasSummary, element.customSummary);
          });
        }
        /**
         * @hidden
         * @protected
         * @param {?} expressions
         * @return {?}
         */

      }, {
        key: "_disableMultipleSummaries",
        value: function _disableMultipleSummaries(expressions) {
          var _this270 = this;

          expressions.forEach(function (column) {
            /** @type {?} */
            var columnName = column && column.fieldName ? column.fieldName : column;

            _this270._summaries(columnName, false);
          });
        }
        /**
         * @hidden
         * @protected
         * @param {?} rec
         * @return {?}
         */

      }, {
        key: "resolveDataTypes",
        value: function resolveDataTypes(rec) {
          if (typeof rec === 'number') {
            return DataType.Number;
          } else if (typeof rec === 'boolean') {
            return DataType.Boolean;
          } else if (typeof rec === 'object' && rec instanceof Date) {
            return DataType.Date;
          }

          return DataType.String;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getScrollWidth",
        value: function getScrollWidth() {
          /** @type {?} */
          var div = document.createElement('div');
          /** @type {?} */

          var style = div.style;
          style.width = '100px';
          style.height = '100px';
          style.position = 'absolute';
          style.top = '-10000px';
          style.top = '-10000px';
          style.overflow = 'scroll';
          document.body.appendChild(div);
          /** @type {?} */

          var scrollWidth = div.offsetWidth - div.clientWidth;
          document.body.removeChild(div);
          return scrollWidth;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "autogenerateColumns",
        value: function autogenerateColumns() {
          var _this271 = this;

          /** @type {?} */
          var data = this.gridAPI.get_data();
          /** @type {?} */

          var factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
          /** @type {?} */

          var fields = this.generateDataFields(data);
          /** @type {?} */

          var columns = [];
          fields.forEach(function (field) {
            /** @type {?} */
            var ref = factory.create(_this271.viewRef.injector);
            ref.instance.field = field;
            ref.instance.dataType = _this271.resolveDataTypes(data[0][field]);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
          });
          this.columnList.reset(columns);

          if (data && data.length > 0) {
            this.shouldGenerate = false;
          }
        }
        /**
         * @protected
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "generateDataFields",
        value: function generateDataFields(data) {
          return Object.keys(data && data.length !== 0 ? data[0] : []);
        }
        /**
         * @hidden
         * @param {?} arr
         * @return {?}
         */

      }, {
        key: "onlyTopLevel",
        value: function onlyTopLevel(arr) {
          return arr.filter(function (c) {
            return c.level === 0;
          });
        }
        /**
         * @hidden
         * @protected
         * @param {?} collection
         * @param {?=} cb
         * @return {?}
         */

      }, {
        key: "initColumns",
        value: function initColumns(collection) {
          var _this272 = this;

          var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          this._columnGroups = this.columnList.some(function (col) {
            return col.columnGroup;
          });

          if (this.hasColumnLayouts) {
            // Set overall row layout size
            this.columnList.forEach(function (col) {
              if (col.columnLayout) {
                /** @type {?} */
                var layoutSize = col.children ? col.children.reduce(function (acc, val) {
                  return Math.max(val.rowStart + val.gridRowSpan - 1, acc);
                }, 1) : 1;
                _this272._multiRowLayoutRowSize = Math.max(layoutSize, _this272._multiRowLayoutRowSize);
              }
            });
          }

          if (this.hasColumnLayouts && this.hasColumnGroups) {
            // invalid configuration - multi-row and column groups
            // remove column groups

            /** @type {?} */
            var columnLayoutColumns = this.columnList.filter(function (col) {
              return col.columnLayout || col.columnLayoutChild;
            });
            this.columnList.reset(columnLayoutColumns);
          }

          this._maxLevelHeaderDepth = null;
          this._columns = this.columnList.toArray();
          collection.forEach(function (column) {
            column.defaultWidth = _this272.columnWidthSetByUser ? _this272._columnWidth : column.defaultWidth ? column.defaultWidth : '';

            if (cb) {
              cb(column);
            }
          });
          this.reinitPinStates();

          if (this.hasColumnLayouts) {
            collection.forEach(function (column) {
              column.populateVisibleIndexes();
            });
          }
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "reinitPinStates",
        value: function reinitPinStates() {
          var _this273 = this;

          this._pinnedColumns = this.hasColumnGroups ? this.columnList.filter(function (c) {
            return c.pinned;
          }) : this.columnList.filter(function (c) {
            return c.pinned;
          }).sort(function (a, b) {
            return _this273._pinnedColumns.indexOf(a) - _this273._pinnedColumns.indexOf(b);
          });
          this._unpinnedColumns = this.columnList.filter(function (c) {
            return !c.pinned;
          });
        }
        /**
         * @hidden
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "isColumnGrouped",
        value: function isColumnGrouped(fieldName) {
          return false;
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onHeaderSelectorClick",
        value: function onHeaderSelectorClick(event) {
          if (!this.isMultiRowSelectionEnabled) {
            return;
          }

          this.selectionService.areAllRowSelected() ? this.selectionService.clearRowSelection(event) : this.selectionService.selectAllRows(event);
        }
        /**
         * @hidden
         * \@internal
         * @param {?} rec
         * @return {?}
         */

      }, {
        key: "isGroupByRecord",
        value: function isGroupByRecord(rec) {
          return false;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "selectedRows",

        /**
         * Get current selection state.
         * Returns an array with selected rows' IDs (primaryKey or rowData)
         * ```typescript
         * const selectedRows = this.grid.selectedRows();
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        value: function selectedRows() {
          return this.selectionService.getSelectedRows();
        }
        /**
         * Select specified rows by ID.
         * ```typescript
         * this.grid.selectRows([1,2,5], true);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} rowIDs
         * @param {?=} clearCurrentSelection if true clears the current selection
         * @return {?}
         */

      }, {
        key: "selectRows",
        value: function selectRows(rowIDs, clearCurrentSelection) {
          this.selectionService.selectRowsWithNoEvent(rowIDs, clearCurrentSelection);
          this.notifyChanges();
        }
        /**
         * Deselect specified rows by ID.
         * ```typescript
         * this.grid.deselectRows([1,2,5]);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} rowIDs
         * @return {?}
         */

      }, {
        key: "deselectRows",
        value: function deselectRows(rowIDs) {
          this.selectionService.deselectRowsWithNoEvent(rowIDs);
          this.notifyChanges();
        }
        /**
         * Selects all rows
         * Note: By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
         * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
         * ```typescript
         * this.grid.selectAllRows();
         * this.grid.selectAllRows(false);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?=} onlyFilterData
         * @return {?}
         */

      }, {
        key: "selectAllRows",
        value: function selectAllRows() {
          var _this274 = this;

          var onlyFilterData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          /** @type {?} */
          var data = onlyFilterData && this.filteredData ? this.filteredData : this.gridAPI.get_all_data(true);
          /** @type {?} */

          var rowIDs = this.selectionService.getRowIDs(data).filter(function (rID) {
            return !_this274.gridAPI.row_deleted_transaction(rID);
          });
          this.selectRows(rowIDs);
        }
        /**
         * Deselects all rows
         * Note: By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
         * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
         * ```typescript
         * this.grid.deselectAllRows();
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?=} onlyFilterData
         * @return {?}
         */

      }, {
        key: "deselectAllRows",
        value: function deselectAllRows() {
          var onlyFilterData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          if (onlyFilterData && this.filteredData && this.filteredData.length > 0) {
            this.deselectRows(this.selectionService.getRowIDs(this.filteredData));
          } else {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges();
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "clearCellSelection",
        value: function clearCellSelection() {
          this.selectionService.clear(true);
          this.notifyChanges();
        }
        /**
         * @param {?} dir
         * @return {?}
         */

      }, {
        key: "dragScroll",
        value: function dragScroll(dir) {
          /** @type {?} */
          var scrollDelta = 48;
          /** @type {?} */

          var horizontal = this.headerContainer.getScroll();
          /** @type {?} */

          var vertical = this.verticalScrollContainer.getScroll();

          switch (dir) {
            case DragScrollDirection.LEFT:
              horizontal.scrollLeft -= scrollDelta;
              break;

            case DragScrollDirection.RIGHT:
              horizontal.scrollLeft += scrollDelta;
              break;

            case DragScrollDirection.TOP:
              vertical.scrollTop -= scrollDelta;
              break;

            case DragScrollDirection.BOTTOM:
              vertical.scrollTop += scrollDelta;
              break;

            case DragScrollDirection.BOTTOMLEFT:
              horizontal.scrollLeft -= scrollDelta;
              vertical.scrollTop += scrollDelta;
              break;

            case DragScrollDirection.BOTTOMRIGHT:
              horizontal.scrollLeft += scrollDelta;
              vertical.scrollTop += scrollDelta;
              break;

            case DragScrollDirection.TOPLEFT:
              horizontal.scrollLeft -= scrollDelta;
              vertical.scrollTop -= scrollDelta;
              break;

            case DragScrollDirection.TOPRIGHT:
              horizontal.scrollLeft += scrollDelta;
              vertical.scrollTop -= scrollDelta;
              break;

            default:
              return;
          }

          this.wheelHandler();
        }
        /**
         * @param {?} arg
         * @return {?}
         */

      }, {
        key: "isDefined",
        value: function isDefined(arg) {
          return arg !== undefined && arg !== null;
        }
        /**
         * @param {?} arg
         * @return {?}
         */

      }, {
        key: "selectRange",
        value: function selectRange(arg) {
          var _this275 = this;

          if (!this.isDefined(arg)) {
            this.clearCellSelection();
            return;
          }

          if (arg instanceof Array) {
            arg.forEach(function (range) {
              return _this275.setSelection(range);
            });
          } else {
            this.setSelection(arg);
          }

          this.notifyChanges();
        }
        /**
         * @param {?} field
         * @return {?}
         */

      }, {
        key: "columnToVisibleIndex",
        value: function columnToVisibleIndex(field) {
          /** @type {?} */
          var visibleColumns = this.visibleColumns;

          if (typeof field === 'number') {
            return field;
          }

          return visibleColumns.find(function (column) {
            return column.field === field;
          }).visibleIndex;
        }
        /**
         * @param {?} range
         * @return {?}
         */

      }, {
        key: "setSelection",
        value: function setSelection(range) {
          /** @type {?} */
          var startNode = {
            row: range.rowStart,
            column: this.columnToVisibleIndex(range.columnStart)
          };
          /** @type {?} */

          var endNode = {
            row: range.rowEnd,
            column: this.columnToVisibleIndex(range.columnEnd)
          };
          this.selectionService.pointerState.node = startNode;
          this.selectionService.selectRange(endNode, this.selectionService.pointerState);
          this.selectionService.addRangeMeta(endNode, this.selectionService.pointerState);
          this.selectionService.initPointerState();
        }
        /**
         * @return {?}
         */

      }, {
        key: "getSelectedRanges",
        value: function getSelectedRanges() {
          return this.selectionService.ranges;
        }
        /**
         * @protected
         * @param {?} source
         * @param {?=} formatters
         * @param {?=} headers
         * @return {?}
         */

      }, {
        key: "extractDataFromSelection",
        value: function extractDataFromSelection(source) {
          var _this276 = this;

          var formatters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          /** @type {?} */
          var columnsArray;
          /** @type {?} */

          var record = {};
          /** @type {?} */

          var selectedData = [];
          /** @type {?} */

          var activeEl = this.selectionService.activeElement;
          /** @type {?} */

          var selectionMap = Array.from(this.selectionService.selection).filter(function (tuple) {
            return tuple[0] < source.length;
          });

          if (this.cellSelection === GridSelectionMode.single && activeEl) {
            selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);
          }

          var _iteratorNormalCompletion56 = true;
          var _didIteratorError56 = false;
          var _iteratorError56 = undefined;

          try {
            var _loop6 = function _loop6() {
              var _step56$value = _slicedToArray(_step56.value, 2),
                  row = _step56$value[0],
                  set = _step56$value[1];

              if (!source[row]) {
                return "continue";
              }
              /** @type {?} */


              var temp = Array.from(set);

              for (var _i23 = 0, _temp = temp; _i23 < _temp.length; _i23++) {
                var each = _temp[_i23];
                columnsArray = _this276.getSelectableColumnsAt(each);
                columnsArray.forEach(function (col) {
                  if (col) {
                    /** @type {?} */
                    var key = headers ? col.header || col.field : col.field;
                    record[key] = formatters && col.formatter ? col.formatter(source[row][col.field]) : source[row][col.field];
                  }
                });
              }

              if (Object.keys(record).length) {
                selectedData.push(record);
              }

              record = {};
            };

            for (var _iterator56 = selectionMap[Symbol.iterator](), _step56; !(_iteratorNormalCompletion56 = (_step56 = _iterator56.next()).done); _iteratorNormalCompletion56 = true) {
              var _ret3 = _loop6();

              if (_ret3 === "continue") continue;
            }
          } catch (err) {
            _didIteratorError56 = true;
            _iteratorError56 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion56 && _iterator56["return"] != null) {
                _iterator56["return"]();
              }
            } finally {
              if (_didIteratorError56) {
                throw _iteratorError56;
              }
            }
          }

          return selectedData;
        }
        /**
         * @protected
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "getSelectableColumnsAt",
        value: function getSelectableColumnsAt(index) {
          if (this.hasColumnLayouts) {
            /** @type {?} */
            var visibleLayoutColumns = this.visibleColumns.filter(function (col) {
              return col.columnLayout;
            }).sort(function (a, b) {
              return a.visibleIndex - b.visibleIndex;
            });
            /** @type {?} */

            var colLayout = visibleLayoutColumns[index];
            return colLayout ? colLayout.children.toArray() : [];
          } else {
            /** @type {?} */
            var visibleColumns = this.visibleColumns.filter(function (col) {
              return !col.columnGroup;
            }).sort(function (a, b) {
              return a.visibleIndex - b.visibleIndex;
            });
            return [visibleColumns[index]];
          }
        }
        /**
         *
         * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
         * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
         * If `headers` is enabled, it will use the column header (if any) instead of the column field.
         * @param {?=} formatters
         * @param {?=} headers
         * @return {?}
         */

      }, {
        key: "getSelectedData",
        value: function getSelectedData() {
          var formatters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          /** @type {?} */
          var source = this.dataView;
          return this.extractDataFromSelection(source, formatters, headers);
        }
        /**
         * @return {?}
         */

      }, {
        key: "copyHandlerIE",
        value: function copyHandlerIE() {
          if (isIE()) {
            this.copyHandler(null, true);
          }
        }
        /**
         * @hidden
         * \@internal
         * @param {?} event
         * @param {?=} ie11
         * @return {?}
         */

      }, {
        key: "copyHandler",
        value: function copyHandler(event) {
          var ie11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (!this.clipboardOptions.enabled || this.crudService.inEditMode) {
            return;
          }
          /** @type {?} */


          var data = this.getSelectedData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
          /** @type {?} */

          var ev =
          /** @type {?} */
          {
            data: data,
            cancel: false
          };
          this.onGridCopy.emit(ev);

          if (ev.cancel) {
            return;
          }
          /** @type {?} */


          var transformer = new CharSeparatedValueData(ev.data, this.clipboardOptions.separator);
          /** @type {?} */

          var result = transformer.prepareData();

          if (!this.clipboardOptions.copyHeaders) {
            result = result.substring(result.indexOf('\n') + 1);
          }

          if (ie11) {
            /** @type {?} */
            window.clipboardData.setData('Text', result);
            return;
          }

          event.preventDefault();
          /* Necessary for the hiearachical case but will probably have to
             change how getSelectedData is propagated in the hiearachical grid
          */

          event.stopPropagation();
          event.clipboardData.setData('text/plain', result);
        }
        /**
         * This method allows you to navigate to a position
         * in the grid based on provided `rowindex` and `visibleColumnIndex`,
         * also to execute a custom logic over the target element,
         * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
         * ```typescript
         *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} rowIndex
         * @param {?=} visibleColIndex
         * @param {?=} cb
         * @return {?}
         */

      }, {
        key: "navigateTo",
        value: function navigateTo(rowIndex) {
          var _this277 = this;

          var visibleColIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
          var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (rowIndex < 0 || rowIndex > this.dataView.length - 1 || visibleColIndex !== -1 && this.columnList.map(function (col) {
            return col.visibleIndex;
          }).indexOf(visibleColIndex) === -1) {
            return;
          }

          this.wheelHandler();

          if (this.dataView.slice(rowIndex, rowIndex + 1).find(function (rec) {
            return rec.expression || rec.childGridsData;
          })) {
            visibleColIndex = -1;
          }
          /** @type {?} */


          var shouldScrollVertically = this.navigation.shouldPerformVerticalScroll(rowIndex, visibleColIndex);
          /** @type {?} */

          var shouldScrollHorizontally = visibleColIndex !== -1 && !this.navigation.isColumnFullyVisible(visibleColIndex);

          if (shouldScrollVertically) {
            this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, function () {
              _this277.navigateTo(rowIndex, visibleColIndex, cb);
            });
          } else if (shouldScrollHorizontally) {
            this.navigation.performHorizontalScrollToCell(rowIndex, visibleColIndex, false, function () {
              _this277.navigateTo(rowIndex, visibleColIndex, cb);
            });
          } else {
            this.executeCallback(rowIndex, visibleColIndex, cb);
          }
        }
        /**
         * Returns `ICellPosition` which defines the next cell,
         * according to the current position, that match specific criteria.
         * You can pass callback function as a third parameter of `getPreviousCell` method.
         * The callback function accepts IgxColumnComponent as a param
         * ```typescript
         *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} currRowIndex
         * @param {?} curVisibleColIndex
         * @param {?=} callback
         * @return {?}
         */

      }, {
        key: "getNextCell",
        value: function getNextCell(currRowIndex, curVisibleColIndex) {
          var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          /** @type {?} */
          var columns = this.columnList.filter(function (col) {
            return !col.columnGroup && col.visibleIndex >= 0;
          });

          if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return {
              rowIndex: currRowIndex,
              visibleColumnIndex: curVisibleColIndex
            };
          }
          /** @type {?} */


          var colIndexes = callback ? columns.filter(function (col) {
            return callback(col);
          }).map(function (editCol) {
            return editCol.visibleIndex;
          }).sort(function (a, b) {
            return a - b;
          }) : columns.map(function (editCol) {
            return editCol.visibleIndex;
          }).sort(function (a, b) {
            return a - b;
          });
          /** @type {?} */

          var nextCellIndex = colIndexes.find(function (index) {
            return index > curVisibleColIndex;
          });

          if (this.dataView.slice(currRowIndex, currRowIndex + 1).find(function (rec) {
            return !rec.expression && !rec.summaries && !rec.childGridsData;
          }) && nextCellIndex !== undefined) {
            return {
              rowIndex: currRowIndex,
              visibleColumnIndex: nextCellIndex
            };
          } else {
            if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex) === currRowIndex) {
              return {
                rowIndex: currRowIndex,
                visibleColumnIndex: curVisibleColIndex
              };
            } else {
              return {
                rowIndex: this.getNextDataRowIndex(currRowIndex),
                visibleColumnIndex: colIndexes[0]
              };
            }
          }
        }
        /**
         * Returns `ICellPosition` which defines the previous cell,
         * according to the current position, that match specific criteria.
         * You can pass callback function as a third parameter of `getPreviousCell` method.
         * The callback function accepts IgxColumnComponent as a param
         * ```typescript
         *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} currRowIndex
         * @param {?} curVisibleColIndex
         * @param {?=} callback
         * @return {?}
         */

      }, {
        key: "getPreviousCell",
        value: function getPreviousCell(currRowIndex, curVisibleColIndex) {
          var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          /** @type {?} */
          var columns = this.columnList.filter(function (col) {
            return !col.columnGroup && col.visibleIndex >= 0;
          });

          if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return {
              rowIndex: currRowIndex,
              visibleColumnIndex: curVisibleColIndex
            };
          }
          /** @type {?} */


          var colIndexes = callback ? columns.filter(function (col) {
            return callback(col);
          }).map(function (editCol) {
            return editCol.visibleIndex;
          }).sort(function (a, b) {
            return b - a;
          }) : columns.map(function (editCol) {
            return editCol.visibleIndex;
          }).sort(function (a, b) {
            return b - a;
          });
          /** @type {?} */

          var prevCellIndex = colIndexes.find(function (index) {
            return index < curVisibleColIndex;
          });

          if (this.dataView.slice(currRowIndex, currRowIndex + 1).find(function (rec) {
            return !rec.expression && !rec.summaries && !rec.childGridsData;
          }) && prevCellIndex !== undefined) {
            return {
              rowIndex: currRowIndex,
              visibleColumnIndex: prevCellIndex
            };
          } else {
            if (colIndexes.length === 0 || this.getPrevDataRowIndex(currRowIndex) === currRowIndex) {
              return {
                rowIndex: currRowIndex,
                visibleColumnIndex: curVisibleColIndex
              };
            } else {
              return {
                rowIndex: this.getPrevDataRowIndex(currRowIndex),
                visibleColumnIndex: colIndexes[0]
              };
            }
          }
        }
        /**
         * @private
         * @param {?} rowIndex
         * @param {?=} visibleColIndex
         * @param {?=} cb
         * @return {?}
         */

      }, {
        key: "executeCallback",
        value: function executeCallback(rowIndex) {
          var visibleColIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
          var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (!cb) {
            return;
          }
          /** @type {?} */


          var targetType;
          /** @type {?} */

          var target;
          /** @type {?} */

          var row = this.summariesRowList.filter(function (s) {
            return s.index !== 0;
          }).concat(this.rowList.toArray()).find(function (r) {
            return r.index === rowIndex;
          });

          if (!row) {
            return;
          }

          switch (row.nativeElement.tagName.toLowerCase()) {
            case 'igx-grid-groupby-row':
              targetType = GridKeydownTargetType.groupRow;
              target = row;
              break;

            case 'igx-grid-summary-row':
              targetType = GridKeydownTargetType.summaryCell;
              target = visibleColIndex !== -1 ? row.summaryCells.find(function (c) {
                return c.visibleColumnIndex === visibleColIndex;
              }) : row.summaryCells.first;
              break;

            case 'igx-child-grid-row':
              targetType = GridKeydownTargetType.hierarchicalRow;
              target = row;
              break;

            default:
              targetType = GridKeydownTargetType.dataCell;
              target = visibleColIndex !== -1 ? row.cells.find(function (c) {
                return c.visibleColumnIndex === visibleColIndex;
              }) : row.cells.first;
              break;
          }
          /** @type {?} */


          var args = {
            targetType: targetType,
            target: target
          };
          cb(args);
        }
        /**
         * @private
         * @param {?} currentRowIndex
         * @return {?}
         */

      }, {
        key: "getPrevDataRowIndex",
        value: function getPrevDataRowIndex(currentRowIndex) {
          if (currentRowIndex <= 0) {
            return currentRowIndex;
          }
          /** @type {?} */


          var prevRow = this.dataView.slice(0, currentRowIndex).reverse().find(function (rec) {
            return !rec.expression && !rec.summaries && !rec.childGridsData;
          });
          return prevRow ? this.dataView.indexOf(prevRow) : currentRowIndex;
        }
        /**
         * @private
         * @param {?} currentRowIndex
         * @return {?}
         */

      }, {
        key: "getNextDataRowIndex",
        value: function getNextDataRowIndex(currentRowIndex) {
          if (currentRowIndex === this.dataView.length) {
            return currentRowIndex;
          }
          /** @type {?} */


          var nextRow = this.dataView.slice(currentRowIndex + 1, this.dataView.length).find(function (rec) {
            return !rec.expression && !rec.summaries && !rec.childGridsData;
          });
          return nextRow ? this.dataView.indexOf(nextRow) : currentRowIndex;
        }
        /**
         * @private
         * @param {?} rowIndex
         * @param {?} colIndex
         * @return {?}
         */

      }, {
        key: "isValidPosition",
        value: function isValidPosition(rowIndex, colIndex) {
          /** @type {?} */
          var rows = this.summariesRowList.filter(function (s) {
            return s.index !== 0;
          }).concat(this.rowList.toArray()).length;
          /** @type {?} */

          var cols = this.columnList.filter(function (col) {
            return !col.columnGroup && col.visibleIndex >= 0;
          }).length;

          if (rows < 1 || cols < 1) {
            return false;
          }

          if (rowIndex > -1 && rowIndex < this.dataView.length && colIndex > -1 && colIndex <= this.unpinnedColumns[this.unpinnedColumns.length - 1].visibleIndex) {
            return true;
          }

          return false;
        }
        /**
         * @hidden
         * @param {?} index
         * @param {?} col
         * @return {?}
         */

      }, {
        key: "trackColumnChanges",
        value: function trackColumnChanges(index, col) {
          return col.field + col._calcWidth;
        }
        /**
         * @private
         * @param {?} text
         * @param {?} increment
         * @param {?=} caseSensitive
         * @param {?=} exactMatch
         * @param {?=} scroll
         * @return {?}
         */

      }, {
        key: "find",
        value: function find(text, increment, caseSensitive, exactMatch, scroll) {
          if (!this.rowList) {
            return 0;
          }

          this.endEdit(false);

          if (!text) {
            this.clearSearch();
            return 0;
          }
          /** @type {?} */


          var caseSensitiveResolved = caseSensitive ? true : false;
          /** @type {?} */

          var exactMatchResolved = exactMatch ? true : false;
          /** @type {?} */

          var rebuildCache = false;

          if (this.lastSearchInfo.searchText !== text || this.lastSearchInfo.caseSensitive !== caseSensitiveResolved || this.lastSearchInfo.exactMatch !== exactMatchResolved) {
            this.lastSearchInfo = {
              searchText: text,
              activeMatchIndex: 0,
              caseSensitive: caseSensitiveResolved,
              exactMatch: exactMatchResolved,
              matchInfoCache: []
            };
            rebuildCache = true;
          } else {
            this.lastSearchInfo.activeMatchIndex += increment;
          }

          if (rebuildCache) {
            this.rowList.forEach(function (row) {
              if (row.cells) {
                row.cells.forEach(function (c) {
                  c.highlightText(text, caseSensitiveResolved, exactMatchResolved);
                });
              }
            });
            this.rebuildMatchCache();
          }

          if (this.lastSearchInfo.activeMatchIndex >= this.lastSearchInfo.matchInfoCache.length) {
            this.lastSearchInfo.activeMatchIndex = 0;
          } else if (this.lastSearchInfo.activeMatchIndex < 0) {
            this.lastSearchInfo.activeMatchIndex = this.lastSearchInfo.matchInfoCache.length - 1;
          }

          if (this.lastSearchInfo.matchInfoCache.length) {
            /** @type {?} */
            var matchInfo = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex];
            this.lastSearchInfo = Object.assign({}, this.lastSearchInfo);

            if (scroll !== false) {
              this.scrollTo(matchInfo.row, matchInfo.column);
            }

            IgxTextHighlightDirective.setActiveHighlight(this.id, {
              column: matchInfo.column,
              row: matchInfo.row,
              index: matchInfo.index
            });
          } else {
            IgxTextHighlightDirective.clearActiveHighlight(this.id);
          }

          return this.lastSearchInfo.matchInfoCache.length;
        }
        /**
         * Returns an array containing the filtered sorted data.
         * ```typescript
         * const filteredSortedData = this.grid1.filteredSortedData;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "initPinning",

        /**
         * @hidden
         * @protected
         * @return {?}
         */
        value: function initPinning() {
          /** @type {?} */
          var currentPinnedWidth = 0;
          /** @type {?} */

          var pinnedColumns = [];
          /** @type {?} */

          var unpinnedColumns = [];
          /** @type {?} */

          var newUnpinnedCols = [];
          this.calculateGridWidth();
          this.resetCaches(); // When a column is a group or is inside a group, pin all related.

          this._pinnedColumns.forEach(function (col) {
            if (col.parent) {
              col.parent.pinned = true;
            }

            if (col.columnGroup) {
              col.children.forEach(function (child) {
                return child.pinned = true;
              });
            }
          }); // Make sure we don't exceed unpinned area min width and get pinned and unpinned col collections.
          // We take into account top level columns (top level groups and non groups).
          // If top level is unpinned the pinning handles all children to be unpinned as well.


          for (var i = 0; i < this._columns.length; i++) {
            if (this._columns[i].pinned && !this._columns[i].parent) {
              // Pinned column. Check if with it the unpinned min width is exceeded.

              /** @type {?} */
              var colWidth = parseInt(this._columns[i].width, 10);

              if (currentPinnedWidth + colWidth > this.calcWidth - this.unpinnedAreaMinWidth) {
                // unpinned min width is exceeded. Unpin the columns and add it to the unpinned collection.
                this._columns[i].pinned = false;
                unpinnedColumns.push(this._columns[i]);
                newUnpinnedCols.push(this._columns[i]);
              } else {
                // unpinned min width is not exceeded. Keep it pinned and add it to the pinned collection.
                currentPinnedWidth += colWidth;
                pinnedColumns.push(this._columns[i]);
              }
            } else if (this._columns[i].pinned && this._columns[i].parent) {
              if (this._columns[i].topLevelParent.pinned) {
                pinnedColumns.push(this._columns[i]);
              } else {
                this._columns[i].pinned = false;
                unpinnedColumns.push(this._columns[i]);
              }
            } else {
              unpinnedColumns.push(this._columns[i]);
            }
          }

          if (newUnpinnedCols.length) {
            console.warn('igxGrid - The pinned area exceeds maximum pinned width. ' + 'The following columns were unpinned to prevent further issues:' + newUnpinnedCols.map(function (col) {
              return '"' + col.header + '"';
            }).toString() + '. For more info see our documentation.');
          } // Assign the applicaple collections.


          this._pinnedColumns = pinnedColumns;
          this._unpinnedColumns = unpinnedColumns;
          this.notifyChanges();
        }
        /**
         * @hidden
         * @protected
         * @param {?} row
         * @param {?} column
         * @param {?=} inCollection
         * @return {?}
         */

      }, {
        key: "scrollTo",
        value: function scrollTo(row, column) {
          var _this278 = this;

          var inCollection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.filteredSortedData;

          /** @type {?} */
          var delayScrolling = false;

          if (this.paging && typeof row !== 'number') {
            /** @type {?} */
            var rowIndex = inCollection.indexOf(row);
            /** @type {?} */

            var page = Math.floor(rowIndex / this.perPage);

            if (this.page !== page) {
              delayScrolling = true;
              this.page = page;
            }
          }

          if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              _this278.scrollDirective(_this278.verticalScrollContainer, typeof row === 'number' ? row : _this278.dataView.indexOf(row));
            });
          } else {
            this.scrollDirective(this.verticalScrollContainer, typeof row === 'number' ? row : this.dataView.indexOf(row));
          }

          this.scrollToHorizontally(column);
        }
        /**
         * @hidden
         * @protected
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "scrollToHorizontally",
        value: function scrollToHorizontally(column) {
          /** @type {?} */
          var columnIndex = typeof column === 'number' ? column : this.getColumnByName(column).visibleIndex;
          /** @type {?} */

          var scrollRow = this.rowList.find(function (r) {
            return r.virtDirRow;
          });
          /** @type {?} */

          var virtDir = scrollRow ? scrollRow.virtDirRow : null;

          if (this.pinnedColumns.length) {
            if (columnIndex >= this.pinnedColumns.length) {
              columnIndex -= this.pinnedColumns.length;
              this.scrollDirective(virtDir, columnIndex);
            }
          } else {
            this.scrollDirective(virtDir, columnIndex);
          }
        }
        /**
         * @hidden
         * @protected
         * @param {?} directive
         * @param {?} goal
         * @return {?}
         */

      }, {
        key: "scrollDirective",
        value: function scrollDirective(directive, goal) {
          if (!directive) {
            return;
          }

          directive.scrollTo(goal);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "rebuildMatchCache",
        value: function rebuildMatchCache() {
          var _this279 = this;

          this.lastSearchInfo.matchInfoCache = [];
          /** @type {?} */

          var caseSensitive = this.lastSearchInfo.caseSensitive;
          /** @type {?} */

          var exactMatch = this.lastSearchInfo.exactMatch;
          /** @type {?} */

          var searchText = caseSensitive ? this.lastSearchInfo.searchText : this.lastSearchInfo.searchText.toLowerCase();
          /** @type {?} */

          var data = this.filteredSortedData;
          /** @type {?} */

          var columnItems = this.visibleColumns.filter(function (c) {
            return !c.columnGroup;
          }).sort(function (c1, c2) {
            return c1.visibleIndex - c2.visibleIndex;
          });
          /** @type {?} */

          var numberPipe = new IgxDecimalPipeComponent(this.locale);
          /** @type {?} */

          var datePipe = new IgxDatePipeComponent(this.locale);
          data.forEach(function (dataRow) {
            columnItems.forEach(function (c) {
              /** @type {?} */
              var value = c.formatter ? c.formatter(dataRow[c.field]) : c.dataType === 'number' ? numberPipe.transform(dataRow[c.field], _this279.locale) : c.dataType === 'date' ? datePipe.transform(dataRow[c.field], _this279.locale) : dataRow[c.field];

              if (value !== undefined && value !== null && c.searchable) {
                /** @type {?} */
                var searchValue = caseSensitive ? String(value) : String(value).toLowerCase();

                if (exactMatch) {
                  if (searchValue === searchText) {
                    _this279.lastSearchInfo.matchInfoCache.push({
                      row: dataRow,
                      column: c.field,
                      index: 0
                    });
                  }
                } else {
                  /** @type {?} */
                  var occurenceIndex = 0;
                  /** @type {?} */

                  var searchIndex = searchValue.indexOf(searchText);

                  while (searchIndex !== -1) {
                    _this279.lastSearchInfo.matchInfoCache.push({
                      row: dataRow,
                      column: c.field,
                      index: occurenceIndex++
                    });

                    searchValue = searchValue.substring(searchIndex + searchText.length);
                    searchIndex = searchValue.indexOf(searchText);
                  }
                }
              }
            });
          });
        }
        /**
         * @hidden
         * @param {?} _group
         * @return {?}
         */

      }, {
        key: "isExpandedGroup",
        value: function isExpandedGroup(_group) {
          return undefined;
        }
        /**
         * @protected
         * @param {?} row
         * @return {?}
         */

      }, {
        key: "changeRowEditingOverlayStateOnScroll",
        value: function changeRowEditingOverlayStateOnScroll(row) {
          if (!this.rowEditable || !this.rowEditingOverlay || this.rowEditingOverlay.collapsed) {
            return;
          }

          if (!row) {
            this.toggleRowEditingOverlay(false);
          } else {
            this.repositionRowEditingOverlay(row);
          }
        }
        /**
         * Should be called when data and/or isLoading input changes so that the overlay can be
         * hidden/shown based on the current value of shouldOverlayLoading
         * @protected
         * @return {?}
         */

      }, {
        key: "evaluateLoadingState",
        value: function evaluateLoadingState() {
          if (this.shouldOverlayLoading) {
            // a new overlay should be shown

            /** @type {?} */
            var overlaySettings = {
              outlet: this.loadingOutlet,
              closeOnOutsideClick: false,
              positionStrategy: new ContainerPositionStrategy()
            };

            if (!this._loadingId) {
              this._loadingId = this.overlayService.attach(this.loadingOverlay, overlaySettings);
              this.overlayService.show(this._loadingId, overlaySettings);
            }
          } else {
            if (this._loadingId) {
              this.overlayService.hide(this._loadingId);
              this._loadingId = null;
            }
          }
        }
        /**
         * @param {?} id
         * @return {?}
         */

      }, {
        key: "openRowOverlay",
        value: function openRowOverlay(id) {
          this.configureRowEditingOverlay(id, this.rowList.length <= MIN_ROW_EDITING_COUNT_THRESHOLD);
          this.rowEditingOverlay.open(this.rowEditSettings);
          this.rowEditPositioningStrategy.isTopInitialPosition = this.rowEditPositioningStrategy.isTop;
          this.rowEditingOverlay.element.addEventListener('wheel', this.rowEditingWheelHandler);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "closeRowEditingOverlay",
        value: function closeRowEditingOverlay() {
          this.rowEditingOverlay.element.removeEventListener('wheel', this.rowEditingWheelHandler);
          this.rowEditPositioningStrategy.isTopInitialPosition = null;
          this.rowEditingOverlay.close();
          this.rowEditingOverlay.element.parentElement.style.display = '';
        }
        /**
         * @hidden
         * @param {?} show
         * @return {?}
         */

      }, {
        key: "toggleRowEditingOverlay",
        value: function toggleRowEditingOverlay(show) {
          /** @type {?} */
          var rowStyle = this.rowEditingOverlay.element.style;

          if (show) {
            rowStyle.display = 'block';
          } else {
            rowStyle.display = 'none';
          }
        }
        /**
         * @hidden
         * @param {?} row
         * @return {?}
         */

      }, {
        key: "repositionRowEditingOverlay",
        value: function repositionRowEditingOverlay(row) {
          if (row && !this.rowEditingOverlay.collapsed) {
            /** @type {?} */
            var rowStyle = this.rowEditingOverlay.element.parentElement.style;

            if (row) {
              rowStyle.display = '';
              this.configureRowEditingOverlay(row.rowID);
              this.rowEditingOverlay.reposition();
            } else {
              rowStyle.display = 'none';
            }
          }
        }
        /**
         * @private
         * @param {?} rowID
         * @param {?=} useOuter
         * @return {?}
         */

      }, {
        key: "configureRowEditingOverlay",
        value: function configureRowEditingOverlay(rowID) {
          var useOuter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          this.rowEditSettings.outlet = useOuter ? this.parentRowOutletDirective : this.rowOutletDirective;
          this.rowEditPositioningStrategy.settings.container = this.tbody.nativeElement;
          /** @type {?} */

          var targetRow = this.gridAPI.get_row_by_key(rowID);

          if (!targetRow) {
            return;
          }

          this.rowEditPositioningStrategy.settings.target = targetRow.element.nativeElement;
          this.toggleRowEditingOverlay(true);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "writeToData",

        /**
         * @protected
         * @param {?} rowIndex
         * @param {?} value
         * @return {?}
         */
        value: function writeToData(rowIndex, value) {
          mergeObjects(this.gridAPI.get_all_data()[rowIndex], value);
        }
        /**
         * @param {?} commit
         * @param {?} row
         * @return {?}
         */

      }, {
        key: "endRowTransaction",
        value: function endRowTransaction(commit, row) {
          row.newData = this.transactions.getAggregatedValue(row.id, true);
          /** @type {?} */

          var args = row.createEditEventArgs();

          if (!commit) {
            this.onRowEditCancel.emit(args);
            this.transactions.endPending(false);
          } else {
            args = this.gridAPI.update_row(row, row.newData);
          }

          if (args.cancel) {
            this.transactions.startPending();
            return;
          }

          this.crudService.endRowEdit();
          this.closeRowEditingOverlay();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "gridOutletKeyboardHandler",
        value: function gridOutletKeyboardHandler(event) {
          // TODO: This should be removed after grid keyboard refactoring
          // call stopPropagation for keydown event for the outlet not to propagate event to the grid
          event.stopPropagation();
        } // TODO: Refactor

        /**
         * Finishes the row transactions on the current row.
         * If `commit === true`, passes them from the pending state to the data (or transaction service)
         *
         * Binding to the event
         * ```html
         * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
         * ```
         * @param {?=} commit
         * @param {?=} event
         * @return {?}
         */

      }, {
        key: "endEdit",
        value: function endEdit() {
          var commit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var event = arguments.length > 1 ? arguments[1] : undefined;

          /** @type {?} */
          var row = this.crudService.row;
          /** @type {?} */

          var cell = this.crudService.cell; // TODO: Merge the crudService with wht BaseAPI service

          if (!row && !cell) {
            return;
          }

          commit ? this.gridAPI.submit_value() : this.gridAPI.escape_editMode();

          if (!this.rowEditable || this.rowEditingOverlay && this.rowEditingOverlay.collapsed || !row) {
            return;
          }

          this.endRowTransaction(commit, row);
          /** @type {?} */

          var activeCell = this.selectionService.activeElement;

          if (event && activeCell) {
            /** @type {?} */
            var rowIndex = activeCell.row;
            /** @type {?} */

            var visibleColIndex = activeCell.layout ? activeCell.layout.columnVisibleIndex : activeCell.column;
            this.navigateTo(rowIndex, visibleColIndex, function (c) {
              if (c.targetType === GridKeydownTargetType.dataCell && c.target) {
                c.target.nativeElement.focus();
              }
            });
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hasHorizontalScroll",

        /**
         * @return {?}
         */
        value: function hasHorizontalScroll() {
          return this.totalWidth - this.unpinnedWidth > 0;
        }
        /**
         * @protected
         * @param {?} row
         * @return {?}
         */

      }, {
        key: "_restoreVirtState",
        value: function _restoreVirtState(row) {
          // check virtualization state of data record added from cache
          // in case state is no longer valid - update it.

          /** @type {?} */
          var rowForOf = row.virtDirRow;
          /** @type {?} */

          var gridScrLeft = rowForOf.getScroll().scrollLeft;
          /** @type {?} */

          var left = -parseInt(rowForOf.dc.instance._viewContainer.element.nativeElement.style.left, 10);
          /** @type {?} */

          var actualScrollLeft = left + rowForOf.getColumnScrollLeft(rowForOf.state.startIndex);

          if (gridScrLeft !== actualScrollLeft) {
            rowForOf.onHScroll(gridScrLeft);
          }
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "getExportExcel",
        value: function getExportExcel() {
          return this._exportExcel;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "getExportCsv",
        value: function getExportCsv() {
          return this._exportCsv;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isSummaryRow",

        /**
         * @hidden
         * @param {?} rowData
         * @return {?}
         */
        value: function isSummaryRow(rowData) {
          return rowData.summaries && rowData.summaries instanceof Map;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "viewDetachHandler",

        /**
         * @hidden
         * @param {?} args
         * @return {?}
         */
        value: function viewDetachHandler(args) {
          /** @type {?} */
          var context = args.view.context;

          if (context['templateID'] === 'dataRow') {
            // some browsers (like FireFox and Edge) do not trigger onBlur when the focused element is detached from DOM
            // hence we need to trigger it manually when cell is detached.

            /** @type {?} */
            var row = this.getRowByIndex(context.index);
            /** @type {?} */

            var focusedCell = row.cells.find(function (x) {
              return x.focused;
            });

            if (focusedCell) {
              focusedCell.onBlur();
            }
          }
        }
        /**
         * @hidden
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "cachedViewLoaded",
        value: function cachedViewLoaded(args) {
          var _this280 = this;

          if (args.context['templateID'] === 'dataRow' && args.context['$implicit'] === args.oldContext['$implicit']) {
            args.view.detectChanges();
            /** @type {?} */

            var row = this.getRowByIndex(args.context.index);

            if (row && row.cells) {
              row.cells.forEach(function (c) {
                c.highlightText(_this280.lastSearchInfo.searchText, _this280.lastSearchInfo.caseSensitive, _this280.lastSearchInfo.exactMatch);
              });
            }
          }

          if (this.hasHorizontalScroll()) {
            /** @type {?} */
            var tmplId = args.context.templateID;
            /** @type {?} */

            var index = args.context.index;
            args.view.detectChanges();
            /** @type {?} */

            var _row = tmplId === 'dataRow' ? this.getRowByIndex(index) : null;
            /** @type {?} */


            var summaryRow = tmplId === 'summaryRow' ? this.summariesRowList.find(function (sr) {
              return sr.dataRowIndex === index;
            }) : null;

            if (_row && _row instanceof IgxRowComponent) {
              this._restoreVirtState(_row);
            } else if (summaryRow) {
              this._restoreVirtState(summaryRow);
            }
          }
        }
        /**
         * Opens the advanced filtering dialog.
         * @return {?}
         */

      }, {
        key: "openAdvancedFilteringDialog",
        value: function openAdvancedFilteringDialog() {
          if (!this._advancedFilteringOverlayId) {
            this._advancedFilteringOverlaySettings.positionStrategy.settings.target =
            /** @type {?} */
            this.rootGrid ?
            /** @type {?} */
            this.rootGrid.nativeElement : this.nativeElement;
            this._advancedFilteringOverlaySettings.outlet = this.outletDirective;
            this._advancedFilteringOverlayId = this.overlayService.attach(IgxAdvancedFilteringDialogComponent, this._advancedFilteringOverlaySettings, {
              injector: this.viewRef.injector,
              componentFactoryResolver: this.resolver
            });
            this.overlayService.show(this._advancedFilteringOverlayId, this._advancedFilteringOverlaySettings);
          }
        }
        /**
         * Closes the advanced filtering dialog.
         * @param {?} applyChanges indicates whether the changes should be applied
         * @return {?}
         */

      }, {
        key: "closeAdvancedFilteringDialog",
        value: function closeAdvancedFilteringDialog(applyChanges) {
          if (this._advancedFilteringOverlayId) {
            /** @type {?} */
            var advancedFilteringOverlay = this.overlayService.getOverlayById(this._advancedFilteringOverlayId);
            /** @type {?} */

            var advancedFilteringDialog =
            /** @type {?} */
            advancedFilteringOverlay.componentRef.instance;

            if (applyChanges) {
              advancedFilteringDialog.applyChanges();
            }

            advancedFilteringDialog.closeDialog();
          }
        }
      }, {
        key: "scrollWidth",
        get: function get() {
          return this._scrollWidth;
        }
        /**
         * An accessor that sets the resource strings.
         * By default it uses EN resources.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "resourceStrings",
        set: function set(value) {
          this._resourceStrings = Object.assign({}, this._resourceStrings, value);
        }
        /**
         * An accessor that returns the resource strings.
         * @return {?}
         */
        ,
        get: function get() {
          return this._resourceStrings;
        }
        /**
         * @return {?}
         */

      }, {
        key: "filteringLogic",
        get: function get() {
          return this._filteringExpressionsTree.operator;
        }
        /**
         * Sets the filtering logic of the `IgxGridComponent`.
         * The default is AND.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._filteringExpressionsTree.operator = value;
        }
        /**
         * Returns the filtering state of `IgxGridComponent`.
         * ```typescript
         * let filteringExpressionsTree = this.grid.filteringExpressionsTree;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "filteringExpressionsTree",
        get: function get() {
          return this._filteringExpressionsTree;
        }
        /**
         * Sets the filtering state of the `IgxGridComponent`.
         * ```typescript
         * const logic = new FilteringExpressionsTree(FilteringLogic.And, "ID");
         * logic.filteringOperands = [
         *     {
         *          condition: IgxNumberFilteringOperand.instance().condition('greaterThan'),
         *          fieldName: 'ID',
         *          searchVal: 1
         *     }
         * ];
         * this.grid.filteringExpressionsTree = (logic);
         * ```
         * Two-way data binding.
         * ```html
         * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(filteringExpressionsTree)]="model.filteringExpressions"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value && value instanceof FilteringExpressionsTree) {
            /** @type {?} */
            var val =
            /** @type {?} */
            value;

            for (var index = 0; index < val.filteringOperands.length; index++) {
              if (!(val.filteringOperands[index] instanceof FilteringExpressionsTree)) {
                /** @type {?} */
                var newExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, val.filteringOperands[index].fieldName);
                newExpressionsTree.filteringOperands.push(
                /** @type {?} */
                val.filteringOperands[index]);
                val.filteringOperands[index] = newExpressionsTree;
              }
            }

            value.type = FilteringExpressionsTreeType.Regular;
            this._filteringExpressionsTree = value;
            this._filteringPipeTrigger++;
            this.filteringExpressionsTreeChange.emit(this._filteringExpressionsTree);

            if (this.filteringService.isFilteringExpressionsTreeEmpty(this._filteringExpressionsTree) && !this.advancedFilteringExpressionsTree) {
              this.filteredData = null;
            }

            this.filteringService.refreshExpressions();
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this.notifyChanges();
          }
        }
        /**
         * Returns the advanced filtering state of `IgxGridComponent`.
         * ```typescript
         * let advancedFilteringExpressionsTree = this.grid.advancedFilteringExpressionsTree;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "advancedFilteringExpressionsTree",
        get: function get() {
          return this._advancedFilteringExpressionsTree;
        }
        /**
         * Sets the advanced filtering state of the `IgxGridComponent`.
         * ```typescript
         * const logic = new FilteringExpressionsTree(FilteringLogic.And);
         * logic.filteringOperands = [
         *     {
         *          condition: IgxNumberFilteringOperand.instance().condition('greaterThan'),
         *          fieldName: 'ID',
         *          searchVal: 1
         *     },
         *     {
         *          condition: IgxStringFilteringOperand.instance().condition('contains'),
         *          fieldName: 'CompanyName',
         *          searchVal: 'a'
         *     }
         * ];
         * this.grid.advancedFilteringExpressionsTree = logic;
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          var _this281 = this;

          if (value && value instanceof FilteringExpressionsTree) {
            value.type = FilteringExpressionsTreeType.Advanced;
            this._advancedFilteringExpressionsTree = value;
            this._filteringPipeTrigger++;
          } else {
            this._advancedFilteringExpressionsTree = null;
          }

          this.advancedFilteringExpressionsTreeChange.emit(this._advancedFilteringExpressionsTree);

          if (this.filteringService.isFilteringExpressionsTreeEmpty(this._advancedFilteringExpressionsTree) && !this.advancedFilteringExpressionsTree) {
            this.filteredData = null;
          }

          this.selectionService.clearHeaderCBState();
          this.summaryService.clearSummaryCache();
          this.notifyChanges(); // Wait for the change detection to update filtered data through the pipes and then emit the event.

          requestAnimationFrame(function () {
            return _this281.onFilteringDone.emit(_this281._advancedFilteringExpressionsTree);
          });
        }
        /**
         * Returns the locale of the grid.
         * If not set, returns browser's language.
         * @return {?}
         */

      }, {
        key: "locale",
        get: function get() {
          if (this._locale) {
            return this._locale;
          } else {
            return 'en';
          }
        }
        /**
         * Sets the locale of the grid.
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._locale = value;
        }
        /**
         * Returns whether the paging feature is enabled/disabled.
         * The default state is disabled (false).
         * ```
         * const paging = this.grid.paging;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "paging",
        get: function get() {
          return this._paging;
        }
        /**
         * Enables/Disables the paging feature.
         * ```html
         * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._paging = value;
          this._pipeTrigger++;
          this.notifyChanges(true);
        }
        /**
         * Returns the current page index.
         * ```html
         * let gridPage = this.grid.page;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "page",
        get: function get() {
          return this._page;
        }
        /**
         * Sets the current page index.
         * ```html
         * <igx-grid #grid [data]="Data" [paging]="true" [page]="5" [autoGenerate]="true"></igx-grid>
         * ```
         * Two-way data binding.
         * ```html
         * <igx-grid #grid [data]="Data" [paging]="true" [(page)]="model.page" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (val === this._page || val < 0 || val > this.totalPages - 1) {
            return;
          }

          this.selectionService.clear(true);
          this.onPagingDone.emit({
            previous: this._page,
            current: val
          });
          this._page = val;
          this.pageChange.emit(this._page);
          this.navigateTo(0);
          this.notifyChanges();
        }
        /**
         * Returns the number of visible items per page of the `IgxGridComponent`.
         * The default is 15.
         * ```html
         * let itemsPerPage = this.grid.perPage;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "perPage",
        get: function get() {
          return this._perPage;
        }
        /**
         * Sets the number of visible items per page of the `IgxGridComponent`.
         * ```html
         * <igx-grid #grid [data]="Data" [paging]="true" [perPage]="5" [autoGenerate]="true"></igx-grid>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-grid #grid [data]="Data" [paging]="true" [(perPage)]="model.perPage" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (val < 0) {
            return;
          }

          this.selectionService.clear(true);
          this._perPage = val;
          this.perPageChange.emit(this._perPage);
          this.page = 0;
          this.endEdit(true);
          this.notifyChanges();
        }
        /**
         * Returns whether the column hiding UI for the `IgxGridComponent` is enabled.
         * By default it is disabled (false).
         * ```typescript
         * let gridColHiding = this.grid.columnHiding;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "columnHiding",
        get: function get() {
          return this._columnHiding;
        }
        /**
         * Sets whether the column hiding UI for the `IgxGridComponent` is enabled.
         * In order for the UI to work, you need to enable the toolbar as shown in the example below.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._columnHiding !== value) {
            this._columnHiding = value;

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "rowSelectable",
        get: function get() {
          return this.isRowSelectable;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this.rowSelection = val ? GridSelectionMode.multiple : GridSelectionMode.none;
        }
        /**
         * Returns if the row selectors are hidden
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "hideRowSelectors",
        get: function get() {
          return this._hideRowSelectors;
        }
        /**
         * Allows you to change the visibility of the row selectors
         * By default row selectors are shown
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._hideRowSelectors = value;
          this.notifyChanges(true);
        }
        /**
         * @return {?}
         */

      }, {
        key: "rowDraggable",
        get: function get() {
          return this._rowDrag && this.hasVisibleColumns;
        }
        /**
         * Sets whether rows can be moved.
         * ```html
         * <igx-grid #grid [rowDraggable]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._rowDrag = val;
          this.notifyChanges(true);
        }
        /**
         * Sets whether the `IgxGridRowComponent` is editable.
         * By default it is set to false.
         * ```typescript
         * let rowEditable = this.grid.rowEditable;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "rowEditable",
        get: function get() {
          return this._rowEditable;
        }
        /**
         * Sets whether rows can be edited.
         * ```html
         * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (!this._init) {
            this.refreshGridState();
          }

          this._rowEditable = val;
          this.notifyChanges();
        }
        /**
         * Returns the height of the `IgxGridComponent`.
         * ```typescript
         * let gridHeight = this.grid.height;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "height",
        get: function get() {
          return this._height;
        }
        /**
         * Sets the height of the `IgxGridComponent`.
         * ```html
         * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._height !== value) {
            this._height = value;
            this.nativeElement.style.height = value;
            this.notifyChanges(true);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hostWidth",
        get: function get() {
          return this._width || this._hostWidth;
        }
        /**
         * Returns the width of the `IgxGridComponent`.
         * ```typescript
         * let gridWidth = this.grid.width;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "width",
        get: function get() {
          return this._width;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._width !== value) {
            this._width = value;
            this.nativeElement.style.width = value;
            this.notifyChanges(true);
          }
        }
        /**
         * Returns the width of the header of the `IgxGridComponent`.
         * ```html
         * let gridHeaderWidth = this.grid.headerWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "headerWidth",
        get: function get() {
          return parseInt(this.width, 10) - 17;
        }
        /**
         * Returns the row height.
         * ```typescript
         * const rowHeight = this.grid.rowHeight;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "rowHeight",
        get: function get() {
          return this._rowHeight ? this._rowHeight : this.defaultRowHeight;
        }
        /**
         * Sets the row height.
         * ```html
         * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._rowHeight = parseInt(value, 10);
        }
        /**
         * An \@Input property that sets the default width of the `IgxGridComponent`'s columns.
         * ```html
         * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "columnWidth",
        get: function get() {
          return this._columnWidth;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._columnWidth = value;
          this.columnWidthSetByUser = true;
          this.notifyChanges(true);
        }
        /**
         * An \@Input property that sets the message displayed when there are no records.
         * ```html
         * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "emptyGridMessage",
        set: function set(value) {
          this._emptyGridMessage = value;
        }
        /**
         * An accessor that returns the message displayed when there are no records.
         * @return {?}
         */
        ,
        get: function get() {
          return this._emptyGridMessage || this.resourceStrings.igx_grid_emptyGrid_message;
        }
        /**
         * An \@Input property that sets whether the grid is going to show loading indicator.
         * ```html
         * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isLoading",
        set: function set(value) {
          var _this282 = this;

          if (this._isLoading !== value) {
            this._isLoading = value;
            this.evaluateLoadingState();
          }

          Promise.resolve().then(function () {
            // wait for the current detection cycle to end before triggering a new one.
            _this282.notifyChanges();
          });
        }
        /**
         * An accessor that returns whether the grid is showing loading indicator.
         * @return {?}
         */
        ,
        get: function get() {
          return this._isLoading;
        }
        /**
         * An \@Input property that sets the message displayed when there are no records and the grid is filtered.
         * ```html
         * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "emptyFilteredGridMessage",
        set: function set(value) {
          this._emptyFilteredGridMessage = value;
        }
        /**
         * An accessor that returns the message displayed when there are no records and the grid is filtered.
         * @return {?}
         */
        ,
        get: function get() {
          return this._emptyFilteredGridMessage || this.resourceStrings.igx_grid_emptyFilteredGrid_message;
        }
        /**
         * Returns if the built-in column pinning UI should be shown in the toolbar.
         * ```typescript
         *  let colPinning = this.grid.columnPinning;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "columnPinning",
        get: function get() {
          return this._columnPinning;
        }
        /**
         * Sets if the built-in column pinning UI should be shown in the toolbar.
         * By default it's disabled.
         * ```html
         * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._columnPinning !== value) {
            this._columnPinning = value;

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * Returns if the filtering is enabled.
         * ```typescript
         *  let filtering = this.grid.allowFiltering;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "allowFiltering",
        get: function get() {
          return this._allowFiltering;
        }
        /**
         * Sets if the filtering is enabled.
         * By default it's disabled.
         * ```html
         * <igx-grid #grid [data]="localData" [allowFiltering]="true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._allowFiltering !== value) {
            this._allowFiltering = value;
            this.filteringService.registerSVGIcons();

            if (!this._init) {
              this.calcGridHeadRow();
            }

            this.filteringService.isFilterRowVisible = false;
            this.filteringService.filteredColumn = null;
            this.notifyChanges(true);
          }
        }
        /**
         * Returns a value indicating whether the advanced filtering is enabled.
         * ```typescript
         *  let filtering = this.grid.allowAdvancedFiltering;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "allowAdvancedFiltering",
        get: function get() {
          return this._allowAdvancedFiltering;
        }
        /**
         * Sets a value indicating whether the advanced filtering is enabled.
         * By default it's disabled.
         * ```html
         * <igx-grid #grid [data]="localData" [allowAdvancedFiltering]="true" [showToolbar]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._allowAdvancedFiltering !== value) {
            this._allowAdvancedFiltering = value;
            this.filteringService.registerSVGIcons();

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * Returns the filter mode.
         * ```typescript
         *  let filtering = this.grid.filterMode;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "filterMode",
        get: function get() {
          return this._filterMode;
        }
        /**
         * Sets filter mode.
         * By default it's set to FilterMode.quickFilter.
         * ```html
         * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._filterMode = value;

          if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.close();
          }

          this.notifyChanges(true);
        }
        /**
         * Returns the summary position.
         * ```typescript
         *  let summaryPosition = this.grid.summaryPosition;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "summaryPosition",
        get: function get() {
          return this._summaryPosition;
        }
        /**
         * Sets summary position.
         * By default it is bottom.
         * ```html
         * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._summaryPosition = value;
          this.notifyChanges();
        }
        /**
         * Returns the summary calculation mode.
         * ```typescript
         *  let summaryCalculationMode = this.grid.summaryCalculationMode;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "summaryCalculationMode",
        get: function get() {
          return this._summaryCalculationMode;
        }
        /**
         * Sets summary calculation mode.
         * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
         * ```html
         * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._summaryCalculationMode = value;

          if (!this._init) {
            this.endEdit(true);
            this.summaryService.resetSummaryHeight();
            this.notifyChanges(true);
          }
        }
        /**
         * Gets the filtering strategy of the grid.
         * ```typescript
         *  let filterStrategy = this.grid.filterStrategy
         * ```
         * @return {?}
         */

      }, {
        key: "filterStrategy",
        get: function get() {
          return this._filteringStrategy;
        }
        /**
         * Sets the filtering strategy of the grid.
         * ```html
         *  <igx-grid #grid [data]="localData" [filterStrategy]="filterStrategy"></igx-grid>
         * ```
         * @param {?} classRef
         * @return {?}
         */
        ,
        set: function set(classRef) {
          this._filteringStrategy = classRef;
        }
        /**
         * Returns the state of the grid virtualization, including the start index and how many records are rendered.
         * ```typescript
         * const gridVirtState = this.grid1.virtualizationState;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "virtualizationState",
        get: function get() {
          return this.verticalScrollContainer.state;
        }
        /**
         * @hidden
         * @param {?} state
         * @return {?}
         */
        ,
        set: function set(state) {
          this.verticalScrollContainer.state = state;
        }
        /**
         * A list of all `IgxGridHeaderGroupComponent`.
         * ```typescript
         * const headerGroupsList = this.grid.headerGroupsList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "headerGroupsList",
        get: function get() {
          return this.headerGroups ? flatten(this.headerGroups.toArray()) : [];
        }
        /**
         * A list of all `IgxGridHeaderComponent`.
         * ```typescript
         * const headers = this.grid.headerCellList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "headerCellList",
        get: function get() {
          return this.headerGroupsList.map(function (headerGroup) {
            return headerGroup.headerCell;
          }).filter(function (headerCell) {
            return headerCell;
          });
        }
        /**
         * A list of all `IgxGridFilteringCellComponent`.
         * ```typescript
         * const filterCells = this.grid.filterCellList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "filterCellList",
        get: function get() {
          return this.headerGroupsList.map(function (headerGroup) {
            return headerGroup.filterCell;
          }).filter(function (filterCell) {
            return filterCell;
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "summariesRowList",
        get: function get() {
          /** @type {?} */
          var res = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();

          if (!this._summaryRowList) {
            return res;
          }
          /** @type {?} */


          var sumList = this._summaryRowList.filter(function (item) {
            return item.element.nativeElement.parentElement !== null;
          });

          res.reset(sumList);
          return res;
        }
        /**
         * A list of `IgxGridRowComponent`.
         * ```typescript
         * const rowList = this.grid.rowList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "rowList",
        get: function get() {
          /** @type {?} */
          var res = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();

          if (!this._rowList) {
            return res;
          }
          /** @type {?} */


          var rList = this._rowList.filter(function (item) {
            return item.element.nativeElement.parentElement !== null;
          }).sort(function (a, b) {
            return a.index - b.index;
          });

          res.reset(rList);
          return res;
        }
        /**
         * A list of `IgxGridRowComponent`, currently rendered.
         * ```typescript
         * const dataList = this.grid.dataRowList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "dataRowList",
        get: function get() {
          /** @type {?} */
          var res = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();

          if (!this._dataRowList) {
            return res;
          }
          /** @type {?} */


          var rList = this._dataRowList.filter(function (item) {
            return item.element.nativeElement.parentElement !== null;
          }).sort(function (a, b) {
            return a.index - b.index;
          });

          res.reset(rList);
          return res;
        }
        /**
         * Returns the template which will be used by the toolbar to show custom content.
         * ```typescript
         * let customContentTemplate = this.grid.toolbarCustomContentTemplate;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "toolbarCustomContentTemplate",
        get: function get() {
          return this.toolbarCustomContentTemplates.first;
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "headSelectorTemplate",
        get: function get() {
          if (this.headSelectorsTemplates && this.headSelectorsTemplates.first) {
            return this.headSelectorsTemplates.first.templateRef;
          }

          return null;
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "rowSelectorTemplate",
        get: function get() {
          if (this.rowSelectorsTemplates && this.rowSelectorsTemplates.first) {
            return this.rowSelectorsTemplates.first.templateRef;
          }

          return null;
        }
        /**
         * The custom template, if any, that should be used when rendering the row drag indicator icon
         * @return {?}
         */

      }, {
        key: "dragIndicatorIconTemplate",
        get: function get() {
          return this._customDragIndicatorIconTemplate || this.dragIndicatorIconTemplates.first;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._customDragIndicatorIconTemplate = val;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "outletDirective",
        get: function get() {
          return this._outletDirective;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "rowOutletDirective",
        get: function get() {
          return this.rowEditingOutletDirective;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "parentRowOutletDirective",
        get: function get() {
          return this.outletDirective;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "rowEditContainer",
        get: function get() {
          return this.rowEditCustom ? this.rowEditCustom : this.defaultRowEditTemplate;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "rowInEditMode",
        get: function get() {
          /** @type {?} */
          var editRowState = this.crudService.row;
          return editRowState !== null ? this.rowList.find(function (e) {
            return e.rowID === editRowState.id;
          }) : null;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "firstEditableColumnIndex",
        get: function get() {
          /** @type {?} */
          var index = this.navigation.gridOrderedColumns.findIndex(function (e) {
            return e.editable;
          });
          return index !== -1 ? index : null;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "lastEditableColumnIndex",
        get: function get() {
          /** @type {?} */
          var orderedColumns = this.navigation.gridOrderedColumns;
          /** @type {?} */

          var index = orderedColumns.reverse().findIndex(function (e) {
            return e.editable;
          });
          return index !== -1 ? orderedColumns.length - 1 - index : null;
        }
        /**
         * @hidden
         * TODO: Nav service logic doesn't handle 0 results from this querylist
         * @return {?}
         */

      }, {
        key: "rowEditTabs",
        get: function get() {
          return this.rowEditTabsCUSTOM.length ? this.rowEditTabsCUSTOM : this.rowEditTabsDEFAULT;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hostClass",
        get: function get() {
          return this.getComponentDensityClass('igx-grid');
        }
        /**
         * @return {?}
         */

      }, {
        key: "bannerClass",
        get: function get() {
          /** @type {?} */
          var position = this.rowEditPositioningStrategy.isTop ? 'igx-banner__border-top' : 'igx-banner__border-bottom';
          return "".concat(this.getComponentDensityClass('igx-banner'), " ").concat(position);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "pipeTrigger",
        get: function get() {
          return this._pipeTrigger;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "filteringPipeTrigger",
        get: function get() {
          return this._filteringPipeTrigger;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "summaryPipeTrigger",
        get: function get() {
          return this._summaryPipeTrigger;
        }
        /**
         * Returns the sorting state of the `IgxGridComponent`.
         * ```typescript
         * const sortingState = this.grid.sortingExpressions;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "sortingExpressions",
        get: function get() {
          return this._sortingExpressions;
        }
        /**
         * Sets the sorting state of the `IgxGridComponent`.
         * ```typescript
         * this.grid.sortingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Desc,
         *     ignoreCase: true
         * }];
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(sortingExpressions)]="model.sortingExpressions"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._sortingExpressions = cloneArray(value);
          this.sortingExpressionsChange.emit(this._sortingExpressions);
          this.notifyChanges();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "maxLevelHeaderDepth",
        get: function get() {
          if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.hasColumnLayouts ? this.columnList.reduce(function (acc, col) {
              return Math.max(acc, col.rowStart);
            }, 0) : this.columnList.reduce(function (acc, col) {
              return Math.max(acc, col.level);
            }, 0);
          }

          return this._maxLevelHeaderDepth;
        }
        /**
         * Returns the number of hidden `IgxColumnComponent`.
         * ```typescript
         * const hiddenCol = this.grid.hiddenColumnsCount;
         * ``
         * @return {?}
         */

      }, {
        key: "hiddenColumnsCount",
        get: function get() {
          return this.columnList.filter(function (col) {
            return col.columnGroup === false && col.hidden === true;
          }).length;
        }
        /**
         * Returns the text to be displayed inside the toggle button
         * for the built-in column hiding UI of the`IgxColumnComponent`.
         * ```typescript
         * const hiddenColText = this.grid.hiddenColumnsText;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "hiddenColumnsText",
        get: function get() {
          return this._hiddenColumnsText;
        }
        /**
         * Sets the text to be displayed inside the toggle button
         * for the built-in column hiding UI of the`IgxColumnComponent`.
         * ```typescript
         * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._hiddenColumnsText = value;
        }
        /**
         * Returns the text to be displayed inside the toggle button
         * for the built-in column pinning UI of the`IgxColumnComponent`.
         * ```typescript
         * const pinnedText = this.grid.pinnedColumnsText;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "pinnedColumnsText",
        get: function get() {
          return this._pinnedColumnsText;
        }
        /**
         * Sets the text to be displayed inside the toggle button
         * for the built-in column pinning UI of the`IgxColumnComponent`.
         * ```html
         * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._pinnedColumnsText = value;
        }
        /**
         * Get transactions service for the grid.
         * @return {?}
         */

      }, {
        key: "transactions",
        get: function get() {
          return this._transactions;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "currentRowState",
        get: function get() {
          return this._currentRowState;
        }
        /**
         * Returns whether the `IgxGridComponent`'s toolbar is shown or hidden.
         * ```typescript
         * const toolbarGrid = this.grid.showToolbar;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "showToolbar",
        get: function get() {
          return this._showToolbar;
        }
        /**
         * Shows or hides the `IgxGridComponent`'s toolbar.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._showToolbar !== newValue) {
            this._showToolbar = newValue;

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * Returns the toolbar's title.
         * ```typescript
         * const toolbarTitle  = this.grid.toolbarTitle;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "toolbarTitle",
        get: function get() {
          return this._toolbarTitle;
        }
        /**
         * Sets the toolbar's title.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._toolbarTitle !== newValue) {
            this._toolbarTitle = newValue;

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * Returns whether the option for exporting to MS Excel is enabled or disabled.
         * ```typescript
         * cosnt excelExporter = this.grid.exportExcel;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "exportExcel",
        get: function get() {
          return this.getExportExcel();
        }
        /**
         * Enable or disable the option for exporting to MS Excel.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._exportExcel !== newValue) {
            this._exportExcel = newValue;

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * Returns whether the option for exporting to CSV is enabled or disabled.
         * ```typescript
         * const exportCsv = this.grid.exportCsv;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "exportCsv",
        get: function get() {
          return this.getExportCsv();
        }
        /**
         * Enable or disable the option for exporting to CSV.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._exportCsv !== newValue) {
            this._exportCsv = newValue;

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * Returns the textual content for the main export button.
         * ```typescript
         * const exportText = this.grid.exportText;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "exportText",
        get: function get() {
          return this._exportText;
        }
        /**
         * Sets the textual content for the main export button.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._exportText !== newValue) {
            this._exportText = newValue;

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * Returns the textual content for the MS Excel export button.
         * ```typescript
         * const excelText = this.grid.exportExcelText;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "exportExcelText",
        get: function get() {
          return this._exportExcelText;
        }
        /**
         * Sets the textual content for the MS Excel export button.
         * ```html
         * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._exportExcelText !== newValue) {
            this._exportExcelText = newValue;

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * Returns the textual content for the CSV export button.
         * ```typescript
         * const csvText = this.grid.exportCsvText;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "exportCsvText",
        get: function get() {
          return this._exportCsvText;
        }
        /**
         * Sets the textual content for the CSV export button.
         * ```html
         * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._exportCsvText !== newValue) {
            this._exportCsvText = newValue;

            if (!this._init) {
              this.notifyChanges(true);
            }
          }
        }
        /**
         * Returns the current cell selection state, which can be none, single or multiple
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "cellSelection",
        get: function get() {
          return this._cellSelectionMode;
        }
        /**
         * Allows you to set cell selection mode
         * By default the cell selection mode is multiple
         * \@memberof IgxGridBaseComponent
         * @param {?} selectionMode
         * @return {?}
         */
        ,
        set: function set(selectionMode) {
          this._cellSelectionMode = selectionMode;

          if (this.gridAPI.grid) {
            this.selectionService.clear(true);
            this.notifyChanges();
          }
        }
        /**
         * Returns the current row selection state, which can be none, single or multiple
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "rowSelection",
        get: function get() {
          return this._rowSelectionMode;
        }
        /**
         * Allows you to set row selection mode
         * By default the row selection mode is none
         * \@memberof IgxGridBaseComponent
         * @param {?} selectionMode
         * @return {?}
         */
        ,
        set: function set(selectionMode) {
          this._rowSelectionMode = selectionMode;

          if (this.gridAPI.grid && this.columnList) {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges(true);
          }
        }
      }, {
        key: "nativeElement",
        get: function get() {
          return this.elementRef.nativeElement;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "outlet",
        get: function get() {
          return this.outletDirective;
        }
        /**
         * Returns the `IgxGridComponent`'s rows height.
         * ```typescript
         * const rowHeigh = this.grid.defaultRowHeight;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "defaultRowHeight",
        get: function get() {
          switch (this.displayDensity) {
            case DisplayDensity.cosy:
              return 40;

            case DisplayDensity.compact:
              return 32;

            default:
              return 50;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "defaultSummaryHeight",
        get: function get() {
          switch (this.displayDensity) {
            case DisplayDensity.cosy:
              return 30;

            case DisplayDensity.compact:
              return 24;

            default:
              return 36;
          }
        }
        /**
         * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
         * Used internally for restricting header group component width.
         * The values below depend on the header cell default right/left padding values.
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "defaultHeaderGroupMinWidth",
        get: function get() {
          switch (this.displayDensity) {
            case DisplayDensity.cosy:
              return 32;

            case DisplayDensity.compact:
              return 24;

            default:
              return 48;
          }
        }
      }, {
        key: "calcPinnedContainerMaxWidth",
        get: function get() {
          return this.calcWidth * 80 / 100;
        }
        /**
         * Returns the minimum width of the container for the unpinned `IgxColumnComponent`s.
         * The width is 20% of the total grid width.
         * ```typescript
         * const minUnpinnedColWidth = this.grid.unpinnedAreaMinWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "unpinnedAreaMinWidth",
        get: function get() {
          return this.calcWidth * 20 / 100;
        }
        /**
         * Returns the current width of the container for the pinned `IgxColumnComponent`s.
         * ```typescript
         * const pinnedWidth = this.grid.getPinnedWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "pinnedWidth",
        get: function get() {
          if (!isNaN(this._pinnedWidth)) {
            return this._pinnedWidth;
          }

          this._pinnedWidth = this.getPinnedWidth();
          return this._pinnedWidth;
        }
        /**
         * Returns the current width of the container for the unpinned `IgxColumnComponent`s.
         * ```typescript
         * const unpinnedWidth = this.grid.getUnpinnedWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "unpinnedWidth",
        get: function get() {
          if (!isNaN(this._unpinnedWidth)) {
            return this._unpinnedWidth;
          }

          this._unpinnedWidth = this.getUnpinnedWidth();
          return this._unpinnedWidth;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isHorizontalScrollHidden",
        get: function get() {
          /** @type {?} */
          var diff = this.unpinnedWidth - this.totalWidth;
          return this.width === null || diff >= 0;
        }
        /**
         * @hidden
         * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
         * TODO: Update for Angular 8. Calling parent class getter using super is not supported for now.
         * @return {?}
         */

      }, {
        key: "featureColumnsWidth",
        get: function get() {
          return this.getFeatureColumnsWidth();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "summariesMargin",
        get: function get() {
          return this.featureColumnsWidth;
        }
        /**
         * Returns an array of `IgxColumnComponent`s.
         * ```typescript
         * const colums = this.grid.columns.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "columns",
        get: function get() {
          return this._columns;
        }
        /**
         * Returns an array of the pinned `IgxColumnComponent`s.
         * ```typescript
         * const pinnedColumns = this.grid.pinnedColumns.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "pinnedColumns",
        get: function get() {
          if (this._pinnedVisible.length) {
            return this._pinnedVisible;
          }

          this._pinnedVisible = this._pinnedColumns.filter(function (col) {
            return !col.hidden;
          });
          return this._pinnedVisible;
        }
        /**
         * Returns an array of unpinned `IgxColumnComponent`s.
         * ```typescript
         * const unpinnedColumns = this.grid.unpinnedColumns.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "unpinnedColumns",
        get: function get() {
          if (this._unpinnedVisible.length) {
            return this._unpinnedVisible;
          }

          this._unpinnedVisible = this._unpinnedColumns.filter(function (col) {
            return !col.hidden;
          });
          return this._unpinnedVisible;
        }
      }, {
        key: "visibleColumns",
        get: function get() {
          if (this._visibleColumns.length) {
            return this._visibleColumns;
          }

          this._visibleColumns = this.columnList.filter(function (c) {
            return !c.hidden;
          });
          return this._visibleColumns;
        }
      }, {
        key: "totalPages",
        get: function get() {
          if (this.pagingState) {
            return this.pagingState.metadata.countPages;
          }

          return -1;
        }
        /**
         * Returns if the current page is the first page.
         * ```typescript
         * const firstPage = this.grid.isFirstPage;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "isFirstPage",
        get: function get() {
          return this.page === 0;
        }
      }, {
        key: "totalRecords",
        get: function get() {
          if (this.pagingState) {
            return this.pagingState.metadata.countRecords;
          }
        }
        /**
         * Returns if the current page is the last page.
         * ```typescript
         * const lastPage = this.grid.isLastPage;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "isLastPage",
        get: function get() {
          return this.page + 1 >= this.totalPages;
        }
        /**
         * Returns the total width of the `IgxGridComponent`.
         * ```typescript
         * const gridWidth = this.grid.totalWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "totalWidth",
        get: function get() {
          if (!isNaN(this._totalWidth)) {
            return this._totalWidth;
          } // Take only top level columns

          /** @type {?} */


          var cols = this.visibleColumns.filter(function (col) {
            return col.level === 0 && !col.pinned;
          });
          /** @type {?} */

          var totalWidth = 0;
          /** @type {?} */

          var i = 0;

          for (i; i < cols.length; i++) {
            totalWidth += parseInt(cols[i].calcWidth, 10) || 0;
          }

          this._totalWidth = totalWidth;
          return totalWidth;
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "showRowSelectors",
        get: function get() {
          return this.isRowSelectable && this.hasVisibleColumns && !this.hideRowSelectors;
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "showDragIcons",
        get: function get() {
          return this.rowDraggable && this.columns.length > this.hiddenColumnsCount;
        }
      }, {
        key: "hasSortableColumns",
        get: function get() {
          return this.columnList.some(function (col) {
            return col.sortable;
          });
        }
        /**
         * Returns if the `IgxGridComponent` has editable columns.
         * ```typescript
         * const editableGrid = this.grid.hasEditableColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "hasEditableColumns",
        get: function get() {
          return this.columnList.some(function (col) {
            return col.editable;
          });
        }
        /**
         * Returns if the `IgxGridComponent` has fiterable columns.
         * ```typescript
         * const filterableGrid = this.grid.hasFilterableColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "hasFilterableColumns",
        get: function get() {
          return this.columnList.some(function (col) {
            return col.filterable;
          });
        }
        /**
         * Returns if the `IgxGridComponent` has summarized columns.
         * ```typescript
         * const summarizedGrid = this.grid.hasSummarizedColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "hasSummarizedColumns",
        get: function get() {
          return this.summaryService.hasSummarizedColumns;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "rootSummariesEnabled",
        get: function get() {
          return this.summaryCalculationMode !== GridSummaryCalculationMode.childLevelsOnly;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hasVisibleColumns",
        get: function get() {
          if (this._hasVisibleColumns === undefined) {
            return this.columnList ? this.columnList.some(function (c) {
              return !c.hidden;
            }) : false;
          }

          return this._hasVisibleColumns;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._hasVisibleColumns = value;
        }
        /**
         * Returns if the `IgxGridComponent` has moveable columns.
         * ```typescript
         * const movableGrid = this.grid.hasMovableColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "hasMovableColumns",
        get: function get() {
          return this.columnList && this.columnList.some(function (col) {
            return col.movable;
          });
        }
        /**
         * Returns if the `IgxGridComponent` has column groups.
         * ```typescript
         * const groupGrid = this.grid.hasColumnGroups;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "hasColumnGroups",
        get: function get() {
          return this._columnGroups;
        }
        /**
         * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
         * ```typescript
         * const layoutGrid = this.grid.hasColumnLayouts;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "hasColumnLayouts",
        get: function get() {
          return !!this.columnList.some(function (col) {
            return col.columnLayout;
          });
        }
        /**
         * Returns an array of the selected `IgxGridCellComponent`s.
         * ```typescript
         * const selectedCells = this.grid.selectedCells;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */

      }, {
        key: "selectedCells",
        get: function get() {
          if (this.dataRowList) {
            return this.dataRowList.map(function (row) {
              return row.cells.filter(function (cell) {
                return cell.selected;
              });
            }).reduce(function (a, b) {
              return a.concat(b);
            }, []);
          }

          return [];
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "multiRowLayoutRowSize",
        get: function get() {
          return this._multiRowLayoutRowSize;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "rowBasedHeight",
        get: function get() {
          return this.dataLength * this.rowHeight;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "isPercentWidth",
        get: function get() {
          return this.width && this.width.indexOf('%') !== -1;
        }
        /**
         * @hidden \@internal
         * @return {?}
         */

      }, {
        key: "isPercentHeight",
        get: function get() {
          return this._height && this._height.indexOf('%') !== -1;
        }
      }, {
        key: "defaultTargetBodyHeight",
        get: function get() {
          /** @type {?} */
          var allItems = this.dataLength;
          return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
        }
        /**
         * @hidden \@internal
         * The rowHeight input is bound to min-height css prop of rows that adds a 1px border in all cases
         * @return {?}
         */

      }, {
        key: "renderedRowHeight",
        get: function get() {
          return this.rowHeight + 1;
        }
      }, {
        key: "outerWidth",
        get: function get() {
          return this.hasVerticalSroll() ? this.calcWidth + this.scrollWidth : this.calcWidth;
        }
      }, {
        key: "headSelectorBaseAriaLabel",
        get: function get() {
          if (this._filteringExpressionsTree.filteringOperands.length > 0) {
            return this.selectionService.areAllRowSelected() ? 'Deselect all filtered' : 'Select all filtered';
          }

          return this.selectionService.areAllRowSelected() ? 'Deselect all' : 'Select all';
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "totalRowsCountAfterFilter",
        get: function get() {
          if (this.data) {
            return this.selectionService.allData.length;
          }

          return 0;
        }
        /**
         * Returns the currently transformed paged/filtered/sorted/grouped data, displayed in the grid.
         * ```typescript
         *      const dataView = this.grid.dataView;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "dataView",
        get: function get() {
          return this.verticalScrollContainer.igxForOf;
        }
      }, {
        key: "filteredSortedData",
        get: function get() {
          return this._filteredSortedData;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._filteredSortedData = value;
          this.refreshSearch(true);
        }
      }, {
        key: "rowChangesCount",
        get: function get() {
          if (!this.crudService.row) {
            return 0;
          }
          /** @type {?} */


          var rowChanges = this.transactions.getAggregatedValue(this.crudService.row.id, false);
          return rowChanges ? Object.keys(rowChanges).length : 0;
        }
      }, {
        key: "dataWithAddedInTransactionRows",
        get: function get() {
          /** @type {?} */
          var result =
          /** @type {?} */
          cloneArray(this.gridAPI.get_all_data());

          if (this.transactions.enabled) {
            result.push.apply(result, _toConsumableArray(this.transactions.getAggregatedChanges(true).filter(function (t) {
              return t.type === TransactionType.ADD;
            }).map(function (t) {
              return t.newValue;
            })));
          }

          return result;
        }
        /**
         * @return {?}
         */

      }, {
        key: "dataLength",
        get: function get() {
          return this.transactions.enabled ? this.dataWithAddedInTransactionRows.length : this.gridAPI.get_all_data().length;
        }
      }, {
        key: "shouldOverlayLoading",
        get: function get() {
          return this.isLoading && this.data && this.data.length > 0;
        }
      }, {
        key: "isMultiRowSelectionEnabled",
        get: function get() {
          return this.rowSelection === GridSelectionMode.multiple;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isRowSelectable",
        get: function get() {
          return this.rowSelection !== GridSelectionMode.none;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isCellSelectable",
        get: function get() {
          return this.cellSelection !== GridSelectionMode.none;
        }
      }]);

      return IgxGridBaseComponent;
    }(DisplayDensityBase);

    IgxGridBaseComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /** @nocollapse */

    IgxGridBaseComponent.ctorParameters = function () {
      return [{
        type: IgxGridSelectionService
      }, {
        type: IgxGridCRUDService
      }, {
        type: IgxColumnResizingService
      }, {
        type: GridBaseAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxGridTransaction]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: IgxGridNavigationService
      }, {
        type: IgxFilteringService
      }, {
        type: IgxOverlayService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxOverlayService]
        }]
      }, {
        type: IgxGridSummaryService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxGridBaseComponent.propDecorators = {
      defaultExpandedTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultExpandedTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultCollapsedTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultCollapsedTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      resourceStrings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      autoGenerate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      emptyGridTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      loadingGridTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filteringLogic: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filteringExpressionsTree: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filteringExpressionsTreeChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      advancedFilteringExpressionsTreeChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      advancedFilteringExpressionsTree: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      locale: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      paging: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      page: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      pageChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      perPage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      perPageChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      paginationTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnHiding: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowSelectable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hideRowSelectors: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowDraggable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowEditable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      height: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.height']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hostWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.width']
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      evenRowCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      oddRowCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowHeight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      primaryKey: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      emptyGridMessage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isLoading: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      emptyFilteredGridMessage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnHidingTitle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnPinning: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      columnPinningTitle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      allowFiltering: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      allowAdvancedFiltering: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filterMode: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      summaryPosition: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      summaryCalculationMode: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      filterStrategy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      uniqueColumnValuesStrategy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onCellClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRowSelectionChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onColumnPinning: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onCellEditCancel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onCellEditEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onCellEdit: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRowEditEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRowEdit: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRowEditCancel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onColumnInit: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onSortingDone: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onFilteringDone: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onPagingDone: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRowAdded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRowDeleted: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onDataPreLoad: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onColumnResized: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onContextMenu: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onDoubleClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onColumnVisibilityChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onColumnMovingStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onColumnMoving: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onColumnMovingEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onGridKeydown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRowDragStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRowDragEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onGridCopy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      resizeLine: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxGridColumnResizerComponent, {
          "static": false
        }]
      }],
      loadingOverlay: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['loadingOverlay', {
          "static": true
        }]
      }],
      loadingOutlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['igxLoadingOverlayOutlet', {
          read: IgxOverlayOutletDirective,
          "static": true
        }]
      }],
      columnList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxColumnComponent, {
          read: IgxColumnComponent,
          descendants: true
        }]
      }],
      excelStyleSortingTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxExcelStyleSortingTemplateDirective, {
          read: IgxExcelStyleSortingTemplateDirective,
          "static": false
        }]
      }],
      excelStyleMovingTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxExcelStyleMovingTemplateDirective, {
          read: IgxExcelStyleMovingTemplateDirective,
          "static": false
        }]
      }],
      excelStyleHidingTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxExcelStyleHidingTemplateDirective, {
          read: IgxExcelStyleHidingTemplateDirective,
          "static": false
        }]
      }],
      excelStylePinningTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxExcelStylePinningTemplateDirective, {
          read: IgxExcelStylePinningTemplateDirective,
          "static": false
        }]
      }],
      excelStyleLoadingValuesTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxExcelStyleLoadingValuesTemplateDirective, {
          read: IgxExcelStyleLoadingValuesTemplateDirective,
          "static": true
        }]
      }],
      headerGroups: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxGridHeaderGroupComponent, {
          read: IgxGridHeaderGroupComponent
        }]
      }],
      _rowList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: ['row']
      }],
      _summaryRowList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: ['summaryRow', {
          read: IgxSummaryRowComponent
        }]
      }],
      _dataRowList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxRowComponent, {
          read: IgxRowComponent
        }]
      }],
      emptyFilteredGridTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['emptyFilteredGrid', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      emptyGridDefaultTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultEmptyGrid', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      loadingGridDefaultTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultLoadingGrid', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      parentVirtDir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['scrollContainer', {
          read: IgxGridForOfDirective,
          "static": true
        }]
      }],
      toolbarCustomContentTemplates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxGridToolbarCustomContentDirective, {
          read: IgxGridToolbarCustomContentDirective,
          descendants: false
        }]
      }],
      headSelectorsTemplates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxHeadSelectorDirective, {
          read: IgxHeadSelectorDirective,
          descendants: false
        }]
      }],
      rowSelectorsTemplates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxRowSelectorDirective, {
          read: IgxRowSelectorDirective,
          descendants: false
        }]
      }],
      dragGhostCustomTemplates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxRowDragGhostDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          descendants: false
        }]
      }],
      dragIndicatorIconTemplates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxDragIndicatorIconDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          descendants: false
        }]
      }],
      verticalScrollContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['verticalScrollContainer', {
          read: IgxGridForOfDirective,
          "static": true
        }]
      }],
      verticalScroll: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['verticalScrollHolder', {
          read: IgxGridForOfDirective,
          "static": true
        }]
      }],
      scr: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['scr', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": true
        }]
      }],
      footer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['footer', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      headerContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['hContainer', {
          read: IgxGridForOfDirective,
          "static": true
        }]
      }],
      headerSelectorContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['headerSelectorContainer', {
          "static": false
        }]
      }],
      headerDragContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['headerDragContainer', {
          "static": false
        }]
      }],
      headerGroupContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['headerGroupContainer', {
          "static": false
        }]
      }],
      filteringRow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['filteringRow', {
          read: IgxGridFilteringRowComponent,
          "static": false
        }]
      }],
      theadRow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['theadRow', {
          "static": true
        }]
      }],
      tbody: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['tbody', {
          "static": true
        }]
      }],
      tfoot: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['tfoot', {
          "static": true
        }]
      }],
      _outletDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['igxFilteringOverlayOutlet', {
          read: IgxOverlayOutletDirective,
          "static": true
        }]
      }],
      rowEditingOutletDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['igxRowEditingOverlayOutlet', {
          read: IgxOverlayOutletDirective,
          "static": true
        }]
      }],
      tmpOutlets: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxTemplateOutletDirective, {
          read: IgxTemplateOutletDirective
        }]
      }],
      dragIndicatorIconBase: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['dragIndicatorIconBase', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultRowEditTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultRowEditTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      rowEditCustom: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxRowEditTemplateDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      rowEditText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxRowEditTextDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      rowEditActions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxRowEditActionsDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      rowExpandedIndicatorTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxRowExpandedIndicatorDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      rowCollapsedIndicatorTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxRowCollapsedIndicatorDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      headerExpandIndicatorTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxHeaderExpandIndicatorDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      headerCollapseIndicatorTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxHeaderCollapseIndicatorDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      rowEditTabsDEFAULT: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxRowEditTabStopDirective]
      }],
      rowEditTabsCUSTOM: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxRowEditTabStopDirective]
      }],
      rowEditingOverlay: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxToggleDirective, {
          "static": false
        }]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      hostClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.class']
      }],
      hostRole: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      sortingExpressions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      sortingExpressionsChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      hiddenColumnsText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      pinnedColumnsText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      toolbar: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['toolbar', {
          read: IgxGridToolbarComponent,
          "static": false
        }]
      }],
      toolbarHtml: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['toolbar', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      showToolbar: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      toolbarTitle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      exportExcel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      exportCsv: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      exportText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      exportExcelText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      exportCsvText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      clipboardOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cellSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onToolbarExporting: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRangeSelection: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Number), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Number])], IgxGridBaseComponent.prototype, "filteringLogic", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxGridBaseComponent.prototype, "filteringExpressionsTree", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxGridBaseComponent.prototype, "advancedFilteringExpressionsTree", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty('rowSelectable property is deprecated. Use rowSelection property instead.'), WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxGridBaseComponent.prototype, "rowSelectable", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxGridBaseComponent.prototype, "hideRowSelectors", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxGridBaseComponent.prototype, "rowEditable", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxGridBaseComponent.prototype, "height", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxGridBaseComponent.prototype, "width", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxGridBaseComponent.prototype, "rowHeight", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxGridBaseComponent.prototype, "columnWidth", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object)], IgxGridBaseComponent.prototype, "primaryKey", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxGridBaseComponent.prototype, "isLoading", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxGridBaseComponent.prototype, "columnPinning", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Array), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Array])], IgxGridBaseComponent.prototype, "sortingExpressions", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxGridBaseComponent.prototype, "hiddenColumnsText", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Object), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Object])], IgxGridBaseComponent.prototype, "pinnedColumnsText", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxGridBaseComponent.prototype, "showToolbar", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxGridBaseComponent.prototype, "toolbarTitle", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxGridBaseComponent.prototype, "exportExcel", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxGridBaseComponent.prototype, "exportCsv", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxGridBaseComponent.prototype, "exportText", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxGridBaseComponent.prototype, "exportExcelText", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxGridBaseComponent.prototype, "exportCsvText", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxGridBaseComponent.prototype, "cellSelection", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([WatchChanges(), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", String), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [String])], IgxGridBaseComponent.prototype, "rowSelection", null);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxGridFooterComponent = function IgxGridFooterComponent() {
      _classCallCheck(this, IgxGridFooterComponent);
    };

    IgxGridFooterComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-grid-footer',
        template: '<ng-content></ng-content>'
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxSummaryDataPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxSummaryDataPipe(gridAPI) {
        _classCallCheck(this, IgxSummaryDataPipe);

        this.gridAPI = gridAPI;
      }
      /**
       * @param {?} id
       * @param {?=} trigger
       * @return {?}
       */


      _createClass(IgxSummaryDataPipe, [{
        key: "transform",
        value: function transform(id) {
          var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          /** @type {?} */
          var summaryService = this.gridAPI.grid.summaryService;
          return summaryService.calculateSummaries(summaryService.rootSummaryID, this.gridAPI.get_summary_data());
        }
      }]);

      return IgxSummaryDataPipe;
    }();

    IgxSummaryDataPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'igxGridSummaryDataPipe',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxSummaryDataPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxProcessBarTextTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxProcessBarTextTemplateDirective(template) {
      _classCallCheck(this, IgxProcessBarTextTemplateDirective);

      this.template = template;
    };

    IgxProcessBarTextTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxProcessBarText]'
      }]
    }];
    /** @nocollapse */

    IgxProcessBarTextTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var ONE_PERCENT = 0.01;
    /** @type {?} */

    var MIN_VALUE = 0;
    /** @enum {string} */

    var IgxTextAlign = {
      START: 'start',
      CENTER: 'center',
      END: 'end'
    };
    /** @enum {string} */

    var IgxProgressType = {
      DANGER: 'danger',
      INFO: 'info',
      WARNING: 'warning',
      SUCCESS: 'success'
    };
    /**
     * @abstract
     */

    var BaseProgress =
    /*#__PURE__*/
    function () {
      function BaseProgress() {
        _classCallCheck(this, BaseProgress);

        /**
         * @hidden
         */
        this.requestAnimationId = undefined;
        /**
         * @hidden
         */

        this._valueInPercent = MIN_VALUE;
        /**
         * @hidden
         */

        this._max = 100;
        /**
         * @hidden
         */

        this._value = MIN_VALUE;
        /**
         * @hidden
         */

        this._animate = true;
      }
      /**
       * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
       * ```typescript
       * \@ViewChild("MyProgressBar")
       * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
       * public valuePercent(event){
       *    let percentValue = this.progressBar.valueInPercent;
       *    alert(percentValue);
       * }
       * ```
       * @return {?}
       */


      _createClass(BaseProgress, [{
        key: "runAnimation",

        /**
         * @hidden
         * @protected
         * @param {?} val
         * @param {?} step
         * @return {?}
         */
        value: function runAnimation(val, step) {
          var _this283 = this;

          this.requestAnimationId = requestAnimationFrame(function () {
            return _this283.updateProgressSmoothly.call(_this283, val, step);
          });
        }
        /**
         * @hidden
         * @protected
         * @param {?} val
         * @param {?} step
         * @return {?}
         */

      }, {
        key: "updateProgressSmoothly",
        value: function updateProgressSmoothly(val, step) {
          var _this284 = this;

          this._value += step;
          /** @type {?} */

          var passedValue = convertInPercentage(val, this._max);
          /** @type {?} */

          var progressValue = convertInPercentage(this._value, this._max);

          if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
          } else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
          } else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(function () {
              return _this284.updateProgressSmoothly.call(_this284, val, step);
            });
          }
        }
        /**
         * @hidden
         * @protected
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "updateProgressDirectly",
        value: function updateProgressDirectly(val) {
          this._value = val;
          this.valueInPercent = convertInPercentage(this._value, this._max);
        }
        /**
         * @hidden
         * @protected
         * @param {?} currentValue
         * @param {?} prevValue
         * @param {?} step
         * @return {?}
         */

      }, {
        key: "directionFlow",
        value: function directionFlow(currentValue, prevValue, step) {
          if (currentValue < prevValue) {
            return step;
          }

          return -step;
        }
        /**
         * @hidden
         * @private
         * @param {?} val
         * @param {?} comparator
         * @param {?} step
         * @return {?}
         */

      }, {
        key: "isInLimitRange",
        value: function isInLimitRange(val, comparator, step) {
          return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
        }
        /**
         * @hidden
         *
         *
         * @private
         * @param {?} val
         * @param {?} comparator
         * @param {?} step
         * @return {?}
         */

      }, {
        key: "isExceedingUpperLimit",
        value: function isExceedingUpperLimit(val, comparator, step) {
          return val > comparator && step > 0;
        }
        /**
         * @hidden
         *
         * @private
         * @param {?} val
         * @param {?} comparator
         * @param {?} step
         * @return {?}
         */

      }, {
        key: "isExceedingLowerLimit",
        value: function isExceedingLowerLimit(val, comparator, step) {
          return val < comparator && step < 0;
        }
        /**
         * @hidden
         * @private
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "updateProgress",
        value: function updateProgress(val) {
          this._value = val;
          this.valueInPercent = convertInPercentage(this._value, this._max);
        }
      }, {
        key: "valueInPercent",
        get: function get() {
          return this._valueInPercent;
        }
        /**
         * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
         *    public setValue(event){
         *    this.progressBar.valueInPercent = 56;
         * }
         * //...
         * ```
         * ```html
         * <button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._valueInPercent = value;
        }
      }]);

      return BaseProgress;
    }();
    /** @type {?} */


    var NEXT_LINEAR_ID = 0;
    /** @type {?} */

    var NEXT_CIRCULAR_ID = 0;

    var IgxLinearProgressBarComponent =
    /*#__PURE__*/
    function (_BaseProgress) {
      _inherits(IgxLinearProgressBarComponent, _BaseProgress);

      function IgxLinearProgressBarComponent() {
        var _this285;

        _classCallCheck(this, IgxLinearProgressBarComponent);

        _this285 = _possibleConstructorReturn(this, _getPrototypeOf(IgxLinearProgressBarComponent).call(this));
        _this285.valueMin = 0;
        _this285.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */

        _this285.striped = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */

        _this285.indeterminate = false;
        /**
         * An \@Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */

        _this285.role = 'progressbar';
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */

        _this285.id = "igx-linear-bar-".concat(NEXT_LINEAR_ID++);
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *    this.positionCenter = IgxTextAlign.CENTER;
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */

        _this285.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         * <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */

        _this285.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         * <igx-linear-bar type="danger" [textTop]="true"></igx-linear-bar>
         * ```
         */

        _this285.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `danger`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="danger"></igx-linear-bar>
         * ```
         */

        _this285.type = 'default';
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
         * ```
         */

        _this285.onProgressChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this285;
      }
      /**
       * Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
       * ```html
       * <igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
       * ```
       * @param {?} animate
       * @return {?}
       */


      _createClass(IgxLinearProgressBarComponent, [{
        key: "animate",
        set: function set(animate) {
          this._animate = animate;
        }
        /**
         * Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent;
         * public animationStatus(event) {
         *    let animationStatus = this.progressBar.animate;
         *    alert(animationStatus);
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._animate;
        }
        /**
         * Set maximum value that can be passed. By default it is set to 100.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
         * ```
         * @param {?} maxNum
         * @return {?}
         */

      }, {
        key: "max",
        set: function set(maxNum) {
          this._max = maxNum;
        }
        /**
         * Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent;
         * public maxValue(event) {
         *    let max = this.progressBar.max;
         *    alert(max);
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._max;
        }
        /**
         * Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent;
         * public stepValue(event) {
         *    let step = this.progressBar.step;
         *    alert(step);
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "step",
        get: function get() {
          if (this._step) {
            return this._step;
          }

          return this._max * ONE_PERCENT;
        }
        /**
         * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
         * ```
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._step = Number(val);
        }
        /**
         * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent;
         * public getValue(event) {
         *    let value = this.progressBar.value;
         *    alert(value);
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * Set value that indicates the current `IgxLinearProgressBarComponent` position.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          val = Number(val);

          if (this._value === val || this.indeterminate) {
            return;
          }
          /** @type {?} */


          var valueInRange = getValueInProperRange(val, this.max);

          if (isNaN(valueInRange)) {
            return;
          }
          /** @type {?} */


          var changedValues = {
            currentValue: valueInRange,
            previousValue: this._value
          };
          /** @type {?} */

          var updateValue = _get(_getPrototypeOf(IgxLinearProgressBarComponent.prototype), "directionFlow", this).call(this, this._value, val, this.step);

          if (this._animate && val >= this.step) {
            _get(_getPrototypeOf(IgxLinearProgressBarComponent.prototype), "runAnimation", this).call(this, valueInRange, updateValue);
          } else {
            _get(_getPrototypeOf(IgxLinearProgressBarComponent.prototype), "updateProgressDirectly", this).call(this, valueInRange);
          }

          this.onProgressChanged.emit(changedValues);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "danger",
        get: function get() {
          return this.type === IgxProgressType.DANGER;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "info",
        get: function get() {
          return this.type === IgxProgressType.INFO;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "warning",
        get: function get() {
          return this.type === IgxProgressType.WARNING;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "success",
        get: function get() {
          return this.type === IgxProgressType.SUCCESS;
        }
      }]);

      return IgxLinearProgressBarComponent;
    }(BaseProgress);

    IgxLinearProgressBarComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-linear-bar',
        template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\"\n    [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
      }]
    }];
    /** @nocollapse */

    IgxLinearProgressBarComponent.ctorParameters = function () {
      return [];
    };

    IgxLinearProgressBarComponent.propDecorators = {
      animate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      max: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-valuemax']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      step: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      valueMin: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-valuemin']
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-linear-bar']
      }],
      striped: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-linear-bar--striped']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      indeterminate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-linear-bar--indeterminate']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      textAlign: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      textVisibility: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      textTop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      text: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-valuenow']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onProgressChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      danger: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-linear-bar--danger']
      }],
      info: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-linear-bar--info']
      }],
      warning: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-linear-bar--warning']
      }],
      success: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-linear-bar--success']
      }]
    };

    var IgxCircularProgressBarComponent =
    /*#__PURE__*/
    function (_BaseProgress2) {
      _inherits(IgxCircularProgressBarComponent, _BaseProgress2);

      /**
       * @param {?} renderer
       */
      function IgxCircularProgressBarComponent(renderer) {
        var _this286;

        _classCallCheck(this, IgxCircularProgressBarComponent);

        _this286 = _possibleConstructorReturn(this, _getPrototypeOf(IgxCircularProgressBarComponent).call(this));
        _this286.renderer = renderer;
        _this286.STROKE_OPACITY_DVIDER = 100;
        _this286.STROKE_OPACITY_ADDITION = .2;
        /**
         * @hidden
         */

        _this286.cssClass = 'igx-circular-bar';
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * ```
         */

        _this286.onProgressChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */

        _this286.id = "igx-circular-bar-".concat(NEXT_CIRCULAR_ID++);
        /**
         * An \@Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         * ```html
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */

        _this286.indeterminate = false;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */

        _this286.textVisibility = true;
        _this286._circleRadius = 46;
        _this286._circumference = 2 * Math.PI * _this286._circleRadius;
        return _this286;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxCircularProgressBarComponent, [{
        key: "updateProgressSmoothly",

        /**
         * @hidden
         * @param {?} val
         * @param {?} step
         * @return {?}
         */
        value: function updateProgressSmoothly(val, step) {
          // Set frames for the animation

          /** @type {?} */
          var FRAMES = [{
            strokeDashoffset: this.getProgress(this._value),
            strokeOpacity: this._value / this.STROKE_OPACITY_DVIDER + this.STROKE_OPACITY_ADDITION
          }, {
            strokeDashoffset: this.getProgress(this.valueInPercent),
            strokeOpacity: this.valueInPercent / this.STROKE_OPACITY_DVIDER + this.STROKE_OPACITY_ADDITION
          }];

          this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
          });

          _get(_getPrototypeOf(IgxCircularProgressBarComponent.prototype), "updateProgressSmoothly", this).call(this, val, step);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "updateProgressDirectly",

        /**
         * @hidden
         * @param {?} val
         * @return {?}
         */
        value: function updateProgressDirectly(val) {
          _get(_getPrototypeOf(IgxCircularProgressBarComponent.prototype), "updateProgressDirectly", this).call(this, val);

          this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
          this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', this.valueInPercent / this.STROKE_OPACITY_DVIDER + this.STROKE_OPACITY_ADDITION);
        }
        /**
         * @private
         * @param {?} percentage
         * @return {?}
         */

      }, {
        key: "getProgress",
        value: function getProgress(percentage) {
          // Reverse the sign here: '-' should become '+' in RTL mode
          return this._circumference - percentage * this._circumference / 100;
        }
      }, {
        key: "context",
        get: function get() {
          return {
            $implicit: {
              value: this.value,
              valueInPercent: this.valueInPercent,
              max: this.max
            }
          };
        }
        /**
         * Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
         * ```html
         * <igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
         * ```
         * @param {?} animate
         * @return {?}
         */

      }, {
        key: "animate",
        set: function set(animate) {
          this._animate = animate;
        }
        /**
         * Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxCircularProgressBarComponent;
         * public animationStatus(event) {
         *    let animationStatus = this.progressBar.animate;
         *    alert(animationStatus);
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._animate;
        }
        /**
         * Set maximum value that can be passed. By default it is set to 100.
         * ```html
         * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
         * ```
         * @param {?} maxNum
         * @return {?}
         */

      }, {
        key: "max",
        set: function set(maxNum) {
          this._max = maxNum;
        }
        /**
         * Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxCircularProgressBarComponent;
         * public maxValue(event) {
         *    let max = this.progressBar.max;
         *    alert(max);
         * }
         * ```
         * ```html
         * <igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._max;
        }
        /**
         * Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxCircularProgressBarComponent;
         * public stepValue(event) {
         *    let step = this.progressBar.step;
         *    alert(step);
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "step",
        get: function get() {
          if (this._step) {
            return this._step;
          }

          return this._max * ONE_PERCENT;
        }
        /**
         * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
         * ```html
         * <igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
         * ```
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._step = Number(val);
        }
        /**
         * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxCircularProgressBarComponent;
         * public getValue(event) {
         *    let value = this.progressBar.value;
         *    alert(value);
         * }
         * ```
         * ```html
         * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
         * ```
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
        /**
         * Set value that indicates the current `IgxCircularProgressBarComponent` position.
         * ```html
         * <igx-circular-bar [value]="50"></igx-circular-bar>
         * ```
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          val = Number(val);

          if (this._value === val || this.indeterminate) {
            return;
          }
          /** @type {?} */


          var valueInProperRange = getValueInProperRange(val, this.max);

          if (isNaN(valueInProperRange)) {
            return;
          }
          /** @type {?} */


          var changedValues = {
            currentValue: valueInProperRange,
            previousValue: this._value
          };
          /** @type {?} */

          var updateValue = _get(_getPrototypeOf(IgxCircularProgressBarComponent.prototype), "directionFlow", this).call(this, this._value, val, this.step);

          if (this.animate && val >= this.step) {
            _get(_getPrototypeOf(IgxCircularProgressBarComponent.prototype), "runAnimation", this).call(this, valueInProperRange, updateValue);
          } else {
            this.updateProgressDirectly(valueInProperRange);
          }

          this.onProgressChanged.emit(changedValues);
        }
      }, {
        key: "textContent",
        get: function get() {
          return this.text;
        }
      }]);

      return IgxCircularProgressBarComponent;
    }(BaseProgress);

    IgxCircularProgressBarComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-circular-bar',
        template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate; context: context\">\n        </ng-container>\n    </text>\n\n    <ng-template #defaultTextTemplate>\n        <tspan class=\"igx-circular-bar__text\"> {{textContent ? textContent: valueInPercent + '%'}}</tspan>\n    </ng-template>\n</svg>\n"
      }]
    }];
    /** @nocollapse */

    IgxCircularProgressBarComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }];
    };

    IgxCircularProgressBarComponent.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-circular-bar']
      }],
      onProgressChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      indeterminate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-circular-bar--indeterminate']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      textVisibility: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      text: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      textTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxProcessBarTextTemplateDirective, {
          read: IgxProcessBarTextTemplateDirective,
          "static": false
        }]
      }],
      animate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      max: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      step: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      _svgCircle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['circle', {
          "static": true
        }]
      }]
    };
    /**
     * @param {?} value
     * @param {?} max
     * @param {?=} min
     * @return {?}
     */

    function getValueInProperRange(value, max) {
      var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      return Math.max(Math.min(value, max), min);
    }
    /**
     * @param {?} value
     * @param {?} max
     * @return {?}
     */


    function convertInPercentage(value, max) {
      return Math.floor(100 * value / max);
    }
    /**
     * @hidden
     */


    var IgxProgressBarModule = function IgxProgressBarModule() {
      _classCallCheck(this, IgxProgressBarModule);
    };

    IgxProgressBarModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
        exports: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The `<igx-select-item>` is a container intended for row items in
     * a `<igx-select>` container.
     */

    var IgxSelectGroupComponent =
    /*#__PURE__*/
    function (_IgxDropDownGroupComp) {
      _inherits(IgxSelectGroupComponent, _IgxDropDownGroupComp);

      function IgxSelectGroupComponent() {
        _classCallCheck(this, IgxSelectGroupComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxSelectGroupComponent).apply(this, arguments));
      }

      return IgxSelectGroupComponent;
    }(IgxDropDownGroupComponent);

    IgxSelectGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-select-item-group',
        template: "\n        <label id=\"{{labelId}}\">{{ label }}</label>\n        <ng-content select=\"igx-select-item\"></ng-content>\n    "
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden \@internal
     */

    var IgxSelectItemNavigationDirective =
    /*#__PURE__*/
    function (_IgxDropDownItemNavig2) {
      _inherits(IgxSelectItemNavigationDirective, _IgxDropDownItemNavig2);

      function IgxSelectItemNavigationDirective() {
        var _this287;

        _classCallCheck(this, IgxSelectItemNavigationDirective);

        _this287 = _possibleConstructorReturn(this, _getPrototypeOf(IgxSelectItemNavigationDirective).call(this, null)); // tslint:disable:member-ordering

        _this287.inputStream = '';
        _this287.clearStream$ = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
        return _this287;
      }
      /**
       * Captures keydown events and calls the appropriate handlers on the target component
       * @param {?} event
       * @return {?}
       */


      _createClass(IgxSelectItemNavigationDirective, [{
        key: "handleKeyDown",
        value: function handleKeyDown(event) {
          if (!event || event.shiftKey) {
            return;
          }
          /** @type {?} */


          var key = event.key.toLowerCase();

          if (event.altKey && (key === 'arrowdown' || key === 'arrowup' || key === 'down' || key === 'up')) {
            this.target.toggle();
            return;
          }

          if (this.target.collapsed) {
            switch (key) {
              case 'space':
              case 'spacebar':
              case ' ':
              case 'enter':
                event.preventDefault();
                this.target.open();
                return;

              case 'arrowdown':
              case 'down':
                this.target.navigateNext();
                this.target.selectItem(this.target.focusedItem);
                event.preventDefault();
                return;

              case 'arrowup':
              case 'up':
                this.target.navigatePrev();
                this.target.selectItem(this.target.focusedItem);
                event.preventDefault();
                return;

              default:
                break;
            }
          }

          _get(_getPrototypeOf(IgxSelectItemNavigationDirective.prototype), "handleKeyDown", this).call(this, event);
        }
        /**
         * Handle continuous letter typing navigation
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "captureKey",
        value: function captureKey(event) {
          var _this288 = this;

          // relying only on key, available on all major browsers:
          // https://caniuse.com/#feat=keyboardevent-key (IE/Edge quirk doesn't affect letter typing)
          if (!event || !event.key || event.key.length > 1) {
            // ignore longer keys ('Alt', 'ArrowDown', etc)
            return;
          }

          this.clearStream$.unsubscribe();
          this.clearStream$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["timer"])(500).subscribe(function () {
            _this288.inputStream = '';
          });
          this.inputStream += event.key;
          /** @type {?} */

          var focusedItem =
          /** @type {?} */
          this.target.focusedItem; // select the item

          if (focusedItem && this.inputStream.length > 1 && focusedItem.itemText.toLowerCase().startsWith(this.inputStream.toLowerCase())) {
            return;
          }

          this.activateItemByText(this.inputStream);
        }
        /**
         * @param {?} text
         * @return {?}
         */

      }, {
        key: "activateItemByText",
        value: function activateItemByText(text) {
          /** @type {?} */
          var items =
          /** @type {?} */
          this.target.items;
          /** @type {?} */

          var activeItemIndex = items.indexOf(
          /** @type {?} */
          this.target.focusedItem) || 0; // ^ this is focused OR selected if the dd is closed

          /** @type {?} */

          var nextItem = items.slice(activeItemIndex + 1).find(function (x) {
            return !x.disabled && x.itemText.toLowerCase().startsWith(text.toLowerCase());
          });

          if (!nextItem) {
            nextItem = items.slice(0, activeItemIndex).find(function (x) {
              return !x.disabled && x.itemText.toLowerCase().startsWith(text.toLowerCase());
            });
          }

          if (!nextItem) {
            return;
          }

          if (this.target.collapsed) {
            this.target.selectItem(nextItem);
          }

          this.target.navigateItem(items.indexOf(nextItem));
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this.clearStream$.unsubscribe();
        }
      }]);

      return IgxSelectItemNavigationDirective;
    }(IgxDropDownItemNavigationDirective);

    IgxSelectItemNavigationDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxSelectItemNavigation]'
      }]
    }];
    /** @nocollapse */

    IgxSelectItemNavigationDirective.ctorParameters = function () {
      return [];
    };

    IgxSelectItemNavigationDirective.propDecorators = {
      target: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxSelectItemNavigation']
      }],
      captureKey: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keyup', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxSelectModule = function IgxSelectModule() {
      _classCallCheck(this, IgxSelectModule);
    };

    IgxSelectModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxSelectComponent, IgxSelectItemComponent, IgxSelectItemNavigationDirective, IgxSelectToggleIconDirective, IgxSelectGroupComponent],
        exports: [IgxSelectComponent, IgxSelectItemComponent, IgxSelectItemNavigationDirective, IgxSelectToggleIconDirective, IgxSelectGroupComponent],
        imports: [IgxRippleModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxInputGroupModule, _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["ReactiveFormsModule"], IgxToggleModule, IgxDropDownModule, IgxButtonModule, IgxIconModule],
        providers: []
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxPaginatorComponent =
    /*#__PURE__*/
    function (_DisplayDensityBase9) {
      _inherits(IgxPaginatorComponent, _DisplayDensityBase9);

      /**
       * @param {?} _displayDensityOptions
       */
      function IgxPaginatorComponent(_displayDensityOptions) {
        var _this289;

        _classCallCheck(this, IgxPaginatorComponent);

        _this289 = _possibleConstructorReturn(this, _getPrototypeOf(IgxPaginatorComponent).call(this, _displayDensityOptions));
        _this289._displayDensityOptions = _displayDensityOptions;
        _this289._page = 0;
        _this289.defaultSelectValues = [5, 10, 15, 25, 50, 100, 500];
        _this289._perPage = 15;
        /**
         * An \@Input property that sets if the pager in the paginator should be enabled.
         * ```html
         * <igx-paginator [pagerEnabled]="true"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */

        _this289.pagerEnabled = true;
        /**
         * An \@Input property that sets if the pager in the paginator should be hidden.
         * ```html
         * <igx-paginator [pagerHidden]="true"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */

        _this289.pagerHidden = false;
        /**
         * An \@Input property that sets if the dropdown in the paginator should be enabled.
         * ```html
         * <igx-paginator [dropdownEnabled]="true"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */

        _this289.dropdownEnabled = true;
        /**
         * An \@Input property that sets if the dropdown in the paginator should be hidden.
         * ```html
         * <igx-paginator [dropdownHidden]="true"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */

        _this289.dropdownHidden = false;
        /**
         * An \@Input property, sets number of label of the select.
         * The default is 'Items per page' localized string.
         * ```html
         * <igx-paginator label="My custom label"></igx-paginator>
         * ```
         * \@memberof IgxPaginatorComponent
         */

        _this289.selectLabel = CurrentResourceStrings.PaginatorResStrings.igx_paginator_label;
        /**
         * An event that is emitted when the select in the `IgxPaginatorComponent` changes its value.
         */

        _this289.perPageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that is emitted when the paginating is used.
         */

        _this289.pageChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this289;
      }
      /**
       * Sets the class of the IgxPaginatorComponent based
       * on the provided displayDensity.
       * @return {?}
       */


      _createClass(IgxPaginatorComponent, [{
        key: "sortUniqueOptions",

        /**
         * @private
         * @param {?} values
         * @param {?} newOption
         * @return {?}
         */
        value: function sortUniqueOptions(values, newOption) {
          return Array.from(new Set([].concat(_toConsumableArray(values), [newOption]))).sort(function (a, b) {
            return a - b;
          });
        }
        /**
         * Sets DisplayDensity for the <select> inside the paginator
         * @hidden
         * @return {?}
         */

      }, {
        key: "paginatorSelectDisplayDensity",
        value: function paginatorSelectDisplayDensity() {
          if (this.displayDensity === DisplayDensity.comfortable) {
            return DisplayDensity.cosy;
          }

          return DisplayDensity.compact;
        }
        /**
         * Goes to the next page of the `IgxPaginatorComponent`, if the paginator is not already at the last page.
         * ```typescript
         * this.paginator.nextPage();
         * ```
         * \@memberof IgxPaginatorComponent
         * @return {?}
         */

      }, {
        key: "nextPage",
        value: function nextPage() {
          if (!this.isLastPage) {
            this.page += 1;
          }
        }
        /**
         * Goes to the previous page of the `IgxPaginatorComponent`, if the paginator is not already at the first page.
         * ```typescript
         * this.paginator.previousPage();
         * ```
         * \@memberof IgxPaginatorComponent
         * @return {?}
         */

      }, {
        key: "previousPage",
        value: function previousPage() {
          if (!this.isFirstPage) {
            this.page -= 1;
          }
        }
        /**
         * Goes to the desired page index.
         * ```typescript
         * this.pagiantor.paginate(1);
         * ```
         * \@memberof IgxPaginatorComponent
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "paginate",
        value: function paginate(val) {
          if (val < 0 || val > this.totalPages - 1) {
            return;
          }

          this.page = val;
        }
      }, {
        key: "classCosy",
        get: function get() {
          return this.displayDensity === DisplayDensity.cosy;
        }
        /**
         * @return {?}
         */

      }, {
        key: "classCompact",
        get: function get() {
          return this.displayDensity === DisplayDensity.compact;
        }
        /**
         * @return {?}
         */

      }, {
        key: "classComfortable",
        get: function get() {
          return this.displayDensity === DisplayDensity.comfortable;
        }
        /**
         * An \@Input property, sets current page of the `IgxPaginatorComponent`.
         * The default is 0.
         * ```typescript
         * let page = this.paginator.page;
         * ```
         * \@memberof IgxPaginatorComponent
         * @return {?}
         */

      }, {
        key: "page",
        get: function get() {
          return this._page;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._page = value;
          this.pageChange.emit(this._page);
        }
        /**
         * An \@Input property, sets number of visible items per page in the `IgxPaginatorComponent`.
         * The default is 15.
         * ```typescript
         * let itemsPerPage = this.paginator.perPage;
         * ```
         * \@memberof IgxPaginatorComponent
         * @return {?}
         */

      }, {
        key: "perPage",
        get: function get() {
          return this._perPage;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._perPage = Number(value);
          this.perPageChange.emit(this._perPage);
          this._selectOptions = this.sortUniqueOptions(this.defaultSelectValues, this._perPage);
          this.totalPages = Math.ceil(this.totalRecords / this._perPage);
        }
        /**
         * An \@Input property that sets the total records.
         * ```typescript
         * let totalRecords = this.paginator.totalRecords;
         * ```
         * \@memberof IgxPaginatorComponent
         * @return {?}
         */

      }, {
        key: "totalRecords",
        get: function get() {
          return this._totalRecords;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._totalRecords = value;
          this.totalPages = Math.ceil(this.totalRecords / this.perPage);
        }
        /**
         * An \@Input property that sets custom options in the select of the paginator
         * ```typescript
         * let options = this.paginator.selectOptions;
         * ```
         * \@memberof IgxPaginatorComponent
         * @return {?}
         */

      }, {
        key: "selectOptions",
        get: function get() {
          return this._selectOptions;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._selectOptions = this.sortUniqueOptions(value, this._perPage);
          this.defaultSelectValues = _toConsumableArray(this._selectOptions);
        }
        /**
         * Returns if the current page is the last page.
         * ```typescript
         * const lastPage = this.paginator.isLastPage;
         * ```
         * @return {?}
         */

      }, {
        key: "isLastPage",
        get: function get() {
          return this.page + 1 >= this.totalPages;
        }
        /**
         * Returns if the current page is the first page.
         * ```typescript
         * const lastPage = this.paginator.isFirstPage;
         * ```
         * @return {?}
         */

      }, {
        key: "isFirstPage",
        get: function get() {
          return this.page === 0;
        }
      }]);

      return IgxPaginatorComponent;
    }(DisplayDensityBase);

    IgxPaginatorComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-paginator',
        template: "<div class=\"igx-paginator__select\" [hidden]=\"dropdownHidden\">\n    <label class=\"igx-paginator__label\">{{ selectLabel }}</label>\n    <div class=\"igx-paginator__select-input\">\n        <igx-select [(ngModel)]=\"perPage\" [displayDensity]=\"paginatorSelectDisplayDensity()\" type=\"border\"\n            [disabled]=\"!dropdownEnabled\">\n            <igx-select-item [value]=\"val\" *ngFor=\"let val of selectOptions\">\n                {{val}}\n            </igx-select-item>\n        </igx-select>\n    </div>\n</div>\n<div class=\"igx-paginator__pager\" [hidden]=\"pagerHidden\">\n    <button [disabled]=\"isFirstPage || !pagerEnabled ? true: false\" (click)=\"paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [disabled]=\"isFirstPage || !pagerEnabled ? true: false\" (click)=\"previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <div class='igx-paginator__pager-text'>\n        <span>{{ page + 1 }}</span>\n        <span>&nbsp;of&nbsp;</span>\n        <span>{{ totalPages }}</span>\n    </div>\n    <button [disabled]=\"isLastPage || !pagerEnabled ? true: false\" (click)=\"nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n    <button [disabled]=\"isLastPage || !pagerEnabled ? true: false\" (click)=\"paginate(totalPages - 1)\" igxButton=\"icon\" igxRipple\n        igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxPaginatorComponent.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxPaginatorComponent.propDecorators = {
      classCosy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-paginator--cosy']
      }],
      classCompact: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-paginator--compact']
      }],
      classComfortable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-paginator']
      }],
      page: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      perPage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      totalRecords: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selectOptions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      pagerEnabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      pagerHidden: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dropdownEnabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dropdownHidden: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selectLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      perPageChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      pageChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };

    var IgxPaginatorModule = function IgxPaginatorModule() {
      _classCallCheck(this, IgxPaginatorModule);
    };

    IgxPaginatorModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxPaginatorComponent],
        exports: [IgxPaginatorComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxSelectModule, _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], IgxIconModule, IgxButtonModule, IgxRippleModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * \@internal
     */

    var IgxGridCellStyleClassesPipe =
    /*#__PURE__*/
    function () {
      function IgxGridCellStyleClassesPipe() {
        _classCallCheck(this, IgxGridCellStyleClassesPipe);
      }

      _createClass(IgxGridCellStyleClassesPipe, [{
        key: "transform",

        /**
         * @param {?} cssClasses
         * @param {?} value
         * @param {?} data
         * @param {?} field
         * @param {?} index
         * @return {?}
         */
        value: function transform(cssClasses, value, data, field, index) {
          if (!cssClasses) {
            return '';
          }
          /** @type {?} */


          var result = [];

          for (var _i24 = 0, _Object$keys11 = Object.keys(cssClasses); _i24 < _Object$keys11.length; _i24++) {
            var cssClass = _Object$keys11[_i24];

            /** @type {?} */
            var callbackOrValue = cssClasses[cssClass];
            /** @type {?} */

            var apply = typeof callbackOrValue === 'function' ? callbackOrValue(data, field, value, index) : callbackOrValue;

            if (apply) {
              result.push(cssClass);
            }
          }

          return result.join(' ');
        }
      }]);

      return IgxGridCellStyleClassesPipe;
    }();

    IgxGridCellStyleClassesPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'igxCellStyleClasses'
      }]
    }];
    /**
     * @hidden
     * \@internal
     */

    var IgxGridCellStylesPipe =
    /*#__PURE__*/
    function () {
      function IgxGridCellStylesPipe() {
        _classCallCheck(this, IgxGridCellStylesPipe);
      }

      _createClass(IgxGridCellStylesPipe, [{
        key: "transform",

        /**
         * @param {?} styles
         * @param {?} value
         * @param {?} data
         * @param {?} field
         * @param {?} index
         * @return {?}
         */
        value: function transform(styles, value, data, field, index) {
          /** @type {?} */
          var css = {};

          if (!styles) {
            return css;
          }

          for (var _i25 = 0, _Object$keys12 = Object.keys(styles); _i25 < _Object$keys12.length; _i25++) {
            var prop = _Object$keys12[_i25];

            /** @type {?} */
            var res = styles[prop];
            css[prop] = typeof res === 'function' ? res(data, field, value, index) : res;
          }

          return css;
        }
      }]);

      return IgxGridCellStylesPipe;
    }();

    IgxGridCellStylesPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'igxCellStyles'
      }]
    }];
    /**
     * @hidden
     * \@internal
     */

    var IgxGridNotGroupedPipe =
    /*#__PURE__*/
    function () {
      function IgxGridNotGroupedPipe() {
        _classCallCheck(this, IgxGridNotGroupedPipe);
      }

      _createClass(IgxGridNotGroupedPipe, [{
        key: "transform",

        /**
         * @param {?} value
         * @return {?}
         */
        value: function transform(value) {
          return value.filter(function (item) {
            return !item.columnGroup;
          });
        }
      }]);

      return IgxGridNotGroupedPipe;
    }();

    IgxGridNotGroupedPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'igxNotGrouped'
      }]
    }];

    var IgxGridTopLevelColumns =
    /*#__PURE__*/
    function () {
      function IgxGridTopLevelColumns() {
        _classCallCheck(this, IgxGridTopLevelColumns);
      }

      _createClass(IgxGridTopLevelColumns, [{
        key: "transform",

        /**
         * @param {?} value
         * @return {?}
         */
        value: function transform(value) {
          return value.filter(function (item) {
            return item.level === 0;
          });
        }
      }]);

      return IgxGridTopLevelColumns;
    }();

    IgxGridTopLevelColumns.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'igxTopLevel'
      }]
    }];
    /**
     * @hidden
     */

    var IgxGridFilterConditionPipe =
    /*#__PURE__*/
    function () {
      function IgxGridFilterConditionPipe() {
        _classCallCheck(this, IgxGridFilterConditionPipe);
      }

      _createClass(IgxGridFilterConditionPipe, [{
        key: "transform",

        /**
         * @param {?} value
         * @return {?}
         */
        value: function transform(value) {
          return value.split(/(?=[A-Z])/).join(' ');
        }
      }]);

      return IgxGridFilterConditionPipe;
    }();

    IgxGridFilterConditionPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'filterCondition',
        pure: true
      }]
    }];
    /**
     * @hidden
     */

    var IgxGridTransactionPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxGridTransactionPipe(gridAPI) {
        _classCallCheck(this, IgxGridTransactionPipe);

        this.gridAPI = gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?} id
       * @param {?} pipeTrigger
       * @return {?}
       */


      _createClass(IgxGridTransactionPipe, [{
        key: "transform",
        value: function transform(collection, id, pipeTrigger) {
          /** @type {?} */
          var grid = this.gridAPI.grid;

          if (grid.transactions.enabled) {
            /** @type {?} */
            var result = DataUtil.mergeTransactions(cloneArray(collection), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
            return result;
          }

          return collection;
        }
      }]);

      return IgxGridTransactionPipe;
    }();

    IgxGridTransactionPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'gridTransaction',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxGridTransactionPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @hidden
     */


    var IgxGridPaginatorOptionsPipe =
    /*#__PURE__*/
    function () {
      function IgxGridPaginatorOptionsPipe() {
        _classCallCheck(this, IgxGridPaginatorOptionsPipe);
      }

      _createClass(IgxGridPaginatorOptionsPipe, [{
        key: "transform",

        /**
         * @param {?} values
         * @return {?}
         */
        value: function transform(values) {
          return Array.from(new Set(_toConsumableArray(values))).sort(function (a, b) {
            return a - b;
          });
        }
      }]);

      return IgxGridPaginatorOptionsPipe;
    }();

    IgxGridPaginatorOptionsPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'paginatorOptions',
        pure: true
      }]
    }];

    var IgxHasVisibleColumnsPipe =
    /*#__PURE__*/
    function () {
      function IgxHasVisibleColumnsPipe() {
        _classCallCheck(this, IgxHasVisibleColumnsPipe);
      }

      _createClass(IgxHasVisibleColumnsPipe, [{
        key: "transform",

        /**
         * @param {?} values
         * @param {?} hasVisibleColumns
         * @return {?}
         */
        value: function transform(values, hasVisibleColumns) {
          if (!(values && values.length)) {
            return values;
          }

          return hasVisibleColumns ? values : [];
        }
      }]);

      return IgxHasVisibleColumnsPipe;
    }();

    IgxHasVisibleColumnsPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'visibleColumns',
        pure: true
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxGridPipesModule = function IgxGridPipesModule() {
      _classCallCheck(this, IgxGridPipesModule);
    };

    IgxGridPipesModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxDatePipeComponent, IgxDecimalPipeComponent, IgxGridFilterConditionPipe, IgxGridTransactionPipe, IgxGridNotGroupedPipe, IgxGridTopLevelColumns, IgxGridCellStylesPipe, IgxGridCellStyleClassesPipe, IgxGridPaginatorOptionsPipe, IgxHasVisibleColumnsPipe],
        exports: [IgxDatePipeComponent, IgxDecimalPipeComponent, IgxGridFilterConditionPipe, IgxGridTransactionPipe, IgxGridNotGroupedPipe, IgxGridTopLevelColumns, IgxGridCellStylesPipe, IgxGridCellStyleClassesPipe, IgxGridPaginatorOptionsPipe, IgxHasVisibleColumnsPipe],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxExcelStyleColumnMovingComponent =
    /*#__PURE__*/
    function () {
      function IgxExcelStyleColumnMovingComponent() {
        _classCallCheck(this, IgxExcelStyleColumnMovingComponent);
      }
      /**
       * @private
       * @return {?}
       */


      _createClass(IgxExcelStyleColumnMovingComponent, [{
        key: "onMoveButtonClicked",

        /**
         * @param {?} moveDirection
         * @return {?}
         */
        value: function onMoveButtonClicked(moveDirection) {
          /** @type {?} */
          var targetColumn;

          if (this.column.pinned) {
            if (this.column.isLastPinned && moveDirection === 1) {
              targetColumn = this.grid.unpinnedColumns[0];
              moveDirection = 0;
            } else {
              targetColumn = this.findColumn(moveDirection, this.grid.pinnedColumns);
            }
          } else if (this.grid.unpinnedColumns.indexOf(this.column) === 0 && moveDirection === 0) {
            targetColumn = this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1];

            if (targetColumn.parent) {
              targetColumn = targetColumn.topLevelParent;
            }

            moveDirection = 1;
          } else {
            targetColumn = this.findColumn(moveDirection, this.grid.unpinnedColumns);
          }

          this.grid.moveColumn(this.column, targetColumn, moveDirection);
        }
        /**
         * @private
         * @param {?} moveDirection
         * @param {?} columns
         * @return {?}
         */

      }, {
        key: "findColumn",
        value: function findColumn(moveDirection, columns) {
          /** @type {?} */
          var index = columns.indexOf(this.column);

          if (moveDirection === 0) {
            while (index > 0) {
              index--;

              if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                return columns[index];
              }
            }
          } else {
            while (index < columns.length - 1) {
              index++;

              if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                return columns[index];
              }
            }
          }
        }
      }, {
        key: "visibleColumns",
        get: function get() {
          return this.grid.visibleColumns.filter(function (col) {
            return !(col instanceof IgxColumnGroupComponent);
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "canNotMoveLeft",
        get: function get() {
          return this.column.visibleIndex === 0 || this.grid.unpinnedColumns.indexOf(this.column) === 0 && this.column.disablePinning || this.grid.unpinnedColumns.indexOf(this.column) === 0 && !this.isColumnPinnable || this.column.level !== 0 && !this.findColumn(0, this.visibleColumns);
        }
        /**
         * @return {?}
         */

      }, {
        key: "canNotMoveRight",
        get: function get() {
          return this.column.visibleIndex === this.visibleColumns.length - 1 || this.column.level !== 0 && !this.findColumn(1, this.visibleColumns);
        }
      }]);

      return IgxExcelStyleColumnMovingComponent;
    }();

    IgxExcelStyleColumnMovingComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-excel-style-column-moving',
        template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_moving_header }}\n</header>\n<section class=\"igx-excel-filter__move-buttons\">\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveLeft\"\n        (click)=\"onMoveButtonClicked(0)\">\n        <igx-icon>arrow_back</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_left_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_left }}\n        </span>\n    </button>\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveRight\"\n        (click)=\"onMoveButtonClicked(1)\">\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_right_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_right }}\n        </span>\n        <igx-icon>arrow_forwards</igx-icon>\n    </button>\n</section>\n"
      }]
    }];
    /** @nocollapse */

    IgxExcelStyleColumnMovingComponent.ctorParameters = function () {
      return [];
    };

    IgxExcelStyleColumnMovingComponent.propDecorators = {
      column: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      grid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      displayDensity: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isColumnPinnable: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @abstract
     */

    var IgxListBase =
    /*#__PURE__*/
    function (_DisplayDensityBase10) {
      _inherits(IgxListBase, _DisplayDensityBase10);

      /**
       * @param {?} _displayDensityOptions
       */
      function IgxListBase(_displayDensityOptions) {
        var _this290;

        _classCallCheck(this, IgxListBase);

        _this290 = _possibleConstructorReturn(this, _getPrototypeOf(IgxListBase).call(this, _displayDensityOptions));
        _this290._displayDensityOptions = _displayDensityOptions;
        return _this290;
      }

      return IgxListBase;
    }(DisplayDensityBase);
    /** @nocollapse */


    IgxListBase.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };
    /** @enum {number} */


    var IgxListPanState = {
      NONE: 0,
      LEFT: 1,
      RIGHT: 2
    };
    IgxListPanState[IgxListPanState.NONE] = 'NONE';
    IgxListPanState[IgxListPanState.LEFT] = 'LEFT';
    IgxListPanState[IgxListPanState.RIGHT] = 'RIGHT';

    var IgxEmptyListTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxEmptyListTemplateDirective(template) {
      _classCallCheck(this, IgxEmptyListTemplateDirective);

      this.template = template;
    };

    IgxEmptyListTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxEmptyList]'
      }]
    }];
    /** @nocollapse */

    IgxEmptyListTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxDataLoadingTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxDataLoadingTemplateDirective(template) {
      _classCallCheck(this, IgxDataLoadingTemplateDirective);

      this.template = template;
    };

    IgxDataLoadingTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxDataLoading]'
      }]
    }];
    /** @nocollapse */

    IgxDataLoadingTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxListItemLeftPanningTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxListItemLeftPanningTemplateDirective(template) {
      _classCallCheck(this, IgxListItemLeftPanningTemplateDirective);

      this.template = template;
    };

    IgxListItemLeftPanningTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxListItemLeftPanning]'
      }]
    }];
    /** @nocollapse */

    IgxListItemLeftPanningTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxListItemRightPanningTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxListItemRightPanningTemplateDirective(template) {
      _classCallCheck(this, IgxListItemRightPanningTemplateDirective);

      this.template = template;
    };

    IgxListItemRightPanningTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxListItemRightPanning]'
      }]
    }];
    /** @nocollapse */

    IgxListItemRightPanningTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * The Ignite UI List Item component is a container intended for row items in the Ignite UI for Angular List component.
     *
     * Example:
     * ```html
     * <igx-list>
     *   <igx-list-item isHeader="true">Contacts</igx-list-item>
     *   <igx-list-item *ngFor="let contact of contacts">
     *     <span class="name">{{ contact.name }}</span>
     *     <span class="phone">{{ contact.phone }}</span>
     *   </igx-list-item>
     * </igx-list>
     * ```
     */


    var IgxListItemComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} list
       * @param {?} elementRef
       * @param {?} _renderer
       */
      function IgxListItemComponent(list, elementRef, _renderer) {
        _classCallCheck(this, IgxListItemComponent);

        this.list = list;
        this.elementRef = elementRef;
        this._renderer = _renderer;
        /**
         * @hidden
         */

        this._panState = IgxListPanState.NONE;
        /**
         * @hidden
         */

        this.panOffset = 0;
        /**
         * @hidden
         */

        this._index = null;
        /**
         * @hidden
         */

        this.lastPanDir = IgxListPanState.NONE;
        /**
         * Sets/gets whether the `list item` is hidden.
         * By default the `hidden` value is `false`.
         * ```html
         * <igx-list-item [hidden] = "true">Hidden Item</igx-list-item>
         * ```
         * ```typescript
         * let isHidden =  this.listItem.hidden;
         * ```
         * \@memberof IgxListItemComponent
         */

        this.hidden = false;
        /**
         * Gets the `touch-action` style of the `list item`.
         * ```typescript
         * let touchAction = this.listItem.touchAction;
         * ```
         */

        this.touchAction = 'pan-y';
      }
      /**
       * Gets the `role` attribute of the `list item`.
       * ```typescript
       * let itemRole =  this.listItem.role;
       * ```
       * \@memberof IgxListItemComponent
       * @return {?}
       */


      _createClass(IgxListItemComponent, [{
        key: "clicked",

        /**
         * @hidden
         * @param {?} evt
         * @return {?}
         */
        value: function clicked(evt) {
          this.list.onItemClicked.emit({
            item: this,
            event: evt,
            direction: this.lastPanDir
          });
          this.lastPanDir = IgxListPanState.NONE;
        }
        /**
         * @hidden
         * @param {?} ev
         * @return {?}
         */

      }, {
        key: "panStart",
        value: function panStart(ev) {
          if (this.isTrue(this.isHeader)) {
            return;
          }

          if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
          }
        }
        /**
         * @hidden
         * @param {?} ev
         * @return {?}
         */

      }, {
        key: "panMove",
        value: function panMove(ev) {
          if (this.isTrue(this.isHeader)) {
            return;
          }

          if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
          }
          /** @type {?} */


          var isPanningToLeft = ev.deltaX < 0;

          if (isPanningToLeft && this.isTrue(this.list.allowLeftPanning)) {
            this.showLeftPanTemplate();
            this.setContentElementLeft(Math.max(this.maxLeft, ev.deltaX));
          } else if (!isPanningToLeft && this.isTrue(this.list.allowRightPanning)) {
            this.showRightPanTemplate();
            this.setContentElementLeft(Math.min(this.maxRight, ev.deltaX));
          }
        }
        /**
         * @hidden
         * @param {?} ev
         * @return {?}
         */

      }, {
        key: "panEnd",
        value: function panEnd(ev) {
          if (this.isTrue(this.isHeader)) {
            return;
          }

          if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
          } // the translation offset of the current list item content

          /** @type {?} */


          var relativeOffset = this.panOffset;
          /** @type {?} */

          var widthTriggeringGrip = this.width * this.list.panEndTriggeringThreshold;

          if (relativeOffset === 0) {
            return; // no panning has occured
          }
          /** @type {?} */


          var dir = relativeOffset > 0 ? IgxListPanState.RIGHT : IgxListPanState.LEFT;
          this.lastPanDir = dir;
          /** @type {?} */

          var oldPanState = this._panState;

          if (Math.abs(relativeOffset) < widthTriggeringGrip) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
            this.hideLeftAndRightPanTemplates();
            return;
          }
          /** @type {?} */


          var args = {
            item: this,
            direction: dir,
            keepItem: false
          };

          if (dir === IgxListPanState.LEFT) {
            this.list.onLeftPan.emit(args);
          } else {
            this.list.onRightPan.emit(args);
          }

          if (args.keepItem === true) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
          } else {
            if (dir === IgxListPanState.LEFT) {
              this.setContentElementLeft(this.maxLeft);
              this._panState = IgxListPanState.LEFT;
            } else {
              this.setContentElementLeft(this.maxRight);
              this._panState = IgxListPanState.RIGHT;
            }
          }

          if (oldPanState !== this._panState) {
            /** @type {?} */
            var args2 = {
              oldState: oldPanState,
              newState: this._panState,
              item: this
            };
            this.list.onPanStateChange.emit(args2);
          }

          this.hideLeftAndRightPanTemplates();
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "showLeftPanTemplate",
        value: function showLeftPanTemplate() {
          this.setLeftAndRightTemplatesVisibility('visible', 'hidden');
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "showRightPanTemplate",
        value: function showRightPanTemplate() {
          this.setLeftAndRightTemplatesVisibility('hidden', 'visible');
        }
        /**
         * @hidden
         * @private
         * @return {?}
         */

      }, {
        key: "hideLeftAndRightPanTemplates",
        value: function hideLeftAndRightPanTemplates() {
          var _this291 = this;

          setTimeout(function () {
            _this291.setLeftAndRightTemplatesVisibility('hidden', 'hidden');
          }, 500);
        }
        /**
         * @hidden
         * @private
         * @param {?} leftVisibility
         * @param {?} rightVisibility
         * @return {?}
         */

      }, {
        key: "setLeftAndRightTemplatesVisibility",
        value: function setLeftAndRightTemplatesVisibility(leftVisibility, rightVisibility) {
          if (this.leftPanningTemplateElement && this.leftPanningTemplateElement.nativeElement) {
            this.leftPanningTemplateElement.nativeElement.style.visibility = leftVisibility;
          }

          if (this.rightPanningTemplateElement && this.rightPanningTemplateElement.nativeElement) {
            this.rightPanningTemplateElement.nativeElement.style.visibility = rightVisibility;
          }
        }
        /**
         * Gets the `panState` of a `list item`.
         * ```typescript
         * let itemPanState =  this.listItem.panState;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "setContentElementLeft",

        /**
         * @hidden
         * @private
         * @param {?} value
         * @return {?}
         */
        value: function setContentElementLeft(value) {
          this.panOffset = value;
          this.contentElement.style.transform = 'translateX(' + value + 'px)';
        }
        /**
         * @hidden
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "isTrue",
        value: function isTrue(value) {
          if (typeof value === 'boolean') {
            return value;
          } else {
            return value === 'true';
          }
        }
      }, {
        key: "role",
        get: function get() {
          return this.isHeader ? 'separator' : 'listitem';
        }
        /**
         * Indicates whether `list item` should have header style.
         * ```typescript
         * let headerStyle =  this.listItem.headerStyle;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "headerStyle",
        get: function get() {
          return this.isHeader;
        }
        /**
         * Applies the inner style of the `list item` if the item is not counted as header.
         * ```typescript
         * let innerStyle =  this.listItem.innerStyle;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "innerStyle",
        get: function get() {
          return !this.isHeader;
        }
        /**
         * Returns string value which describes the display mode of the `list item`.
         * ```typescript
         * let isHidden = this.listItem.display;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "display",
        get: function get() {
          return this.hidden ? 'none' : '';
        }
      }, {
        key: "panState",
        get: function get() {
          return this._panState;
        }
        /**
         * Gets the `index` of a `list item`.
         * ```typescript
         * let itemIndex =  this.listItem.index;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "index",
        get: function get() {
          return this._index !== null ? this._index : this.list.children.toArray().indexOf(this);
        }
        /**
         * Sets the `index` of the `list item`.
         * ```typescript
         * this.listItem.index = index;
         * ```
         * \@memberof IgxListItemComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._index = value;
        }
        /**
         * Returns an element reference to the list item.
         * ```typescript
         * let listItemElement =  this.listItem.element.
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "element",
        get: function get() {
          return this.elementRef.nativeElement;
        }
        /**
         * Returns a reference container which contains the list item's content.
         * ```typescript
         * let listItemContainer =  this.listItem.contentElement.
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "contentElement",
        get: function get() {
          /** @type {?} */
          var candidates = this.element.getElementsByClassName('igx-list__item-content');
          return candidates && candidates.length > 0 ? candidates[0] : null;
        }
        /**
         * Returns the `context` object which represents the `template context` binding into the `list item container`
         * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.
         * ```typescript
         * let listItemComponent = this.listItem.context;
         * ```
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          return {
            $implicit: this
          };
        }
        /**
         * Gets the width of a `list item`.
         * ```typescript
         * let itemWidth = this.listItem.width;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "width",
        get: function get() {
          if (this.element) {
            return this.element.offsetWidth;
          }
        }
        /**
         * Gets the maximum left position of the `list item`.
         * ```typescript
         * let maxLeft = this.listItem.maxLeft;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "maxLeft",
        get: function get() {
          return -this.width;
        }
        /**
         * Gets the maximum right position of the `list item`.
         * ```typescript
         * let maxRight = this.listItem.maxRight;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */

      }, {
        key: "maxRight",
        get: function get() {
          return this.width;
        }
      }]);

      return IgxListItemComponent;
    }();

    IgxListItemComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [HammerGesturesManager],
        selector: 'igx-list-item',
        template: "   \n<div *ngIf=\"!isHeader && list.listItemLeftPanningTemplate != null\" #leftPanningTmpl class=\"igx-list__item-right\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemLeftPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<div *ngIf=\"!isHeader && list.listItemRightPanningTemplate != null\" #rightPanningTmpl class=\"igx-list__item-left\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemRightPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<ng-template #itemsContent>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #itemThumbnails>\n    <div class=\"igx-list__item-thumbnail\">\n        <ng-content select=\"[igxListThumbnail], igx-list__item-thumbnail, igx-avatar\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemLines>\n    <div class=\"igx-list__item-lines\">\n        <ng-content select=\"[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemActions>\n    <div class=\"igx-list__item-actions\">\n        <ng-content select=\"[igxListAction], .igx-list__item-actions\"></ng-content>\n    </div>\n</ng-template>\n\n    \n<ng-container *ngIf=\"isHeader\">\n    <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"!isHeader\">\n    <div class=\"igx-list__item-content\">\n        <ng-container *ngTemplateOutlet=\"itemThumbnails\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemLines\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemActions\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n    </div>\n</ng-container>\n",
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush
      }]
    }];
    /** @nocollapse */

    IgxListItemComponent.ctorParameters = function () {
      return [{
        type: IgxListBase
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }];
    };

    IgxListItemComponent.propDecorators = {
      leftPanningTemplateElement: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['leftPanningTmpl', {
          "static": false
        }]
      }],
      rightPanningTemplateElement: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['rightPanningTmpl', {
          "static": false
        }]
      }],
      isHeader: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hidden: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-label']
      }],
      touchAction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.touch-action']
      }],
      headerStyle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-list__header']
      }],
      innerStyle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-list__item-base']
      }],
      display: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.display']
      }],
      clicked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }],
      panStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['panstart', ['$event']]
      }],
      panMove: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['panmove', ['$event']]
      }],
      panEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['panend', ['$event']]
      }],
      index: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$l = 0;
    /**
     * **Ignite UI for Angular List** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/list.html)
     *
     * The Ignite UI List displays rows of items and supports one or more header items as well as search and filtering
     * of list items. Each list item is completely templateable and will support any valid HTML or Angular component.
     *
     * Example:
     * ```html
     * <igx-list>
     *   <igx-list-item isHeader="true">Contacts</igx-list-item>
     *   <igx-list-item *ngFor="let contact of contacts">
     *     <span class="name">{{ contact.name }}</span>
     *     <span class="phone">{{ contact.phone }}</span>
     *   </igx-list-item>
     * </igx-list>
     * ```
     */

    /**
     * igxListThumbnail is container for the List media
     * Use it to wrap anything you want to be used as a thumbnail.
     */

    var IgxListThumbnailDirective = function IgxListThumbnailDirective() {
      _classCallCheck(this, IgxListThumbnailDirective);
    };

    IgxListThumbnailDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: '[igxListThumbnail]'
      }]
    }];
    /**
     * igxListAction is container for the List action
     * Use it to wrap anything you want to be used as a list action: icon, checkbox...
     */

    var IgxListActionDirective = function IgxListActionDirective() {
      _classCallCheck(this, IgxListActionDirective);
    };

    IgxListActionDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: '[igxListAction]'
      }]
    }];
    /**
     * igxListLine is container for the List text content
     * Use it to wrap anything you want to be used as a plane text.
     */

    var IgxListLineDirective = function IgxListLineDirective() {
      _classCallCheck(this, IgxListLineDirective);
    };

    IgxListLineDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: '[igxListLine]'
      }]
    }];
    /**
     * igxListLineTitle is a directive that add class to the target element
     * Use it to make anything to look like list Title.
     */

    var IgxListLineTitleDirective = function IgxListLineTitleDirective() {
      _classCallCheck(this, IgxListLineTitleDirective);

      this.cssClass = 'igx-list__item-line-title';
    };

    IgxListLineTitleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: '[igxListLineTitle]'
      }]
    }];
    IgxListLineTitleDirective.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-list__item-line-title']
      }]
    };
    /**
     * igxListLineSubTitle is a directive that add class to the target element
     * Use it to make anything to look like list Subtitle.
     */

    var IgxListLineSubTitleDirective = function IgxListLineSubTitleDirective() {
      _classCallCheck(this, IgxListLineSubTitleDirective);

      this.cssClass = 'igx-list__item-line-subtitle';
    };

    IgxListLineSubTitleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: '[igxListLineSubTitle]'
      }]
    }];
    IgxListLineSubTitleDirective.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-list__item-line-subtitle']
      }]
    };

    var IgxListComponent =
    /*#__PURE__*/
    function (_IgxListBase) {
      _inherits(IgxListComponent, _IgxListBase);

      /**
       * @param {?} element
       * @param {?} _displayDensityOptions
       */
      function IgxListComponent(element, _displayDensityOptions) {
        var _this292;

        _classCallCheck(this, IgxListComponent);

        _this292 = _possibleConstructorReturn(this, _getPrototypeOf(IgxListComponent).call(this, _displayDensityOptions));
        _this292.element = element;
        _this292._displayDensityOptions = _displayDensityOptions;
        /**
         * Provides a threshold after which the item's panning will be completed automatically.
         * By default this property is set to 0.5 which is 50% of the list item's width.
         * ```typescript
         * this.list.panEndTriggeringThreshold = 0.8;
         * ```
         */

        _this292.panEndTriggeringThreshold = 0.5;
        /**
         * Sets/gets the `id` of the list.
         * If not set, the `id` of the first list component will be `"igx-list-0"`.
         * ```html
         * <igx-list id = "my-first-list"></igx-list>
         * ```
         * ```typescript
         * let listId =  this.list.id;
         * ```
         * \@memberof IgxListComponent
         */

        _this292.id = "igx-list-".concat(NEXT_ID$l++);
        /**
         * Sets/gets whether the left panning of an item is allowed.
         * Default value is `false`.
         * ```html
         *  <igx-list [allowLeftPanning] = "true"></igx-list>
         * ```
         * ```typescript
         * let isLeftPanningAllowed = this.list.allowLeftPanning;
         * ```
         * \@memberof IgxListComponent
         */

        _this292.allowLeftPanning = false;
        /**
         * Sets/gets whether the right panning of an item is allowed.
         * Default value is `false`.
         * ```html
         *  <igx-list [allowRightPanning] = "true"></igx-list>
         * ```
         * ```typescript
         * let isRightPanningAllowed = this.list.allowRightPanning;
         * ```
         * \@memberof IgxListComponent
         */

        _this292.allowRightPanning = false;
        /**
         * Sets/gets whether the list is currently loading data.
         * Set it to display the dataLoadingTemplate while data is being retrieved.
         * Default value is `false`.
         * ```html
         *  <igx-list [isLoading]="true"></igx-list>
         * ```
         * ```typescript
         * let isLoading = this.list.isLoading;
         * ```
         * \@memberof IgxListComponent
         */

        _this292.isLoading = false;
        /**
         * Emits an event within the current list when left pan gesture is executed on a list item.
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         * ```html
         * <igx-list [allowLeftPanning]="true" (onLeftPan)="onLeftPan($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */

        _this292.onLeftPan = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event within the current list when right pan gesture is executed on a list item.
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         * ```html
         * <igx-list [allowRightPanning]="true" (onRightPan)="onRightPan($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */

        _this292.onRightPan = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event within the current list when pan gesture is executed on list item.
         * Provides references to the `IgxListItemComponent` and `IgxListPanState` as event arguments.
         * ```html
         * <igx-list (onPanStateChange) = "onPanStateChange($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */

        _this292.onPanStateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event within the current list when a list item has been clicked.
         * Provides references to the `IgxListItemComponent` and `Event` as event arguments.
         *  ```html
         * <igx-list (onItemClicked) = "onItemClicked($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */

        _this292.onItemClicked = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this292;
      }
      /**
       * @hidden
       * \@internal
       * @protected
       * @return {?}
       */


      _createClass(IgxListComponent, [{
        key: "sortedChildren",
        get: function get() {
          if (this.children !== undefined) {
            return this.children.toArray().sort(function (a, b) {
              return a.index - b.index;
            });
          }

          return null;
        }
        /**
         * Gets the `role` attribute.
         * ```typescript
         * let listRole =  this.list.role;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */

      }, {
        key: "role",
        get: function get() {
          return 'list';
        }
        /**
         * Returns boolean indicating if the list is empty.
         * ```typescript
         * let isEmpty =  this.list.isListEmpty;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */

      }, {
        key: "isListEmpty",
        get: function get() {
          return !this.children || this.children.length === 0;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "cssClass",
        get: function get() {
          return !this.isListEmpty && this.displayDensity === DisplayDensity.comfortable;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "cssClassCompact",
        get: function get() {
          return !this.isListEmpty && this.displayDensity === DisplayDensity.compact;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "cssClassCosy",
        get: function get() {
          return !this.isListEmpty && this.displayDensity === DisplayDensity.cosy;
        }
        /**
         * Returns the `items` in the list excluding the headers.
         * ```typescript
         * let listItems: IgxListItemComponent[] = this.list.items;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */

      }, {
        key: "items",
        get: function get() {
          /** @type {?} */
          var items = [];

          if (this.children !== undefined) {
            var _iteratorNormalCompletion57 = true;
            var _didIteratorError57 = false;
            var _iteratorError57 = undefined;

            try {
              for (var _iterator57 = this.sortedChildren[Symbol.iterator](), _step57; !(_iteratorNormalCompletion57 = (_step57 = _iterator57.next()).done); _iteratorNormalCompletion57 = true) {
                var child = _step57.value;

                if (!child.isHeader) {
                  items.push(child);
                }
              }
            } catch (err) {
              _didIteratorError57 = true;
              _iteratorError57 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion57 && _iterator57["return"] != null) {
                  _iterator57["return"]();
                }
              } finally {
                if (_didIteratorError57) {
                  throw _iteratorError57;
                }
              }
            }
          }

          return items;
        }
        /**
         * Returns the headers in the list.
         * ```typescript
         * let listHeaders: IgxListItemComponent[] =  this.list.headers;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */

      }, {
        key: "headers",
        get: function get() {
          /** @type {?} */
          var headers = [];

          if (this.children !== undefined) {
            var _iteratorNormalCompletion58 = true;
            var _didIteratorError58 = false;
            var _iteratorError58 = undefined;

            try {
              for (var _iterator58 = this.children.toArray()[Symbol.iterator](), _step58; !(_iteratorNormalCompletion58 = (_step58 = _iterator58.next()).done); _iteratorNormalCompletion58 = true) {
                var child = _step58.value;

                if (child.isHeader) {
                  headers.push(child);
                }
              }
            } catch (err) {
              _didIteratorError58 = true;
              _iteratorError58 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion58 && _iterator58["return"] != null) {
                  _iterator58["return"]();
                }
              } finally {
                if (_didIteratorError58) {
                  throw _iteratorError58;
                }
              }
            }
          }

          return headers;
        }
        /**
         * Returns the `context` object which represents the `template context` binding into the `list container`
         * by providing the `$implicit` declaration which is the `IgxListComponent` itself.
         * ```typescript
         * let listComponent =  this.list.context;
         * ```
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          return {
            $implicit: this
          };
        }
        /**
         * Returns the `template` of an empty list.
         * ```typescript
         * let listTemplate = this.list.template;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */

      }, {
        key: "template",
        get: function get() {
          if (this.isLoading) {
            return this.dataLoadingTemplate ? this.dataLoadingTemplate.template : this.defaultDataLoadingTemplate;
          } else {
            return this.emptyListTemplate ? this.emptyListTemplate.template : this.defaultEmptyListTemplate;
          }
        }
      }]);

      return IgxListComponent;
    }(IgxListBase);

    IgxListComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-list',
        template: "<ng-content></ng-content>\n\n<ng-template #defaultEmptyList>\n    <article class=\"message\">\n        There are no items in the list.\n    </article>\n</ng-template>\n\n<ng-template #defaultDataLoading>\n    <article class=\"message\">\n        Loading data from the server...\n    </article>\n</ng-template>\n\n<ng-container *ngIf=\"!children || children.length === 0 || isLoading\">\n    <ng-container *ngTemplateOutlet=\"template; context: context\">\n    </ng-container>\n</ng-container>\n",
        providers: [{
          provide: IgxListBase,
          useExisting: IgxListComponent
        }]
      }]
    }];
    /** @nocollapse */

    IgxListComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxListComponent.propDecorators = {
      children: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxListItemComponent;
        })]
      }],
      emptyListTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxEmptyListTemplateDirective, {
          read: IgxEmptyListTemplateDirective,
          "static": false
        }]
      }],
      dataLoadingTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxDataLoadingTemplateDirective, {
          read: IgxDataLoadingTemplateDirective,
          "static": false
        }]
      }],
      listItemLeftPanningTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxListItemLeftPanningTemplateDirective, {
          read: IgxListItemLeftPanningTemplateDirective,
          "static": false
        }]
      }],
      listItemRightPanningTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxListItemRightPanningTemplateDirective, {
          read: IgxListItemRightPanningTemplateDirective,
          "static": false
        }]
      }],
      panEndTriggeringThreshold: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      defaultEmptyListTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultEmptyList', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultDataLoadingTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultDataLoading', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      allowLeftPanning: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      allowRightPanning: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isLoading: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onLeftPan: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onRightPan: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onPanStateChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onItemClicked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      isListEmpty: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-list-empty']
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-list']
      }],
      cssClassCompact: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-list--compact']
      }],
      cssClassCosy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-list--cosy']
      }]
    };
    /**
     * @hidden
     */

    var IgxListModule = function IgxListModule() {
      _classCallCheck(this, IgxListModule);
    };

    IgxListModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxListComponent, IgxListItemComponent, IgxListThumbnailDirective, IgxListActionDirective, IgxListLineDirective, IgxListLineTitleDirective, IgxListLineSubTitleDirective, IgxDataLoadingTemplateDirective, IgxEmptyListTemplateDirective, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective],
        exports: [IgxListComponent, IgxListItemComponent, IgxListThumbnailDirective, IgxListActionDirective, IgxListLineDirective, IgxListLineTitleDirective, IgxListLineSubTitleDirective, IgxDataLoadingTemplateDirective, IgxEmptyListTemplateDirective, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxRippleModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxExcelStyleSearchFilterPipe =
    /*#__PURE__*/
    function () {
      function IgxExcelStyleSearchFilterPipe() {
        _classCallCheck(this, IgxExcelStyleSearchFilterPipe);
      }

      _createClass(IgxExcelStyleSearchFilterPipe, [{
        key: "transform",

        /**
         * @param {?} items
         * @param {?} searchText
         * @return {?}
         */
        value: function transform(items, searchText) {
          if (!items || !items.length) {
            return [];
          }

          if (!searchText) {
            return items;
          }

          searchText = searchText.toLowerCase();
          /** @type {?} */

          var result = items.filter(function (it, i) {
            return i === 0 && it.isSpecial || it.value !== null && it.value !== undefined && it.value.toString().toLowerCase().indexOf(searchText) > -1;
          }); // If 'result' contains the 'Select All' item and at least one more - we use it, otherwise we use an empty array.

          return result.length > 1 ? result : [];
        }
      }]);

      return IgxExcelStyleSearchFilterPipe;
    }();

    IgxExcelStyleSearchFilterPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'excelStyleSearchFilter'
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxGridExcelStyleFilteringModule = function IgxGridExcelStyleFilteringModule() {
      _classCallCheck(this, IgxGridExcelStyleFilteringModule);
    };

    IgxGridExcelStyleFilteringModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxGridExcelStyleFilteringComponent, IgxExcelStyleSortingComponent, IgxExcelStyleColumnMovingComponent, IgxExcelStyleSearchComponent, IgxExcelStyleCustomDialogComponent, IgxExcelStyleDefaultExpressionComponent, IgxExcelStyleDateExpressionComponent, IgxExcelStyleSortingTemplateDirective, IgxExcelStyleHidingTemplateDirective, IgxExcelStyleMovingTemplateDirective, IgxExcelStylePinningTemplateDirective, IgxExcelStyleLoadingValuesTemplateDirective, IgxExcelStyleSearchFilterPipe],
        exports: [IgxGridExcelStyleFilteringComponent, IgxExcelStyleSortingTemplateDirective, IgxExcelStyleHidingTemplateDirective, IgxExcelStyleMovingTemplateDirective, IgxExcelStylePinningTemplateDirective, IgxExcelStyleLoadingValuesTemplateDirective, IgxExcelStyleDateExpressionComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], IgxGridPipesModule, IgxButtonModule, IgxButtonGroupModule, IgxDatePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxDropDownModule, IgxForOfModule, IgxCheckboxModule, IgxFilterModule, IgxToggleModule, IgxListModule, IgxProgressBarModule],
        entryComponents: [IgxGridExcelStyleFilteringComponent],
        providers: [IgxSelectionAPIService]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxGridCommonModule = function IgxGridCommonModule() {
      _classCallCheck(this, IgxGridCommonModule);
    };

    IgxGridCommonModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxGridCellComponent, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnLayoutComponent, IgxGridHeaderComponent, IgxGridToolbarComponent, IgxGridToolbarCustomContentDirective, IgxCellFooterTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellEditorTemplateDirective, IgxCellTemplateDirective, IgxRowEditTemplateDirective, IgxRowEditActionsDirective, IgxRowEditTextDirective, IgxRowEditTabStopDirective, IgxColumnResizerDirective, IgxResizeHandleDirective, IgxColumnMovingDragDirective, IgxColumnMovingDropDirective, IgxGridBodyDirective, IgxGridFilteringCellComponent, IgxGridFilteringRowComponent, IgxSummaryDataPipe, IgxGridHeaderGroupComponent, IgxSummaryRowComponent, IgxSummaryCellComponent, IgxGridDragSelectDirective, IgxGridColumnResizerComponent, IgxFilterCellTemplateDirective, IgxGridFooterComponent, IgxAdvancedFilteringDialogComponent],
        entryComponents: [IgxColumnComponent, IgxColumnGroupComponent, IgxColumnLayoutComponent, IgxAdvancedFilteringDialogComponent],
        exports: [IgxGridCellComponent, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnLayoutComponent, IgxGridHeaderComponent, IgxGridToolbarComponent, IgxGridToolbarCustomContentDirective, IgxCellFooterTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellEditorTemplateDirective, IgxCellTemplateDirective, IgxRowEditTemplateDirective, IgxRowEditActionsDirective, IgxRowEditTextDirective, IgxRowEditTabStopDirective, IgxColumnResizerDirective, IgxColumnMovingDragDirective, IgxColumnMovingDropDirective, IgxGridBodyDirective, IgxSummaryDataPipe, IgxButtonModule, IgxDatePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxToggleModule, IgxForOfModule, IgxTemplateOutletModule, IgxFocusModule, IgxTextHighlightModule, IgxTextSelectionModule, IgxCheckboxModule, IgxBadgeModule, IgxChipsModule, IgxDragDropModule, IgxColumnHidingModule, IgxDropDownModule, IgxButtonGroupModule, IgxColumnPinningModule, IgxProgressBarModule, IgxGridFilteringCellComponent, IgxGridFilteringRowComponent, IgxGridHeaderGroupComponent, IgxSummaryRowComponent, IgxSummaryCellComponent, IgxGridDragSelectDirective, IgxGridColumnResizerComponent, IgxFilterModule, IgxGridPipesModule, IgxGridExcelStyleFilteringModule, IgxFilterCellTemplateDirective, IgxRowDragModule, IgxPaginatorModule, IgxGridFooterComponent, IgxAdvancedFilteringDialogComponent, IgxRowSelectorsModule],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], IgxButtonModule, IgxDatePickerModule, IgxIconModule, IgxRippleModule, IgxInputGroupModule, IgxToggleModule, IgxForOfModule, IgxTemplateOutletModule, IgxFocusModule, IgxTextHighlightModule, IgxTextSelectionModule, IgxCheckboxModule, IgxBadgeModule, IgxChipsModule, IgxDragDropModule, IgxColumnHidingModule, IgxDropDownModule, IgxButtonGroupModule, IgxColumnPinningModule, IgxProgressBarModule, IgxFilterModule, IgxGridPipesModule, IgxGridExcelStyleFilteringModule, IgxRowDragModule, IgxSelectModule, IgxPaginatorModule, IgxRowSelectorsModule],
        providers: [IgxGridSelectionService, IgxSelectionAPIService, IgxColumnMovingService, IgxGridNavigationService, IgxColumnResizingService, IgxGridSummaryService, {
          provide: IgxGridTransaction,
          useClass: IgxBaseTransactionService
        }]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxGridAPIService =
    /*#__PURE__*/
    function (_GridBaseAPIService) {
      _inherits(IgxGridAPIService, _GridBaseAPIService);

      function IgxGridAPIService() {
        _classCallCheck(this, IgxGridAPIService);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxGridAPIService).apply(this, arguments));
      }

      _createClass(IgxGridAPIService, [{
        key: "groupBy",

        /**
         * @param {?} expression
         * @return {?}
         */
        value: function groupBy(expression) {
          /** @type {?} */
          var groupingState = cloneArray(this.grid.groupingExpressions);
          /** @type {?} */

          var sortingState = cloneArray(this.grid.sortingExpressions);
          this.prepare_sorting_expression([sortingState, groupingState], expression);
          this.grid.groupingExpressions = groupingState;
          this.arrange_sorting_expressions();
        }
        /**
         * @param {?} expressions
         * @return {?}
         */

      }, {
        key: "groupBy_multiple",
        value: function groupBy_multiple(expressions) {
          /** @type {?} */
          var groupingState = cloneArray(this.grid.groupingExpressions);
          /** @type {?} */

          var sortingState = cloneArray(this.grid.sortingExpressions);
          var _iteratorNormalCompletion59 = true;
          var _didIteratorError59 = false;
          var _iteratorError59 = undefined;

          try {
            for (var _iterator59 = expressions[Symbol.iterator](), _step59; !(_iteratorNormalCompletion59 = (_step59 = _iterator59.next()).done); _iteratorNormalCompletion59 = true) {
              var each = _step59.value;
              this.prepare_sorting_expression([sortingState, groupingState], each);
            }
          } catch (err) {
            _didIteratorError59 = true;
            _iteratorError59 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion59 && _iterator59["return"] != null) {
                _iterator59["return"]();
              }
            } finally {
              if (_didIteratorError59) {
                throw _iteratorError59;
              }
            }
          }

          this.grid.groupingExpressions = groupingState;
          this.arrange_sorting_expressions();
        }
        /**
         * @param {?=} name
         * @return {?}
         */

      }, {
        key: "clear_groupby",
        value: function clear_groupby(name) {
          var _this293 = this;

          /** @type {?} */
          var groupingState = cloneArray(this.grid.groupingExpressions);
          /** @type {?} */

          var sortingState = cloneArray(this.grid.sortingExpressions);

          if (name) {
            /** @type {?} */
            var names = typeof name === 'string' ? [name] : name;
            /** @type {?} */

            var groupedCols = groupingState.filter(function (state) {
              return names.indexOf(state.fieldName) < 0;
            });
            /** @type {?} */

            var newSortingExpr = sortingState.filter(function (state) {
              return names.indexOf(state.fieldName) < 0;
            });
            this.grid.groupingExpressions = groupedCols;
            this.grid.sortingExpressions = newSortingExpr;
            names.forEach(function (colName) {
              /** @type {?} */
              var grExprIndex = groupingState.findIndex(function (exp) {
                return exp.fieldName === colName;
              });
              /** @type {?} */

              var grpExpandState = _this293.grid.groupingExpansionState;
              /* remove expansion states related to the cleared group
              and all with deeper hierarchy than the cleared group */

              _this293.grid.groupingExpansionState = grpExpandState.filter(function (val) {
                return val.hierarchy && val.hierarchy.length <= grExprIndex;
              });
            });
          } else {
            // clear all
            this.grid.groupingExpressions = [];
            this.grid.groupingExpansionState = [];
            var _iteratorNormalCompletion60 = true;
            var _didIteratorError60 = false;
            var _iteratorError60 = undefined;

            try {
              var _loop7 = function _loop7() {
                var grExpr = _step60.value;

                /** @type {?} */
                var sortExprIndex = sortingState.findIndex(function (exp) {
                  return exp.fieldName === grExpr.fieldName;
                });

                if (sortExprIndex > -1) {
                  sortingState.splice(sortExprIndex, 1);
                }
              };

              for (var _iterator60 = groupingState[Symbol.iterator](), _step60; !(_iteratorNormalCompletion60 = (_step60 = _iterator60.next()).done); _iteratorNormalCompletion60 = true) {
                _loop7();
              }
            } catch (err) {
              _didIteratorError60 = true;
              _iteratorError60 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion60 && _iterator60["return"] != null) {
                  _iterator60["return"]();
                }
              } finally {
                if (_didIteratorError60) {
                  throw _iteratorError60;
                }
              }
            }

            this.grid.sortingExpressions = sortingState;
          }
        }
        /**
         * @param {?} groupRow
         * @return {?}
         */

      }, {
        key: "groupBy_get_expanded_for_group",
        value: function groupBy_get_expanded_for_group(groupRow) {
          /** @type {?} */
          var grState = this.grid.groupingExpansionState;
          /** @type {?} */

          var hierarchy = DataUtil.getHierarchy(groupRow);
          return grState.find(function (state) {
            return DataUtil.isHierarchyMatch(state.hierarchy || [{
              fieldName: groupRow.expression.fieldName,
              value: groupRow.value
            }], hierarchy);
          });
        }
        /**
         * @param {?} groupRow
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "groupBy_is_row_in_group",
        value: function groupBy_is_row_in_group(groupRow, rowID) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var rowInGroup = false;
          groupRow.records.forEach(function (row) {
            if (grid.primaryKey ? row[grid.primaryKey] === rowID : row === rowID) {
              rowInGroup = true;
            }
          });
          return rowInGroup;
        }
        /**
         * @param {?} groupRow
         * @return {?}
         */

      }, {
        key: "groupBy_toggle_group",
        value: function groupBy_toggle_group(groupRow) {
          /** @type {?} */
          var grid = this.grid;

          if (grid.crudService.isInEditMode) {
            grid.endEdit(true);
          }
          /** @type {?} */


          var expansionState = grid.groupingExpansionState;
          /** @type {?} */

          var state = this.groupBy_get_expanded_for_group(groupRow);

          if (state) {
            state.expanded = !state.expanded;
          } else {
            expansionState.push({
              expanded: !grid.groupsExpanded,
              hierarchy: DataUtil.getHierarchy(groupRow)
            });
          }

          this.grid.groupingExpansionState = _toConsumableArray(expansionState);

          if (grid.rowEditable) {
            grid.repositionRowEditingOverlay(grid.rowInEditMode);
          }
        }
        /**
         * @param {?} groupRow
         * @return {?}
         */

      }, {
        key: "groupBy_fully_expand_group",
        value: function groupBy_fully_expand_group(groupRow) {
          /** @type {?} */
          var state = this.groupBy_get_expanded_for_group(groupRow);
          /** @type {?} */

          var expanded = state ? state.expanded : this.grid.groupsExpanded;

          if (!expanded) {
            this.groupBy_toggle_group(groupRow);
          }

          if (groupRow.groupParent) {
            this.groupBy_fully_expand_group(groupRow.groupParent);
          }
        }
        /**
         * @protected
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "remove_grouping_expression",
        value: function remove_grouping_expression(fieldName) {
          /** @type {?} */
          var groupingExpressions = this.grid.groupingExpressions;
          /** @type {?} */

          var index = groupingExpressions.findIndex(function (expr) {
            return expr.fieldName === fieldName;
          });

          if (index !== -1) {
            groupingExpressions.splice(index, 1);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "arrange_sorting_expressions",
        value: function arrange_sorting_expressions() {
          /** @type {?} */
          var groupingState = this.grid.groupingExpressions;
          this.grid.sortingExpressions.sort(function (a, b) {
            /** @type {?} */
            var groupExprA = groupingState.find(function (expr) {
              return expr.fieldName === a.fieldName;
            });
            /** @type {?} */

            var groupExprB = groupingState.find(function (expr) {
              return expr.fieldName === b.fieldName;
            });

            if (groupExprA && groupExprB) {
              return groupingState.indexOf(groupExprA) > groupingState.indexOf(groupExprB) ? 1 : -1;
            } else if (groupExprA) {
              return -1;
            } else if (groupExprB) {
              return 1;
            } else {
              return 0;
            }
          });
        }
        /**
         * @param {?} gRow
         * @return {?}
         */

      }, {
        key: "get_groupBy_record_id",
        value: function get_groupBy_record_id(gRow) {
          /** @type {?} */
          var recordId = '{ ';
          /** @type {?} */

          var hierrarchy = DataUtil.getHierarchy(gRow);

          for (var i = 0; i < hierrarchy.length; i++) {
            /** @type {?} */
            var groupByKey = hierrarchy[i];
            recordId += "'".concat(groupByKey.fieldName, "': '").concat(groupByKey.value, "'");

            if (i < hierrarchy.length - 1) {
              recordId += ', ';
            }
          }

          recordId += ' }';
          return recordId;
        }
      }]);

      return IgxGridAPIService;
    }(GridBaseAPIService);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */


    var NavigationDirection = {
      horizontal: 'horizontal',
      vertical: 'vertical'
    };
    /**
     * @hidden
     */

    var IgxGridMRLNavigationService =
    /*#__PURE__*/
    function (_IgxGridNavigationSer) {
      _inherits(IgxGridMRLNavigationService, _IgxGridNavigationSer);

      function IgxGridMRLNavigationService() {
        _classCallCheck(this, IgxGridMRLNavigationService);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxGridMRLNavigationService).apply(this, arguments));
      }

      _createClass(IgxGridMRLNavigationService, [{
        key: "setStartNavigationCell",

        /**
         * @hidden
         * \@internal
         * @param {?} colStart
         * @param {?} rowStart
         * @param {?} dir
         * @return {?}
         */
        value: function setStartNavigationCell(colStart, rowStart, dir) {
          this.startNavigationCell = {
            colStart: colStart,
            rowStart: rowStart,
            direction: dir
          };
        }
        /**
         * @private
         * @param {?} colStart
         * @param {?} rowStart
         * @param {?} navDirection
         * @return {?}
         */

      }, {
        key: "applyNavigationCell",
        value: function applyNavigationCell(colStart, rowStart, navDirection) {
          /** @type {?} */
          var oppositeDir = navDirection === NavigationDirection.vertical ? NavigationDirection.horizontal : NavigationDirection.vertical;

          if (this.startNavigationCell && this.startNavigationCell.direction !== navDirection) {
            this.startNavigationCell.direction = oppositeDir;
          } else {
            this.setStartNavigationCell(colStart, rowStart, oppositeDir);
          }

          return navDirection === NavigationDirection.vertical ? this.startNavigationCell.colStart : this.startNavigationCell.rowStart;
        }
        /**
         * @param {?} rowElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "navigateUp",
        value: function navigateUp(rowElement, selectedNode) {
          this.focusCellUpFromLayout(rowElement, selectedNode);
        }
        /**
         * @param {?} rowElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "navigateDown",
        value: function navigateDown(rowElement, selectedNode) {
          this.focusCellDownFromLayout(rowElement, selectedNode);
        }
        /**
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "isColumnRightEdgeVisible",
        value: function isColumnRightEdgeVisible(visibleColumnIndex) {
          /** @type {?} */
          var column = this.grid.columnList.filter(function (c) {
            return !c.columnGroup;
          }).find(function (col) {
            return col.visibleIndex === visibleColumnIndex;
          });
          /** @type {?} */

          var forOfDir = this.grid.headerContainer;
          /** @type {?} */

          var horizontalScroll = forOfDir.getScroll();

          if (!horizontalScroll.clientWidth || column && column.pinned) {
            return true;
          } else if (column) {
            if (this.isParentColumnFullyVisible(column)) {
              return true;
            }
            /** @type {?} */


            var scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
            return this.displayContainerWidth >= scrollPos.rightScroll - this.displayContainerScrollLeft && this.displayContainerScrollLeft <= scrollPos.leftScroll;
          }

          return false;
        }
        /**
         * @private
         * @param {?} parent
         * @return {?}
         */

      }, {
        key: "isParentColumnFullyVisible",
        value: function isParentColumnFullyVisible(parent) {
          /** @type {?} */
          var forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.headerContainer;
          /** @type {?} */

          var horizontalScroll = forOfDir.getScroll();

          if (!horizontalScroll.clientWidth || parent.pinned) {
            return true;
          }
          /** @type {?} */


          var index = forOfDir.igxForOf.indexOf(parent);
          return this.displayContainerWidth >= forOfDir.getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft && this.displayContainerScrollLeft <= forOfDir.getColumnScrollLeft(index);
        }
        /**
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "isColumnLeftEdgeVisible",
        value: function isColumnLeftEdgeVisible(visibleColumnIndex) {
          /** @type {?} */
          var forOfDir = this.grid.headerContainer;
          /** @type {?} */

          var horizontalScroll = forOfDir.getScroll();
          /** @type {?} */

          var column = this.grid.columnList.filter(function (c) {
            return !c.columnGroup;
          }).find(function (col) {
            return col.visibleIndex === visibleColumnIndex;
          });

          if (!horizontalScroll.clientWidth || column.pinned) {
            return true;
          }

          if (this.isParentColumnFullyVisible(column)) {
            return true;
          }
          /** @type {?} */


          var scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
          return this.displayContainerScrollLeft <= scrollPos.leftScroll;
        }
        /**
         * @param {?} element
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "onKeydownArrowRight",
        value: function onKeydownArrowRight(element, selectedNode) {
          this.focusNextCellFromLayout(element, selectedNode);
        }
        /**
         * @param {?} element
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "onKeydownArrowLeft",
        value: function onKeydownArrowLeft(element, selectedNode) {
          this.focusPrevCellFromLayout(element, selectedNode);
        }
        /**
         * @return {?}
         */

      }, {
        key: "performTab",

        /**
         * @param {?} currentRowEl
         * @param {?} selectedNode
         * @return {?}
         */
        value: function performTab(currentRowEl, selectedNode) {
          /** @type {?} */
          var visibleColumnIndex = selectedNode.layout ? selectedNode.layout.columnVisibleIndex : 0;
          /** @type {?} */

          var nextElementColumn = this.grid.columns.find(function (x) {
            return !x.columnGroup && x.visibleIndex === visibleColumnIndex + 1;
          });
          /** @type {?} */

          var rowIndex = selectedNode.row;
          /** @type {?} */

          var row = this.grid.getRowByIndex(rowIndex);

          this._moveFocusToCell(currentRowEl, nextElementColumn, row, selectedNode, 'next');

          if (nextElementColumn) {
            this.setStartNavigationCell(nextElementColumn.colStart, nextElementColumn.rowStart, null);
          }
        }
        /**
         * @protected
         * @param {?} currentRowEl
         * @param {?} nextElementColumn
         * @param {?} row
         * @param {?} selectedNode
         * @param {?} dir
         * @return {?}
         */

      }, {
        key: "_moveFocusToCell",
        value: function _moveFocusToCell(currentRowEl, nextElementColumn, row, selectedNode, dir) {
          var _this294 = this;

          if (nextElementColumn && row.cells) {
            /** @type {?} */
            var nextCell = row.cells.find(function (currCell) {
              return currCell.column === nextElementColumn;
            });
            /** @type {?} */

            var isVisible = this.isColumnRightEdgeVisible(nextElementColumn.visibleIndex);

            if (!nextCell || !isVisible) {
              this.grid.nativeElement.focus({
                preventScroll: true
              });
              /** @type {?} */

              var cb = function cb() {
                nextCell = row.cells.find(function (currCell) {
                  return currCell.column === nextElementColumn;
                });

                if (_this294.grid.rowEditable && _this294.isRowInEditMode(row.index)) {
                  if (dir === 'next') {
                    _this294.moveNextEditable(row.index, selectedNode.layout.columnVisibleIndex);
                  } else {
                    _this294.movePreviousEditable(row.index, selectedNode.layout.columnVisibleIndex);
                  }

                  return;
                }

                _this294._focusCell(nextCell.nativeElement);
              };

              this.performHorizontalScrollToCell(row.index, nextElementColumn.visibleIndex, false, cb);
            } else {
              if (this.grid.rowEditable && this.isRowInEditMode(row.index)) {
                if (dir === 'next') {
                  this.moveNextEditable(row.index, selectedNode.layout.columnVisibleIndex);
                } else {
                  this.movePreviousEditable(row.index, selectedNode.layout.columnVisibleIndex);
                }

                return;
              }

              this._focusCell(nextCell.nativeElement);
            }
          } else {
            // end of layout reached
            if (this.isRowInEditMode(row.index)) {
              //  TODO: make gridAPI visible for internal use and remove cast to any

              /** @type {?} */
              this.grid.gridAPI.submit_value();

              if (dir === 'next') {
                this.grid.rowEditTabs.first.element.nativeElement.focus();
              } else {
                this.grid.rowEditTabs.last.element.nativeElement.focus();
              }

              return;
            }

            if (dir === 'next') {
              _get(_getPrototypeOf(IgxGridMRLNavigationService.prototype), "navigateDown", this).call(this, currentRowEl, {
                row: row.index,
                column: 0
              });
            } else {
              /** @type {?} */
              var lastVisibleIndex = 0;
              this.grid.unpinnedColumns.forEach(function (col) {
                lastVisibleIndex = Math.max(lastVisibleIndex, col.visibleIndex);
              });

              _get(_getPrototypeOf(IgxGridMRLNavigationService.prototype), "navigateUp", this).call(this, currentRowEl, {
                row: row.index,
                column: lastVisibleIndex
              });
            }
          }
        }
        /**
         * @param {?} currentRowEl
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "performShiftTabKey",
        value: function performShiftTabKey(currentRowEl, selectedNode) {
          /** @type {?} */
          var visibleColumnIndex = selectedNode.layout ? selectedNode.layout.columnVisibleIndex : 0;
          /** @type {?} */

          var rowIndex = selectedNode.row;
          /** @type {?} */

          var row = this.grid.getRowByIndex(rowIndex);
          /** @type {?} */

          var prevElementColumn = this.grid.columns.find(function (x) {
            return !x.columnGroup && x.visibleIndex === visibleColumnIndex - 1 && !x.hidden;
          });

          this._moveFocusToCell(currentRowEl, prevElementColumn, row, selectedNode, 'prev');

          if (prevElementColumn) {
            this.setStartNavigationCell(prevElementColumn.colStart, prevElementColumn.rowStart, null);
          }
        }
        /**
         * @private
         * @param {?} rowElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "focusCellUpFromLayout",
        value: function focusCellUpFromLayout(rowElement, selectedNode) {
          var _this295 = this;

          /** @type {?} */
          var isGroupRow = rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row';
          /** @type {?} */

          var currentRowStart = selectedNode.layout ? selectedNode.layout.rowStart : 1;
          /** @type {?} */

          var currentColStart = this.applyNavigationCell(selectedNode.layout ? selectedNode.layout.colStart : 1, currentRowStart, NavigationDirection.vertical);
          /** @type {?} */

          var parentIndex = selectedNode.column;
          /** @type {?} */

          var columnLayout = this.grid.columns.find(function (x) {
            return x.columnLayout && x.visibleIndex === parentIndex;
          });
          /** @type {?} */

          var movePrev; // check if element up is from the same layout

          /** @type {?} */

          var upperElementColumn = columnLayout.children.find(function (c) {
            return (c.rowEnd === currentRowStart || c.rowStart + c.gridRowSpan === currentRowStart) && c.colStart <= currentColStart && (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan);
          });

          if (isGroupRow || !upperElementColumn) {
            // no prev row in current row layout, go to next row last rowstart

            /** @type {?} */
            var layoutRowEnd = this.grid.multiRowLayoutRowSize + 1;
            upperElementColumn = columnLayout.children.find(function (c) {
              return (c.rowEnd === layoutRowEnd || c.rowStart + c.gridRowSpan === layoutRowEnd) && c.colStart <= currentColStart && (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan);
            });
            movePrev = true;
          }
          /** @type {?} */


          var rowIndex = movePrev ? selectedNode.row - 1 : selectedNode.row;

          if (rowIndex < 0) {
            // end of rows reached.
            return;
          }
          /** @type {?} */


          var prevRow;
          /** @type {?} */

          var cb = function cb() {
            prevRow = _this295.grid.getRowByIndex(rowIndex);

            if (prevRow && prevRow.cells) {
              _this295._focusCell(upperElementColumn.cells.find(function (c) {
                return c.rowIndex === prevRow.index;
              }).nativeElement);
            } else if (prevRow) {
              prevRow.nativeElement.focus({
                preventScroll: true
              });
            }
          };

          if (this.shouldPerformVerticalScroll(rowIndex, upperElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({
              preventScroll: true
            });
            this.performVerticalScrollToCell(rowIndex, upperElementColumn.visibleIndex, cb);
          } else {
            cb();
          }
        }
        /**
         * @private
         * @param {?} rowElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "focusCellDownFromLayout",
        value: function focusCellDownFromLayout(rowElement, selectedNode) {
          var _this296 = this;

          /** @type {?} */
          var isGroupRow = rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row';
          /** @type {?} */

          var parentIndex = selectedNode.column;
          /** @type {?} */

          var columnLayout = this.grid.columns.find(function (x) {
            return x.columnLayout && x.visibleIndex === parentIndex;
          });
          /** @type {?} */

          var currentRowEnd = selectedNode.layout ? selectedNode.layout.rowEnd || selectedNode.layout.rowStart + 1 : 2;
          /** @type {?} */

          var currentColStart = this.applyNavigationCell(selectedNode.layout ? selectedNode.layout.colStart : 1, selectedNode.layout ? selectedNode.layout.rowStart : 1, NavigationDirection.vertical);
          /** @type {?} */

          var moveNext; // check if element down is from the same layout

          /** @type {?} */

          var nextElementColumn = columnLayout.children.find(function (c) {
            return c.rowStart === currentRowEnd && c.colStart <= currentColStart && (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan);
          });

          if (isGroupRow || !nextElementColumn) {
            // no next row in current row layout, go to next row first rowstart
            nextElementColumn = columnLayout.children.find(function (c) {
              return c.rowStart === 1 && c.colStart <= currentColStart && (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan);
            });
            moveNext = true;
          }
          /** @type {?} */


          var rowIndex = moveNext ? selectedNode.row + 1 : selectedNode.row;

          if (rowIndex > this.grid.dataView.length - 1) {
            // end of rows reached.
            return;
          }
          /** @type {?} */


          var nextRow;
          /** @type {?} */

          var cb = function cb() {
            nextRow = _this296.grid.getRowByIndex(rowIndex);

            if (nextRow && nextRow.cells) {
              _this296._focusCell(nextElementColumn.cells.find(function (c) {
                return c.rowIndex === nextRow.index;
              }).nativeElement);
            } else if (nextRow) {
              nextRow.nativeElement.focus({
                preventScroll: true
              });
            }
          };

          if (this.shouldPerformVerticalScroll(rowIndex, nextElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({
              preventScroll: true
            });
            this.performVerticalScrollToCell(rowIndex, nextElementColumn.visibleIndex, cb);
          } else {
            cb();
          }
        }
        /**
         * @private
         * @param {?} cellElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "focusNextCellFromLayout",
        value: function focusNextCellFromLayout(cellElement, selectedNode) {
          var _this297 = this;

          /** @type {?} */
          var parentIndex = selectedNode.column;
          /** @type {?} */

          var columnLayout = this.grid.columns.find(function (x) {
            return x.columnLayout && x.visibleIndex === parentIndex;
          });
          /** @type {?} */

          var currentColEnd = selectedNode.layout.colEnd || selectedNode.layout.colStart + 1;
          /** @type {?} */

          var currentRowStart = this.applyNavigationCell(selectedNode.layout.colStart, selectedNode.layout.rowStart, NavigationDirection.horizontal);
          /** @type {?} */

          var rowIndex = selectedNode.row; // check if next element is from the same layout

          /** @type {?} */

          var nextElementColumn = columnLayout.children.find(function (c) {
            return c.colStart === currentColEnd && c.rowStart <= currentRowStart && (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan);
          });

          if (!nextElementColumn) {
            // no next column in current layout, search for next layout
            columnLayout = this.grid.columns.find(function (c) {
              return c.columnLayout && !c.hidden && c.visibleIndex === columnLayout.visibleIndex + 1;
            });

            if (!columnLayout) {
              // reached the end
              return null;
            } // next element is from the next layout


            nextElementColumn = columnLayout.children.find(function (c) {
              return c.colStart === 1 && c.rowStart <= currentRowStart && (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan);
            });
          }
          /** @type {?} */


          var cb = function cb() {
            /** @type {?} */
            var nextElement = nextElementColumn.cells.find(function (c) {
              return c.rowIndex === rowIndex;
            }).nativeElement;

            _this297._focusCell(nextElement);
          };

          if (!this.isColumnRightEdgeVisible(nextElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({
              preventScroll: true
            });
            this.performHorizontalScrollToCell(rowIndex, nextElementColumn.visibleIndex, false, cb);
          } else {
            cb();
          }
        }
        /**
         * @private
         * @param {?} cellElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "focusPrevCellFromLayout",
        value: function focusPrevCellFromLayout(cellElement, selectedNode) {
          var _this298 = this;

          /** @type {?} */
          var parentIndex = selectedNode.column;
          /** @type {?} */

          var columnLayout = this.grid.columns.find(function (x) {
            return x.columnLayout && x.visibleIndex === parentIndex;
          });
          /** @type {?} */

          var currentColStart = selectedNode.layout.colStart;
          /** @type {?} */

          var currentRowStart = this.applyNavigationCell(currentColStart, selectedNode.layout.rowStart, NavigationDirection.horizontal);
          /** @type {?} */

          var rowIndex = selectedNode.row; // check previous element is from the same layout

          /** @type {?} */

          var prevElementColumn = columnLayout.children.find(function (c) {
            return (c.colEnd === currentColStart || c.colStart + c.gridColumnSpan === currentColStart) && c.rowStart <= currentRowStart && (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan);
          });

          if (!prevElementColumn) {
            // no prev column in current layout, seacrh for prev layout
            columnLayout = this.grid.columns.find(function (c) {
              return c.columnLayout && !c.hidden && c.visibleIndex === columnLayout.visibleIndex - 1;
            });

            if (!columnLayout) {
              // reached the end
              return null;
            }
            /** @type {?} */


            var layoutSize = columnLayout.getInitialChildColumnSizes(columnLayout.children).length; // first element is from the next layout

            prevElementColumn = columnLayout.children.find(function (c) {
              return (c.colEnd === layoutSize + 1 || c.colStart + c.gridColumnSpan === layoutSize + 1) && c.rowStart <= currentRowStart && (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan);
            });
          }
          /** @type {?} */


          var cb = function cb() {
            /** @type {?} */
            var prevElement = prevElementColumn.cells.find(function (c) {
              return c.rowIndex === rowIndex;
            }).nativeElement;

            _this298._focusCell(prevElement);
          };

          if (!this.isColumnLeftEdgeVisible(prevElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({
              preventScroll: true
            });
            this.performHorizontalScrollToCell(rowIndex, prevElementColumn.visibleIndex, false, cb);
          } else {
            cb();
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?=} isSummary
         * @param {?=} cellRowStart
         * @return {?}
         */

      }, {
        key: "onKeydownEnd",
        value: function onKeydownEnd(rowIndex) {
          var _this299 = this;

          var isSummary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var cellRowStart = arguments.length > 2 ? arguments[2] : undefined;

          /** @type {?} */
          var layouts = this.grid.columns.filter(function (c) {
            return c.columnLayout && !c.hidden;
          }).sort(function (a, b) {
            return a.visibleIndex - b.visibleIndex;
          });
          /** @type {?} */

          var lastLayout = layouts[layouts.length - 1];
          /** @type {?} */

          var lastLayoutChildren = lastLayout.children;
          /** @type {?} */

          var layoutSize = lastLayout.getInitialChildColumnSizes(lastLayoutChildren).length;
          /** @type {?} */

          var currentRowStart = this.applyNavigationCell(this.startNavigationCell ? this.startNavigationCell.colStart : 1, cellRowStart || this.grid.multiRowLayoutRowSize, NavigationDirection.horizontal);
          /** @type {?} */

          var nextElementColumn = lastLayout.children.find(function (c) {
            return (c.colEnd === layoutSize + 1 || c.colStart + c.gridColumnSpan === layoutSize + 1) && c.rowStart <= currentRowStart && (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan);
          });
          /** @type {?} */

          var indexInLayout = lastLayoutChildren.toArray().indexOf(nextElementColumn);
          /** @type {?} */

          var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
          /** @type {?} */

          var rowElement = rowList.find(function (row) {
            return row.index === rowIndex;
          });

          if (!rowElement) {
            return;
          }

          rowElement = rowElement.nativeElement;

          if (!this.isColumnRightEdgeVisible(nextElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({
              preventScroll: true
            });
            /** @type {?} */

            var cb = function cb() {
              /** @type {?} */
              var allBlocks = rowElement.querySelectorAll(_this299.getColumnLayoutSelector());
              /** @type {?} */

              var cell = allBlocks[allBlocks.length - 1].children[indexInLayout];

              _this299._focusCell(cell);
            };

            this.performHorizontalScrollToCell(rowIndex, nextElementColumn.visibleIndex, false, cb);
            return;
          } else {
            /** @type {?} */
            var allBlocks = rowElement.querySelectorAll(this.getColumnLayoutSelector());
            /** @type {?} */

            var cell = allBlocks[allBlocks.length - 1].children[indexInLayout];

            this._focusCell(cell);
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?=} isSummary
         * @param {?=} cellRowStart
         * @return {?}
         */

      }, {
        key: "onKeydownHome",
        value: function onKeydownHome(rowIndex) {
          var _this300 = this;

          var isSummary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var cellRowStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

          /** @type {?} */
          var firstLayout = this.grid.columns.filter(function (c) {
            return c.columnLayout && !c.hidden;
          })[0];
          /** @type {?} */

          var lastLayoutChildren = firstLayout.children.toArray();
          /** @type {?} */

          var currentRowStart = this.applyNavigationCell(this.startNavigationCell ? this.startNavigationCell.colStart : 1, cellRowStart, NavigationDirection.horizontal);
          /** @type {?} */

          var nextElementColumn = firstLayout.children.find(function (c) {
            return c.colStart === 1 && c.rowStart <= currentRowStart && (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan);
          });
          /** @type {?} */

          var indexInLayout = lastLayoutChildren.indexOf(nextElementColumn);
          /** @type {?} */

          var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
          /** @type {?} */

          var rowElement = rowList.find(function (row) {
            return row.index === rowIndex;
          });

          if (!rowElement) {
            return;
          }

          rowElement = rowElement.nativeElement;

          if (!this.isColumnLeftEdgeVisible(nextElementColumn.visibleIndex)) {
            this.grid.nativeElement.focus({
              preventScroll: true
            });
            /** @type {?} */

            var cb = function cb() {
              /** @type {?} */
              var allBlocks = rowElement.querySelectorAll(_this300.getColumnLayoutSelector());
              /** @type {?} */

              var cell = allBlocks[0].children[indexInLayout];

              _this300._focusCell(cell);
            };

            this.performHorizontalScrollToCell(rowIndex, nextElementColumn.visibleIndex, false, cb);
            return;
          } else {
            /** @type {?} */
            var allBlocks = rowElement.querySelectorAll(this.getColumnLayoutSelector());
            /** @type {?} */

            var cell = allBlocks[0].children[indexInLayout];

            this._focusCell(cell);
          }
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "getColumnLayoutSelector",
        value: function getColumnLayoutSelector() {
          return '.igx-grid__mrl-block';
        }
        /**
         * @protected
         * @param {?} visibleColIndex
         * @return {?}
         */

      }, {
        key: "getChildColumnScrollPositions",
        value: function getChildColumnScrollPositions(visibleColIndex) {
          /** @type {?} */
          var forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.headerContainer;
          /** @type {?} */

          var targetCol = this.getColunmByVisibleIndex(visibleColIndex);
          /** @type {?} */

          var parent = targetCol.parent;
          /** @type {?} */

          var parentVIndex = forOfDir.igxForOf.indexOf(parent);
          /** @type {?} */

          var leftScroll = forOfDir.getColumnScrollLeft(parentVIndex);
          /** @type {?} */

          var rightScroll = 0; // caculate offset from parent based on target column colStart and colEnd and the resolved child column sizes.

          /** @type {?} */

          var childSizes = parent.getFilledChildColumnSizes(parent.children);
          /** @type {?} */

          var colStart = targetCol.colStart || 1;
          /** @type {?} */

          var colEnd = targetCol.colEnd || colStart + 1;

          for (var i = 1; i < colStart; i++) {
            leftScroll += parseInt(childSizes[i - 1], 10);
          }

          rightScroll += leftScroll;

          for (var j = colStart; j < colEnd; j++) {
            rightScroll += parseInt(childSizes[j - 1], 10);
          }

          return {
            leftScroll: leftScroll,
            rightScroll: rightScroll
          };
        }
        /**
         * @protected
         * @param {?} visibleColIndex
         * @return {?}
         */

      }, {
        key: "getColunmByVisibleIndex",
        value: function getColunmByVisibleIndex(visibleColIndex) {
          visibleColIndex = visibleColIndex < 0 ? 0 : visibleColIndex;
          return this.grid.columnList.find(function (col) {
            return !col.columnLayout && col.visibleIndex === visibleColIndex;
          });
        }
        /**
         * @param {?} rowIndex
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "shouldPerformVerticalScroll",
        value: function shouldPerformVerticalScroll(rowIndex, visibleColumnIndex) {
          if (this._isGroupRecordAt(rowIndex)) {
            return _get(_getPrototypeOf(IgxGridMRLNavigationService.prototype), "shouldPerformVerticalScroll", this).call(this, rowIndex, visibleColumnIndex);
          }

          if (!_get(_getPrototypeOf(IgxGridMRLNavigationService.prototype), "shouldPerformVerticalScroll", this).call(this, rowIndex, visibleColumnIndex)) {
            return false;
          }
          /** @type {?} */


          var targetRow = this.grid.summariesRowList.filter(function (s) {
            return s.index !== 0;
          }).concat(this.grid.rowList.toArray()).find(function (r) {
            return r.index === rowIndex;
          });
          /** @type {?} */

          var scrollTop = Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
          /** @type {?} */

          var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
          /** @type {?} */

          var scrollPos = this.getVerticalScrollPositions(rowIndex, visibleColumnIndex);

          if (!targetRow || targetRow.nativeElement.offsetTop + scrollPos.topOffset < Math.abs(this.verticalDCTopOffset) || containerHeight && containerHeight < scrollPos.rowBottom - scrollTop) {
            return true;
          } else {
            return false;
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "_isGroupRecordAt",

        /**
         * @private
         * @param {?} rowIndex
         * @return {?}
         */
        value: function _isGroupRecordAt(rowIndex) {
          /** @type {?} */
          var record = this.grid.dataView[rowIndex];
          return record.records && record.records.length;
        }
        /**
         * @param {?} rowIndex
         * @param {?} visibleColumnIndex
         * @param {?=} cb
         * @return {?}
         */

      }, {
        key: "performVerticalScrollToCell",
        value: function performVerticalScrollToCell(rowIndex, visibleColumnIndex, cb) {
          if (this._isGroupRecordAt(rowIndex)) {
            return _get(_getPrototypeOf(IgxGridMRLNavigationService.prototype), "performVerticalScrollToCell", this).call(this, rowIndex, visibleColumnIndex, cb);
          }
          /** @type {?} */


          var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
          /** @type {?} */

          var scrollTop = Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
          /** @type {?} */

          var scrollPos = this.getVerticalScrollPositions(rowIndex, visibleColumnIndex);
          /** @type {?} */

          var targetRow = this.grid.summariesRowList.filter(function (s) {
            return s.index !== 0;
          }).concat(this.grid.rowList.toArray()).find(function (r) {
            return r.index === rowIndex;
          });
          /** @type {?} */

          var isPrevious = scrollTop > scrollPos.rowTop && (!targetRow || targetRow.nativeElement.offsetTop + scrollPos.topOffset < Math.abs(this.verticalDCTopOffset));
          /** @type {?} */

          var scrollAmount = isPrevious ? scrollPos.rowTop : Math.abs(scrollTop + containerHeight - scrollPos.rowBottom);
          this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
            cb();
          });

          if (isPrevious) {
            this.grid.verticalScrollContainer.scrollPosition = scrollAmount;
          } else {
            this.grid.verticalScrollContainer.addScrollTop(scrollAmount);
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?} visibleColIndex
         * @return {?}
         */

      }, {
        key: "getVerticalScrollPositions",
        value: function getVerticalScrollPositions(rowIndex, visibleColIndex) {
          /** @type {?} */
          var targetCol = this.getColunmByVisibleIndex(visibleColIndex);
          /** @type {?} */

          var topOffset = (targetCol.rowStart - 1) * this.grid.defaultRowHeight;
          /** @type {?} */

          var rowTop = this.grid.verticalScrollContainer.sizesCache[rowIndex] + topOffset;
          /** @type {?} */

          var rowBottom = rowTop + this.grid.defaultRowHeight * targetCol.gridRowSpan;
          return {
            rowTop: rowTop,
            rowBottom: rowBottom,
            topOffset: topOffset
          };
        }
        /**
         * @param {?} rowIndex
         * @param {?} visibleColumnIndex
         * @param {?=} isSummary
         * @param {?=} cb
         * @return {?}
         */

      }, {
        key: "performHorizontalScrollToCell",
        value: function performHorizontalScrollToCell(rowIndex, visibleColumnIndex) {
          var _this301 = this;

          var isSummary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var cb = arguments.length > 3 ? arguments[3] : undefined;

          /** @type {?} */
          var scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
          /** @type {?} */

          var hScroll = this.horizontalScroll(rowIndex);
          this.grid.parentVirtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
            if (cb) {
              cb();
            } else {
              _this301._focusCell(_this301.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary));
            }
          });
          /** @type {?} */

          var isPrevItem = hScroll.getScroll().scrollLeft > scrollPos.leftScroll;
          /** @type {?} */

          var containerSize = parseInt(hScroll.igxForContainerSize, 10);
          /** @type {?} */

          var nextScroll = isPrevItem ? scrollPos.leftScroll : scrollPos.rightScroll - containerSize;
          hScroll.scrollPosition = nextScroll;
        }
        /**
         * @protected
         * @param {?} cellElem
         * @return {?}
         */

      }, {
        key: "_focusCell",
        value: function _focusCell(cellElem) {
          // in case of variable row heights in mrl grid make sure cell is really in view after it has been rendered.

          /** @type {?} */
          var gridBoundingClientRect = this.grid.tbody.nativeElement.getBoundingClientRect();
          /** @type {?} */

          var diffTop = cellElem.getBoundingClientRect().top - gridBoundingClientRect.top;
          /** @type {?} */

          var diffBottom = cellElem.getBoundingClientRect().bottom - gridBoundingClientRect.bottom;

          if (diffTop < 0) {
            // cell is above grid top - not visible
            this.grid.nativeElement.focus({
              preventScroll: true
            });
            this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              cellElem.focus({
                preventScroll: true
              });
            });
            this.grid.verticalScrollContainer.addScrollTop(diffTop);
          } else if (diffBottom > 0) {
            // cell is below grid bottom - not visible
            this.grid.nativeElement.focus({
              preventScroll: true
            });
            this.grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              cellElem.focus({
                preventScroll: true
              });
            });
            this.grid.verticalScrollContainer.addScrollTop(diffBottom);
          } else {
            // cell is visible
            cellElem.focus({
              preventScroll: true
            });
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "goToFirstCell",
        value: function goToFirstCell() {
          this.startNavigationCell = null;

          _get(_getPrototypeOf(IgxGridMRLNavigationService.prototype), "goToFirstCell", this).call(this);
        }
        /**
         * @return {?}
         */

      }, {
        key: "goToLastCell",
        value: function goToLastCell() {
          this.startNavigationCell = null;

          _get(_getPrototypeOf(IgxGridMRLNavigationService.prototype), "goToLastCell", this).call(this);
        }
      }, {
        key: "gridOrderedColumns",
        get: function get() {
          return [].concat(_toConsumableArray(this.grid.pinnedColumns), _toConsumableArray(this.grid.unpinnedColumns)).filter(function (c) {
            return !c.columnGroup;
          }).sort(function (a, b) {
            return a.visibleIndex - b.visibleIndex;
          });
        }
      }, {
        key: "verticalDCTopOffset",
        get: function get() {
          return parseInt(this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement.style.top, 10);
        }
      }]);

      return IgxGridMRLNavigationService;
    }(IgxGridNavigationService);

    IgxGridMRLNavigationService.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$m = 0;
    /**
     * **Ignite UI for Angular Grid** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
     *
     * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
     * has been bound, it can be manipulated through filtering, sorting & editing operations.
     *
     * Example:
     * ```html
     * <igx-grid [data]="employeeData" autoGenerate="false">
     *   <igx-column field="first" header="First Name"></igx-column>
     *   <igx-column field="last" header="Last Name"></igx-column>
     *   <igx-column field="role" header="Role"></igx-column>
     * </igx-grid>
     * ```
     */

    var IgxGridComponent =
    /*#__PURE__*/
    function (_IgxGridBaseComponent) {
      _inherits(IgxGridComponent, _IgxGridBaseComponent);

      function IgxGridComponent() {
        var _this302;

        _classCallCheck(this, IgxGridComponent);

        _this302 = _possibleConstructorReturn(this, _getPrototypeOf(IgxGridComponent).apply(this, arguments));
        _this302._id = "igx-grid-".concat(NEXT_ID$m++);
        /**
         * @hidden
         */

        _this302._groupingExpressions = [];
        /**
         * @hidden
         */

        _this302._groupingExpandState = [];
        _this302._hideGroupedColumns = false;
        _this302._dropAreaMessage = null;
        _this302._filteredData = null;
        /**
         * @hidden
         */

        _this302.groupingExpressionsChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this302.groupingExpansionStateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Input property that determines whether created groups are rendered expanded or collapsed.
         * The default rendered state is expanded.
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */

        _this302.groupsExpanded = true;
        /**
         * A hierarchical representation of the group by records.
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         * \@memberof IgxGridComponent
         */

        _this302.groupsRecords = [];
        /**
         * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
         * grouped/ungrouped at once by using the Group By API.
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * ```typescript
         * groupingDone(event: IGroupingDoneEventArgs){
         *     const expressions = event.expressions;
         *     //the newly grouped columns
         *     const groupedColumns = event.groupedColumns;
         *     //the newly ungrouped columns
         *     const ungroupedColumns = event.ungroupedColumns;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */

        _this302.onGroupingDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        return _this302;
      }
      /**
       * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
       * ```html
       * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
       * ```
       * \@memberof IgxGridComponent
       * @return {?}
       */


      _createClass(IgxGridComponent, [{
        key: "groupBy",

        /**
         * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
         * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
         * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
         * ```typescript
         * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
         * this.grid.groupBy([
         * { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
         * { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
         * { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
         * ]);
         * ```
         * \@memberof IgxGridComponent
         * @param {?} expression
         * @return {?}
         */
        value: function groupBy(expression) {
          if (this.checkIfNoColumnField(expression)) {
            return;
          }

          this.endEdit(true);

          if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
          } else {
            this._gridAPI.groupBy(expression);
          }

          this.notifyChanges(true);
        }
        /**
         * Clears all grouping in the grid, if no parameter is passed.
         * If a parameter is provided, clears grouping for a particular column or an array of columns.
         * ```typescript
         * this.grid.clearGrouping(); //clears all grouping
         * this.grid.clearGrouping("ID"); //ungroups a single column
         * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
         * ```
         *
         * @param {?=} name
         * @return {?}
         */

      }, {
        key: "clearGrouping",
        value: function clearGrouping(name) {
          this._gridAPI.clear_groupby(name);

          this.notifyChanges(true);
        }
        /**
         * Returns if a group is expanded or not.
         * ```typescript
         * public groupRow: IGroupByRecord;
         * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
         * ```
         * \@memberof IgxGridComponent
         * @param {?} group
         * @return {?}
         */

      }, {
        key: "isExpandedGroup",
        value: function isExpandedGroup(group) {
          /** @type {?} */
          var state = this._getStateForGroupRow(group);

          return state ? state.expanded : this.groupsExpanded;
        }
        /**
         * Toggles the expansion state of a group.
         * ```typescript
         * public groupRow: IGroupByRecord;
         * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
         * ```
         * \@memberof IgxGridComponent
         * @param {?} groupRow
         * @return {?}
         */

      }, {
        key: "toggleGroup",
        value: function toggleGroup(groupRow) {
          this._toggleGroup(groupRow);

          this.notifyChanges();
        }
        /**
         * Expands the specified group and all of its parent groups.
         * ```typescript
         * public groupRow: IGroupByRecord;
         * this.grid.fullyExpandGroup(this.groupRow);
         * ```
         * \@memberof IgxGridComponent
         * @param {?} groupRow
         * @return {?}
         */

      }, {
        key: "fullyExpandGroup",
        value: function fullyExpandGroup(groupRow) {
          this._fullyExpandGroup(groupRow);

          this.notifyChanges();
        }
        /**
         * @hidden
         * @param {?} record
         * @return {?}
         */

      }, {
        key: "isGroupByRecord",
        value: function isGroupByRecord(record) {
          // return record.records instance of GroupedRecords fails under Webpack
          return record.records && record.records.length;
        }
        /**
         * Toggles the expansion state of all group rows recursively.
         * ```typescript
         * this.grid.toggleAllGroupRows;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "toggleAllGroupRows",
        value: function toggleAllGroupRows() {
          this.groupingExpansionState = [];
          this.groupsExpanded = !this.groupsExpanded;
          this.notifyChanges();
        }
        /**
         * Returns if the `IgxGridComponent` has groupable columns.
         * ```typescript
         * const groupableGrid = this.grid.hasGroupableColumns;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "_setGroupColsVisibility",

        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        value: function _setGroupColsVisibility(value) {
          var _this303 = this;

          if (this.columnList.length > 0 && !this.hasColumnLayouts) {
            this.groupingExpressions.forEach(function (expr) {
              /** @type {?} */
              var col = _this303.getColumnByName(expr.fieldName);

              col.hidden = value;
            });
          }
        }
        /**
         * Returns if the grid's group by drop area is visible.
         * ```typescript
         * const dropVisible = this.grid.dropAreaVisible;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "_getStateForGroupRow",

        /**
         * @hidden
         * @protected
         * @param {?} groupRow
         * @return {?}
         */
        value: function _getStateForGroupRow(groupRow) {
          return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
        }
        /**
         * @hidden
         * @protected
         * @param {?} groupRow
         * @return {?}
         */

      }, {
        key: "_toggleGroup",
        value: function _toggleGroup(groupRow) {
          this._gridAPI.groupBy_toggle_group(groupRow);
        }
        /**
         * @hidden
         * @protected
         * @param {?} groupRow
         * @return {?}
         */

      }, {
        key: "_fullyExpandGroup",
        value: function _fullyExpandGroup(groupRow) {
          this._gridAPI.groupBy_fully_expand_group(groupRow);
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "_applyGrouping",
        value: function _applyGrouping() {
          this._gridAPI.sort_multiple(this._groupingExpressions);
        }
        /**
         * @hidden
         * @param {?} fieldName
         * @return {?}
         */

      }, {
        key: "isColumnGrouped",
        value: function isColumnGrouped(fieldName) {
          return this.groupingExpressions.find(function (exp) {
            return exp.fieldName === fieldName;
          }) ? true : false;
        }
        /**
         * @hidden
         * @param {?} rowData
         * @param {?} rowIndex
         * @return {?}
         */

      }, {
        key: "getContext",
        value: function getContext(rowData, rowIndex) {
          return {
            $implicit: rowData,
            index: rowIndex,
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
          };
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onChipRemoved",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function onChipRemoved(event) {
          this.clearGrouping(event.owner.id);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "chipsOrderChanged",
        value: function chipsOrderChanged(event) {
          var _this304 = this;

          /** @type {?} */
          var newGrouping = [];

          var _loop8 = function _loop8(i) {
            /** @type {?} */
            var expr = _this304.groupingExpressions.filter(function (item) {
              return item.fieldName === event.chipsArray[i].id;
            })[0];

            if (!_this304.getColumnByName(expr.fieldName).groupable) {
              // disallow changing order if there are columns with groupable: false
              return {
                v: void 0
              };
            }

            newGrouping.push(expr);
          };

          for (var i = 0; i < event.chipsArray.length; i++) {
            var _ret4 = _loop8(i);

            if (typeof _ret4 === "object") return _ret4.v;
          }

          this.groupingExpansionState = [];
          this.chipsGoupingExpressions = newGrouping;

          if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
          }

          this.notifyChanges();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "chipsMovingEnded",
        value: function chipsMovingEnded() {
          this.groupingExpressions = this.chipsGoupingExpressions;
          this.notifyChanges();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipClicked",
        value: function onChipClicked(event) {
          /** @type {?} */
          var sortingExpr = this.sortingExpressions;
          /** @type {?} */

          var columnExpr = sortingExpr.find(function (expr) {
            return expr.fieldName === event.owner.id;
          });
          columnExpr.dir = 3 - columnExpr.dir;
          this.sort(columnExpr);
          this.notifyChanges();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onChipKeyDown",
        value: function onChipKeyDown(event) {
          if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            /** @type {?} */
            var sortingExpr = this.sortingExpressions;
            /** @type {?} */

            var columnExpr = sortingExpr.find(function (expr) {
              return expr.fieldName === event.owner.id;
            });
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.notifyChanges();
          }
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "getGroupAreaHeight",

        /**
         * @hidden
         * @protected
         * @return {?}
         */
        value: function getGroupAreaHeight() {
          return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
        }
        /**
         * @hidden
         * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
         * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
         * @return {?}
         */

      }, {
        key: "getFeatureColumnsWidth",
        value: function getFeatureColumnsWidth() {
          /** @type {?} */
          var width = _get(_getPrototypeOf(IgxGridComponent.prototype), "getFeatureColumnsWidth", this).call(this);

          if (this.groupingExpressions.length && this.headerGroupContainer) {
            width += this.headerGroupContainer.nativeElement.offsetWidth;
          }

          return width;
        }
        /**
         * @hidden
         * @protected
         * @param {?} row
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "scrollTo",
        value: function scrollTo(row, column) {
          if (this.groupingExpressions && this.groupingExpressions.length && typeof row !== 'number') {
            /** @type {?} */
            var rowIndex = this.groupingResult.indexOf(row);
            /** @type {?} */

            var groupByRecord = this.groupingMetadata[rowIndex];

            if (groupByRecord) {
              this._fullyExpandGroup(groupByRecord);
            }
          }

          _get(_getPrototypeOf(IgxGridComponent.prototype), "scrollTo", this).call(this, row, column, this.groupingFlatResult);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getGroupByChipTitle",

        /**
         * @hidden
         * @param {?} expression
         * @return {?}
         */
        value: function getGroupByChipTitle(expression) {
          /** @type {?} */
          var column = this.getColumnByName(expression.fieldName);
          return column && column.header || expression.fieldName;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getColumnGroupable",

        /**
         * @hidden
         * @param {?} fieldName
         * @return {?}
         */
        value: function getColumnGroupable(fieldName) {
          /** @type {?} */
          var column = this.getColumnByName(fieldName);
          return column && column.groupable;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          _get(_getPrototypeOf(IgxGridComponent.prototype), "ngAfterContentInit", this).call(this);

          if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
          }

          if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
          }

          if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
          }

          this._setupNavigationService();
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this305 = this;

          _get(_getPrototypeOf(IgxGridComponent.prototype), "ngOnInit", this).call(this);

          this.onGroupingDone.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (args) {
            _this305.endEdit(true);

            _this305.summaryService.updateSummaryCache(args);
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          var _this306 = this;

          if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {
            /** @type {?} */
            var changes = this.groupingDiffer.diff(this.groupingExpressions);

            if (changes && this.columnList.length > 0) {
              changes.forEachAddedItem(function (rec) {
                /** @type {?} */
                var col = _this306.getColumnByName(rec.item.fieldName);

                col.hidden = true;
              });
              changes.forEachRemovedItem(function (rec) {
                /** @type {?} */
                var col = _this306.getColumnByName(rec.item.fieldName);

                col.hidden = false;
              });
            }
          }

          _get(_getPrototypeOf(IgxGridComponent.prototype), "ngDoCheck", this).call(this);
        }
        /**
         * \@inheritdoc
         * @param {?=} formatters
         * @param {?=} headers
         * @return {?}
         */

      }, {
        key: "getSelectedData",
        value: function getSelectedData() {
          var formatters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (this.groupingExpressions.length) {
            /** @type {?} */
            var source = [];
            /** @type {?} */

            var process = function process(record) {
              if (record.expression || record.summaries) {
                source.push(null);
                return;
              }

              source.push(record);
            };

            this.dataView.forEach(process);
            return this.extractDataFromSelection(source, formatters, headers);
          } else {
            return _get(_getPrototypeOf(IgxGridComponent.prototype), "getSelectedData", this).call(this, formatters, headers);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_setupNavigationService",
        value: function _setupNavigationService() {
          if (this.hasColumnLayouts) {
            this.navigation = new IgxGridMRLNavigationService();
            this.navigation.grid = this;
          }
        }
        /**
         * @private
         * @param {?} expression
         * @return {?}
         */

      }, {
        key: "checkIfNoColumnField",
        value: function checkIfNoColumnField(expression) {
          if (expression instanceof Array) {
            var _iteratorNormalCompletion61 = true;
            var _didIteratorError61 = false;
            var _iteratorError61 = undefined;

            try {
              for (var _iterator61 = expression[Symbol.iterator](), _step61; !(_iteratorNormalCompletion61 = (_step61 = _iterator61.next()).done); _iteratorNormalCompletion61 = true) {
                var singleExpression = _step61.value;

                if (!singleExpression.fieldName) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError61 = true;
              _iteratorError61 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion61 && _iterator61["return"] != null) {
                  _iterator61["return"]();
                }
              } finally {
                if (_didIteratorError61) {
                  throw _iteratorError61;
                }
              }
            }

            return false;
          }

          return !expression.fieldName;
        }
      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._id = value;
        }
        /**
         * An \@Input property that lets you fill the `IgxGridComponent` with an array of data.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "data",
        get: function get() {
          return this._data;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._data = value || [];
          this.summaryService.clearSummaryCache();

          if (this.shouldGenerate) {
            this.setupColumns();
          }

          this.cdr.markForCheck();
        }
        /**
         * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "filteredData",
        get: function get() {
          return this._filteredData;
        }
        /**
         * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._filteredData = value;
        }
        /**
         * Sets the total number of records in the data source.
         * This property is required for remote grid virtualization to function when it is bound to remote data.
         * ```typescript
         * this.grid1.totalItemCount = 55;
         * ```
         * \@memberof IgxGridComponent
         * @param {?} count
         * @return {?}
         */

      }, {
        key: "totalItemCount",
        set: function set(count) {
          this.verticalScrollContainer.totalItemCount = count;
          this.cdr.detectChanges();
        }
        /**
         * Returns the total number of records in the data source.
         * Works only with remote grid virtualization.
         * ```typescript
         * const itemCount = this.grid1.totalItemCount;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        ,
        get: function get() {
          return this.verticalScrollContainer.totalItemCount;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_gridAPI",
        get: function get() {
          return (
            /** @type {?} */
            this.gridAPI
          );
        }
        /**
         * Returns the group by state of the `IgxGridComponent`.
         * ```typescript
         * let groupByState = this.grid.groupingExpressions;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "groupingExpressions",
        get: function get() {
          return this._groupingExpressions;
        }
        /**
         * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
         * event with the appropriate arguments.
         * ```typescript
         * this.grid.groupingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Asc,
         *     ignoreCase: false
         * }];
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          var _this307 = this;

          if (value && value.length > 10) {
            throw Error('Maximum amount of grouped columns is 10.');
          }
          /** @type {?} */


          var oldExpressions = this.groupingExpressions;
          /** @type {?} */

          var newExpressions = value;
          this._groupingExpressions = cloneArray(value);
          this.groupingExpressionsChange.emit(this._groupingExpressions);
          this.chipsGoupingExpressions = cloneArray(value);

          if (this._gridAPI.grid) {
            /* grouping should work in conjunction with sorting
            and without overriding separate sorting expressions */
            this._applyGrouping();

            this._gridAPI.arrange_sorting_expressions();

            this.notifyChanges();
          } else {
            // setter called before grid is registered in grid API service
            this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
          }

          if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
            /** @type {?} */
            var groupedCols = [];
            /** @type {?} */

            var ungroupedCols = [];
            /** @type {?} */

            var groupedColsArr = newExpressions.filter(function (obj) {
              return !oldExpressions.some(function (obj2) {
                return obj.fieldName === obj2.fieldName;
              });
            });
            groupedColsArr.forEach(function (elem) {
              groupedCols.push(_this307.getColumnByName(elem.fieldName));
            }, this);
            /** @type {?} */

            var ungroupedColsArr = oldExpressions.filter(function (obj) {
              return !newExpressions.some(function (obj2) {
                return obj.fieldName === obj2.fieldName;
              });
            });
            ungroupedColsArr.forEach(function (elem) {
              ungroupedCols.push(_this307.getColumnByName(elem.fieldName));
            }, this);
            this.notifyChanges();
            /** @type {?} */

            var groupingDoneArgs = {
              expressions: newExpressions,
              groupedColumns: groupedCols,
              ungroupedColumns: ungroupedCols
            };
            this.onGroupingDone.emit(groupingDoneArgs);
          }
        }
        /**
         * Returns a list of expansion states for group rows.
         * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
         * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
         * ```typescript
         * const groupExpState = this.grid.groupingExpansionState;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "groupingExpansionState",
        get: function get() {
          return this._groupingExpandState;
        }
        /**
         * Sets a list of expansion states for group rows.
         * ```typescript
         *      this.grid.groupingExpansionState = [{
         *      expanded: false,
         *      hierarchy: [{ fieldName: 'ID', value: 1 }]
         *   }];
         * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value !== this._groupingExpandState) {
            this.groupingExpansionStateChange.emit(value);
          }

          this._groupingExpandState = value;

          if (this.gridAPI.grid) {
            this.cdr.detectChanges();
          }
        }
        /**
         * An \@Input property that sets whether the grouped columns should be hidden as well.
         * The default value is "false"
         * ```html
         * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "hideGroupedColumns",
        get: function get() {
          return this._hideGroupedColumns;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value) {
            this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
          } else {
            this.groupingDiffer = null;
          }

          if (this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(value);
          }

          this._hideGroupedColumns = value;
        }
        /**
         * An \@Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
         * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
         * ```html
         * <igx-grid dropAreaMessage="Drop here to group!">
         *      <igx-column [groupable]="true" field="ID"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "dropAreaMessage",
        set: function set(value) {
          this._dropAreaMessage = value;
          this.notifyChanges();
        }
        /**
         * An accessor that returns the message displayed inside the GroupBy drop area where columns can be dragged on.
         * @return {?}
         */
        ,
        get: function get() {
          return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
        }
        /**
         * A list of all group rows.
         * ```typescript
         * const groupList = this.grid.groupsRowList;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "groupsRowList",
        get: function get() {
          /** @type {?} */
          var res = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();

          if (!this._groupsRowList) {
            return res;
          }
          /** @type {?} */


          var rList = this._groupsRowList.filter(function (item) {
            return item.element.nativeElement.parentElement !== null;
          });

          res.reset(rList);
          return res;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "groupAreaHostClass",
        get: function get() {
          return this.getComponentDensityClass('igx-drop-area');
        }
        /**
         * Returns the template reference of the `IgxGridComponent`'s group row.
         * ```
         * const groupRowTemplate = this.grid.groupRowTemplate;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "groupRowTemplate",
        get: function get() {
          return this._groupRowTemplate;
        }
        /**
         * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
         * ```typescript
         * this.grid.groupRowTemplate = myRowTemplate.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {
          this._groupRowTemplate = template;
          this.notifyChanges();
        }
        /**
         * Returns the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * const groupAreaTemplate = this.grid.groupAreaTemplate;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */

      }, {
        key: "groupAreaTemplate",
        get: function get() {
          return this._groupAreaTemplate;
        }
        /**
         * Sets the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * this.grid.groupAreaTemplate = myAreaTemplate.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {
          this._groupAreaTemplate = template;
          this.notifyChanges();
        }
      }, {
        key: "hasGroupableColumns",
        get: function get() {
          return this.columnList.some(function (col) {
            return col.groupable && !col.columnGroup;
          });
        }
      }, {
        key: "dropAreaVisible",
        get: function get() {
          return this.draggedColumn && this.draggedColumn.groupable || !this.chipsGoupingExpressions.length;
        }
      }, {
        key: "template",
        get: function get() {
          if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
          }

          if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
          }

          if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
          }
        }
      }, {
        key: "defaultTargetBodyHeight",
        get: function get() {
          /** @type {?} */
          var allItems = this.totalItemCount || this.dataLength;
          return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
        }
      }, {
        key: "dropAreaTemplateResolved",
        get: function get() {
          if (this.dropAreaTemplate) {
            return this.dropAreaTemplate;
          } else {
            return this.defaultDropAreaTemplate;
          }
        }
      }, {
        key: "iconTemplate",
        get: function get() {
          if (this.groupsExpanded) {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
          } else {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
          }
        }
      }]);

      return IgxGridComponent;
    }(IgxGridBaseComponent);

    IgxGridComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        providers: [IgxGridNavigationService, IgxGridSummaryService, IgxGridSelectionService, IgxGridCRUDService, {
          provide: GridBaseAPIService,
          useClass: IgxGridAPIService
        }, {
          provide: IgxGridBaseComponent,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxGridComponent;
          })
        }, IgxFilteringService, IgxColumnResizingService, IgxForOfSyncService, IgxForOfScrollSyncService, IgxRowIslandAPIService],
        selector: 'igx-grid',
        template: "<igx-grid-toolbar [style.flex-basis.px]=\"outerWidth\" role=\"rowgroup\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div [style.flex-basis.px]='outerWidth' class=\"igx-grid__grouparea\"\n    *ngIf=\"groupingExpressions.length > 0 || hasGroupableColumns\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [attr.title]=\"getGroupByChipTitle(expr)\"\n                [removable]=\"getColumnGroupable(expr.fieldName)\"\n                [draggable]=\"getColumnGroupable(expr.fieldName)\" [displayDensity]=\"displayDensity\"\n                (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\"\n                (onClick)=\"getColumnGroupable(expr.fieldName) ? onChipClicked($event): null\"\n                [disabled]='!getColumnGroupable(expr.fieldName)'>\n                <span>{{ getGroupByChipTitle(expr) }}</span>\n                <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\">arrow_forward\n                </igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\"\n            [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" [class.igx-grid__tr--mrl]='hasColumnLayouts' role=\"rowgroup\"\n    [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"\n                    [ngClass]=\"{\n                    'igx-grid__header-indentation--no-border': isRowSelectable || rowDraggable\n                }\" #headerGroupContainer  (click)=\"toggleAllGroupRows()\">\n\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !isRowSelectable\n                }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth || null' #tbody>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight'\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n                </igx-grid-row>\n            </ng-template>\n            <ng-template #group_template>\n                <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n                </igx-grid-groupby-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                    class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n            <ng-template\n                [igxTemplateOutlet]='isGroupByRecord(rowData) ? group_template : isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onBeforeViewDetach)='viewDetachHandler($event)' >\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n   [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_less</igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n    [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_more</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n"
      }]
    }];
    IgxGridComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      groupingExpressions: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      groupingExpressionsChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      groupingExpansionState: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      groupingExpansionStateChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      groupsExpanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hideGroupedColumns: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dropAreaMessage: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dropAreaTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onGroupingDone: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      groupTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxGroupByRowTemplateDirective, {
          read: IgxGroupByRowTemplateDirective,
          "static": false
        }]
      }],
      _groupsRowList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxGridGroupByRowComponent, {
          read: IgxGridGroupByRowComponent
        }]
      }],
      defaultDropAreaTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultDropArea', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      groupArea: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['groupArea', {
          "static": false
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxGridSortingPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxGridSortingPipe(gridAPI) {
        _classCallCheck(this, IgxGridSortingPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?} expressions
       * @param {?} id
       * @param {?} pipeTrigger
       * @return {?}
       */


      _createClass(IgxGridSortingPipe, [{
        key: "transform",
        value: function transform(collection, expressions, id, pipeTrigger) {
          /** @type {?} */
          var grid = this.gridAPI.grid;
          /** @type {?} */

          var result;

          if (!expressions.length) {
            result = collection;
          } else {
            result = DataUtil.sort(cloneArray(collection), expressions);
          }

          grid.filteredSortedData = result;
          return result;
        }
      }]);

      return IgxGridSortingPipe;
    }();

    IgxGridSortingPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'gridSort',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxGridSortingPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @hidden
     */


    var IgxGridGroupingPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxGridGroupingPipe(gridAPI) {
        _classCallCheck(this, IgxGridGroupingPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?} expression
       * @param {?} expansion
       * @param {?} defaultExpanded
       * @param {?} id
       * @param {?} groupsRecords
       * @param {?} pipeTrigger
       * @return {?}
       */


      _createClass(IgxGridGroupingPipe, [{
        key: "transform",
        value: function transform(collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
          /** @type {?} */
          var state = {
            expressions: [],
            expansion: [],
            defaultExpanded: defaultExpanded
          };
          /** @type {?} */

          var grid = this.gridAPI.grid;
          state.expressions = grid.groupingExpressions;
          /** @type {?} */

          var result;
          /** @type {?} */

          var fullResult = {
            data: [],
            metadata: []
          };

          if (!state.expressions.length) {
            // empty the array without changing reference
            groupsRecords.splice(0, groupsRecords.length);
            result = {
              data: collection,
              metadata: collection
            };
          } else {
            state.expansion = grid.groupingExpansionState;
            state.defaultExpanded = grid.groupsExpanded;
            result = DataUtil.group(cloneArray(collection), state, grid, groupsRecords, fullResult);
          }

          grid.groupingFlatResult = result.data;
          grid.groupingResult = fullResult.data;
          grid.groupingMetadata = fullResult.metadata;
          return result;
        }
      }]);

      return IgxGridGroupingPipe;
    }();

    IgxGridGroupingPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'gridGroupBy',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxGridGroupingPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @hidden
     */


    var IgxGridPagingPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxGridPagingPipe(gridAPI) {
        _classCallCheck(this, IgxGridPagingPipe);

        this.gridAPI = gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?=} page
       * @param {?=} perPage
       * @param {?=} id
       * @param {?=} pipeTrigger
       * @return {?}
       */


      _createClass(IgxGridPagingPipe, [{
        key: "transform",
        value: function transform(collection) {
          var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var perPage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 15;
          var id = arguments.length > 3 ? arguments[3] : undefined;
          var pipeTrigger = arguments.length > 4 ? arguments[4] : undefined;

          if (!this.gridAPI.grid.paging) {
            return collection;
          }
          /** @type {?} */


          var state = {
            index: page,
            recordsPerPage: perPage
          };
          DataUtil.correctPagingState(state, collection.data.length);
          /** @type {?} */

          var result = {
            data: DataUtil.page(cloneArray(collection.data), state),
            metadata: DataUtil.page(cloneArray(collection.metadata), state)
          };

          if (this.gridAPI.grid.page !== state.index) {
            this.gridAPI.grid.page = state.index;
          }

          this.gridAPI.grid.pagingState = state;
          return result;
        }
      }]);

      return IgxGridPagingPipe;
    }();

    IgxGridPagingPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'gridPaging',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxGridPagingPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @hidden
     */


    var IgxGridFilteringPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxGridFilteringPipe(gridAPI) {
        _classCallCheck(this, IgxGridFilteringPipe);

        this.gridAPI = gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?} expressionsTree
       * @param {?} filterStrategy
       * @param {?} advancedExpressionsTree
       * @param {?} id
       * @param {?} pipeTrigger
       * @param {?} filteringPipeTrigger
       * @return {?}
       */


      _createClass(IgxGridFilteringPipe, [{
        key: "transform",
        value: function transform(collection, expressionsTree, filterStrategy, advancedExpressionsTree, id, pipeTrigger, filteringPipeTrigger) {
          /** @type {?} */
          var grid = this.gridAPI.grid;
          /** @type {?} */

          var state = {
            expressionsTree: expressionsTree,
            strategy: filterStrategy,
            advancedExpressionsTree: advancedExpressionsTree
          };

          if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            return collection;
          }
          /** @type {?} */


          var result = DataUtil.filter(cloneArray(collection), state);
          grid.filteredData = result;
          return result;
        }
      }]);

      return IgxGridFilteringPipe;
    }();

    IgxGridFilteringPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'gridFiltering',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxGridFilteringPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxGridRowComponent =
    /*#__PURE__*/
    function (_IgxRowComponent) {
      _inherits(IgxGridRowComponent, _IgxRowComponent);

      // R.K. TODO: Remove

      /**
       * @param {?} gridAPI
       * @param {?} crudService
       * @param {?} selectionService
       * @param {?} element
       * @param {?} cdr
       */
      function IgxGridRowComponent(gridAPI, crudService, selectionService, element, cdr) {
        var _this308;

        _classCallCheck(this, IgxGridRowComponent);

        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        _this308 = _possibleConstructorReturn(this, _getPrototypeOf(IgxGridRowComponent).call(this, gridAPI, crudService, selectionService, element, cdr));
        _this308.gridAPI = gridAPI;
        _this308.crudService = crudService;
        _this308.selectionService = selectionService;
        _this308.element = element;
        _this308.cdr = cdr;
        return _this308;
      }
      /**
       * @return {?}
       */


      _createClass(IgxGridRowComponent, [{
        key: "hasColumnLayouts",
        get: function get() {
          return this.grid.hasColumnLayouts;
        }
      }]);

      return IgxGridRowComponent;
    }(IgxRowComponent);

    IgxGridRowComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-grid-row',
        template: "<ng-container *ngIf=\"grid.groupingExpressions.length > 0\">\n    <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}\"></div>\n</ng-container>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"this.showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n         <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <igx-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [lastPinned]=\"col.isLastPinned\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [cellSelectionMode]=\"grid.cellSelection\">\n        </igx-grid-cell>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [cellSelectionMode]=\"grid.cellSelection\">\n        </igx-grid-cell>\n    </ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <div *ngFor=\"let col of pinnedColumns | igxTopLevel\" class=\"igx-grid__mrl-block\"\n        [ngClass]=\"{'igx-grid__td--pinned-last': col.hasLastPinnedChildColumn}\"\n        [ngStyle]=\"{'grid-template-rows':col.getGridTemplate(true, false),\n        'grid-template-columns':col.getGridTemplate(false, false),\n        'z-index': col.pinned ? 1 : null,\n        '-ms-grid-rows':col.getGridTemplate(true, true),\n        '-ms-grid-columns':col.getGridTemplate(false, true)}\">\n            <igx-grid-cell *ngFor=\"let child of col.children\"\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"child.dataType === 'number'\"\n                [ngClass]=\"child.cellClasses | igxCellStyleClasses:rowData[child.field]:rowData:child.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [editMode]=\"child.editable && crudService.isInEditMode(index, child.index)\"\n                [column]=\"child\"\n                [formatter]=\"child.formatter\"\n                [row]=\"this\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [visibleColumnIndex]=\"child.visibleIndex\"\n                [value]=\"rowData[child.field]\"\n                [cellTemplate]=\"child.bodyTemplate\"\n                [cellSelectionMode]=\"grid.cellSelection\"></igx-grid-cell>\n        </div>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <div class=\"igx-grid__mrl-block\"\n        [ngStyle]=\"{'grid-template-rows':col.getGridTemplate(true, false),\n     'grid-template-columns':col.getGridTemplate(false, false),\n     '-ms-grid-rows':col.getGridTemplate(true, true),\n     '-ms-grid-columns':col.getGridTemplate(false, true)}\">\n            <igx-grid-cell *ngFor=\"let child of col.children\"\n                class=\"igx-grid__td igx-grid__td--fw\"\n                [class.igx-grid__td--number]=\"child.dataType === 'number'\"\n                [ngClass]=\"child.cellClasses | igxCellStyleClasses:rowData[child.field]:rowData:child.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [editMode]=\"child.editable && crudService.isInEditMode(index, child.index)\"\n                [column]=\"child\"\n                [formatter]=\"child.formatter\"\n                [row]=\"this\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [visibleColumnIndex]=\"child.visibleIndex\"\n                [value]=\"rowData[child.field]\"\n                [cellTemplate]=\"child.bodyTemplate\"\n                [cellSelectionMode]=\"grid.cellSelection\"></igx-grid-cell>\n        </div>\n    </ng-template>\n</ng-container>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [checked]=\"selected\"\n            [readonly]=\"true\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n",
        providers: [{
          provide: IgxRowComponent,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxGridRowComponent;
          })
        }]
      }]
    }];
    /** @nocollapse */

    IgxGridRowComponent.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: IgxGridCRUDService
      }, {
        type: IgxGridSelectionService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxGridRowComponent.propDecorators = {
      hasColumnLayouts: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__tr--mrl']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxGridSummaryPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxGridSummaryPipe(gridAPI) {
        _classCallCheck(this, IgxGridSummaryPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?} hasSummary
       * @param {?} summaryCalculationMode
       * @param {?} summaryPosition
       * @param {?} id
       * @param {?} pipeTrigger
       * @param {?} summaryPipeTrigger
       * @return {?}
       */


      _createClass(IgxGridSummaryPipe, [{
        key: "transform",
        value: function transform(collection, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
          if (!collection.data || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return collection.data;
          }

          return this.addSummaryRows(id, collection, summaryPosition);
        }
        /**
         * @private
         * @param {?} gridId
         * @param {?} collection
         * @param {?} summaryPosition
         * @return {?}
         */

      }, {
        key: "addSummaryRows",
        value: function addSummaryRows(gridId, collection, summaryPosition) {
          /** @type {?} */
          var recordsWithSummary = [];
          /** @type {?} */

          var lastChildMap = new Map();
          /** @type {?} */

          var grid = this.gridAPI.grid;
          /** @type {?} */

          var maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();

          if (collection.metadata.length && !grid.isGroupByRecord(collection.data[0]) && grid.isGroupByRecord(collection.metadata[0]) && summaryPosition === GridSummaryPosition.bottom) {
            var _collection$data;

            /** @type {?} */
            var groups = [];
            groups.push(collection.metadata[0]);

            while (groups[groups.length - 1].groupParent) {
              groups.push(groups[groups.length - 1].groupParent);
            }

            groups.reverse();
            groups.forEach(function (g) {
              return g.skip = true;
            });

            (_collection$data = collection.data).splice.apply(_collection$data, [0, 0].concat(groups));
          }

          for (var i = 0; i < collection.data.length; i++) {
            /** @type {?} */
            var record = collection.data[i];
            /** @type {?} */

            var skipAdd = false;
            /** @type {?} */

            var recordId = void 0;
            /** @type {?} */

            var groupByRecord = null;

            if (grid.isGroupByRecord(record)) {
              skipAdd = !!record.skip;
              record.skip = null;
              groupByRecord =
              /** @type {?} */
              record;
              recordId = this.gridAPI.get_groupBy_record_id(groupByRecord);
            } else {
              recordId = this.gridAPI.get_row_id(record);
            }

            if (!skipAdd) {
              recordsWithSummary.push(record);
            }

            if (summaryPosition === GridSummaryPosition.bottom && lastChildMap.has(recordId)) {
              /** @type {?} */
              var groupRecords = lastChildMap.get(recordId);

              for (var j = 0; j < groupRecords.length; j++) {
                /** @type {?} */
                var groupRecord = groupRecords[j];
                /** @type {?} */

                var groupRecordId = this.gridAPI.get_groupBy_record_id(groupRecord);
                /** @type {?} */

                var records = this.removeDeletedRecord(grid, groupRecord.records.slice());
                /** @type {?} */

                var summaries = grid.summaryService.calculateSummaries(groupRecordId, records);
                /** @type {?} */

                var summaryRecord = {
                  summaries: summaries,
                  max: maxSummaryHeight
                };
                recordsWithSummary.push(summaryRecord);
              }
            }

            if (groupByRecord === null || !grid.isExpandedGroup(groupByRecord)) {
              continue;
            }

            if (summaryPosition === GridSummaryPosition.top) {
              /** @type {?} */
              var _records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
              /** @type {?} */


              var _summaries2 = grid.summaryService.calculateSummaries(recordId, _records);
              /** @type {?} */


              var _summaryRecord = {
                summaries: _summaries2,
                max: maxSummaryHeight
              };
              recordsWithSummary.push(_summaryRecord);
            } else if (summaryPosition === GridSummaryPosition.bottom) {
              /** @type {?} */
              var lastChild = groupByRecord;

              while (lastChild.groups && lastChild.groups.length > 0 && grid.isExpandedGroup(lastChild)) {
                lastChild = lastChild.groups[lastChild.groups.length - 1];
              }
              /** @type {?} */


              var lastChildId = void 0;

              if (grid.isExpandedGroup(lastChild)) {
                lastChildId = this.gridAPI.get_row_id(lastChild.records[lastChild.records.length - 1]);
              } else {
                lastChildId = this.gridAPI.get_groupBy_record_id(lastChild);
              }
              /** @type {?} */


              var _groupRecords = lastChildMap.get(lastChildId);

              if (!_groupRecords) {
                _groupRecords = [];
                lastChildMap.set(lastChildId, _groupRecords);
              }

              _groupRecords.unshift(groupByRecord);
            }
          }

          return recordsWithSummary;
        }
        /**
         * @private
         * @param {?} grid
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "removeDeletedRecord",
        value: function removeDeletedRecord(grid, data) {
          if (!grid.transactions.enabled) {
            return data;
          }
          /** @type {?} */


          var deletedRows = grid.transactions.getTransactionLog().filter(function (t) {
            return t.type === 'delete';
          }).map(function (t) {
            return t.id;
          });
          deletedRows.forEach(function (rowID) {
            /** @type {?} */
            var tempData = grid.primaryKey ? data.map(function (rec) {
              return rec[grid.primaryKey];
            }) : data;
            /** @type {?} */

            var index = tempData.indexOf(rowID);

            if (index !== -1) {
              data.splice(index, 1);
            }
          });
          return data;
        }
      }]);

      return IgxGridSummaryPipe;
    }();

    IgxGridSummaryPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'gridSummary',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxGridSummaryPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var IgxGridModule =
    /*#__PURE__*/
    function () {
      function IgxGridModule() {
        _classCallCheck(this, IgxGridModule);
      }

      _createClass(IgxGridModule, null, [{
        key: "forRoot",

        /**
         * @return {?}
         */
        value: function forRoot() {
          return {
            ngModule: IgxGridModule
          };
        }
      }]);

      return IgxGridModule;
    }();

    IgxGridModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxGridComponent, IgxGridRowComponent, IgxGridGroupByRowComponent, IgxGroupByRowTemplateDirective, IgxRowExpandedIndicatorDirective, IgxRowCollapsedIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHeaderCollapseIndicatorDirective, IgxGroupAreaDropDirective, IgxGridGroupingPipe, IgxGridPagingPipe, IgxGridSortingPipe, IgxGridFilteringPipe, IgxGridSummaryPipe],
        exports: [IgxGridComponent, IgxGridGroupByRowComponent, IgxGridRowComponent, IgxGroupByRowTemplateDirective, IgxRowExpandedIndicatorDirective, IgxRowCollapsedIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHeaderCollapseIndicatorDirective, IgxGroupAreaDropDirective, IgxGridCommonModule, IgxGridGroupingPipe, IgxGridPagingPipe, IgxGridSortingPipe, IgxGridFilteringPipe, IgxGridSummaryPipe],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], IgxChipsModule, IgxGridCommonModule, IgxSelectModule]
      }]
    }];
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateMethod('IgxGridModule.forRoot method is deprecated. Use IgxGridModule instead.'), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Function), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", []), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:returntype", void 0)], IgxGridModule, "forRoot", null);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxTreeGridAPIService =
    /*#__PURE__*/
    function (_GridBaseAPIService2) {
      _inherits(IgxTreeGridAPIService, _GridBaseAPIService2);

      function IgxTreeGridAPIService() {
        _classCallCheck(this, IgxTreeGridAPIService);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxTreeGridAPIService).apply(this, arguments));
      }

      _createClass(IgxTreeGridAPIService, [{
        key: "get_all_data",

        /**
         * @param {?=} transactions
         * @return {?}
         */
        value: function get_all_data(transactions) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var data = transactions ? grid.dataWithAddedInTransactionRows : grid.flatData;
          return data ? data : [];
        }
        /**
         * @return {?}
         */

      }, {
        key: "get_summary_data",
        value: function get_summary_data() {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var data = grid.processedRootRecords.filter(function (row) {
            return row.isFilteredOutParent === undefined || row.isFilteredOutParent === false;
          }).map(function (rec) {
            return rec.data;
          });

          if (grid.transactions.enabled) {
            /** @type {?} */
            var deletedRows = grid.transactions.getTransactionLog().filter(function (t) {
              return t.type === TransactionType.DELETE;
            }).map(function (t) {
              return t.id;
            });
            deletedRows.forEach(function (rowID) {
              /** @type {?} */
              var tempData = grid.primaryKey ? data.map(function (rec) {
                return rec[grid.primaryKey];
              }) : data;
              /** @type {?} */

              var index = tempData.indexOf(rowID);

              if (index !== -1) {
                data.splice(index, 1);
              }
            });
          }

          return data;
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "expand_row",
        value: function expand_row(rowID) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var expandedStates = grid.expansionStates;
          expandedStates.set(rowID, true);
          grid.expansionStates = expandedStates;

          if (grid.rowEditable) {
            grid.endEdit(true);
          }
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "collapse_row",
        value: function collapse_row(rowID) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var expandedStates = grid.expansionStates;
          expandedStates.set(rowID, false);
          grid.expansionStates = expandedStates;

          if (grid.rowEditable) {
            grid.endEdit(true);
          }
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "toggle_row_expansion",
        value: function toggle_row_expansion(rowID) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var expandedStates = grid.expansionStates;
          /** @type {?} */

          var treeRecord = grid.records.get(rowID);

          if (treeRecord) {
            /** @type {?} */
            var isExpanded = this.get_row_expansion_state(treeRecord);
            expandedStates.set(rowID, !isExpanded);
            grid.expansionStates = expandedStates;
          }

          if (grid.rowEditable) {
            grid.endEdit(true);
          }
        } // TODO: Maybe move the focus logic in the tree cell ?

        /**
         * @param {?} row
         * @param {?} expanded
         * @param {?=} event
         * @param {?=} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "trigger_row_expansion_toggle",
        value: function trigger_row_expansion_toggle(row, expanded, event, visibleColumnIndex) {
          var _this309 = this;

          /** @type {?} */
          var grid = this.grid;

          if (row.expanded === expanded || (!row.children || !row.children.length) && (!grid.loadChildrenOnDemand || grid.hasChildrenKey && !row.data[grid.hasChildrenKey])) {
            return;
          }
          /** @type {?} */


          var args = {
            rowID: row.rowID,
            expanded: expanded,
            event: event,
            cancel: false
          };
          grid.onRowToggle.emit(args);

          if (args.cancel) {
            return;
          }
          /** @type {?} */


          var expandedStates = grid.expansionStates;
          expandedStates.set(row.rowID, expanded);
          grid.expansionStates = expandedStates;

          if (grid.rowEditable) {
            grid.endEdit(true);
          } // TODO: Leave it to grid observer


          requestAnimationFrame(function () {
            /** @type {?} */
            var el = _this309.grid.selectionService.activeElement;

            if (el) {
              /** @type {?} */
              var cell = _this309.get_cell_by_visible_index(el.row, el.column);

              if (cell) {
                cell.nativeElement.focus();
              }
            }
          });
        }
        /**
         * @param {?} record
         * @return {?}
         */

      }, {
        key: "expand_path_to_record",
        value: function expand_path_to_record(record) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var expandedStates = grid.expansionStates;

          while (record.parent) {
            record = record.parent;
            /** @type {?} */

            var expanded = this.get_row_expansion_state(record);

            if (!expanded) {
              expandedStates.set(record.rowID, true);
            }
          }

          grid.expansionStates = expandedStates;

          if (grid.rowEditable) {
            grid.endEdit(true);
          }
        }
        /**
         * @param {?} record
         * @return {?}
         */

      }, {
        key: "get_row_expansion_state",
        value: function get_row_expansion_state(record) {
          /** @type {?} */
          var grid = this.grid;
          /** @type {?} */

          var states = grid.expansionStates;
          /** @type {?} */

          var expanded = states.get(record.rowID);

          if (expanded !== undefined) {
            return expanded;
          } else {
            return record.children && record.children.length && record.level < grid.expansionDepth;
          }
        }
        /**
         * @protected
         * @param {?} value
         * @param {?} rowID
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "update_row_in_array",
        value: function update_row_in_array(value, rowID, index) {
          /** @type {?} */
          var grid = this.grid;

          if (grid.primaryKey && grid.foreignKey) {
            _get(_getPrototypeOf(IgxTreeGridAPIService.prototype), "update_row_in_array", this).call(this, value, rowID, index);
          } else {
            /** @type {?} */
            var record = grid.records.get(rowID);
            /** @type {?} */

            var childData = record.parent ? record.parent.data[grid.childDataKey] : grid.data;
            index = grid.primaryKey ? childData.map(function (c) {
              return c[grid.primaryKey];
            }).indexOf(rowID) : childData.indexOf(rowID);
            childData[index] = value;
          }
        }
        /**
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "should_apply_number_style",
        value: function should_apply_number_style(column) {
          return column.dataType === DataType.Number && column.visibleIndex !== 0;
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "deleteRowById",
        value: function deleteRowById(rowID) {
          /** @type {?} */
          var treeGrid = this.grid;
          /** @type {?} */

          var flatDataWithCascadeOnDeleteAndTransactions = treeGrid.primaryKey && treeGrid.foreignKey && treeGrid.cascadeOnDelete && treeGrid.transactions.enabled;

          if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.startPending();
          }

          _get(_getPrototypeOf(IgxTreeGridAPIService.prototype), "deleteRowById", this).call(this, rowID);

          if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.endPending(true);
          }
        }
        /**
         * @param {?} rowID
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "deleteRowFromData",
        value: function deleteRowFromData(rowID, index) {
          /** @type {?} */
          var treeGrid = this.grid;
          /** @type {?} */

          var record = treeGrid.records.get(rowID);

          if (treeGrid.primaryKey && treeGrid.foreignKey) {
            index = treeGrid.primaryKey ? treeGrid.data.map(function (c) {
              return c[treeGrid.primaryKey];
            }).indexOf(rowID) : treeGrid.data.indexOf(rowID);

            _get(_getPrototypeOf(IgxTreeGridAPIService.prototype), "deleteRowFromData", this).call(this, rowID, index);

            if (treeGrid.cascadeOnDelete) {
              if (record && record.children && record.children.length > 0) {
                for (var i = 0; i < record.children.length; i++) {
                  /** @type {?} */
                  var child = record.children[i];

                  _get(_getPrototypeOf(IgxTreeGridAPIService.prototype), "deleteRowById", this).call(this, child.rowID);
                }
              }
            }
          } else {
            /** @type {?} */
            var collection = record.parent ? record.parent.data[treeGrid.childDataKey] : treeGrid.data;
            index = treeGrid.primaryKey ? collection.map(function (c) {
              return c[treeGrid.primaryKey];
            }).indexOf(rowID) : collection.indexOf(rowID);
            /** @type {?} */

            var selectedChildren = [];
            this.get_selected_children(record, selectedChildren);

            if (selectedChildren.length > 0) {
              treeGrid.deselectRows(selectedChildren);
            }

            if (treeGrid.transactions.enabled) {
              /** @type {?} */
              var path = treeGrid.generateRowPath(rowID);
              treeGrid.transactions.add({
                id: rowID,
                type: TransactionType.DELETE,
                newValue: null,
                path: path
              }, collection[index]);
            } else {
              collection.splice(index, 1);
            }
          }
        }
        /**
         * Updates related row of provided grid's data source with provided new row value
         * @protected
         * @param {?} grid Grid to update data for
         * @param {?} rowID ID of the row to update
         * @param {?} rowValueInDataSource Initial value of the row as it is in data source
         * @param {?} rowCurrentValue Current value of the row as it is with applied previous transactions
         * @param {?} rowNewValue New value of the row
         * @return {?}
         */

      }, {
        key: "updateData",
        value: function updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
          if (grid.transactions.enabled) {
            /** @type {?} */
            var path = grid.generateRowPath(rowID);
            /** @type {?} */

            var transaction = {
              id: rowID,
              type: TransactionType.UPDATE,
              newValue: rowNewValue,
              path: path
            };
            grid.transactions.add(transaction, rowCurrentValue);
          } else {
            mergeObjects(rowValueInDataSource, rowNewValue);
          }
        }
        /**
         * @param {?} record
         * @param {?} selectedRowIDs
         * @return {?}
         */

      }, {
        key: "get_selected_children",
        value: function get_selected_children(record, selectedRowIDs) {
          /** @type {?} */
          var grid = this.grid;

          if (!record.children || record.children.length === 0) {
            return;
          }

          var _iteratorNormalCompletion62 = true;
          var _didIteratorError62 = false;
          var _iteratorError62 = undefined;

          try {
            for (var _iterator62 = record.children[Symbol.iterator](), _step62; !(_iteratorNormalCompletion62 = (_step62 = _iterator62.next()).done); _iteratorNormalCompletion62 = true) {
              var child = _step62.value;

              if (grid.selectionService.isRowSelected(child.rowID)) {
                selectedRowIDs.push(child.rowID);
              }

              this.get_selected_children(child, selectedRowIDs);
            }
          } catch (err) {
            _didIteratorError62 = true;
            _iteratorError62 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion62 && _iterator62["return"] != null) {
                _iterator62["return"]();
              }
            } finally {
              if (_didIteratorError62) {
                throw _iteratorError62;
              }
            }
          }
        }
        /**
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "row_deleted_transaction",
        value: function row_deleted_transaction(rowID) {
          return this.row_deleted_parent(rowID) || _get(_getPrototypeOf(IgxTreeGridAPIService.prototype), "row_deleted_transaction", this).call(this, rowID);
        }
        /**
         * @private
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "row_deleted_parent",
        value: function row_deleted_parent(rowID) {
          /** @type {?} */
          var grid = this.grid;

          if (!grid) {
            return false;
          }

          if (grid.cascadeOnDelete && grid.foreignKey || grid.childDataKey) {
            /** @type {?} */
            var node = grid.records.get(rowID);

            while (node) {
              /** @type {?} */
              var state = grid.transactions.getState(node.rowID);

              if (state && state.type === TransactionType.DELETE) {
                return true;
              }

              node = node.parent;
            }
          }

          return false;
        }
      }]);

      return IgxTreeGridAPIService;
    }(GridBaseAPIService);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxTreeGridNavigationService =
    /*#__PURE__*/
    function (_IgxGridNavigationSer2) {
      _inherits(IgxTreeGridNavigationService, _IgxGridNavigationSer2);

      function IgxTreeGridNavigationService() {
        _classCallCheck(this, IgxTreeGridNavigationService);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxTreeGridNavigationService).apply(this, arguments));
      }

      _createClass(IgxTreeGridNavigationService, [{
        key: "getCellSelector",

        /**
         * @protected
         * @param {?=} visibleIndex
         * @param {?=} isSummary
         * @return {?}
         */
        value: function getCellSelector(visibleIndex) {
          var isSummary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (isSummary) {
            return 'igx-grid-summary-cell';
          }

          if (visibleIndex === 0) {
            return 'igx-tree-grid-cell';
          }

          return 'igx-grid-cell';
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "getRowSelector",
        value: function getRowSelector() {
          return 'igx-tree-grid-row';
        }
      }]);

      return IgxTreeGridNavigationService;
    }(IgxGridNavigationService);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var IgxRowLoadingIndicatorTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxRowLoadingIndicatorTemplateDirective(template) {
      _classCallCheck(this, IgxRowLoadingIndicatorTemplateDirective);

      this.template = template;
    };

    IgxRowLoadingIndicatorTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRowLoadingIndicator]'
      }]
    }];
    /** @nocollapse */

    IgxRowLoadingIndicatorTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var NEXT_ID$n = 0;
    /**
     * **Ignite UI for Angular Tree Grid** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
     *
     * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
     * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
     *
     * Example:
     * ```html
     * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
     *   <igx-column field="first" header="First Name"></igx-column>
     *   <igx-column field="last" header="Last Name"></igx-column>
     *   <igx-column field="role" header="Role"></igx-column>
     * </igx-tree-grid>
     * ```
     */

    var IgxTreeGridComponent =
    /*#__PURE__*/
    function (_IgxGridBaseComponent2) {
      _inherits(IgxTreeGridComponent, _IgxGridBaseComponent2);

      function IgxTreeGridComponent() {
        var _this310;

        _classCallCheck(this, IgxTreeGridComponent);

        _this310 = _possibleConstructorReturn(this, _getPrototypeOf(IgxTreeGridComponent).apply(this, arguments));
        _this310._id = "igx-tree-grid-".concat(NEXT_ID$n++);
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */

        _this310.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */

        _this310.processedRecords = new Map();
        /**
         * An \@Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */

        _this310.cascadeOnDelete = true;
        _this310._expansionDepth = Infinity;
        _this310._expansionStates = new Map();
        /**
         * @hidden
         */

        _this310.expansionStatesChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when the expanded state of a row gets changed.
         * ```typescript
         * rowToggle(event: IRowToggleEventArgs){
         *  // the id of the row
         *  const rowID = event.rowID;
         *  // the new expansion state
         *  const newExpandedState = event.expanded;
         *  // the original event that triggered onRowToggle
         *  const originalEvent = event.event;
         *  // whether the event should be cancelled
         *  event.cancel = true;
         * }
         * ```
         * ```html
         * <igx-tree-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */

        _this310.onRowToggle = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this310.loadingRows = new Set();
        _this310._filteredData = null;
        return _this310;
      }
      /**
       * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
       * ```html
       * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
       * ```
       * \@memberof IgxTreeGridComponent
       * @return {?}
       */


      _createClass(IgxTreeGridComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          var _this311 = this;

          _get(_getPrototypeOf(IgxTreeGridComponent.prototype), "ngOnInit", this).call(this);

          this.onRowToggle.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (args) {
            _this311.loadChildrenOnRowExpansion(args);
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          _get(_getPrototypeOf(IgxTreeGridComponent.prototype), "ngDoCheck", this).call(this);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
          }

          _get(_getPrototypeOf(IgxTreeGridComponent.prototype), "ngAfterContentInit", this).call(this);
        }
        /**
         * @private
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "loadChildrenOnRowExpansion",
        value: function loadChildrenOnRowExpansion(args) {
          var _this312 = this;

          if (this.loadChildrenOnDemand) {
            /** @type {?} */
            var parentID = args.rowID;

            if (args.expanded && !this._expansionStates.has(parentID)) {
              this.loadingRows.add(parentID);
              this.loadChildrenOnDemand(parentID, function (children) {
                _this312.loadingRows["delete"](parentID);

                _this312.addChildRows(children, parentID);

                _this312.notifyChanges();

                requestAnimationFrame(function () {
                  /** @type {?} */
                  var cellID = _this312.selectionService.activeElement;

                  if (cellID) {
                    /** @type {?} */
                    var cell = _this312._gridAPI.get_cell_by_index(cellID.row, cellID.column);

                    if (cell) {
                      cell.nativeElement.focus();
                    }
                  }
                });
              });
            }
          }
        }
        /**
         * @private
         * @param {?} children
         * @param {?} parentID
         * @return {?}
         */

      }, {
        key: "addChildRows",
        value: function addChildRows(children, parentID) {
          var _this313 = this;

          if (this.primaryKey && this.foreignKey) {
            var _this$data;

            var _iteratorNormalCompletion63 = true;
            var _didIteratorError63 = false;
            var _iteratorError63 = undefined;

            try {
              for (var _iterator63 = children[Symbol.iterator](), _step63; !(_iteratorNormalCompletion63 = (_step63 = _iterator63.next()).done); _iteratorNormalCompletion63 = true) {
                var child = _step63.value;
                child[this.foreignKey] = parentID;
              }
            } catch (err) {
              _didIteratorError63 = true;
              _iteratorError63 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion63 && _iterator63["return"] != null) {
                  _iterator63["return"]();
                }
              } finally {
                if (_didIteratorError63) {
                  throw _iteratorError63;
                }
              }
            }

            (_this$data = this.data).push.apply(_this$data, _toConsumableArray(children));
          } else if (this.childDataKey) {
            /** @type {?} */
            var parent = this.records.get(parentID);
            /** @type {?} */

            var parentData = parent.data;

            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
              /** @type {?} */
              var path = [];

              while (parent) {
                path.push(parent.rowID);
                parent = parent.parent;
              }
              /** @type {?} */


              var collection = this.data;
              /** @type {?} */

              var record;

              var _loop9 = function _loop9(i) {
                /** @type {?} */
                var pid = path[i];
                record = collection.find(function (r) {
                  return r[_this313.primaryKey] === pid;
                });

                if (!record) {
                  return "break";
                }

                collection = record[_this313.childDataKey];
              };

              for (var i = path.length - 1; i >= 0; i--) {
                var _ret5 = _loop9(i);

                if (_ret5 === "break") break;
              }

              if (record) {
                parentData = record;
              }
            }

            parentData[this.childDataKey] = children;
          }

          this.selectionService.clearHeaderCBState();
          this._pipeTrigger++;
        }
        /**
         * @private
         * @param {?} mapIn
         * @return {?}
         */

      }, {
        key: "cloneMap",
        value: function cloneMap(mapIn) {
          /** @type {?} */
          var mapCloned = new Map();
          mapIn.forEach(function (value, key, mapObj) {
            mapCloned.set(key, value);
          });
          return mapCloned;
        }
        /**
         * Expands the `IgxTreeGridRowComponent` with the specified rowID.
         * \@memberof IgxTreeGridComponent
         * @param {?} rowID The identifier of the row to be expanded.
         * ```typescript
         * this.grid.expandRow(2);
         * ```
         * @return {?}
         */

      }, {
        key: "expandRow",
        value: function expandRow(rowID) {
          this._gridAPI.expand_row(rowID);
        }
        /**
         * Collapses the `IgxTreeGridRowComponent` with the specified rowID.
         * \@memberof IgxTreeGridComponent
         * @param {?} rowID The identifier of the row to be collapsed.
         * ```typescript
         * this.grid.collapseRow(2);
         * ```
         * @return {?}
         */

      }, {
        key: "collapseRow",
        value: function collapseRow(rowID) {
          this._gridAPI.collapse_row(rowID);
        }
        /**
         * Toggles the expansion state of the `IgxTreeGridRowComponent` with the specified rowID.
         * \@memberof IgxTreeGridComponent
         * @param {?} rowID The identifier of the row to be toggled.
         * ```typescript
         * this.grid.toggleRow(2);
         * ```
         * @return {?}
         */

      }, {
        key: "toggleRow",
        value: function toggleRow(rowID) {
          this._gridAPI.toggle_row_expansion(rowID);
        }
        /**
         * Expands all rows.
         * ```typescript
         * this.grid.expandAll();
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */

      }, {
        key: "expandAll",
        value: function expandAll() {
          this._expansionDepth = Infinity;
          this.expansionStates = new Map();
        }
        /**
         * Collapses all rows.
         * ```typescript
         * this.grid.collapseAll();
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */

      }, {
        key: "collapseAll",
        value: function collapseAll() {
          this._expansionDepth = 0;
          this.expansionStates = new Map();
        }
        /**
         * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
         * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
         * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
         * ```typescript
         * const record = {
         *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
         *     Name: this.newRecord
         * };
         * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
         * ```
         * \@memberof IgxTreeGridComponent
         * @param {?} data
         * @param {?=} parentRowID
         * @return {?}
         */

      }, {
        key: "addRow",
        value: function addRow(data, parentRowID) {
          if (parentRowID !== undefined && parentRowID !== null) {
            _get(_getPrototypeOf(IgxTreeGridComponent.prototype), "endEdit", this).call(this, true);
            /** @type {?} */


            var state = this.transactions.getState(parentRowID); // we should not allow adding of rows as child of deleted row

            if (state && state.type === TransactionType.DELETE) {
              throw Error("Cannot add child row to deleted parent row");
            }
            /** @type {?} */


            var parentRecord = this.records.get(parentRowID);

            if (!parentRecord) {
              throw Error('Invalid parent row ID!');
            }

            this.summaryService.clearSummaryCache({
              rowID: parentRecord.rowID
            });

            if (this.primaryKey && this.foreignKey) {
              data[this.foreignKey] = parentRowID;

              _get(_getPrototypeOf(IgxTreeGridComponent.prototype), "addRow", this).call(this, data);
            } else {
              /** @type {?} */
              var parentData = parentRecord.data;
              /** @type {?} */

              var childKey = this.childDataKey;

              if (this.transactions.enabled) {
                /** @type {?} */
                var rowId = this.primaryKey ? data[this.primaryKey] : data;
                /** @type {?} */

                var path = [];
                path.push.apply(path, _toConsumableArray(this.generateRowPath(parentRowID)));
                path.push(parentRowID);
                this.transactions.add(
                /** @type {?} */
                {
                  id: rowId,
                  path: path,
                  newValue: data,
                  type: TransactionType.ADD
                }, null);
              } else {
                if (!parentData[childKey]) {
                  parentData[childKey] = [];
                }

                parentData[childKey].push(data);
              }

              this.onRowAdded.emit({
                data: data
              });
              this._pipeTrigger++;
              this.notifyChanges();
            }
          } else {
            if (this.primaryKey && this.foreignKey) {
              /** @type {?} */
              var rowID = data[this.foreignKey];
              this.summaryService.clearSummaryCache({
                rowID: rowID
              });
            }

            _get(_getPrototypeOf(IgxTreeGridComponent.prototype), "addRow", this).call(this, data);
          }
        }
        /**
         * @hidden
         * @param {?} rowId
         * @return {?}
         */

      }, {
        key: "deleteRowById",
        value: function deleteRowById(rowId) {
          //  if this is flat self-referencing data, and CascadeOnDelete is set to true
          //  and if we have transactions we should start pending transaction. This allows
          //  us in case of delete action to delete all child rows as single undo action
          this._gridAPI.deleteRowById(rowId);
        }
        /**
         * @hidden
         * @param {?} rowId
         * @return {?}
         */

      }, {
        key: "generateRowPath",
        value: function generateRowPath(rowId) {
          /** @type {?} */
          var path = [];
          /** @type {?} */

          var record = this.records.get(rowId);

          while (record.parent) {
            path.push(record.parent.rowID);
            record = record.parent;
          }

          return path.reverse();
        }
        /**
         * @hidden \@internal
         * @protected
         * @return {?}
         */

      }, {
        key: "getDataBasedBodyHeight",
        value: function getDataBasedBodyHeight() {
          return !this.flatData || this.flatData.length < this._defaultTargetRecordNumber ? 0 : this.defaultTargetBodyHeight;
        }
        /**
         * @hidden
         * @protected
         * @param {?} row
         * @param {?} column
         * @return {?}
         */

      }, {
        key: "scrollTo",
        value: function scrollTo(row, column) {
          var _this314 = this;

          /** @type {?} */
          var delayScrolling = false;
          /** @type {?} */

          var record;

          if (typeof row !== 'number') {
            /** @type {?} */
            var rowData = row;
            /** @type {?} */

            var rowID = this._gridAPI.get_row_id(rowData);

            record = this.processedRecords.get(rowID);

            this._gridAPI.expand_path_to_record(record);

            if (this.paging) {
              /** @type {?} */
              var rowIndex = this.processedExpandedFlatData.indexOf(rowData);
              /** @type {?} */

              var page = Math.floor(rowIndex / this.perPage);

              if (this.page !== page) {
                delayScrolling = true;
                this.page = page;
              }
            }
          }

          if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
              _this314.scrollDirective(_this314.verticalScrollContainer, typeof row === 'number' ? row : _this314.dataView.indexOf(record));
            });
          } else {
            this.scrollDirective(this.verticalScrollContainer, typeof row === 'number' ? row : this.dataView.indexOf(record));
          }

          this.scrollToHorizontally(column);
        }
        /**
         * @hidden
         * @param {?} rowData
         * @param {?} rowIndex
         * @return {?}
         */

      }, {
        key: "getContext",
        value: function getContext(rowData, rowIndex) {
          return {
            $implicit: rowData,
            index: rowIndex,
            templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
          };
        }
        /**
         * \@inheritdoc
         * @param {?=} formatters
         * @param {?=} headers
         * @return {?}
         */

      }, {
        key: "getSelectedData",
        value: function getSelectedData() {
          var formatters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          /** @type {?} */
          var source = [];
          /** @type {?} */

          var process = function process(record) {
            if (record.summaries) {
              source.push(null);
              return;
            }

            source.push(record.data);
          };

          this.dataView.forEach(process);
          return this.extractDataFromSelection(source, formatters, headers);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "writeToData",

        /**
         * @protected
         * @param {?} rowIndex
         * @param {?} value
         * @return {?}
         */
        value: function writeToData(rowIndex, value) {
          mergeObjects(this.flatData[rowIndex], value);
        }
        /**
         * @hidden
         * @protected
         * @param {?} collection
         * @param {?=} cb
         * @return {?}
         */

      }, {
        key: "initColumns",
        value: function initColumns(collection) {
          var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts

            /** @type {?} */
            var nonColumnLayoutColumns = this.columnList.filter(function (col) {
              return !col.columnLayout && !col.columnLayoutChild;
            });
            this.columnList.reset(nonColumnLayoutColumns);
          }

          _get(_getPrototypeOf(IgxTreeGridComponent.prototype), "initColumns", this).call(this, collection, cb);
        }
      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._id = value;
        }
        /**
         * An \@Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
         * ```html
         * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */

      }, {
        key: "data",
        get: function get() {
          return this._data;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._data = value || [];
          this.summaryService.clearSummaryCache();

          if (this.shouldGenerate) {
            this.setupColumns();
          }

          this.cdr.markForCheck();
        }
        /**
         * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */

      }, {
        key: "filteredData",
        get: function get() {
          return this._filteredData;
        }
        /**
         * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * \@memberof IgxTreeGridComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._filteredData = value;
        }
        /**
         * Get transactions service for the grid.
         * \@experimental \@hidden
         * @return {?}
         */

      }, {
        key: "transactions",
        get: function get() {
          return this._transactions;
        }
        /**
         * An \@Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
         * set to `Infinity` which means all levels would be expanded.
         * ```html
         * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */

      }, {
        key: "expansionDepth",
        get: function get() {
          return this._expansionDepth;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._expansionDepth = value;
          this.notifyChanges();
        }
        /**
         * Returns a list of key-value pairs [row ID, expansion state]. Includes only states that differ from the default one.
         * ```typescript
         * const expansionStates = this.grid.expansionStates;
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */

      }, {
        key: "expansionStates",
        get: function get() {
          return this._expansionStates;
        }
        /**
         * Sets a list of key-value pairs [row ID, expansion state].
         * ```typescript
         * const states = new Map<any, boolean>();
         * states.set(1, true);
         * this.grid.expansionStates = states;
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" [(expansionStates)]="model.expansionStates">
         * </igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._expansionStates = this.cloneMap(value);
          this.expansionStatesChange.emit(this._expansionStates);

          if (this.gridAPI.grid) {
            this.cdr.detectChanges();
          }
        }
        /**
         * An \@Input property that provides a template for the row loading indicator when load on demand is enabled.
         * ```html
         * <ng-template #rowLoadingTemplate>
         *     <igx-icon fontSet="material">loop</igx-icon>
         * </ng-template>
         *
         * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
         *                [loadChildrenOnDemand]="loadChildren"
         *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
         * </igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */

      }, {
        key: "rowLoadingIndicatorTemplate",
        get: function get() {
          return this._rowLoadingIndicatorTemplate;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._rowLoadingIndicatorTemplate = value;
          this.notifyChanges();
        } // Kind of stupid

        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_gridAPI",
        get: function get() {
          return (
            /** @type {?} */
            this.gridAPI
          );
        }
      }, {
        key: "template",
        get: function get() {
          if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
          }

          if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
          }

          if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
          }
        }
      }]);

      return IgxTreeGridComponent;
    }(IgxGridBaseComponent);

    IgxTreeGridComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-tree-grid',
        template: "<igx-grid-toolbar role=\"rowgroup\" [style.flex-basis.px]='outerWidth' *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]=\"'calcPixelWidth'\" #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)'\n        (wheel)=\"wheelHandler()\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData\n            [igxGridForOf]=\"data\n        | treeGridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:id:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:id:pipeTrigger\n        | treeGridFlattening:id:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:id:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\" let-rowIndex=\"index\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" #row>\n                </igx-tree-grid-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                    [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                    class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onBeforeViewDetach)='viewDetachHandler($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"processedExpandedFlatData.length\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [readonly]=\"true\"\n            disableRipple=\"true\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
        providers: [IgxGridSelectionService, IgxGridCRUDService, IgxGridSummaryService, {
          provide: IgxGridNavigationService,
          useClass: IgxTreeGridNavigationService
        }, {
          provide: GridBaseAPIService,
          useClass: IgxTreeGridAPIService
        }, {
          provide: IgxGridBaseComponent,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxTreeGridComponent;
          })
        }, IgxFilteringService, IgxForOfSyncService, IgxForOfScrollSyncService, IgxRowIslandAPIService]
      }]
    }];
    IgxTreeGridComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      childDataKey: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      foreignKey: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hasChildrenKey: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cascadeOnDelete: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      expansionDepth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      expansionStates: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      expansionStatesChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      rowLoadingTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxRowLoadingIndicatorTemplateDirective, {
          read: IgxRowLoadingIndicatorTemplateDirective,
          "static": false
        }]
      }],
      rowLoadingIndicatorTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      loadChildrenOnDemand: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onRowToggle: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      dragIndicatorIconBase: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['dragIndicatorIconBase', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxTreeGridRowComponent =
    /*#__PURE__*/
    function (_IgxRowComponent2) {
      _inherits(IgxTreeGridRowComponent, _IgxRowComponent2);

      function IgxTreeGridRowComponent() {
        _classCallCheck(this, IgxTreeGridRowComponent);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxTreeGridRowComponent).apply(this, arguments));
      }

      _createClass(IgxTreeGridRowComponent, [{
        key: "resolveClasses",

        /**
         * @hidden
         * @protected
         * @return {?}
         */
        value: function resolveClasses() {
          /** @type {?} */
          var classes = _get(_getPrototypeOf(IgxTreeGridRowComponent.prototype), "resolveClasses", this).call(this);
          /** @type {?} */


          var filteredClass = this.treeRow.isFilteredOutParent ? 'igx-grid__tr--filtered' : '';
          return "".concat(classes, " ").concat(filteredClass);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          this.isLoading = this.grid.loadChildrenOnDemand ? this.grid.loadingRows.has(this.rowID) : false;

          _get(_getPrototypeOf(IgxTreeGridRowComponent.prototype), "ngDoCheck", this).call(this);
        }
      }, {
        key: "treeRow",

        /**
         * The `ITreeGridRecord` passed to the row component.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * const treeRow = row.treeRow;
         * ```
         * @return {?}
         */
        get: function get() {
          return this._treeRow;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (this._treeRow !== value) {
            this._treeRow = value;
            this.rowData = this._treeRow.data;
          }
        }
        /**
         * Returns a value indicating whether the row component is expanded.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * const expanded = row.expanded;
         * ```
         * @return {?}
         */

      }, {
        key: "expanded",
        get: function get() {
          return this._treeRow.expanded;
        }
        /**
         * Sets a value indicating whether the row component is expanded.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * row.expanded = true;
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          /** @type {?} */
          this.gridAPI.trigger_row_expansion_toggle(this._treeRow, value);
        }
        /**
         * @hidden
         * \@internal
         * @return {?}
         */

      }, {
        key: "viewIndex",
        get: function get() {
          return this.index + this.grid.page * this.grid.perPage;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "showIndicator",
        get: function get() {
          return this.grid.loadChildrenOnDemand ? this.grid.expansionStates.has(this.rowID) ? this.treeRow.children && this.treeRow.children.length : this.grid.hasChildrenKey ? this.rowData[this.grid.hasChildrenKey] : true : this.treeRow.children && this.treeRow.children.length;
        }
      }]);

      return IgxTreeGridRowComponent;
    }(IgxRowComponent);

    IgxTreeGridRowComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        selector: 'igx-tree-grid-row',
        template: "<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"pinnedColumns.length > 0\">\n    <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n        <ng-template #cellTemplate>\n            <igx-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width.px]=\"col.width\"\n                [style.flex-basis.px]=\"col.width\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [cellSelectionMode]=\"grid.cellSelection\" #treeCell>\n            </igx-grid-cell>\n            </ng-template>\n        <ng-template #treeCellTemplate>\n            <igx-tree-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [level]=\"treeRow.level\"\n                [expanded]=\"treeRow.expanded\"\n                [showIndicator]=\"showIndicator\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width.px]=\"col.width\"\n                [style.flex-basis.px]=\"col.width\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [isLoading]=\"isLoading\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [cellSelectionMode]=\"grid.cellSelection\"  #treeCell>\n            </igx-tree-grid-cell>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n    </ng-template>\n</ng-container>\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]=\"'calcPixelWidth'\" [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <ng-template #cellTemplate>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [cellSelectionMode]=\"grid.cellSelection\"  #treeCell>\n        </igx-grid-cell>\n    </ng-template>\n    <ng-template #treeCellTemplate>\n        <igx-tree-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [level]=\"treeRow.level\"\n            [expanded]=\"treeRow.expanded\"\n            [showIndicator]=\"showIndicator\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [isLoading]=\"isLoading\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [cellSelectionMode]=\"grid.cellSelection\"  #treeCell>\n        </igx-tree-grid-cell>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n</ng-template>\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n",
        providers: [{
          provide: IgxRowComponent,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxTreeGridRowComponent;
          })
        }]
      }]
    }];
    IgxTreeGridRowComponent.propDecorators = {
      cells: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: ['treeCell']
      }],
      treeRow: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      expanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-expanded']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxTreeGridHierarchizingPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxTreeGridHierarchizingPipe(gridAPI) {
        _classCallCheck(this, IgxTreeGridHierarchizingPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?} primaryKey
       * @param {?} foreignKey
       * @param {?} childDataKey
       * @param {?} id
       * @param {?} pipeTrigger
       * @return {?}
       */


      _createClass(IgxTreeGridHierarchizingPipe, [{
        key: "transform",
        value: function transform(collection, primaryKey, foreignKey, childDataKey, id, pipeTrigger) {
          /** @type {?} */
          var grid = this.gridAPI.grid;
          /** @type {?} */

          var hierarchicalRecords = [];
          /** @type {?} */

          var treeGridRecordsMap = new Map();
          /** @type {?} */

          var flatData = [];

          if (primaryKey && foreignKey) {
            hierarchicalRecords = this.hierarchizeFlatData(id, collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);
          } else if (childDataKey) {
            hierarchicalRecords = this.hierarchizeRecursive(id, collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);
          }

          grid.flatData = flatData;
          grid.records = treeGridRecordsMap;
          grid.rootRecords = hierarchicalRecords;
          return hierarchicalRecords;
        }
        /**
         * @private
         * @param {?} primaryKey
         * @param {?} rowData
         * @return {?}
         */

      }, {
        key: "getRowID",
        value: function getRowID(primaryKey, rowData) {
          return primaryKey ? rowData[primaryKey] : rowData;
        }
        /**
         * @private
         * @param {?} id
         * @param {?} collection
         * @param {?} primaryKey
         * @param {?} foreignKey
         * @param {?} map
         * @param {?} flatData
         * @return {?}
         */

      }, {
        key: "hierarchizeFlatData",
        value: function hierarchizeFlatData(id, collection, primaryKey, foreignKey, map, flatData) {
          var _this315 = this;

          /** @type {?} */
          var result = [];
          /** @type {?} */

          var missingParentRecords = [];
          collection.forEach(function (row) {
            /** @type {?} */
            var record = {
              rowID: _this315.getRowID(primaryKey, row),
              data: row,
              children: []
            };
            /** @type {?} */

            var parent = map.get(row[foreignKey]);

            if (parent) {
              record.parent = parent;
              parent.children.push(record);
            } else {
              missingParentRecords.push(record);
            }

            map.set(row[primaryKey], record);
          });
          missingParentRecords.forEach(function (record) {
            /** @type {?} */
            var parent = map.get(record.data[foreignKey]);

            if (parent) {
              record.parent = parent;
              parent.children.push(record);
            } else {
              result.push(record);
            }
          });
          this.setIndentationLevels(id, result, 0, flatData);
          return result;
        }
        /**
         * @private
         * @param {?} id
         * @param {?} collection
         * @param {?} indentationLevel
         * @param {?} flatData
         * @return {?}
         */

      }, {
        key: "setIndentationLevels",
        value: function setIndentationLevels(id, collection, indentationLevel, flatData) {
          for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var record = collection[i];
            record.level = indentationLevel;
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(record.data);

            if (record.children && record.children.length > 0) {
              this.setIndentationLevels(id, record.children, indentationLevel + 1, flatData);
            }
          }
        }
        /**
         * @private
         * @param {?} id
         * @param {?} collection
         * @param {?} primaryKey
         * @param {?} childDataKey
         * @param {?} parent
         * @param {?} flatData
         * @param {?} indentationLevel
         * @param {?} map
         * @return {?}
         */

      }, {
        key: "hierarchizeRecursive",
        value: function hierarchizeRecursive(id, collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map) {
          /** @type {?} */
          var result = [];

          for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var item = collection[i];
            /** @type {?} */

            var record = {
              rowID: this.getRowID(primaryKey, item),
              data: item,
              parent: parent,
              level: indentationLevel
            };
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(item);
            map.set(record.rowID, record);
            record.children = item[childDataKey] ? this.hierarchizeRecursive(id, item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map) : undefined;
            result.push(record);
          }

          return result;
        }
      }]);

      return IgxTreeGridHierarchizingPipe;
    }();

    IgxTreeGridHierarchizingPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'treeGridHierarchizing',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxTreeGridHierarchizingPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @hidden
     */


    var IgxTreeGridFlatteningPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxTreeGridFlatteningPipe(gridAPI) {
        _classCallCheck(this, IgxTreeGridFlatteningPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?} id
       * @param {?} expandedLevels
       * @param {?} expandedStates
       * @param {?} pipeTrigger
       * @return {?}
       */


      _createClass(IgxTreeGridFlatteningPipe, [{
        key: "transform",
        value: function transform(collection, id, expandedLevels, expandedStates, pipeTrigger) {
          /** @type {?} */
          var grid = this.gridAPI.grid;
          /** @type {?} */

          var data = [];
          grid.processedRootRecords = collection;
          grid.processedRecords = new Map();
          this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, id, true);
          grid.processedExpandedFlatData = data.map(function (r) {
            return r.data;
          });
          return data;
        }
        /**
         * @private
         * @param {?} collection
         * @param {?} data
         * @param {?} expandedLevels
         * @param {?} expandedStates
         * @param {?} gridID
         * @param {?} parentExpanded
         * @return {?}
         */

      }, {
        key: "getFlatDataRecursive",
        value: function getFlatDataRecursive(collection, data, expandedLevels, expandedStates, gridID, parentExpanded) {
          if (!collection || !collection.length) {
            return;
          }
          /** @type {?} */


          var grid = this.gridAPI.grid;

          for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var hierarchicalRecord = collection[i];

            if (parentExpanded) {
              data.push(hierarchicalRecord);
            }

            hierarchicalRecord.expanded = this.gridAPI.get_row_expansion_state(hierarchicalRecord);
            this.updateNonProcessedRecordExpansion(grid, hierarchicalRecord);
            grid.processedRecords.set(hierarchicalRecord.rowID, hierarchicalRecord);
            this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, gridID, parentExpanded && hierarchicalRecord.expanded);
          }
        }
        /**
         * @private
         * @param {?} grid
         * @param {?} record
         * @return {?}
         */

      }, {
        key: "updateNonProcessedRecordExpansion",
        value: function updateNonProcessedRecordExpansion(grid, record) {
          /** @type {?} */
          var rec = grid.records.get(record.rowID);
          rec.expanded = record.expanded;
        }
      }]);

      return IgxTreeGridFlatteningPipe;
    }();

    IgxTreeGridFlatteningPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'treeGridFlattening',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxTreeGridFlatteningPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @hidden
     */


    var IgxTreeGridSortingPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxTreeGridSortingPipe(gridAPI) {
        _classCallCheck(this, IgxTreeGridSortingPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} hierarchicalData
       * @param {?} expressions
       * @param {?} id
       * @param {?} pipeTrigger
       * @return {?}
       */


      _createClass(IgxTreeGridSortingPipe, [{
        key: "transform",
        value: function transform(hierarchicalData, expressions, id, pipeTrigger) {
          /** @type {?} */
          var grid = this.gridAPI.grid;
          /** @type {?} */

          var result;

          if (!expressions.length) {
            result = hierarchicalData;
          } else {
            result = DataUtil.treeGridSort(hierarchicalData, expressions);
          }
          /** @type {?} */


          var filteredSortedData = [];
          this.flattenTreeGridRecords(result, filteredSortedData);
          grid.filteredSortedData = filteredSortedData;
          return result;
        }
        /**
         * @private
         * @param {?} records
         * @param {?} flatData
         * @return {?}
         */

      }, {
        key: "flattenTreeGridRecords",
        value: function flattenTreeGridRecords(records, flatData) {
          if (records && records.length) {
            var _iteratorNormalCompletion64 = true;
            var _didIteratorError64 = false;
            var _iteratorError64 = undefined;

            try {
              for (var _iterator64 = records[Symbol.iterator](), _step64; !(_iteratorNormalCompletion64 = (_step64 = _iterator64.next()).done); _iteratorNormalCompletion64 = true) {
                var record = _step64.value;
                flatData.push(record.data);
                this.flattenTreeGridRecords(record.children, flatData);
              }
            } catch (err) {
              _didIteratorError64 = true;
              _iteratorError64 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion64 && _iterator64["return"] != null) {
                  _iterator64["return"]();
                }
              } finally {
                if (_didIteratorError64) {
                  throw _iteratorError64;
                }
              }
            }
          }
        }
      }]);

      return IgxTreeGridSortingPipe;
    }();

    IgxTreeGridSortingPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'treeGridSorting',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxTreeGridSortingPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @hidden
     */


    var IgxTreeGridPagingPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxTreeGridPagingPipe(gridAPI) {
        _classCallCheck(this, IgxTreeGridPagingPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?=} page
       * @param {?=} perPage
       * @param {?=} id
       * @param {?=} pipeTrigger
       * @return {?}
       */


      _createClass(IgxTreeGridPagingPipe, [{
        key: "transform",
        value: function transform(collection) {
          var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var perPage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 15;
          var id = arguments.length > 3 ? arguments[3] : undefined;
          var pipeTrigger = arguments.length > 4 ? arguments[4] : undefined;

          /** @type {?} */
          var grid = this.gridAPI.grid;

          if (!grid.paging) {
            return collection;
          }
          /** @type {?} */


          var len = collection.length;
          /** @type {?} */

          var totalPages = Math.ceil(len / perPage);
          /** @type {?} */

          var state = {
            index: totalPages > 0 && page >= totalPages ? totalPages - 1 : page,
            recordsPerPage: perPage
          };
          /** @type {?} */

          var result = DataUtil.page(cloneArray(collection), state);
          grid.pagingState = state;

          /** @type {?} */
          grid._page = state.index;
          return result;
        }
      }]);

      return IgxTreeGridPagingPipe;
    }();

    IgxTreeGridPagingPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'treeGridPaging',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxTreeGridPagingPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @hidden
     */


    var IgxTreeGridTransactionPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxTreeGridTransactionPipe(gridAPI) {
        _classCallCheck(this, IgxTreeGridTransactionPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?} id
       * @param {?} pipeTrigger
       * @return {?}
       */


      _createClass(IgxTreeGridTransactionPipe, [{
        key: "transform",
        value: function transform(collection, id, pipeTrigger) {
          /** @type {?} */
          var grid = this.gridAPI.grid;

          if (grid.transactions.enabled) {
            /** @type {?} */
            var aggregatedChanges = grid.transactions.getAggregatedChanges(true);

            if (aggregatedChanges.length > 0) {
              /** @type {?} */
              var primaryKey = grid.primaryKey;

              if (!primaryKey) {
                return collection;
              }
              /** @type {?} */


              var foreignKey = grid.foreignKey;
              /** @type {?} */

              var childDataKey = grid.childDataKey;

              if (foreignKey) {
                /** @type {?} */
                var flatDataClone = cloneArray(collection);
                return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, grid.primaryKey);
              } else if (childDataKey) {
                /** @type {?} */
                var hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);
                return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, grid.primaryKey);
              }
            }
          }

          return collection;
        }
      }]);

      return IgxTreeGridTransactionPipe;
    }();

    IgxTreeGridTransactionPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'treeGridTransaction',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxTreeGridTransactionPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxTreeGridCellComponent =
    /*#__PURE__*/
    function (_IgxGridCellComponent) {
      _inherits(IgxTreeGridCellComponent, _IgxGridCellComponent);

      /**
       * @param {?} selectionService
       * @param {?} crudService
       * @param {?} gridAPI
       * @param {?} cdr
       * @param {?} element
       * @param {?} zone
       * @param {?} touchManager
       * @param {?} document
       * @param {?} platformUtil
       */
      function IgxTreeGridCellComponent(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
        var _this316;

        _classCallCheck(this, IgxTreeGridCellComponent);

        _this316 = _possibleConstructorReturn(this, _getPrototypeOf(IgxTreeGridCellComponent).call(this, selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil));
        _this316.zone = zone;
        _this316.document = document;
        _this316.platformUtil = platformUtil;
        /**
         * @hidden
         */

        _this316.expanded = false;
        /**
         * @hidden
         */

        _this316.level = 0;
        /**
         * @hidden
         */

        _this316.showIndicator = false;
        _this316.treeGridAPI =
        /** @type {?} */
        gridAPI;
        return _this316;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxTreeGridCellComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          _get(_getPrototypeOf(IgxTreeGridCellComponent.prototype), "ngOnInit", this).call(this);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle(event) {
          event.stopPropagation();
          this.treeGridAPI.trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onIndicatorFocus",
        value: function onIndicatorFocus() {
          this.gridAPI.submit_value();
          this.nativeElement.focus();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onLoadingDblClick",
        value: function onLoadingDblClick(event) {
          event.stopPropagation();
        }
        /**
         * @hidden
         * @param {?} range
         * @return {?}
         */

      }, {
        key: "calculateSizeToFit",
        value: function calculateSizeToFit(range) {
          /** @type {?} */
          var indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
          /** @type {?} */

          var indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
          /** @type {?} */

          var indicatorMargin = parseFloat(indicatorStyle.marginRight);
          /** @type {?} */

          var leftPadding = 0;

          if (this.indentationDiv) {
            /** @type {?} */
            var indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
          }
          /** @type {?} */


          var largestWidth = Math.max.apply(Math, _toConsumableArray(Array.from(this.nativeElement.children).map(function (child) {
            return getNodeSizeViaRange(range, child);
          })));
          return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "iconTemplate",
        get: function get() {
          if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
          } else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
          }
        }
      }]);

      return IgxTreeGridCellComponent;
    }(IgxGridCellComponent);

    IgxTreeGridCellComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        selector: 'igx-tree-grid-cell',
        template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <ng-container *ngIf=\"level > 0\">\n        <div #indentationDiv class=\"igx-grid__tree-cell--padding-level-{{level}}\"></div>\n    </ng-container>\n    <div #indicator\n         *ngIf=\"!isLoading\"\n         class=\"igx-grid__tree-grouping-indicator\"\n         [ngStyle]=\"{'visibility': showIndicator ? 'visible' : 'hidden'}\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\" tabindex=\"-1\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n    <div *ngIf=\"isLoading\"\n         (dblclick)=\"onLoadingDblClick($event)\"\n         class=\"igx-grid__tree-loading-indicator\">\n        <ng-container *ngTemplateOutlet=\"grid.rowLoadingIndicatorTemplate ? grid.rowLoadingIndicatorTemplate : defaultLoadingIndicatorTemplate\">\n        </ng-container>\n    </div>\n    <ng-template #defaultLoadingIndicatorTemplate>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </ng-template>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
        providers: [HammerGesturesManager]
      }]
    }];
    /** @nocollapse */

    IgxTreeGridCellComponent.ctorParameters = function () {
      return [{
        type: IgxGridSelectionService
      }, {
        type: IgxGridCRUDService
      }, {
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: HammerGesturesManager
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
        }]
      }, {
        type: PlatformUtil
      }];
    };

    IgxTreeGridCellComponent.propDecorators = {
      expanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      level: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      showIndicator: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      indicator: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['indicator', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      indentationDiv: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['indentationDiv', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      defaultContentElement: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultContentElement', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      defaultExpandedTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultExpandedTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultCollapsedTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultCollapsedTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      isLoading: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxTreeGridSummaryPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxTreeGridSummaryPipe(gridAPI) {
        _classCallCheck(this, IgxTreeGridSummaryPipe);

        this.gridAPI =
        /** @type {?} */
        gridAPI;
      }
      /**
       * @param {?} flatData
       * @param {?} hasSummary
       * @param {?} summaryCalculationMode
       * @param {?} summaryPosition
       * @param {?} id
       * @param {?} pipeTrigger
       * @param {?} summaryPipeTrigger
       * @return {?}
       */


      _createClass(IgxTreeGridSummaryPipe, [{
        key: "transform",
        value: function transform(flatData, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
          /** @type {?} */
          var grid = this.gridAPI.grid;

          if (!flatData || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return flatData;
          }

          return this.addSummaryRows(grid, flatData, summaryPosition);
        }
        /**
         * @private
         * @param {?} grid
         * @param {?} collection
         * @param {?} summaryPosition
         * @return {?}
         */

      }, {
        key: "addSummaryRows",
        value: function addSummaryRows(grid, collection, summaryPosition) {
          /** @type {?} */
          var recordsWithSummary = [];
          /** @type {?} */

          var maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();

          for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var record = collection[i];
            recordsWithSummary.push(record);
            /** @type {?} */

            var isExpanded = record.children && record.children.length > 0 && record.expanded;

            if (summaryPosition === GridSummaryPosition.bottom && !isExpanded) {
              /** @type {?} */
              var childRecord = record;
              /** @type {?} */

              var parent = record.parent;

              while (parent) {
                /** @type {?} */
                var children = parent.children;

                if (children[children.length - 1] === childRecord) {
                  /** @type {?} */
                  var childData = children.filter(function (r) {
                    return !r.isFilteredOutParent;
                  }).map(function (r) {
                    return r.data;
                  });
                  childData = this.removeDeletedRecord(grid, parent.rowID, childData);
                  /** @type {?} */

                  var summaries = grid.summaryService.calculateSummaries(parent.rowID, childData);
                  /** @type {?} */

                  var summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight,
                    cellIndentation: parent.level + 1
                  };
                  recordsWithSummary.push(summaryRecord);
                  childRecord = parent;
                  parent = childRecord.parent;
                } else {
                  break;
                }
              }
            } else if (summaryPosition === GridSummaryPosition.top && isExpanded) {
              /** @type {?} */
              var _childData = record.children.filter(function (r) {
                return !r.isFilteredOutParent;
              }).map(function (r) {
                return r.data;
              });

              _childData = this.removeDeletedRecord(grid, record.rowID, _childData);
              /** @type {?} */

              var _summaries3 = grid.summaryService.calculateSummaries(record.rowID, _childData);
              /** @type {?} */


              var _summaryRecord2 = {
                summaries: _summaries3,
                max: maxSummaryHeight,
                cellIndentation: record.level + 1
              };
              recordsWithSummary.push(_summaryRecord2);
            }
          }

          return recordsWithSummary;
        }
        /**
         * @private
         * @param {?} grid
         * @param {?} rowId
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "removeDeletedRecord",
        value: function removeDeletedRecord(grid, rowId, data) {
          if (!grid.transactions.enabled || !grid.cascadeOnDelete) {
            return data;
          }
          /** @type {?} */


          var deletedRows = grid.transactions.getTransactionLog().filter(function (t) {
            return t.type === 'delete';
          }).map(function (t) {
            return t.id;
          });
          /** @type {?} */

          var row = grid.records.get(rowId);

          if (!row && deletedRows.lenght === 0) {
            return [];
          }

          row = row.children ? row : row.parent;

          while (row) {
            rowId = row.rowID;

            if (deletedRows.indexOf(rowId) !== -1) {
              return [];
            }

            row = row.parent;
          }

          deletedRows.forEach(function (rowID) {
            /** @type {?} */
            var tempData = grid.primaryKey ? data.map(function (rec) {
              return rec[grid.primaryKey];
            }) : data;
            /** @type {?} */

            var index = tempData.indexOf(rowID);

            if (index !== -1) {
              data.splice(index, 1);
            }
          });
          return data;
        }
      }]);

      return IgxTreeGridSummaryPipe;
    }();

    IgxTreeGridSummaryPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'treeGridSummary',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxTreeGridSummaryPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var IgxTreeGridModule = function IgxTreeGridModule() {
      _classCallCheck(this, IgxTreeGridModule);
    };

    IgxTreeGridModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxTreeGridComponent, IgxTreeGridRowComponent, IgxTreeGridCellComponent, IgxTreeGridHierarchizingPipe, IgxTreeGridFlatteningPipe, IgxTreeGridSortingPipe, IgxTreeGridFilteringPipe, IgxTreeGridPagingPipe, IgxTreeGridTransactionPipe, IgxTreeGridSummaryPipe, IgxRowLoadingIndicatorTemplateDirective],
        exports: [IgxTreeGridComponent, IgxTreeGridRowComponent, IgxTreeGridCellComponent, IgxRowLoadingIndicatorTemplateDirective, IgxGridCommonModule],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], IgxChipsModule, IgxGridCommonModule, IgxSelectModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxHierarchicalGridNavigationService =
    /*#__PURE__*/
    function (_IgxGridNavigationSer3) {
      _inherits(IgxHierarchicalGridNavigationService, _IgxGridNavigationSer3);

      function IgxHierarchicalGridNavigationService() {
        _classCallCheck(this, IgxHierarchicalGridNavigationService);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxHierarchicalGridNavigationService).apply(this, arguments));
      }

      _createClass(IgxHierarchicalGridNavigationService, [{
        key: "getCellSelector",

        /**
         * @protected
         * @param {?=} visibleIndex
         * @param {?=} isSummary
         * @return {?}
         */
        value: function getCellSelector(visibleIndex) {
          var isSummary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return isSummary ? 'igx-grid-summary-cell' : 'igx-hierarchical-grid-cell';
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "getRowSelector",
        value: function getRowSelector() {
          return 'igx-hierarchical-grid-row';
        }
        /**
         * @protected
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "getRowByIndex",
        value: function getRowByIndex(index) {
          var _this317 = this;

          /** @type {?} */
          var selector = this.getRowSelector();
          /** @type {?} */

          var rows = Array.from(this.grid.nativeElement.querySelectorAll("".concat(selector, "[data-rowindex=\"").concat(index, "\"]")));
          /** @type {?} */

          var row;
          rows.forEach(function (r) {
            /** @type {?} */
            var parentGrid = _this317.getClosestElemByTag(r, 'igx-hierarchical-grid');

            if (parentGrid && parentGrid.getAttribute('id') === _this317.grid.id) {
              row = r;
            }
          });
          return row;
        }
        /**
         * @private
         * @param {?=} grid
         * @return {?}
         */

      }, {
        key: "getChildContainer",
        value: function getChildContainer(grid) {
          /** @type {?} */
          var currGrid = grid || this.grid;
          return currGrid.nativeElement.parentNode.parentNode.parentNode;
        }
        /**
         * @private
         * @param {?=} grid
         * @return {?}
         */

      }, {
        key: "getChildGridRowContainer",
        value: function getChildGridRowContainer(grid) {
          /** @type {?} */
          var currGrid = grid || this.grid;
          return currGrid.nativeElement.parentNode.parentNode;
        }
        /**
         * @private
         * @param {?} childGridID
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "getChildGrid",
        value: function getChildGrid(childGridID, grid) {
          /** @type {?} */
          var cgrid = grid.hgridAPI.getChildGrids(true).filter(function (g) {
            return g.id === childGridID;
          })[0];
          return cgrid;
        }
        /**
         * @private
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "_isScrolledToBottom",
        value: function _isScrolledToBottom(grid) {
          /** @type {?} */
          var scrollTop = grid.verticalScrollContainer.scrollPosition;
          /** @type {?} */

          var scrollHeight = grid.verticalScrollContainer.getScroll().scrollHeight;
          return scrollHeight === 0 || Math.round(scrollTop + grid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        /**
         * @private
         * @param {?} index
         * @return {?}
         */

      }, {
        key: "getIsChildAtIndex",
        value: function getIsChildAtIndex(index) {
          return this.grid.isChildGridRecord(this.grid.dataView[index]);
        }
        /**
         * @param {?} rowIndex
         * @param {?} visibleColumnIndex
         * @param {?=} isSummary
         * @return {?}
         */

      }, {
        key: "getCellElementByVisibleIndex",
        value: function getCellElementByVisibleIndex(rowIndex, visibleColumnIndex) {
          var isSummary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          /** @type {?} */
          var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);

          if (isSummary) {
            /** @type {?} */
            var summaryRow = this.grid.summariesRowList.toArray()[0].nativeElement;
            return summaryRow.querySelector("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));
          }
          /** @type {?} */


          var row = this.getRowByIndex(rowIndex);
          return row.querySelector("".concat(cellSelector, "[data-rowindex=\"").concat(rowIndex, "\"][data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));
        }
        /**
         * @param {?} rowElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "navigateUp",
        value: function navigateUp(rowElement, selectedNode) {
          var _this318 = this;

          if (selectedNode.isSummaryRow) {
            return;
          }
          /** @type {?} */


          var prevElem = rowElement.previousElementSibling;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;
          /** @type {?} */

          var currentRowIndex = selectedNode.row;

          if (prevElem) {
            /** @type {?} */
            var nodeName = prevElem.children[0].nodeName.toLowerCase();
            /** @type {?} */

            var isElemChildGrid = nodeName.toLowerCase() === 'igx-child-grid-row';

            if (isElemChildGrid) {
              this.focusPrevChild(prevElem, visibleColumnIndex, this.grid);
            } else {
              if (this.grid.parent !== null) {
                // currently navigating in child grid
                this._navigateUpInChild(rowElement, currentRowIndex, visibleColumnIndex);
              } else {
                _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateUp", this).call(this, rowElement, selectedNode);
              }
            }
          } else if (currentRowIndex !== 0) {
            // handle scenario when prev item is child grid but is not yet in view

            /** @type {?} */
            var isPrevChildGrid = this.getIsChildAtIndex(currentRowIndex - 1);

            if (!isPrevChildGrid) {
              _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateUp", this).call(this, rowElement, selectedNode);
            } else {
              this.scrollGrid(this.grid, -rowElement.offsetHeight, function () {
                rowElement = _this318.getRowByIndex(currentRowIndex);

                _this318.navigateUp(rowElement, selectedNode);
              });
            }
          } else if (this.grid.parent !== null && currentRowIndex === 0) {
            // move to prev row in sibling layout or parent
            this.focusPrev(visibleColumnIndex);
          }
        }
        /**
         * @param {?} rowElement
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "navigateDown",
        value: function navigateDown(rowElement, selectedNode) {
          if (selectedNode.isSummaryRow) {
            return;
          }
          /** @type {?} */


          var nextElem = rowElement.nextElementSibling;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;
          /** @type {?} */

          var currentRowIndex = selectedNode.row;

          if (nextElem) {
            // next elem is in DOM

            /** @type {?} */
            var nodeName = nextElem.children[0].nodeName.toLowerCase();
            /** @type {?} */

            var isNextElemChildGrid = nodeName.toLowerCase() === 'igx-child-grid-row';

            if (isNextElemChildGrid) {
              this.focusNextChild(nextElem, visibleColumnIndex, this.grid);
            } else {
              if (this.grid.parent !== null) {
                // currently navigating in child grid
                this._navigateDownInChild(rowElement, currentRowIndex, visibleColumnIndex);
              } else {
                _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateDown", this).call(this, rowElement, selectedNode);
              }
            }
          } else if (currentRowIndex !== this.grid.dataView.length - 1) {
            // scroll next in view
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateDown", this).call(this, rowElement, selectedNode);
          } else if (this.grid.parent !== null && currentRowIndex === this.grid.dataView.length - 1) {
            // move to next row in sibling layout or in parent
            this.focusNext(visibleColumnIndex);
          }
        }
        /**
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "navigateTop",
        value: function navigateTop(visibleColumnIndex) {
          var _this319 = this;

          if (this.grid.parent !== null) {
            // navigating in child

            /** @type {?} */
            var childContainer = this.grid.nativeElement.parentNode.parentNode;
            /** @type {?} */

            var diff = childContainer.getBoundingClientRect().top - this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top;
            /** @type {?} */

            var topIsVisible = diff >= 0;
            /** @type {?} */

            var scrollable = this.getNextScrollable(this.grid);

            if (!topIsVisible) {
              this.scrollGrid(scrollable.grid, diff, function () {
                return _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateTop", _this319).call(_this319, visibleColumnIndex);
              });
            } else {
              _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateTop", this).call(this, visibleColumnIndex);
            }
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateTop", this).call(this, visibleColumnIndex);
          }
        }
        /**
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "navigateBottom",
        value: function navigateBottom(visibleColumnIndex) {
          var _this320 = this;

          // handle scenario where last index is child grid
          // in that case focus cell in last data row

          /** @type {?} */
          var lastIndex = this.grid.dataView.length - 1;

          if (this.getIsChildAtIndex(lastIndex)) {
            /** @type {?} */
            var targetIndex = lastIndex - 1;
            /** @type {?} */

            var scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, true);
            /** @type {?} */

            var verticalScrollTop = this.grid.verticalScrollContainer.scrollPosition;
            /** @type {?} */

            var cellSelector = this.getCellSelector(visibleColumnIndex);

            if (verticalScrollTop === scrTopPosition) {
              /** @type {?} */
              var cells = this.getRowByIndex(targetIndex).querySelectorAll("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));
              cells[cells.length - 1].focus();
            } else {
              this.scrollGrid(this.grid, scrTopPosition - verticalScrollTop, function () {
                /** @type {?} */
                var cells = _this320.getRowByIndex(targetIndex).querySelectorAll("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));

                if (cells.length > 0) {
                  cells[cells.length - 1].focus();
                }
              });
            }
          } else if (this.grid.parent !== null) {
            /** @type {?} */
            var childContainer = this.grid.nativeElement.parentNode.parentNode;
            /** @type {?} */

            var diff = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */

            var endIsVisible = diff < 0;
            /** @type {?} */

            var scrollable = this.getNextScrollableDown(this.grid);

            if (!endIsVisible) {
              this.scrollGrid(scrollable.grid, diff, function () {
                return _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateBottom", _this320).call(_this320, visibleColumnIndex);
              });
            } else {
              _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateBottom", this).call(this, visibleColumnIndex);
            }
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateBottom", this).call(this, visibleColumnIndex);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "goToLastCell",
        value: function goToLastCell() {
          var _this321 = this;

          // handle scenario where last index is child grid
          // in that case focus last cell in last data row

          /** @type {?} */
          var lastIndex = this.grid.dataView.length - 1;

          if (this.getIsChildAtIndex(lastIndex)) {
            /** @type {?} */
            var targetIndex = lastIndex - 1;
            /** @type {?} */

            var scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, true);
            /** @type {?} */

            var verticalScrollTop = this.grid.verticalScrollContainer.scrollPosition;

            if (verticalScrollTop === scrTopPosition) {
              this.onKeydownEnd(targetIndex);
            } else {
              this.scrollGrid(this.grid, scrTopPosition - verticalScrollTop, function () {
                _this321.onKeydownEnd(targetIndex);
              });
            }
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "goToLastCell", this).call(this);
          }
        }
        /**
         * @param {?} rowIndex
         * @param {?=} isSummary
         * @return {?}
         */

      }, {
        key: "onKeydownEnd",
        value: function onKeydownEnd(rowIndex) {
          var _this322 = this;

          var isSummary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (this.grid.parent && !isSummary) {
            // handle scenario where last child row might not be in view
            // parent should scroll to child grid end

            /** @type {?} */
            var childContainer = this.grid.nativeElement.parentNode.parentNode;
            /** @type {?} */

            var diffBottom = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */

            var row = this.grid.getRowByIndex(rowIndex).element.nativeElement;
            /** @type {?} */

            var rowBottom = row.getBoundingClientRect().bottom;
            /** @type {?} */

            var rowIsVisible = rowBottom <= this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */

            var gridTop = this._getMaxTop(this.grid);
            /** @type {?} */


            var diffTop = row.getBoundingClientRect().bottom - row.offsetHeight - gridTop;
            /** @type {?} */

            var endIsVisible = diffBottom <= 0;
            /** @type {?} */

            var topVisible = diffTop >= 0;

            if (!endIsVisible && !rowIsVisible) {
              this.scrollGrid(this.grid.parent, diffBottom, function () {
                return _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "onKeydownEnd", _this322).call(_this322, rowIndex);
              });
            } else if (!topVisible) {
              /** @type {?} */
              var scrGrid = this.grid.verticalScrollContainer.scrollPosition !== 0 ? this.grid : this.getNextScrollable(this.grid).grid;
              /** @type {?} */

              var topGrid = scrGrid.tbody.nativeElement.getBoundingClientRect().top > this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top ? scrGrid : this.grid.rootGrid;
              this.scrollGrid(topGrid, diffTop, function () {
                return _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "onKeydownEnd", _this322).call(_this322, rowIndex);
              });
            } else {
              _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "onKeydownEnd", this).call(this, rowIndex, isSummary);
            }
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "onKeydownEnd", this).call(this, rowIndex, isSummary);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "goToFirstCell",
        value: function goToFirstCell() {
          var _this323 = this;

          /** @type {?} */
          var verticalScroll = this.grid.verticalScrollContainer.getScroll();
          /** @type {?} */

          var horizontalScroll = this.grid.dataRowList.first.virtDirRow.getScroll();

          if (verticalScroll.scrollTop === 0 && this.grid.parent) {
            // scroll parent so that current child is in view
            if (!horizontalScroll.clientWidth || parseInt(horizontalScroll.scrollLeft, 10) <= 1 || this.grid.pinnedColumns.length) {
              this.navigateTop(0);
            } else {
              this.horizontalScroll(this.grid.dataRowList.first.index).scrollTo(0);
              this.grid.parentVirtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(function () {
                _this323.navigateTop(0);
              });
            }
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "goToFirstCell", this).call(this);
          }
        }
        /**
         * @param {?} currentRowEl
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "performTab",
        value: function performTab(currentRowEl, selectedNode) {
          var _this324 = this;

          if (this.grid.rowInEditMode) {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "performTab", this).call(this, currentRowEl, selectedNode);

            return;
          }
          /** @type {?} */


          var rowIndex = selectedNode.row;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;
          /** @type {?} */

          var isSummaryRow = selectedNode.isSummaryRow;
          /** @type {?} */

          var summaryRows = this.grid.summariesRowList.toArray();
          /** @type {?} */

          var hasSummaries = summaryRows.length > 0;
          /** @type {?} */

          var isLastDataRow = rowIndex === this.grid.dataView.length - 1;
          /** @type {?} */

          var nextIsDataRow = this.grid.dataRowList.find(function (row) {
            return row.index === rowIndex + 1;
          });
          /** @type {?} */

          var isLastColumn = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex;
          /** @type {?} */

          var isLastSummaryRow = hasSummaries && isSummaryRow;
          /** @type {?} */

          var nextIndex = rowIndex + 1;
          /** @type {?} */

          var virt = this.grid.verticalScrollContainer;
          /** @type {?} */

          var isNextChild = nextIndex <= virt.igxForOf.length - 1 && this.grid.isChildGridRecord(virt.igxForOf[nextIndex]);

          if (!nextIsDataRow && !(isLastDataRow && hasSummaries) && isLastColumn && !isSummaryRow) {
            // navigating in child, next is not summary

            /** @type {?} */
            var childContainer = this.getChildGridRowContainer();
            /** @type {?} */

            var nextIsSiblingChild = this.grid.parent ? !!childContainer.nextElementSibling : false;

            if (nextIsSiblingChild) {
              this.focusNextChildDOMElem(childContainer, this.grid.parent);
            } else if (isNextChild) {
              /** @type {?} */
              var isInView = virt.state.startIndex + virt.state.chunkSize > nextIndex;

              if (!isInView) {
                this.scrollGrid(this.grid, 'next', function () {
                  _this324.focusNextChildDOMElem(currentRowEl, _this324.grid);
                });
              } else {
                this.focusNextChildDOMElem(currentRowEl, this.grid);
              }
            } else if (this.grid.parent && this.grid.parent.summariesRowList.length > 0) {
              this._navigateToNextParentRow(currentRowEl);
            } else {
              this.navigateDown(currentRowEl, {
                row: rowIndex,
                column: 0
              });
            }
          } else if (isLastSummaryRow && isLastColumn && this.grid.parent) {
            this._navigateToNextParentRow(currentRowEl);
          } else if (isLastDataRow && hasSummaries && isLastColumn && this.grid.parent) {
            // navigating in child rows, next is child grid's summary row
            this.focusNextRow(summaryRows[0].nativeElement, 0, this.grid.parent, true);
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "performTab", this).call(this, currentRowEl, selectedNode);
          }
        }
        /**
         * @private
         * @param {?} currentRowEl
         * @return {?}
         */

      }, {
        key: "_navigateToNextParentRow",
        value: function _navigateToNextParentRow(currentRowEl) {
          // next is parent summary or next parent row

          /** @type {?} */
          var parent = this.grid.parent;
          /** @type {?} */

          var parentHasSummary = parent.summariesRowList.length > 0;
          /** @type {?} */

          var parentRowIndex = parseInt(this.getClosestElemByTag(currentRowEl, 'igx-child-grid-row').parentNode.getAttribute('data-rowindex'), 10);
          /** @type {?} */

          var isLastRowInParent = parent.dataView.length - 1 === parentRowIndex; // check if next is sibling

          /** @type {?} */

          var childRowContainer = this.getChildGridRowContainer(this.grid);
          /** @type {?} */

          var nextIsSiblingChild = !!childRowContainer.nextElementSibling;

          if (isLastRowInParent && parentHasSummary && !nextIsSiblingChild) {
            // next is parent summary

            /** @type {?} */
            var parentSummary = parent.summariesRowList.first.nativeElement;
            parent.navigation.focusNextRow(parentSummary, 0, parent, true);
          } else {
            // next is sibling or parent
            this.focusNext(0);
          }
        }
        /**
         * @private
         * @param {?} currentRowEl
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "focusNextChildDOMElem",
        value: function focusNextChildDOMElem(currentRowEl, grid) {
          /** @type {?} */
          var gridElem = currentRowEl.nextElementSibling.querySelector('igx-hierarchical-grid');
          /** @type {?} */

          var childGridID = gridElem.getAttribute('id');
          /** @type {?} */

          var childGrid = this.getChildGrid(childGridID, grid);

          if (childGrid.allowFiltering && childGrid.filterMode === FilterMode.quickFilter) {
            childGrid.navigation.moveFocusToFilterCell(true);
            return;
          }

          this.focusNextChild(currentRowEl.nextElementSibling, 0, grid);
        }
        /**
         * @param {?} column
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "navigatePrevFilterCell",
        value: function navigatePrevFilterCell(column, eventArgs) {
          if (column.visibleIndex === 0 && this.grid.parent) {
            eventArgs.preventDefault();
            /** @type {?} */

            var targetGrid = this.grid.parent;
            /** @type {?} */

            var prevSiblingChild = this.getChildGridRowContainer().previousElementSibling;

            if (prevSiblingChild) {
              /** @type {?} */
              var gridElem = prevSiblingChild.querySelectorAll('igx-hierarchical-grid')[0];
              targetGrid = this.getChildGrid(gridElem.getAttribute('id'), this.grid.parent);
            }

            this.focusPrev(targetGrid.unpinnedColumns[targetGrid.unpinnedColumns.length - 1].visibleIndex);
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigatePrevFilterCell", this).call(this, column, eventArgs);
          }
        }
        /**
         * @param {?} column
         * @param {?} eventArgs
         * @return {?}
         */

      }, {
        key: "navigateNextFilterCell",
        value: function navigateNextFilterCell(column, eventArgs) {
          /** @type {?} */
          var cols = this.grid.filteringService.unpinnedFilterableColumns;
          /** @type {?} */

          var nextFilterableIndex = cols.indexOf(column) + 1;

          if (nextFilterableIndex >= this.grid.filteringService.unpinnedFilterableColumns.length) {
            // next is not filter cell

            /** @type {?} */
            var dataRows = this.grid.rowList.toArray();
            /** @type {?} */

            var hasRows = dataRows.length !== 0;
            /** @type {?} */

            var summaryRows = this.grid.summariesRowList.toArray();
            /** @type {?} */

            var hasSummaries = summaryRows.length > 0 && summaryRows[0].summaryCells.length > 0;

            if (hasRows) {
              this.focusNextRow(dataRows[0].nativeElement, 0, this.grid, false);
            } else if (hasSummaries) {
              this.focusNextRow(summaryRows[0].nativeElement, 0, this.grid, true);
            } else {
              this.focusNext(0);
            }

            eventArgs.preventDefault();
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateNextFilterCell", this).call(this, column, eventArgs);
          }
        }
        /**
         * @param {?} currentRowEl
         * @param {?} selectedNode
         * @return {?}
         */

      }, {
        key: "performShiftTabKey",
        value: function performShiftTabKey(currentRowEl, selectedNode) {
          var _this325 = this;

          if (this.grid.rowInEditMode) {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "performShiftTabKey", this).call(this, currentRowEl, selectedNode);

            return;
          }
          /** @type {?} */


          var rowIndex = selectedNode.row;
          /** @type {?} */

          var visibleColumnIndex = selectedNode.column;
          /** @type {?} */

          var isSummary = selectedNode.isSummaryRow;

          if (visibleColumnIndex === 0 && rowIndex === 0 && this.grid.parent && !isSummary) {
            if (this.grid.allowFiltering && this.grid.filterMode === FilterMode.quickFilter) {
              this.moveFocusToFilterCell();
            } else {
              /** @type {?} */
              var prevSiblingChild = this.getChildGridRowContainer().previousElementSibling;

              if (prevSiblingChild) {
                /** @type {?} */
                var gridElem = prevSiblingChild.querySelectorAll('igx-hierarchical-grid')[0];
                this.performShiftTabIntoChild(gridElem, currentRowEl, rowIndex);
              } else {
                /** @type {?} */
                var selNode = {
                  row: rowIndex,
                  column: this.grid.parent.unpinnedColumns[this.grid.parent.unpinnedColumns.length - 1].visibleIndex
                };
                this.navigateUp(currentRowEl, selNode);
              }
            }
          } else if (visibleColumnIndex === 0 && currentRowEl.previousElementSibling && currentRowEl.previousElementSibling.children[0].tagName.toLowerCase() === 'igx-child-grid-row') {
            /** @type {?} */
            var _gridElem = this.getLastGridElem(currentRowEl.previousElementSibling);

            this.performShiftTabIntoChild(_gridElem, currentRowEl, rowIndex);
          } else if (visibleColumnIndex === 0 && isSummary) {
            /** @type {?} */
            var lastRowIndex = this.grid.dataView.length - 1;

            if (lastRowIndex === -1) {
              // no child data
              if (this.grid.allowFiltering && this.grid.filterMode === FilterMode.quickFilter) {
                this.moveFocusToFilterCell();
              } else {
                /** @type {?} */
                var _selNode = {
                  row: rowIndex,
                  column: this.grid.parent.unpinnedColumns[this.grid.parent.unpinnedColumns.length - 1].visibleIndex
                };
                this.navigateUp(currentRowEl, _selNode);
              }
            } else if (!this.getIsChildAtIndex(lastRowIndex)) {
              _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "goToLastCell", this).call(this);
            } else {
              /** @type {?} */
              var scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(lastRowIndex, true);
              /** @type {?} */

              var verticalScrollTop = this.grid.verticalScrollContainer.scrollPosition;

              if (verticalScrollTop === scrTopPosition || isNaN(scrTopPosition)) {
                /** @type {?} */
                var closestChild = this.getLastGridElem(this.grid.getRowByIndex(lastRowIndex).nativeElement.parentElement);
                this.performShiftTabIntoChild(closestChild, currentRowEl, rowIndex);
              } else {
                this.scrollGrid(this.grid, scrTopPosition - verticalScrollTop, function () {
                  /** @type {?} */
                  var closestChild = _this325.getLastGridElem(_this325.grid.getRowByIndex(lastRowIndex).nativeElement.parentElement);

                  _this325.performShiftTabIntoChild(closestChild, currentRowEl, rowIndex);
                });
              }
            }
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "performShiftTabKey", this).call(this, currentRowEl, selectedNode);
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "getFocusableGrid",
        value: function getFocusableGrid() {
          return isIE() && this.grid.rootGrid ? this.grid.rootGrid : this.grid;
        }
        /**
         * @private
         * @param {?} trContainer
         * @return {?}
         */

      }, {
        key: "getLastGridElem",
        value: function getLastGridElem(trContainer) {
          /** @type {?} */
          var children = trContainer.children;
          /** @type {?} */

          var closestChild = children[children.length - 1].children[0].children[0];
          return closestChild;
        }
        /**
         * @private
         * @param {?} gridElem
         * @param {?} currentRowEl
         * @param {?} rowIndex
         * @return {?}
         */

      }, {
        key: "performShiftTabIntoChild",
        value: function performShiftTabIntoChild(gridElem, currentRowEl, rowIndex) {
          /** @type {?} */
          var childGridID = gridElem.getAttribute('id');
          /** @type {?} */

          var childGrid = this.getChildGrid(childGridID, this.grid) || this.getChildGrid(childGridID, this.grid.parent);
          /** @type {?} */

          var lastIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
          /** @type {?} */

          var summaryRows = childGrid.summariesRowList.toArray();

          if (summaryRows.length > 0 && summaryRows[0].summaryCells.length > 0) {
            // move focus to last summary row cell

            /** @type {?} */
            var summaryRow = summaryRows[0].nativeElement;
            this.focusPrevRow(summaryRow, lastIndex, childGrid, true, true);
          } else if (childGrid.rowList.length === 0 && childGrid.allowFiltering && childGrid.filterMode === FilterMode.quickFilter) {
            // move to filter cell
            childGrid.navigation.moveFocusToFilterCell();
          } else if (childGrid.rowList.length === 0) {
            // move to prev child or parent row

            /** @type {?} */
            var prevChild = this.getSibling(childGrid);

            if (prevChild) {
              this.performShiftTabIntoChild(prevChild, currentRowEl, rowIndex);
            } else {
              /** @type {?} */
              var selNode = {
                row: rowIndex,
                column: this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex
              };
              this.navigateUp(currentRowEl, selNode);
            }
          } else {
            // move to prev cell
            childGrid.navigation.goToLastCell();
          }
        }
        /**
         * @private
         * @param {?} childGrid
         * @return {?}
         */

      }, {
        key: "getSibling",
        value: function getSibling(childGrid) {
          /** @type {?} */
          var prevChildRow = childGrid.childRow.nativeElement.previousElementSibling;

          if (prevChildRow) {
            return prevChildRow.children[0].children[0];
          }

          return null;
        }
        /**
         * @private
         * @param {?} elem
         * @param {?} visibleColumnIndex
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "focusNextChild",
        value: function focusNextChild(elem, visibleColumnIndex, grid) {
          var _this326 = this;

          /** @type {?} */
          var gridElem = elem.querySelector('igx-hierarchical-grid');
          /** @type {?} */

          var childGridID = gridElem.getAttribute('id');
          /** @type {?} */

          var childGrid = this.getChildGrid(childGridID, grid);

          if (childGrid.rowList.length === 0) {
            this.focusNext(visibleColumnIndex, childGrid);
            return;
          } // Update column index since the next child can have in general less columns than visibleColumnIndex value.

          /** @type {?} */


          var lastCellIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
          visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);

          if (childGrid.verticalScrollContainer.state.startIndex !== 0) {
            // scroll to top
            this.scrollGrid(childGrid, 'top', function () {
              return _this326.focusNextRow(elem, visibleColumnIndex, childGrid);
            });
          } else {
            this.focusNextRow(elem, visibleColumnIndex, childGrid);
          }
        }
        /**
         * @private
         * @param {?} elem
         * @param {?} visibleColumnIndex
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "focusPrevChild",
        value: function focusPrevChild(elem, visibleColumnIndex, grid) {
          var _this327 = this;

          /** @type {?} */
          var grids = [];
          /** @type {?} */

          var gridElems = Array.from(elem.querySelectorAll('igx-hierarchical-grid'));
          /** @type {?} */

          var childLevel = grid.childLayoutList.first.level;
          gridElems.forEach(function (hg) {
            /** @type {?} */
            var parentRow = _this327.getClosestElemByTag(hg, 'igx-child-grid-row');

            if (parentRow && parseInt(parentRow.getAttribute('data-level'), 10) === childLevel) {
              grids.push(hg);
            }
          });
          /** @type {?} */

          var gridElem = grids[grids.length - 1];
          /** @type {?} */

          var childGridID = gridElem.getAttribute('id');
          /** @type {?} */

          var childGrid = this.getChildGrid(childGridID, grid);

          if (childGrid.rowList.length === 0) {
            this.focusPrev(visibleColumnIndex, childGrid);
            return;
          } // Update column index since the previous child can have in general less columns than visibleColumnIndex value.

          /** @type {?} */


          var lastCellIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
          visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
          /** @type {?} */

          var isScrolledToBottom = this._isScrolledToBottom(childGrid);
          /** @type {?} */


          var lastIndex = childGrid.dataView.length - 1;

          if (!isScrolledToBottom) {
            // scroll to end
            this.scrollGrid(childGrid, 'bottom', function () {
              return _this327.focusPrevChild(elem, visibleColumnIndex, grid);
            });
          } else {
            /** @type {?} */
            var lastRowInChild = childGrid.getRowByIndex(lastIndex);
            /** @type {?} */

            var isChildGrid = lastRowInChild.nativeElement.nodeName.toLowerCase() === 'igx-child-grid-row';

            if (isChildGrid) {
              this.focusPrevChild(lastRowInChild.nativeElement.parentNode, visibleColumnIndex, childGrid);
            } else {
              this.focusPrevRow(lastRowInChild.nativeElement, visibleColumnIndex, childGrid, true);
            }
          }
        }
        /**
         * @private
         * @param {?} visibleColumnIndex
         * @param {?=} grid
         * @return {?}
         */

      }, {
        key: "focusPrev",
        value: function focusPrev(visibleColumnIndex, grid) {
          var _this328 = this;

          /** @type {?} */
          var currGrid = grid || this.grid;
          /** @type {?} */

          var parentContainer = this.getChildContainer(currGrid);
          /** @type {?} */

          var childRowContainer = this.getChildGridRowContainer(currGrid);
          /** @type {?} */

          var prevIsSiblingChild = !!childRowContainer.previousElementSibling;
          /** @type {?} */

          var prev = childRowContainer.previousElementSibling || parentContainer.previousElementSibling;

          if (prev) {
            if (prevIsSiblingChild) {
              this.focusPrevChild(prev, visibleColumnIndex, currGrid.parent);
            } else {
              this.focusPrevRow(prev, visibleColumnIndex, currGrid.parent);
            }
          } else {
            this.scrollGrid(currGrid.parent, 'prev', function () {
              parentContainer = _this328.getChildContainer(grid);
              childRowContainer = _this328.getChildGridRowContainer(grid);
              prev = childRowContainer.previousElementSibling || parentContainer.previousElementSibling;

              if (prevIsSiblingChild) {
                _this328.focusPrevChild(prev, visibleColumnIndex, currGrid.parent);
              } else {
                _this328.focusPrevRow(prev, visibleColumnIndex, currGrid.parent);
              }
            });
          }
        }
        /**
         * @private
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "getNextParentInfo",
        value: function getNextParentInfo(grid) {
          // find next parent that is not at bottom

          /** @type {?} */
          var currGrid = grid.parent;
          /** @type {?} */

          var nextElem = this.getChildContainer(grid).nextElementSibling;

          while (!nextElem && currGrid.parent !== null) {
            nextElem = this.getChildContainer(currGrid).nextElementSibling;
            currGrid = currGrid.parent;
          }

          return {
            grid: currGrid,
            nextElement: nextElem
          };
        }
        /**
         * @private
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "getNextScrollable",
        value: function getNextScrollable(grid) {
          /** @type {?} */
          var currGrid = grid.parent;

          if (!currGrid) {
            return {
              grid: grid,
              prev: null
            };
          }
          /** @type {?} */


          var nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
          /** @type {?} */

          var prev = grid;

          while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
          }

          return {
            grid: currGrid,
            prev: prev
          };
        }
        /**
         * @private
         * @param {?} visibleColumnIndex
         * @param {?=} grid
         * @return {?}
         */

      }, {
        key: "focusNext",
        value: function focusNext(visibleColumnIndex, grid) {
          var _this329 = this;

          /** @type {?} */
          var currGrid = grid || this.grid;
          /** @type {?} */

          var parentInfo = this.getNextParentInfo(currGrid);
          /** @type {?} */

          var nextParentGrid = parentInfo.grid;
          /** @type {?} */

          var nextParentElem = parentInfo.nextElement;
          /** @type {?} */

          var childRowContainer = this.getChildGridRowContainer(currGrid);
          /** @type {?} */

          var nextIsSiblingChild = !!childRowContainer.nextElementSibling;
          /** @type {?} */

          var next = childRowContainer.nextElementSibling || nextParentElem;
          /** @type {?} */

          var verticalScroll = nextParentGrid.verticalScrollContainer.getScroll();
          /** @type {?} */

          var parentState = nextParentGrid.verticalScrollContainer.state;
          /** @type {?} */

          var atLastChunk = parentState.startIndex + parentState.chunkSize === nextParentGrid.dataView.length;

          if (next) {
            if (nextIsSiblingChild) {
              this.focusNextChild(next, visibleColumnIndex, nextParentGrid);
            } else {
              this.focusNextRow(next, visibleColumnIndex, grid || nextParentGrid);
            }
          } else if (verticalScroll.scrollTop !== verticalScroll.scrollHeight - nextParentGrid.verticalScrollContainer.igxForContainerSize && !atLastChunk) {
            this.scrollGrid(nextParentGrid, 'next', function () {
              nextParentElem = parentInfo.nextElement;
              childRowContainer = _this329.getChildGridRowContainer();
              next = childRowContainer.nextElementSibling || nextParentElem;

              if (next && nextIsSiblingChild) {
                _this329.focusNextChild(next, visibleColumnIndex, nextParentGrid);
              } else if (next) {
                _this329.focusNextRow(next, visibleColumnIndex, grid || nextParentGrid);
              }
            });
          }
        }
        /**
         * @private
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "getNextScrollableDown",
        value: function getNextScrollableDown(grid) {
          /** @type {?} */
          var currGrid = grid.parent;

          if (!currGrid) {
            return {
              grid: grid,
              prev: null
            };
          }
          /** @type {?} */


          var scrollTop = currGrid.verticalScrollContainer.scrollPosition;
          /** @type {?} */

          var scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
          /** @type {?} */

          var nonScrollable = scrollHeight === 0 || Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
          /** @type {?} */

          var prev = grid;

          while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 || Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
          }

          return {
            grid: currGrid,
            prev: prev
          };
        }
        /**
         * @private
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "_getMinBottom",
        value: function _getMinBottom(grid) {
          /** @type {?} */
          var currGrid = grid;
          /** @type {?} */

          var bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;

          while (currGrid.parent) {
            currGrid = currGrid.parent;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom);
          }

          return bottom;
        }
        /**
         * @private
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "_getMaxTop",
        value: function _getMaxTop(grid) {
          /** @type {?} */
          var currGrid = grid;
          /** @type {?} */

          var top = currGrid.tbody.nativeElement.getBoundingClientRect().top;

          while (currGrid.parent) {
            currGrid = currGrid.parent;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top);
          }

          return top;
        }
        /**
         * @private
         * @param {?} elem
         * @param {?} visibleColumnIndex
         * @param {?} grid
         * @param {?=} isSummary
         * @return {?}
         */

      }, {
        key: "focusNextRow",
        value: function focusNextRow(elem, visibleColumnIndex, grid, isSummary) {
          var _this330 = this;

          /** @type {?} */
          var lastCellIndex = grid.unpinnedColumns[grid.unpinnedColumns.length - 1].visibleIndex;
          visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
          /** @type {?} */

          var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);

          if (grid.navigation.isColumnFullyVisible(visibleColumnIndex) || grid.rowList.length === 0) {
            /** @type {?} */
            var cell = elem.querySelector("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));
            /** @type {?} */

            var closestScrollableGrid = this.getNextScrollableDown(grid).grid; // const diff = cell.getBoundingClientRect().bottom - grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;

            /** @type {?} */

            var gridBottom = this._getMinBottom(grid);
            /** @type {?} */


            var diff = cell.getBoundingClientRect().bottom - gridBottom;
            /** @type {?} */

            var inView = diff <= 0;
            /** @type {?} */

            var scrollTop = closestScrollableGrid.verticalScrollContainer.scrollPosition;
            /** @type {?} */

            var scrollHeight = closestScrollableGrid.verticalScrollContainer.getScroll().scrollHeight;
            /** @type {?} */

            var canScroll = !(scrollHeight === 0 || Math.round(scrollTop + closestScrollableGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight);

            if (!inView && canScroll) {
              this.scrollGrid(closestScrollableGrid, diff, function () {
                return cell.focus({
                  preventScroll: true
                });
              });
            } else {
              cell.focus({
                preventScroll: true
              });
            }
          } else {
            this.horizontalScrollGridToIndex(grid, visibleColumnIndex, function () {
              _this330.focusNextRow(elem, visibleColumnIndex, grid, isSummary);
            });
          }
        }
        /**
         * @param {?} visibleColumnIndex
         * @param {?=} grid
         * @return {?}
         */

      }, {
        key: "getColumnUnpinnedIndex",
        value: function getColumnUnpinnedIndex(visibleColumnIndex, grid) {
          /** @type {?} */
          var currGrid = grid || this.grid;
          /** @type {?} */

          var column = currGrid.unpinnedColumns.find(function (col) {
            return !col.columnGroup && col.visibleIndex === visibleColumnIndex;
          });
          return currGrid.pinnedColumns.length ? currGrid.unpinnedColumns.filter(function (c) {
            return !c.columnGroup;
          }).indexOf(column) : visibleColumnIndex;
        }
        /**
         * @private
         * @param {?} elem
         * @param {?} visibleColumnIndex
         * @param {?} grid
         * @param {?=} inChild
         * @param {?=} isSummary
         * @return {?}
         */

      }, {
        key: "focusPrevRow",
        value: function focusPrevRow(elem, visibleColumnIndex, grid, inChild, isSummary) {
          var _this331 = this;

          /** @type {?} */
          var lastCellIndex = grid.unpinnedColumns[grid.unpinnedColumns.length - 1].visibleIndex;
          visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);

          if (grid.navigation.isColumnFullyVisible(visibleColumnIndex)) {
            /** @type {?} */
            var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
            /** @type {?} */

            var cells = elem.querySelectorAll("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"));
            /** @type {?} */

            var cell = cells[cells.length - 1];
            /** @type {?} */

            var rIndex = parseInt(elem.getAttribute('data-rowindex'), 10);
            /** @type {?} */

            var scrGrid = grid.verticalScrollContainer.scrollPosition !== 0 ? grid : this.getNextScrollable(grid).grid;
            /** @type {?} */

            var topGrid = scrGrid.tbody.nativeElement.getBoundingClientRect().top > grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top ? scrGrid : grid.rootGrid;
            /** @type {?} */

            var gridTop = this._getMaxTop(grid);
            /** @type {?} */


            var scrTop = scrGrid.verticalScrollContainer.scrollPosition;
            /** @type {?} */

            var diff = cell.getBoundingClientRect().bottom - cell.offsetHeight - gridTop;

            if (scrTop !== 0 && diff < 0 && !inChild) {
              this.scrollGrid(scrGrid, diff, function () {
                /** @type {?} */
                var el = !isSummary ? grid.navigation.getRowByIndex(rIndex) : elem;
                cell = el.querySelectorAll("".concat(cellSelector, "[data-visibleIndex=\"").concat(visibleColumnIndex, "\"]"))[0];
                cell.focus({
                  preventScroll: true
                });
              });
            } else if (diff < 0 && inChild) {
              this.scrollGrid(topGrid, diff, function () {
                cell.focus({
                  preventScroll: true
                });
              });
            } else {
              cell.focus({
                preventScroll: true
              });
            }
          } else {
            this.horizontalScrollGridToIndex(grid, visibleColumnIndex, function () {
              _this331.focusPrevRow(elem, visibleColumnIndex, grid, inChild, isSummary);
            });
          }
        }
        /**
         * @private
         * @param {?} grid
         * @param {?} visibleColumnIndex
         * @param {?} callBackFunc
         * @return {?}
         */

      }, {
        key: "horizontalScrollGridToIndex",
        value: function horizontalScrollGridToIndex(grid, visibleColumnIndex, callBackFunc) {
          /** @type {?} */
          var unpinnedIndex = this.getColumnUnpinnedIndex(visibleColumnIndex, grid);
          grid.parentVirtDir.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(callBackFunc);

          if (grid.dataRowList.length > 0) {
            grid.dataRowList.first.virtDirRow.scrollTo(unpinnedIndex);
          } else {
            grid.headerContainer.scrollTo(unpinnedIndex);
          }
        }
        /**
         * @private
         * @param {?} grid
         * @param {?} target
         * @param {?} callBackFunc
         * @return {?}
         */

      }, {
        key: "scrollGrid",
        value: function scrollGrid(grid, target, callBackFunc) {
          this.getFocusableGrid().nativeElement.focus({
            preventScroll: true
          });
          requestAnimationFrame(function () {
            if (typeof target === 'number') {
              grid.verticalScrollContainer.addScrollTop(target);
            } else {
              switch (target) {
                case 'top':
                  grid.verticalScrollContainer.scrollTo(0);
                  break;

                case 'bottom':
                  grid.verticalScrollContainer.scrollTo(grid.dataView.length - 1);
                  break;

                case 'next':
                  grid.verticalScrollContainer.scrollNext();
                  break;

                case 'prev':
                  grid.verticalScrollContainer.scrollPrev();
                  break;
              }
            }

            grid.verticalScrollContainer.onChunkLoad.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["first"])()).subscribe(callBackFunc);
          });
        }
        /**
         * @private
         * @param {?} rowElement
         * @param {?} currentRowIndex
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "_navigateUpInChild",
        value: function _navigateUpInChild(rowElement, currentRowIndex, visibleColumnIndex) {
          var _this332 = this;

          /** @type {?} */
          var prevElem = rowElement.previousElementSibling;
          /** @type {?} */

          var scrollable = this.getNextScrollable(this.grid);
          /** @type {?} */

          var grid = scrollable.grid;
          /** @type {?} */

          var scrTop = grid.verticalScrollContainer.scrollPosition;
          /** @type {?} */

          var containerTop = scrollable.prev.nativeElement.parentNode.parentNode.parentNode.parentNode;
          /** @type {?} */

          var top = parseInt(containerTop.style.top, 10);

          if (scrTop !== 0 && top < 0) {
            this.scrollGrid(grid, -prevElem.offsetHeight, function () {
              return _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateUp", _this332).call(_this332, rowElement, {
                row: currentRowIndex,
                column: visibleColumnIndex
              });
            });
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateUp", this).call(this, rowElement, {
              row: currentRowIndex,
              column: visibleColumnIndex
            });
          }
        }
        /**
         * @private
         * @param {?} rowElement
         * @param {?} currentRowIndex
         * @param {?} visibleColumnIndex
         * @return {?}
         */

      }, {
        key: "_navigateDownInChild",
        value: function _navigateDownInChild(rowElement, currentRowIndex, visibleColumnIndex) {
          var _this333 = this;

          /** @type {?} */
          var nextElem = rowElement.nextElementSibling;
          /** @type {?} */

          var childContainer = this.grid.nativeElement.parentNode.parentNode;
          /** @type {?} */

          var diff = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.nativeElement.getBoundingClientRect().bottom;
          /** @type {?} */

          var endIsVisible = diff < 0;
          /** @type {?} */

          var scrollable = this.getNextScrollableDown(this.grid);
          /** @type {?} */

          var grid = scrollable.grid;

          if (!endIsVisible) {
            this.scrollGrid(grid, nextElem.offsetHeight, function () {
              return _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateDown", _this333).call(_this333, rowElement, {
                row: currentRowIndex,
                column: visibleColumnIndex
              });
            });
          } else {
            _get(_getPrototypeOf(IgxHierarchicalGridNavigationService.prototype), "navigateDown", this).call(this, rowElement, {
              row: currentRowIndex,
              column: visibleColumnIndex
            });
          }
        }
        /**
         * @private
         * @param {?} sourceElem
         * @param {?} targetTag
         * @return {?}
         */

      }, {
        key: "getClosestElemByTag",
        value: function getClosestElemByTag(sourceElem, targetTag) {
          /** @type {?} */
          var result = sourceElem;

          while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
              return result;
            }

            result = result.parentNode;
          }

          return null;
        }
        /**
         * @protected
         * @param {?} nextIndex
         * @return {?}
         */

      }, {
        key: "getNextRowByIndex",
        value: function getNextRowByIndex(nextIndex) {
          return this.grid.dataRowList.find(function (element) {
            return element.index === nextIndex;
          }).element.nativeElement;
        }
      }]);

      return IgxHierarchicalGridNavigationService;
    }(IgxGridNavigationService);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var IgxHierarchicalTransactionServiceFactory = {
      provide: IgxGridTransaction,
      useFactory: hierarchicalTransactionServiceFactory
    };
    /**
     * @return {?}
     */

    function hierarchicalTransactionServiceFactory() {
      return function () {
        return new IgxHierarchicalTransactionService();
      };
    }
    /**
     * @abstract
     */


    var IgxHierarchicalGridBaseComponent =
    /*#__PURE__*/
    function (_IgxGridBaseComponent3) {
      _inherits(IgxHierarchicalGridBaseComponent, _IgxGridBaseComponent3);

      /**
       * @param {?} selectionService
       * @param {?} crudService
       * @param {?} colResizingService
       * @param {?} gridAPI
       * @param {?} transactionFactory
       * @param {?} elementRef
       * @param {?} zone
       * @param {?} document
       * @param {?} cdr
       * @param {?} resolver
       * @param {?} differs
       * @param {?} viewRef
       * @param {?} navigation
       * @param {?} filteringService
       * @param {?} overlayService
       * @param {?} summaryService
       * @param {?} _displayDensityOptions
       */
      function IgxHierarchicalGridBaseComponent(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        var _this334;

        _classCallCheck(this, IgxHierarchicalGridBaseComponent);

        _this334 = _possibleConstructorReturn(this, _getPrototypeOf(IgxHierarchicalGridBaseComponent).call(this, selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions));
        _this334.selectionService = selectionService;
        _this334.colResizingService = colResizingService;
        _this334.transactionFactory = transactionFactory;
        _this334.document = document;
        _this334.overlayService = overlayService;
        _this334.summaryService = summaryService;
        _this334._displayDensityOptions = _displayDensityOptions;
        _this334.showExpandAll = false;
        _this334._expandChildren = false;
        _this334.hgridAPI =
        /** @type {?} */
        gridAPI;
        return _this334;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxHierarchicalGridBaseComponent, [{
        key: "createColumnsList",

        /**
         * @hidden
         * @param {?} cols
         * @return {?}
         */
        value: function createColumnsList(cols) {
          var _this335 = this;

          /** @type {?} */
          var columns = [];
          /** @type {?} */

          var topLevelCols = this.onlyTopLevel(cols);
          topLevelCols.forEach(function (col) {
            /** @type {?} */
            var ref = _this335._createColumn(col);

            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
          });
          /** @type {?} */

          var result = flatten$1(columns);
          this.columnList.reset(result);
          this.columnList.notifyOnChanges();
          this.initPinning();
        }
        /**
         * @protected
         * @param {?} col
         * @return {?}
         */

      }, {
        key: "_createColumn",
        value: function _createColumn(col) {
          /** @type {?} */
          var ref;

          if (col instanceof IgxColumnGroupComponent) {
            ref = this._createColGroupComponent(col);
          } else {
            ref = this._createColComponent(col);
          }

          return ref;
        }
        /**
         * @protected
         * @param {?} col
         * @return {?}
         */

      }, {
        key: "_createColGroupComponent",
        value: function _createColGroupComponent(col) {
          var _this336 = this;

          /** @type {?} */
          var factoryGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);
          /** @type {?} */

          var ref = this.viewRef.createComponent(factoryGroup, null, this.viewRef.injector);
          ref.changeDetectorRef.detectChanges();
          factoryGroup.inputs.forEach(function (input) {
            /** @type {?} */
            var propName = input.propName;

            /** @type {?} */
            ref.instance[propName] =
            /** @type {?} */
            col[propName];
          });

          if (col.children.length > 0) {
            /** @type {?} */
            var newChildren = [];
            col.children.forEach(function (child) {
              /** @type {?} */
              var newCol = _this336._createColumn(child).instance;

              newCol.parent = ref.instance;
              newChildren.push(newCol);
            });

            /** @type {?} */
            ref.instance.children.reset(newChildren);

            /** @type {?} */
            ref.instance.children.notifyOnChanges();
          } // (<IgxColumnGroupComponent>ref.instance).grid = this;


          return ref;
        }
        /**
         * @protected
         * @param {?} col
         * @return {?}
         */

      }, {
        key: "_createColComponent",
        value: function _createColComponent(col) {
          /** @type {?} */
          var factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
          /** @type {?} */

          var ref = this.viewRef.createComponent(factoryColumn, null, this.viewRef.injector);
          factoryColumn.inputs.forEach(function (input) {
            /** @type {?} */
            var propName = input.propName;

            if (!(
            /** @type {?} */
            col[propName] instanceof IgxSummaryOperand)) {
              /** @type {?} */
              ref.instance[propName] =
              /** @type {?} */
              col[propName];
            } else {
              /** @type {?} */
              ref.instance[propName] = col[propName].constructor;
            }
          }); // (<IgxColumnComponent>ref.instance).grid = this;

          return ref;
        }
        /**
         * @protected
         * @param {?} rowIslandID
         * @return {?}
         */

      }, {
        key: "getGridsForIsland",
        value: function getGridsForIsland(rowIslandID) {
          return this.hgridAPI.getChildGridsForRowIsland(rowIslandID);
        }
        /**
         * @protected
         * @param {?} path
         * @return {?}
         */

      }, {
        key: "getChildGrid",
        value: function getChildGrid(path) {
          if (!path) {
            return;
          }

          return this.hgridAPI.getChildGrid(path);
        }
      }, {
        key: "maxLevelHeaderDepth",
        get: function get() {
          if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.columnList.reduce(function (acc, col) {
              return Math.max(acc, col.level);
            }, 0);
          }

          return this._maxLevelHeaderDepth;
        }
        /**
         * @hidden
         * @protected
         * @return {?}
         */

      }, {
        key: "outlet",
        get: function get() {
          return this.rootGrid ? this.rootGrid.outletDirective : this.outletDirective;
        }
      }]);

      return IgxHierarchicalGridBaseComponent;
    }(IgxGridBaseComponent);
    /** @nocollapse */


    IgxHierarchicalGridBaseComponent.ctorParameters = function () {
      return [{
        type: IgxGridSelectionService
      }, {
        type: IgxGridCRUDService
      }, {
        type: IgxColumnResizingService
      }, {
        type: GridBaseAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxGridTransaction]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: IgxHierarchicalGridNavigationService
      }, {
        type: IgxFilteringService
      }, {
        type: IgxOverlayService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxOverlayService]
        }]
      }, {
        type: IgxGridSummaryService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxHierarchicalGridBaseComponent.propDecorators = {
      expandChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hasChildrenKey: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      showExpandAll: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      dragIndicatorIconBase: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['dragIndicatorIconBase', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }]
    };
    /**
     * @param {?} arr
     * @return {?}
     */

    function flatten$1(arr) {
      /** @type {?} */
      var result = [];
      arr.forEach(function (el) {
        result.push(el);

        if (el.children) {
          result = result.concat(flatten$1(el.children.toArray()));
        }
      });
      return result;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxHierarchicalGridAPIService =
    /*#__PURE__*/
    function (_GridBaseAPIService3) {
      _inherits(IgxHierarchicalGridAPIService, _GridBaseAPIService3);

      function IgxHierarchicalGridAPIService() {
        var _this337;

        _classCallCheck(this, IgxHierarchicalGridAPIService);

        _this337 = _possibleConstructorReturn(this, _getPrototypeOf(IgxHierarchicalGridAPIService).apply(this, arguments));
        _this337.childRowIslands = new Map();
        _this337.childGrids = new Map();
        return _this337;
      }
      /**
       * @param {?} rowIsland
       * @return {?}
       */


      _createClass(IgxHierarchicalGridAPIService, [{
        key: "registerChildRowIsland",
        value: function registerChildRowIsland(rowIsland) {
          this.childRowIslands.set(rowIsland.key, rowIsland);
          this.destroyMap.set(rowIsland.key, new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]());
        }
        /**
         * @param {?} rowIsland
         * @return {?}
         */

      }, {
        key: "unsetChildRowIsland",
        value: function unsetChildRowIsland(rowIsland) {
          this.childGrids["delete"](rowIsland.key);
          this.childRowIslands["delete"](rowIsland.key);
          this.destroyMap["delete"](rowIsland.key);
        }
        /**
         * @param {?} key
         * @return {?}
         */

      }, {
        key: "getChildRowIsland",
        value: function getChildRowIsland(key) {
          return this.childRowIslands.get(key);
        }
        /**
         * @param {?} path
         * @return {?}
         */

      }, {
        key: "getChildGrid",
        value: function getChildGrid(path) {
          /** @type {?} */
          var currPath = path;
          /** @type {?} */

          var grid;
          /** @type {?} */

          var pathElem = currPath.shift();
          /** @type {?} */

          var childrenForLayout = this.childGrids.get(pathElem.rowIslandKey);

          if (childrenForLayout) {
            /** @type {?} */
            var childGrid = childrenForLayout.get(pathElem.rowID);

            if (currPath.length === 0) {
              grid = childGrid;
            } else {
              grid = childGrid.hgridAPI.getChildGrid(currPath);
            }
          }

          return grid;
        }
        /**
         * @param {?=} inDepth
         * @return {?}
         */

      }, {
        key: "getChildGrids",
        value: function getChildGrids(inDepth) {
          /** @type {?} */
          var allChildren = [];
          this.childGrids.forEach(function (layoutMap) {
            layoutMap.forEach(function (grid) {
              allChildren.push(grid);

              if (inDepth) {
                /** @type {?} */
                var children = grid.hgridAPI.getChildGrids(inDepth);
                children.forEach(function (item) {
                  allChildren.push(item);
                });
              }
            });
          });
          return allChildren;
        }
        /**
         * @param {?} childGrid
         * @return {?}
         */

      }, {
        key: "getParentRowId",
        value: function getParentRowId(childGrid) {
          /** @type {?} */
          var rowID;
          this.childGrids.forEach(function (layoutMap) {
            layoutMap.forEach(function (grid, key) {
              if (grid === childGrid) {
                rowID = key;
                return;
              }
            });
          });
          return rowID;
        }
        /**
         * @param {?} parentRowID
         * @param {?} rowIslandKey
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "registerChildGrid",
        value: function registerChildGrid(parentRowID, rowIslandKey, grid) {
          /** @type {?} */
          var childrenForLayout = this.childGrids.get(rowIslandKey);

          if (!childrenForLayout) {
            this.childGrids.set(rowIslandKey, new Map());
            childrenForLayout = this.childGrids.get(rowIslandKey);
          }

          childrenForLayout.set(parentRowID, grid);
        }
        /**
         * @param {?} rowIslandKey
         * @return {?}
         */

      }, {
        key: "getChildGridsForRowIsland",
        value: function getChildGridsForRowIsland(rowIslandKey) {
          /** @type {?} */
          var childrenForLayout = this.childGrids.get(rowIslandKey);
          /** @type {?} */

          var children = [];

          if (childrenForLayout) {
            childrenForLayout.forEach(function (child) {
              children.push(child);
            });
          }

          return children;
        }
        /**
         * @param {?} rowIslandKey
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "getChildGridByID",
        value: function getChildGridByID(rowIslandKey, rowID) {
          /** @type {?} */
          var childrenForLayout = this.childGrids.get(rowIslandKey);
          return childrenForLayout.get(rowID);
        }
      }]);

      return IgxHierarchicalGridAPIService;
    }(GridBaseAPIService);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxRowIslandComponent =
    /*#__PURE__*/
    function (_IgxHierarchicalGridB) {
      _inherits(IgxRowIslandComponent, _IgxHierarchicalGridB);

      /**
       * @param {?} selectionService
       * @param {?} crudService
       * @param {?} colResizingService
       * @param {?} gridAPI
       * @param {?} transactionFactory
       * @param {?} elementRef
       * @param {?} zone
       * @param {?} document
       * @param {?} cdr
       * @param {?} resolver
       * @param {?} differs
       * @param {?} viewRef
       * @param {?} navigation
       * @param {?} filteringService
       * @param {?} overlayService
       * @param {?} summaryService
       * @param {?} _displayDensityOptions
       * @param {?} rowIslandAPI
       */
      function IgxRowIslandComponent(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, rowIslandAPI) {
        var _this338;

        _classCallCheck(this, IgxRowIslandComponent);

        _this338 = _possibleConstructorReturn(this, _getPrototypeOf(IgxRowIslandComponent).call(this, selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions));
        _this338.selectionService = selectionService;
        _this338.colResizingService = colResizingService;
        _this338.transactionFactory = transactionFactory;
        _this338.document = document;
        _this338.overlayService = overlayService;
        _this338.summaryService = summaryService;
        _this338._displayDensityOptions = _displayDensityOptions;
        _this338.rowIslandAPI = rowIslandAPI;
        /**
         * @hidden
         */

        _this338.children = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */

        _this338.childColumns = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */

        _this338.onLayoutChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event emmited when a grid is being created based on this row island.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" (onGridCreated)="gridCreated($event)" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         * \@memberof IgxRowIslandComponent
         */

        _this338.onGridCreated = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this338.initialChanges = [];
        /**
         * @hidden
         */

        _this338.rootGrid = null;
        _this338.layout_id = "igx-row-island-";
        _this338.isInit = false;
        _this338.hgridAPI =
        /** @type {?} */
        gridAPI;
        return _this338;
      }
      /**
       * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.
       * ```html
       * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
       *      <igx-row-island [key]="'childData'" [expandChildren]="true" #rowIsland>
       *          <!-- ... -->
       *      </igx-row-island>
       * </igx-hierarchical-grid>
       * ```
       * \@memberof IgxRowIslandComponent
       * @param {?} value
       * @return {?}
       */


      _createClass(IgxRowIslandComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this.rootGrid = this.hgridAPI.grid;
          this.rowIslandAPI.rowIsland = this;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {}
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          var _this339 = this;

          this.updateChildren();
          this.children.notifyOnChanges();
          this.children.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (change) {
            _this339.updateChildren(); // update existing grids since their child ri have been changed.


            _this339.getGridsForIsland(_this339.key).forEach(function (grid) {
              /** @type {?} */
              grid.onRowIslandChange(_this339.children);
            });
          });
          /** @type {?} */

          var nestedColumns = this.children.map(function (layout) {
            return layout.columnList.toArray();
          });
          /** @type {?} */

          var colsArray = [].concat.apply([], nestedColumns);
          /** @type {?} */

          var topCols = this.columnList.filter(function (item) {
            return colsArray.indexOf(item) === -1;
          });
          this.childColumns.reset(topCols);
          this.columnList.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function () {
            _this339.updateColumnList();
          });
        }
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "updateChildren",
        value: function updateChildren() {
          var _this340 = this;

          this.children.reset(this.children.toArray().slice(1));
          this.children.forEach(function (child) {
            child.parentIsland = _this340;
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.rowIslandAPI.register(this);

          if (this.parentIsland) {
            this.parentIsland.rowIslandAPI.registerChildRowIsland(this);
          } else {
            this.rootGrid.hgridAPI.registerChildRowIsland(this);
          }

          this._init = false;
        }
        /**
         * @hidden
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          this.onLayoutChange.emit(changes);

          if (!this.isInit) {
            this.initialChanges.push(changes);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _this341 = this;

          // Override the base destroy because we don't have rendered anything to use removeEventListener on
          this.destroy$.next(true);
          this.destroy$.complete();
          this._destroyed = true;
          this.rowIslandAPI.unset(this.id);

          if (this.parentIsland) {
            this.getGridsForIsland(this.key).forEach(function (grid) {
              _this341.cleanGridState(grid);

              grid.hgridAPI.unsetChildRowIsland(_this341);
            });
            this.parentIsland.rowIslandAPI.unsetChildRowIsland(this);
          } else {
            this.rootGrid.hgridAPI.unsetChildRowIsland(this);
            this.cleanGridState(this.rootGrid);
          }
        }
        /**
         * @private
         * @param {?} grid
         * @return {?}
         */

      }, {
        key: "cleanGridState",
        value: function cleanGridState(grid) {
          grid.childGridTemplates.forEach(function (tmpl) {
            tmpl.owner.cleanView(tmpl.context.templateID);
          });
          grid.childGridTemplates.clear();
          grid.onRowIslandChange();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "reflow",
        value: function reflow() {}
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "calculateGridHeight",
        value: function calculateGridHeight() {}
        /**
         * @protected
         * @return {?}
         */

      }, {
        key: "updateColumnList",
        value: function updateColumnList() {
          var _this342 = this;

          /** @type {?} */
          var nestedColumns = this.children.map(function (layout) {
            return layout.columnList.toArray();
          });
          /** @type {?} */

          var colsArray = [].concat.apply([], nestedColumns);
          /** @type {?} */

          var topCols = this.columnList.filter(function (item) {
            if (colsArray.indexOf(item) === -1) {
              /* Reset the default width of the columns that come into this row island,
              because the root catches them first during the detectChanges() and sets their defaultWidth. */
              item.defaultWidth = undefined;
              return true;
            }

            return false;
          });
          this.childColumns.reset(topCols);

          if (this.parentIsland) {
            this.parentIsland.columnList.notifyOnChanges();
          } else {
            this.rootGrid.columnList.notifyOnChanges();
          }

          this.rowIslandAPI.getChildGrids().forEach(function (grid) {
            grid.createColumnsList(_this342.childColumns.toArray());

            if (!document.body.contains(grid.nativeElement)) {
              grid.updateOnRender = true;
            }
          });
        }
      }, {
        key: "expandChildren",
        set: function set(value) {
          this._expandChildren = value;
          this.rowIslandAPI.getChildGrids().forEach(function (grid) {
            if (document.body.contains(grid.nativeElement)) {
              // Detect changes right away if the grid is visible
              grid.expandChildren = value;
              grid.markForCheck();
            } else {
              // Else defer the detection on changes when the grid gets into view for performance.
              grid.updateOnRender = true;
            }
          });
        }
        /**
         * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.
         * ```typescript
         * const expanded = this.rowIsland.expandChildren;
         * ```
         * \@memberof IgxRowIslandComponent
         * @return {?}
         */
        ,
        get: function get() {
          return this._expandChildren;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "id",
        get: function get() {
          /** @type {?} */
          var pId = this.parentId ? this.parentId.substring(this.parentId.indexOf(this.layout_id) + this.layout_id.length) + '-' : '';
          return this.layout_id + pId + this.key;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "parentId",
        get: function get() {
          return this.parentIsland ? this.parentIsland.id : null;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "level",
        get: function get() {
          /** @type {?} */
          var ptr = this.parentIsland;
          /** @type {?} */

          var lvl = 0;

          while (ptr) {
            lvl++;
            ptr = ptr.parentIsland;
          }

          return lvl + 1;
        }
        /**
         * Get transactions service for the children grid components.
         * \@experimental \@hidden
         * @return {?}
         */

      }, {
        key: "transactions",
        get: function get() {
          /** @type {?} */
          var grids = this.rowIslandAPI.getChildGrids();
          return grids.length ? grids[0].transactions : this._transactions;
        }
      }]);

      return IgxRowIslandComponent;
    }(IgxHierarchicalGridBaseComponent);

    IgxRowIslandComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        selector: 'igx-row-island',
        template: "",
        providers: [IgxRowIslandAPIService]
      }]
    }];
    /** @nocollapse */

    IgxRowIslandComponent.ctorParameters = function () {
      return [{
        type: IgxGridSelectionService
      }, {
        type: IgxGridCRUDService
      }, {
        type: IgxColumnResizingService
      }, {
        type: GridBaseAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxGridTransaction]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: IgxHierarchicalGridNavigationService
      }, {
        type: IgxFilteringService
      }, {
        type: IgxOverlayService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxOverlayService]
        }]
      }, {
        type: IgxGridSummaryService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }, {
        type: IgxRowIslandAPIService
      }];
    };

    IgxRowIslandComponent.propDecorators = {
      key: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      expandChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      children: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxRowIslandComponent, {
          read: IgxRowIslandComponent,
          descendants: false
        }]
      }],
      childColumns: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxColumnComponent, {
          read: IgxColumnComponent,
          descendants: false
        }]
      }],
      onLayoutChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onGridCreated: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxChildGridRowComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       * @param {?} element
       * @param {?} resolver
       * @param {?} cdr
       */
      function IgxChildGridRowComponent(gridAPI, element, resolver, cdr) {
        _classCallCheck(this, IgxChildGridRowComponent);

        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */

        this.expanded = false;
        /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         */

        this.rowData = [];
        /**
         * @hidden
         */

        this.tabindex = 0;
        /**
         * @hidden
         */

        this.role = 'row';
        this.resolver = resolver;
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxChildGridRowComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          var _this343 = this;

          this.layout.onLayoutChange.subscribe(function (ch) {
            _this343._handleLayoutChanges(ch);
          });
          /** @type {?} */

          var changes = this.layout.initialChanges;
          changes.forEach(function (change) {
            _this343._handleLayoutChanges(change);
          });
          this.hGrid.parent = this.parentGrid;
          this.hGrid.parentIsland = this.layout;
          this.hGrid.childRow = this; // handler logic that re-emits hgrid events on the row island

          this.setupEventEmitters();
          this.layout.onGridCreated.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this344 = this;

          this.hGrid.childLayoutList = this.layout.children;

          if (this.layout.childColumns.length > 0 && !this.hGrid.autoGenerate) {
            this.hGrid.createColumnsList(this.layout.childColumns.toArray());
          }
          /** @type {?} */


          var layouts = this.hGrid.childLayoutList.toArray();
          layouts.forEach(function (l) {
            return _this344.hGrid.hgridAPI.registerChildRowIsland(l);
          });
          this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
          this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
          this.hGrid.cdr.detectChanges();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "setupEventEmitters",
        value: function setupEventEmitters() {
          var _this345 = this;

          /** @type {?} */
          var destructor = Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.hGrid.destroy$);
          /** @type {?} */

          var factory = this.resolver.resolveComponentFactory(IgxGridComponent); // exclude outputs related to two-way binding functionality

          /** @type {?} */

          var inputNames = factory.inputs.map(function (input) {
            return input.propName;
          });
          /** @type {?} */

          var outputs = factory.outputs.filter(function (o) {
            /** @type {?} */
            var matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));
            return inputNames.indexOf(matchingInputPropName) === -1;
          });
          outputs.forEach(function (output) {
            if (_this345.hGrid[output.propName]) {
              _this345.hGrid[output.propName].pipe(destructor).subscribe(function (args) {
                if (!args) {
                  args = {};
                }

                args.owner = _this345.hGrid;

                _this345.layout[output.propName].emit(args);
              });
            }
          });
        }
        /**
         * @private
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "_handleLayoutChanges",
        value: function _handleLayoutChanges(changes) {
          for (var change in changes) {
            if (changes.hasOwnProperty(change)) {
              this.hGrid[change] = changes[change].currentValue;
            }
          }
        }
      }, {
        key: "parentHasScroll",
        get: function get() {
          return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
        }
        /**
         * Get a reference to the grid that contains the selected row.
         *
         * ```typescript
         * handleRowSelection(event) {
         *  // the grid on which the onRowSelectionChange event was triggered
         *  const grid = event.row.grid;
         * }
         * ```
         *
         * ```html
         *  <igx-grid
         *    [data]="data"
         *    (onRowSelectionChange)="handleRowSelection($event)">
         *  </igx-grid>
         * ```
         * @return {?}
         */
        // TODO: Refactor

      }, {
        key: "parentGrid",
        get: function get() {
          return this.gridAPI.grid;
        }
        /**
         * @return {?}
         */

      }, {
        key: "level",
        get: function get() {
          return this.layout.level;
        }
        /**
         * The native DOM element representing the row. Could be null in certain environments.
         *
         * ```typescript
         * // get the nativeElement of the second selected row
         * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
         * ```
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this.element.nativeElement;
        }
      }]);

      return IgxChildGridRowComponent;
    }();

    IgxChildGridRowComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-child-grid-row',
        template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid [data]='rowData.childGridsData[layout.key]'></igx-hierarchical-grid>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxChildGridRowComponent.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxChildGridRowComponent.propDecorators = {
      layout: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      parentGridID: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      rowData: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      index: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hGrid: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['hgrid', {
          "static": true
        }]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      level: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.data-level']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$o = 0;

    var IgxHierarchicalGridComponent =
    /*#__PURE__*/
    function (_IgxHierarchicalGridB2) {
      _inherits(IgxHierarchicalGridComponent, _IgxHierarchicalGridB2);

      /**
       * @param {?} selectionService
       * @param {?} crudService
       * @param {?} colResizingService
       * @param {?} gridAPI
       * @param {?} transactionFactory
       * @param {?} elementRef
       * @param {?} zone
       * @param {?} document
       * @param {?} cdr
       * @param {?} resolver
       * @param {?} differs
       * @param {?} viewRef
       * @param {?} navigation
       * @param {?} filteringService
       * @param {?} overlayService
       * @param {?} summaryService
       * @param {?} _displayDensityOptions
       */
      function IgxHierarchicalGridComponent(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        var _this346;

        _classCallCheck(this, IgxHierarchicalGridComponent);

        _this346 = _possibleConstructorReturn(this, _getPrototypeOf(IgxHierarchicalGridComponent).call(this, selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions));
        _this346.selectionService = selectionService;
        _this346.colResizingService = colResizingService;
        _this346.transactionFactory = transactionFactory;
        _this346.document = document;
        _this346.overlayService = overlayService;
        _this346.summaryService = summaryService;
        _this346._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         */

        _this346.hierarchicalStateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        _this346.childLayoutKeys = [];
        /**
         * @hidden
         */

        _this346.highlightedRowID = null;
        /**
         * @hidden
         */

        _this346.updateOnRender = false;
        /**
         * @hidden
         */

        _this346.parent = null;
        _this346._hierarchicalState = [];
        _this346._filteredData = null;
        _this346.h_id = "igx-hierarchical-grid-".concat(NEXT_ID$o++);
        _this346.childGridTemplates = new Map();
        _this346.scrollTop = 0;
        _this346.scrollLeft = 0;
        _this346.hgridAPI =
        /** @type {?} */
        gridAPI;
        return _this346;
      }
      /**
       * Sets the value of the `id` attribute. If not provided it will be automatically generated.
       * ```html
       * <igx-hierarchical-grid [id]="'igx-hgrid-1'" [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
       * ```
       * \@memberof IgxHierarchicalGridComponent
       * @return {?}
       */


      _createClass(IgxHierarchicalGridComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this._transactions = this.parentIsland ? this.parentIsland.transactions : this._transactions;

          _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "ngOnInit", this).call(this);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (this._cdrRequestRepaint && !this._init) {
            this.updateSizes();
          }

          _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "ngDoCheck", this).call(this);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this347 = this;

          _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "ngAfterViewInit", this).call(this);

          this.verticalScrollContainer.getScroll().addEventListener('scroll', this.hg_verticalScrollHandler.bind(this));
          this.headerContainer.getScroll().addEventListener('scroll', this.hg_horizontalScrollHandler.bind(this));

          if (this.expandChildren && this.data && this.hierarchicalState.length !== this.data.length) {
            this.hierarchicalState = this.data.map(function (rec) {
              return {
                rowID: _this347.primaryKey ? rec[_this347.primaryKey] : rec
              };
            });
            this.cdr.detectChanges();
          }

          this.verticalScrollContainer.onBeforeViewDestroyed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function (view) {
            /** @type {?} */
            var rowData = view.context.$implicit;

            if (_this347.isChildGridRecord(rowData)) {
              /** @type {?} */
              var cachedData = _this347.childGridTemplates.get(rowData.rowID);

              if (cachedData) {
                /** @type {?} */
                var tmlpOutlet = cachedData.owner;

                tmlpOutlet._viewContainerRef.detach(0);
              }
            }
          });

          if (this.parent) {
            this._displayDensity = this.rootGrid._displayDensity;
            this.rootGrid.onDensityChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function () {
              _this347._displayDensity = _this347.rootGrid._displayDensity;

              _this347.notifyChanges(true);

              _this347.cdr.markForCheck();
            });
            this.childLayoutKeys = this.parentIsland.children.map(function (item) {
              return item.key;
            });
          }

          this.toolbarCustomContentTemplates = this.parentIsland ? this.parentIsland.toolbarCustomContentTemplates : this.toolbarCustomContentTemplates;
          this.headSelectorsTemplates = this.parentIsland ? this.parentIsland.headSelectorsTemplates : this.headSelectorsTemplates;
          this.rowSelectorsTemplates = this.parentIsland ? this.parentIsland.rowSelectorsTemplates : this.rowSelectorsTemplates;
          this.dragIndicatorIconTemplate = this.parentIsland ? this.parentIsland.dragIndicatorIconTemplate : this.dragIndicatorIconTemplate;
          this.rowExpandedIndicatorTemplate = this.rootGrid.rowExpandedIndicatorTemplate;
          this.rowCollapsedIndicatorTemplate = this.rootGrid.rowCollapsedIndicatorTemplate;
          this.headerCollapseIndicatorTemplate = this.rootGrid.headerCollapseIndicatorTemplate;
          this.headerExpandIndicatorTemplate = this.rootGrid.headerExpandIndicatorTemplate;
          this.hasChildrenKey = this.parentIsland ? this.parentIsland.hasChildrenKey || this.rootGrid.hasChildrenKey : this.rootGrid.hasChildrenKey;
          this.showExpandAll = this.parentIsland ? this.parentIsland.showExpandAll : this.rootGrid.showExpandAll;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "updateSizes",
        value: function updateSizes() {
          if (document.body.contains(this.nativeElement) && this.isPercentWidth) {
            this.reflow();
            this.hgridAPI.getChildGrids(false).forEach(function (grid) {
              grid.updateSizes();
            });
          }
        }
        /**
         * @protected
         * @param {?} renderedHeight
         * @return {?}
         */

      }, {
        key: "_shouldAutoSize",
        value: function _shouldAutoSize(renderedHeight) {
          if (this.isPercentHeight && this.parent) {
            return true;
          }

          return _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "_shouldAutoSize", this).call(this, renderedHeight);
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterContentInit() {
          var _this348 = this;

          this.updateColumnList(false);
          this.childLayoutKeys = this.parent ? this.parentIsland.children.map(function (item) {
            return item.key;
          }) : this.childLayoutKeys = this.childLayoutList.map(function (item) {
            return item.key;
          });
          this.childLayoutList.notifyOnChanges();
          this.childLayoutList.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.destroy$)).subscribe(function () {
            return _this348.onRowIslandChange();
          });

          _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "ngAfterContentInit", this).call(this);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onRowIslandChange",
        value: function onRowIslandChange() {
          if (this.parent) {
            this.childLayoutKeys = this.parentIsland.children.filter(function (item) {
              return !
              /** @type {?} */
              item._destroyed;
            }).map(function (item) {
              return item.key;
            });
          } else {
            this.childLayoutKeys = this.childLayoutList.filter(function (item) {
              return !
              /** @type {?} */
              item._destroyed;
            }).map(function (item) {
              return item.key;
            });
          }

          if (!
          /** @type {?} */
          this.cdr.destroyed) {
            this.cdr.detectChanges();
          }
        }
        /**
         * @protected
         * @param {?} change
         * @return {?}
         */

      }, {
        key: "onColumnsChanged",
        value: function onColumnsChanged(change) {
          var _this349 = this;

          this.updateColumnList();
          /** @type {?} */

          var cols = change.filter(function (c) {
            return c.gridAPI.grid === _this349;
          });

          if (cols.length > 0) {
            this.columnList.reset(cols);

            _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "onColumnsChanged", this).call(this, this.columnList);
          }
        }
        /**
         * @private
         * @param {?=} recalcColSizes
         * @return {?}
         */

      }, {
        key: "updateColumnList",
        value: function updateColumnList() {
          var recalcColSizes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          /** @type {?} */
          var childLayouts = this.parent ? this.childLayoutList : this.allLayoutList;
          /** @type {?} */

          var nestedColumns = childLayouts.map(function (layout) {
            return layout.columnList.toArray();
          });
          /** @type {?} */

          var colsArray = [].concat.apply([], nestedColumns);
          /** @type {?} */

          var colLength = this.columnList.length;

          if (colsArray.length > 0) {
            /** @type {?} */
            var topCols = this.columnList.filter(function (item) {
              return colsArray.indexOf(item) === -1;
            });
            this.columnList.reset(topCols);

            if (recalcColSizes && this.columnList.length !== colLength) {
              this.calculateGridSizes();
            }
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (!this.parent) {
            this.hgridAPI.getChildGrids(true).forEach(function (grid) {
              if (!grid.childRow.cdr.destroyed) {
                grid.childRow.cdr.destroy();
              }
            });
          }

          if (this.parent && this.selectionService.activeElement) {
            // in case selection is in destroyed child grid, selection should be cleared.
            this._clearSeletionHighlights();
          }

          _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "ngOnDestroy", this).call(this);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_clearSeletionHighlights",
        value: function _clearSeletionHighlights() {
          [this.rootGrid].concat(_toConsumableArray(this.rootGrid.getChildGrids(true))).forEach(function (grid) {
            grid.selectionService.clear();
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getFeatureColumnsWidth",

        /**
         * @hidden
         * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
         * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
         * @return {?}
         */
        value: function getFeatureColumnsWidth() {
          /** @type {?} */
          var width = _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "getFeatureColumnsWidth", this).call(this);

          if (this.hasExpandableChildren) {
            width += this.headerHierarchyExpander.nativeElement.offsetWidth || this.getDefaultExpanderWidth();
          }

          return width;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getDefaultExpanderWidth",
        value: function getDefaultExpanderWidth() {
          switch (this.displayDensity) {
            case DisplayDensity.cosy:
              return 57;

            case DisplayDensity.compact:
              return 49;

            default:
              return 72;
          }
        }
        /**
         * @hidden
         * @param {?} rowData
         * @return {?}
         */

      }, {
        key: "isRowHighlighted",
        value: function isRowHighlighted(rowData) {
          return this.highlightedRowID === rowData.rowID;
        }
        /**
         * @hidden
         * @param {?} record
         * @return {?}
         */

      }, {
        key: "isHierarchicalRecord",
        value: function isHierarchicalRecord(record) {
          return this.childLayoutList.length !== 0 && record[this.childLayoutList.first.key];
        }
        /**
         * @hidden
         * @param {?} record
         * @return {?}
         */

      }, {
        key: "isChildGridRecord",
        value: function isChildGridRecord(record) {
          // Can be null when there is defined layout but no child data was found
          return record.childGridsData !== undefined;
        }
        /**
         * @hidden
         * @param {?} index
         * @param {?} rec
         * @return {?}
         */

      }, {
        key: "trackChanges",
        value: function trackChanges(index, rec) {
          if (rec.childGridsData !== undefined) {
            // if is child rec
            return rec.rowID;
          }

          return rec;
        }
        /**
         * @hidden
         * @param {?} rowData
         * @return {?}
         */

      }, {
        key: "getContext",
        value: function getContext(rowData) {
          if (this.isChildGridRecord(rowData)) {
            /** @type {?} */
            var cachedData = this.childGridTemplates.get(rowData.rowID);

            if (cachedData) {
              /** @type {?} */
              var view = cachedData.view;
              /** @type {?} */

              var tmlpOutlet = cachedData.owner;
              return {
                $implicit: rowData,
                moveView: view,
                owner: tmlpOutlet,
                index: this.dataView.indexOf(rowData)
              };
            } else {
              /** @type {?} */
              var rowID = this.primaryKey ? rowData.rowID : this.data.indexOf(rowData.rowID); // child rows contain unique grids, hence should have unique templates

              return {
                $implicit: rowData,
                templateID: 'childRow-' + rowID,
                index: this.dataView.indexOf(rowData)
              };
            }
          } else {
            return {
              $implicit: rowData,
              templateID: 'dataRow',
              index: this.dataView.indexOf(rowData)
            };
          }
        }
        /**
         * @hidden
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */

      }, {
        key: "getDragGhostCustomTemplate",

        /**
         * @hidden
         * \@internal
         * @return {?}
         */
        value: function getDragGhostCustomTemplate() {
          if (this.parentIsland) {
            return this.parentIsland.getDragGhostCustomTemplate();
          }

          return _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "getDragGhostCustomTemplate", this).call(this);
        }
        /**
         * @hidden
         * @protected
         * @param {?} collection
         * @param {?=} cb
         * @return {?}
         */

      }, {
        key: "initColumns",
        value: function initColumns(collection) {
          var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (this.hasColumnLayouts) {
            // invalid configuration - hierarchical grid should not allow column layouts
            // remove column layouts

            /** @type {?} */
            var nonColumnLayoutColumns = this.columnList.filter(function (col) {
              return !col.columnLayout && !col.columnLayoutChild;
            });
            this.columnList.reset(nonColumnLayoutColumns);
          }

          _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "initColumns", this).call(this, collection, cb);
        }
        /**
         * @hidden
         * Gets the visible content height that includes header + tbody + footer.
         * For hierarchical child grid it may be scrolled and not fully visible.
         * @return {?}
         */

      }, {
        key: "getVisibleContentHeight",
        value: function getVisibleContentHeight() {
          /** @type {?} */
          var height = _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "getVisibleContentHeight", this).call(this);

          if (this.parent) {
            /** @type {?} */
            var rootHeight = this.rootGrid.getVisibleContentHeight();
            /** @type {?} */

            var topDiff = this.nativeElement.getBoundingClientRect().top - this.rootGrid.nativeElement.getBoundingClientRect().top;
            height = rootHeight - topDiff > height ? height : rootHeight - topDiff;
          }

          return height;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "toggleAll",
        value: function toggleAll() {
          /** @type {?} */
          var expanded = this.hierarchicalState.length > 0 && this.hasExpandableChildren;

          if (!expanded && this.showExpandAll) {
            this.expandAll();
          } else {
            this.collapseAll();
          }
        }
        /**
         * Collapses all rows of the current hierarchical grid.
         * ```typescript
         * this.grid.collapseAll();
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */

      }, {
        key: "collapseAll",
        value: function collapseAll() {
          this.hierarchicalState = [];
        }
        /**
         * Expands all rows of the current hierarchical grid.
         * ```typescript
         * this.grid.expandAll();
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */

      }, {
        key: "expandAll",
        value: function expandAll() {
          var _this350 = this;

          if (this.data) {
            this.hierarchicalState = this.data.map(function (rec) {
              return {
                rowID: _this350.primaryKey ? rec[_this350.primaryKey] : rec
              };
            });
          }
        }
        /**
         * @hidden
         * @param {?} record
         * @return {?}
         */

      }, {
        key: "isExpanded",
        value: function isExpanded(record) {
          var _this351 = this;

          /** @type {?} */
          var inState;

          if (record.childGridsData !== undefined) {
            inState = !!this.hierarchicalState.find(function (v) {
              return v.rowID === record.rowID;
            });
          } else {
            inState = !!this.hierarchicalState.find(function (v) {
              return _this351.primaryKey ? v.rowID === record[_this351.primaryKey] : v.rowID === record;
            });
          }

          return inState && this.childLayoutList.length !== 0;
        }
        /**
         * @hidden
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "viewCreatedHandler",
        value: function viewCreatedHandler(args) {
          if (this.isChildGridRecord(args.context.$implicit)) {
            /** @type {?} */
            var key = args.context.$implicit.rowID;
            this.childGridTemplates.set(key, args);
          }
        }
        /**
         * @hidden
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "viewMovedHandler",
        value: function viewMovedHandler(args) {
          var _this352 = this;

          if (this.isChildGridRecord(args.context.$implicit)) {
            // view was moved, update owner in cache

            /** @type {?} */
            var key = args.context.$implicit.rowID;
            /** @type {?} */

            var cachedData = this.childGridTemplates.get(key);
            cachedData.owner = args.owner;
            this.childLayoutList.forEach(function (layout) {
              /** @type {?} */
              var relatedGrid = _this352.hgridAPI.getChildGridByID(layout.key, args.context.$implicit.rowID);

              if (relatedGrid && relatedGrid.updateOnRender) {
                // Detect changes if `expandChildren` has changed when the grid wasn't visible. This is for performance reasons.
                relatedGrid.notifyChanges(true);
                relatedGrid.updateOnRender = false;
              }
            });
            /** @type {?} */

            var childGrids = this.getChildGrids(true);
            childGrids.forEach(function (grid) {
              if (grid.isPercentWidth) {
                grid.notifyChanges(true);
              }

              grid.updateScrollPosition();
            });
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "updateScrollPosition",
        value: function updateScrollPosition() {
          /** @type {?} */
          var vScr = this.verticalScrollContainer.getScroll();
          /** @type {?} */

          var hScr = this.headerContainer.getScroll();

          if (vScr) {
            vScr.scrollTop = this.scrollTop;
          }

          if (hScr) {
            hScr.scrollLeft = this.scrollLeft;
          }
        }
        /**
         * @protected
         * @param {?=} inDeph
         * @return {?}
         */

      }, {
        key: "getChildGrids",
        value: function getChildGrids(inDeph) {
          return this.hgridAPI.getChildGrids(inDeph);
        }
        /**
         * @protected
         * @param {?} data
         * @return {?}
         */

      }, {
        key: "generateDataFields",
        value: function generateDataFields(data) {
          var _this353 = this;

          return _get(_getPrototypeOf(IgxHierarchicalGridComponent.prototype), "generateDataFields", this).call(this, data).filter(function (field) {
            /** @type {?} */
            var layoutsList = _this353.parentIsland ? _this353.parentIsland.children : _this353.childLayoutList;
            /** @type {?} */

            var keys = layoutsList.map(function (item) {
              return item.key;
            });
            return keys.indexOf(field) === -1;
          });
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "hg_verticalScrollHandler",
        value: function hg_verticalScrollHandler(event) {
          this.scrollTop = event.target.scrollTop;
        }
        /**
         * @return {?}
         */

      }, {
        key: "onContainerScroll",
        value: function onContainerScroll() {
          this.hideOverlays();
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "hg_horizontalScrollHandler",
        value: function hg_horizontalScrollHandler(event) {
          this.scrollLeft = event.target.scrollLeft;
        }
      }, {
        key: "id",
        get: function get() {
          return this.h_id;
        }
        /**
         * An \@Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "data",
        set: function set(value) {
          this._data = value || [];
          this.summaryService.clearSummaryCache();

          if (this.shouldGenerate) {
            this.setupColumns();
            this.reflow();
          }

          this.cdr.markForCheck();

          if (this.parent && (this.height === null || this.height.indexOf('%') !== -1)) {
            // If the height will change based on how much data there is, recalculate sizes in igxForOf.
            this.notifyChanges(true);
          }
        }
        /**
         * Returns an array of data set to the `IgxHierarchicalGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */
        ,
        get: function get() {
          return this._data;
        }
        /**
         * Sets the state of the `IgxHierarchicalGridComponent` containing which rows are expanded.
         * ```typescript
         * this.gridState = [{ rowID: 1 }, { rowID: 4}];
         * ```
         * ```html
         * <igx-hierarchical-grid [primaryKey]="'ID'" [data]="Data" [autoGenerate]="false" [hierarchicalState]="hgridState">
         *      <igx-column field="ID"  [dataType]='number'></igx-column>
         *      <igx-column field="Product"  [dataType]='string'></igx-column>
         *      <igx-column field="Description"  [dataType]='string'></igx-column>
         * </igx-hierarchical-grid>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-hierarchical-grid [primaryKey]="'ID'" [data]="Data" [autoGenerate]="false" [(hierarchicalState)]="hgridState">
         *      <igx-column field="ID"  [dataType]='number'></igx-column>
         *      <igx-column field="Product"  [dataType]='string'></igx-column>
         *      <igx-column field="Description"  [dataType]='string'></igx-column>
         * </igx-hierarchical-grid>
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */

      }, {
        key: "hierarchicalState",
        get: function get() {
          return this._hierarchicalState;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          var _this354 = this;

          if (this._hierarchicalState !== val) {
            this.hierarchicalStateChange.emit(val);
          }

          if (this.hasChildrenKey) {
            val = val.filter(function (item) {
              /** @type {?} */
              var rec = _this354.primaryKey ? _this354.data.find(function (x) {
                return x[_this354.primaryKey] === item.rowID;
              }) : item.rowID;
              return rec[_this354.hasChildrenKey];
            });
          }

          this._hierarchicalState = val;

          if (this.parent) {
            this.notifyChanges(true);
          }
        }
        /**
         * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "filteredData",
        set: function set(value) {
          this._filteredData = value;
        }
        /**
         * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */
        ,
        get: function get() {
          return this._filteredData;
        }
        /**
         * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.
         * Defult value is false.
         * ```html
         * <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" [expandChildren]="true"></igx-hierarchical-grid>
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "expandChildren",
        set: function set(value) {
          var _this355 = this;

          this._expandChildren = value;

          if (value && this.data) {
            this.hierarchicalState = this.data.map(function (rec) {
              return {
                rowID: _this355.primaryKey ? rec[_this355.primaryKey] : rec
              };
            });
          } else if (this.data) {
            this.hierarchicalState = [];
          }
        }
        /**
         * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.
         * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.
         * ```typescript
         * const expanded = this.grid.expandChildren;
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */
        ,
        get: function get() {
          return this._expandChildren;
        }
        /**
         * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the
         * parent grid is set or an object reference of the parent record otherwise.
         * ```typescript
         * const foreignKey = this.grid.foreignKey;
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */

      }, {
        key: "foreignKey",
        get: function get() {
          if (!this.parent) {
            return null;
          }

          return this.parent.hgridAPI.getParentRowId(this);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hasExpandableChildren",
        get: function get() {
          return !!this.childLayoutKeys.length;
        }
      }, {
        key: "outletDirective",
        get: function get() {
          return this.rootGrid._outletDirective;
        }
      }, {
        key: "template",
        get: function get() {
          if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
          }

          if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
          }

          if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
          }
        }
      }, {
        key: "rootGrid",
        get: function get() {
          /** @type {?} */
          var currGrid =
          /** @type {?} */
          this;

          while (currGrid.parent) {
            currGrid = currGrid.parent;
          }

          return currGrid;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "iconTemplate",
        get: function get() {
          /** @type {?} */
          var expanded = this.hierarchicalState.length > 0 && this.hasExpandableChildren;

          if (!expanded && this.showExpandAll) {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
          } else {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
          }
        }
      }]);

      return IgxHierarchicalGridComponent;
    }(IgxHierarchicalGridBaseComponent);

    IgxHierarchicalGridComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-hierarchical-grid',
        template: "<igx-grid-toolbar role=\"rowgroup\" [style.flex-basis.px]=\"outerWidth\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n                <div #headerHierarchyExpander (click)=\"toggleAll()\" [hidden]='!hasExpandableChildren || !hasVisibleColumns' [ngClass]=\"{\n                    'igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header': hasExpandableChildren,\n                    'igx-grid__hierarchical-expander--push': filteringService.isFilterRowVisible,\n                    'igx-grid__hierarchical-expander--no-border': isRowSelectable || rowDraggable\n                }\">\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n            </div>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                        'igx-grid__drag-indicator--header': !isRowSelectable\n                    }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                        'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                    }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter,\n                                        selectAll: selectAllRows.bind(this),\n                                        deselectAll: deselectAllRows.bind(this) }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" role=\"rowgroup\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:id:pipeTrigger\n        | gridHierarchicalPaging:page:perPage:id:pipeTrigger\n        | gridHierarchical:hierarchicalState:id:primaryKey:childLayoutKeys:pipeTrigger\" let-rowIndex=\"index\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template))'\n                [igxTemplateOutletContext]='getContext(rowData)' (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)' (onCachedViewLoaded)='cachedViewLoaded($event)' (onBeforeViewDetach)='viewDetachHandler($event)'></ng-template>\n            <!-- <ng-container *igxTemplateOutlet=\"(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template)); context: getContext(rowData)\"></ng-container> -->\n        </ng-template>\n        <ng-template #hierarchical_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n        <ng-template #child_record_template let-rowIndex=\"index\" let-rowData>\n            <div style=\"overflow:auto;width: 100%;\" [attr.data-rowindex]='rowIndex' (scroll)='onContainerScroll()'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr--highlighted':isRowHighlighted(rowData)\n            }\">\n                <igx-child-grid-row *ngFor=\"let layout of childLayoutList\" [parentGridID]=\"id\" [index]=\"rowIndex\"\n                    [rowData]=\"rowData\" [layout]='layout' #row>\n                </igx-child-grid-row>\n            </div>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n            id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" fontSet=\"material\">unfold_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" [isActive]='hierarchicalState.length > 0 && hasExpandableChildren' [isActive]='true' fontSet=\"material\">unfold_less</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
        providers: [IgxGridSelectionService, IgxGridCRUDService, {
          provide: GridBaseAPIService,
          useClass: IgxHierarchicalGridAPIService
        }, {
          provide: IgxGridBaseComponent,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxHierarchicalGridComponent;
          })
        }, IgxGridSummaryService, IgxFilteringService, IgxHierarchicalGridNavigationService, IgxForOfSyncService, IgxForOfScrollSyncService]
      }]
    }];
    /** @nocollapse */

    IgxHierarchicalGridComponent.ctorParameters = function () {
      return [{
        type: IgxGridSelectionService
      }, {
        type: IgxGridCRUDService
      }, {
        type: IgxColumnResizingService
      }, {
        type: GridBaseAPIService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxGridTransaction]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ComponentFactoryResolver"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"]
      }, {
        type: IgxHierarchicalGridNavigationService
      }, {
        type: IgxFilteringService
      }, {
        type: IgxOverlayService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IgxOverlayService]
        }]
      }, {
        type: IgxGridSummaryService
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [DisplayDensityToken]
        }]
      }];
    };

    IgxHierarchicalGridComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      data: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hierarchicalState: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      hierarchicalStateChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      expandChildren: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      childLayoutList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxRowIslandComponent, {
          read: IgxRowIslandComponent,
          descendants: false
        }]
      }],
      allLayoutList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [IgxRowIslandComponent, {
          read: IgxRowIslandComponent,
          descendants: true
        }]
      }],
      hierarchicalRecordTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['hierarchical_record_template', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      childTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['child_record_template', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      headerHierarchyExpander: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['headerHierarchyExpander', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": true
        }]
      }],
      templateOutlets: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxTemplateOutletDirective, {
          read: IgxTemplateOutletDirective
        }]
      }],
      hierarchicalRows: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxChildGridRowComponent, {
          read: IgxChildGridRowComponent
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxHierarchicalGridCellComponent =
    /*#__PURE__*/
    function (_IgxGridCellComponent2) {
      _inherits(IgxHierarchicalGridCellComponent, _IgxGridCellComponent2);

      /**
       * @param {?} selectionService
       * @param {?} crudService
       * @param {?} gridAPI
       * @param {?} cdr
       * @param {?} helement
       * @param {?} zone
       * @param {?} touchManager
       * @param {?} platformUtil
       */
      function IgxHierarchicalGridCellComponent(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil) {
        var _this356;

        _classCallCheck(this, IgxHierarchicalGridCellComponent);

        _this356 = _possibleConstructorReturn(this, _getPrototypeOf(IgxHierarchicalGridCellComponent).call(this, selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil));
        _this356.selectionService = selectionService;
        _this356.crudService = crudService;
        _this356.gridAPI = gridAPI;
        _this356.cdr = cdr;
        _this356.helement = helement;
        _this356.zone = zone;
        _this356.platformUtil = platformUtil; // this.hSelection = <IgxHierarchicalSelectionAPIService>selection;

        return _this356;
      }
      /**
       * @return {?}
       */


      _createClass(IgxHierarchicalGridCellComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          _get(_getPrototypeOf(IgxHierarchicalGridCellComponent.prototype), "ngOnInit", this).call(this);

          this._rootGrid = this._getRootGrid();
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getRootGrid",
        value: function _getRootGrid() {
          /** @type {?} */
          var currGrid = this.grid;

          while (currGrid.parent) {
            currGrid = currGrid.parent;
          }

          return currGrid;
        } // TODO: Extend the new selection service to avoid complete traversal

        /**
         * @return {?}
         */

      }, {
        key: "_clearAllHighlights",
        value: function _clearAllHighlights() {
          [this._rootGrid].concat(_toConsumableArray(this._rootGrid.getChildGrids(true))).forEach(function (grid) {
            grid.selectionService.clear();
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
          });
        }
        /**
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus(event) {
          this._clearAllHighlights();
          /** @type {?} */


          var currentElement = this.grid.nativeElement;
          /** @type {?} */

          var parentGrid = this.grid;
          /** @type {?} */

          var childGrid; // add highligh to the current grid

          if (this._rootGrid.id !== currentElement.id) {
            currentElement.classList.add('igx-grid__tr--highlighted');
          } // add highligh to the current grid


          while (this._rootGrid.id !== parentGrid.id) {
            childGrid = parentGrid;
            parentGrid = parentGrid.parent;
            /** @type {?} */

            var parentRowID = parentGrid.hgridAPI.getParentRowId(childGrid);
            parentGrid.highlightedRowID = parentRowID;
          }

          _get(_getPrototypeOf(IgxHierarchicalGridCellComponent.prototype), "onFocus", this).call(this, event);
        } // TODO: Refactor

        /**
         * @hidden
         * \@internal
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          var _this357 = this;

          /** @type {?} */
          var key = event.key.toLowerCase();

          if (event.altKey && !this.row.added) {
            /** @type {?} */
            var grid = this.gridAPI.grid;
            /** @type {?} */

            var state = this.gridAPI.grid.hierarchicalState;
            /** @type {?} */

            var collapse = this.row.expanded && (key === 'left' || key === 'arrowleft' || key === 'up' || key === 'arrowup');
            /** @type {?} */

            var expand = !this.row.expanded && (key === 'right' || key === 'arrowright' || key === 'down' || key === 'arrowdown');

            if (collapse) {
              grid.hierarchicalState = state.filter(function (v) {
                return v.rowID !== _this357.row.rowID;
              });
            } else if (expand) {
              state.push({
                rowID: this.row.rowID
              });
              grid.hierarchicalState = _toConsumableArray(state);
            }

            if (expand || collapse) {
              /** @type {?} */
              var rowID = this.cellID.rowID;
              grid.cdr.detectChanges();
              this.persistFocusedCell(rowID);
            }

            return;
          }

          _get(_getPrototypeOf(IgxHierarchicalGridCellComponent.prototype), "dispatchEvent", this).call(this, event);
        }
        /**
         * @protected
         * @param {?} rowID
         * @return {?}
         */

      }, {
        key: "persistFocusedCell",
        value: function persistFocusedCell(rowID) {
          var _this358 = this;

          requestAnimationFrame(function () {
            // TODO: Test it out

            /** @type {?} */
            var cell = _this358.gridAPI.get_cell_by_key(rowID, _this358.column.field);

            if (cell) {
              cell.nativeElement.focus();
            }
          });
        }
      }]);

      return IgxHierarchicalGridCellComponent;
    }(IgxGridCellComponent);

    IgxHierarchicalGridCellComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-hierarchical-grid-cell',
        template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"focused\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n            [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n",
        providers: [HammerGesturesManager]
      }]
    }];
    /** @nocollapse */

    IgxHierarchicalGridCellComponent.ctorParameters = function () {
      return [{
        type: IgxGridSelectionService
      }, {
        type: IgxGridCRUDService
      }, {
        type: GridBaseAPIService
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: HammerGesturesManager
      }, {
        type: PlatformUtil
      }];
    };

    IgxHierarchicalGridCellComponent.propDecorators = {
      onFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus', ['$event']]
      }],
      dispatchEvent: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown', ['$event']]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxHierarchicalRowComponent =
    /*#__PURE__*/
    function (_IgxRowComponent3) {
      _inherits(IgxHierarchicalRowComponent, _IgxRowComponent3);

      function IgxHierarchicalRowComponent() {
        var _this359;

        _classCallCheck(this, IgxHierarchicalRowComponent);

        _this359 = _possibleConstructorReturn(this, _getPrototypeOf(IgxHierarchicalRowComponent).apply(this, arguments));
        /**
         * @hidden
         */

        _this359.tabindex = 0;
        /**
         * @hidden
         * \@internal
         */

        _this359.select = function () {
          _this359.grid.selectRows([_this359.rowID]);
        };
        /**
         * @hidden
         * \@internal
         */


        _this359.deselect = function () {
          _this359.grid.deselectRows([_this359.rowID]);
        };

        return _this359;
      }
      /**
       * @return {?}
       */


      _createClass(IgxHierarchicalRowComponent, [{
        key: "expanderClick",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function expanderClick(event) {
          event.stopPropagation();
          this.toggle();
        }
        /**
         * Toggles the hierarchical row.
         * ```typescript
         * this.grid1.rowList.first.toggle()
         * ```
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          var _this360 = this;

          if (this.added) {
            return;
          }
          /** @type {?} */


          var grid = this.gridAPI.grid;
          this.endEdit(grid.rootGrid);
          /** @type {?} */

          var state = this.gridAPI.grid.hierarchicalState;

          if (!this.expanded) {
            state.push({
              rowID: this.rowID
            });
            grid.hierarchicalState = _toConsumableArray(state);
          } else {
            grid.hierarchicalState = state.filter(function (v) {
              return v.rowID !== _this360.rowID;
            });
          }

          grid.cdr.detectChanges();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "endEdit",

        /**
         * @private
         * @param {?} grid
         * @return {?}
         */
        value: function endEdit(grid) {
          if (grid.crudService.inEditMode) {
            grid.endEdit();
          }

          grid.hgridAPI.getChildGrids(true).forEach(function (g) {
            if (g.crudService.inEditMode) {
              g.endEdit();
            }
          });
        }
      }, {
        key: "viewIndex",
        get: function get() {
          return this.index + this.grid.page * this.grid.perPage;
        }
        /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         * @return {?}
         */

      }, {
        key: "expanded",
        get: function get() {
          return this.grid.isExpanded(this.rowData);
        }
        /**
         * @return {?}
         */

      }, {
        key: "hasChildren",
        get: function get() {
          return !!this.grid.childLayoutKeys.length;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "highlighted",
        get: function get() {
          return this.grid && this.grid.highlightedRowID === this.rowID;
        }
      }, {
        key: "iconTemplate",
        get: function get() {
          /** @type {?} */
          var expandable = true;

          if (this.grid.hasChildrenKey) {
            expandable = this.rowData[this.grid.hasChildrenKey];
          }

          if (!expandable) {
            return this.defaultEmptyTemplate;
          }

          if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
          } else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
          }
        }
      }]);

      return IgxHierarchicalRowComponent;
    }(IgxRowComponent);

    IgxHierarchicalRowComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
        preserveWhitespaces: false,
        selector: 'igx-hierarchical-grid-row',
        template: "<div (click)=\"expanderClick($event)\" class=\"igx-grid__hierarchical-expander\" [tabIndex]=\"tabindex\" *ngIf=\"hasChildren\" #expander>\n        <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n        </ng-container>\n</div>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon [isActive]='!added' fontSet=\"material\">expand_more</igx-icon>\n    </ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon [isActive]='!added' fontSet=\"material\">chevron_right</igx-icon>\n </ng-template>\n\n <ng-template #defaultEmptyTemplate>\n    <igx-icon fontSet=\"material\"></igx-icon>\n</ng-template>\n\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n            <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: {\n                            index: viewIndex,\n                            rowID: rowID,\n                            selected: selected,\n                            select: select,\n                            deselect: deselect }}\">\n        </ng-template>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"pinnedColumns.length > 0\">\n    <igx-hierarchical-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.isLastPinned\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width.px]=\"col.width\"\n        [style.flex-basis.px]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [cellSelectionMode]=\"grid.cellSelection\">\n    </igx-hierarchical-grid-cell>\n</ng-container>\n\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"' [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-hierarchical-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width.px]=\"col.width\"\n        [style.flex-basis.px]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [cellSelectionMode]=\"grid.cellSelection\">\n    </igx-hierarchical-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            disableRipple=\"true\"\n            [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n",
        providers: [{
          provide: IgxRowComponent,
          useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
            return IgxHierarchicalRowComponent;
          })
        }]
      }]
    }];
    IgxHierarchicalRowComponent.propDecorators = {
      cells: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxHierarchicalGridCellComponent;
        }), {
          read: IgxHierarchicalGridCellComponent
        }]
      }],
      expander: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['expander', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      defaultExpandedTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultExpandedTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultEmptyTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultEmptyTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      defaultCollapsedTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultCollapsedTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      expanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__tr--expanded']
      }],
      highlighted: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-grid__tr--highlighted']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxGridHierarchicalPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxGridHierarchicalPipe(gridAPI) {
        _classCallCheck(this, IgxGridHierarchicalPipe);

        this.gridAPI = gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?=} state
       * @param {?=} id
       * @param {?=} primaryKey
       * @param {?=} childKeys
       * @param {?=} pipeTrigger
       * @return {?}
       */


      _createClass(IgxGridHierarchicalPipe, [{
        key: "transform",
        value: function transform(collection) {
          var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          var id = arguments.length > 2 ? arguments[2] : undefined;
          var primaryKey = arguments.length > 3 ? arguments[3] : undefined;
          var childKeys = arguments.length > 4 ? arguments[4] : undefined;
          var pipeTrigger = arguments.length > 5 ? arguments[5] : undefined;

          if (childKeys.length === 0) {
            return collection;
          }
          /** @type {?} */


          var grid = this.gridAPI.grid;
          /** @type {?} */

          var result = this.addHierarchy(grid, cloneArray(collection), state, primaryKey, childKeys);
          return result;
        }
        /**
         * @template T
         * @param {?} grid
         * @param {?} data
         * @param {?} state
         * @param {?} primaryKey
         * @param {?} childKeys
         * @return {?}
         */

      }, {
        key: "addHierarchy",
        value: function addHierarchy(grid, data, state, primaryKey, childKeys) {
          /** @type {?} */
          var result = [];
          data.forEach(function (v) {
            result.push(v);
            /** @type {?} */

            var childGridsData = {};
            childKeys.forEach(function (childKey) {
              /** @type {?} */
              var childData = v[childKey] ? v[childKey] : null;
              childGridsData[childKey] = childData;
            });

            if (grid.isExpanded(v)) {
              result.push({
                rowID: primaryKey ? v[primaryKey] : v,
                childGridsData: childGridsData
              });
            }
          });
          return result;
        }
      }]);

      return IgxGridHierarchicalPipe;
    }();

    IgxGridHierarchicalPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'gridHierarchical',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxGridHierarchicalPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @hidden
     */


    var IgxGridHierarchicalPagingPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} gridAPI
       */
      function IgxGridHierarchicalPagingPipe(gridAPI) {
        _classCallCheck(this, IgxGridHierarchicalPagingPipe);

        this.gridAPI = gridAPI;
      }
      /**
       * @param {?} collection
       * @param {?=} page
       * @param {?=} perPage
       * @param {?=} id
       * @param {?=} pipeTrigger
       * @return {?}
       */


      _createClass(IgxGridHierarchicalPagingPipe, [{
        key: "transform",
        value: function transform(collection) {
          var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var perPage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 15;
          var id = arguments.length > 3 ? arguments[3] : undefined;
          var pipeTrigger = arguments.length > 4 ? arguments[4] : undefined;

          if (!this.gridAPI.grid.paging) {
            return collection;
          }
          /** @type {?} */


          var state = {
            index: page,
            recordsPerPage: perPage
          };
          /** @type {?} */

          var result = DataUtil.page(cloneArray(collection), state);
          this.gridAPI.grid.pagingState = state;
          return result;
        }
      }]);

      return IgxGridHierarchicalPagingPipe;
    }();

    IgxGridHierarchicalPagingPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'gridHierarchicalPaging',
        pure: true
      }]
    }];
    /** @nocollapse */

    IgxGridHierarchicalPagingPipe.ctorParameters = function () {
      return [{
        type: GridBaseAPIService
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */


    var IgxHierarchicalGridModule = function IgxHierarchicalGridModule() {
      _classCallCheck(this, IgxHierarchicalGridModule);
    };

    IgxHierarchicalGridModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxHierarchicalGridComponent, IgxHierarchicalRowComponent, IgxRowIslandComponent, IgxChildGridRowComponent, IgxHierarchicalGridCellComponent, IgxGridHierarchicalPipe, IgxGridHierarchicalPagingPipe],
        exports: [IgxGridModule, IgxHierarchicalGridComponent, IgxHierarchicalRowComponent, IgxHierarchicalGridCellComponent, IgxRowIslandComponent, IgxChildGridRowComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"], IgxChipsModule, IgxGridModule, IgxSelectModule],
        providers: [IgxRowIslandAPIService],
        entryComponents: [IgxGridComponent]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * IgxActionIcon is a container for the action nav icon of the IgxNavbar.
     */

    var IgxActionIconDirective = function IgxActionIconDirective() {
      _classCallCheck(this, IgxActionIconDirective);
    };

    IgxActionIconDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        // tslint:disable-next-line:directive-selector
        selector: 'igx-action-icon'
      }]
    }];
    /** @type {?} */

    var NEXT_ID$p = 0;
    /**
     * **Ignite UI for Angular Navbar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navbar.html)
     *
     * The Ignite UI Navbar is most commonly used to provide an app header with a hamburger menu and navigation
     * state such as a "Go Back" button. It also supports other actions represented by icons.
     *
     * Example:
     * ```html
     * <igx-navbar title="Sample App" actionButtonIcon="menu">
     *   <igx-icon>search</igx-icon>
     *   <igx-icon>favorite</igx-icon>
     *   <igx-icon>more_vert</igx-icon>
     * </igx-navbar>
     * ```
     */

    var IgxNavbarComponent =
    /*#__PURE__*/
    function () {
      function IgxNavbarComponent() {
        _classCallCheck(this, IgxNavbarComponent);

        this.isVisible = true;
        /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-navbar [id]="'igx-navbar-12'" title="Sample App" actionButtonIcon="menu">
         * ```
         */

        this.id = "igx-navbar-".concat(NEXT_ID$p++);
        /**
         * The event that will be thrown when the action is executed,
         * provides reference to the `IgxNavbar` component as argument
         * ```typescript
         * public actionExc(event){
         *    alert("Action Execute!");
         * }
         * //..
         * ```
         * ```html
         * <igx-navbar (onAction)="actionExc($event)" title="Sample App" actionButtonIcon="menu">
         * ```
         */

        this.onAction = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An \@Input property that sets the titleId of the `IgxNavbarComponent`. If not set it will be automatically generated.
         * ```html
         * <igx-navbar [titleId]="'igx-navbar-7'" title="Sample App" actionButtonIcon="menu">
         * ```
         */

        this.titleId = "igx-navbar-".concat(IgxNavbarComponent.NEXT_ID++);
      }
      /**
       * Returns whether the `IgxNavbarComponent` action button is visible, true/false.
       * ```typescript
       * \@ViewChild("MyChild")
       * public navBar: IgxNavbarComponent;
       * ngAfterViewInit(){
       *    let actionButtonVisibile = this.navBar.isActionButtonVisible;
       * }
       * ```
       * @return {?}
       */


      _createClass(IgxNavbarComponent, [{
        key: "_triggerAction",

        /**
         * @hidden
         * @return {?}
         */
        value: function _triggerAction() {
          this.onAction.emit(this);
        }
      }, {
        key: "isActionButtonVisible",
        get: function get() {
          if (this.actionIconTemplate || !this.actionButtonIcon) {
            return false;
          }

          return this.isVisible;
        }
        /**
         * Sets whether the action button of the `IgxNavbarComponent` is visible.
         * ```html
         * <igx-navbar [title]="currentView" [isActionButtonVisible]="'false'"></igx-navbar>
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this.isVisible = value;
        }
      }]);

      return IgxNavbarComponent;
    }();

    IgxNavbarComponent.NEXT_ID = 1;
    IgxNavbarComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-navbar',
        template: "<nav class=\"igx-navbar\" role=\"navigation\" [attr.aria-labelledby]=\"titleId\">\n    <div class=\"igx-navbar__left\">\n        <igx-icon (click)=\"_triggerAction()\" fontSet=\"material\" *ngIf=\"isActionButtonVisible\">{{actionButtonIcon}}</igx-icon>\n        <ng-content select=\"igx-action-icon\"></ng-content>\n        <h1 class=\"igx-navbar__title\" [attr.id]=\"titleId\">{{ title }}</h1>\n    </div>\n    <div class=\"igx-navbar__right\">\n        <ng-content></ng-content>\n    </div>\n</nav>\n",
        styles: ["\n        :host {\n            display: block;\n        }\n    "]
      }]
    }];
    IgxNavbarComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isActionButtonVisible: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      actionButtonIcon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      title: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onAction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      titleId: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      actionIconTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxActionIconDirective, {
          read: IgxActionIconDirective,
          "static": false
        }]
      }]
    };
    /**
     * @hidden
     */

    var IgxNavbarModule = function IgxNavbarModule() {
      _classCallCheck(this, IgxNavbarModule);
    };

    IgxNavbarModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxNavbarComponent, IgxActionIconDirective],
        exports: [IgxNavbarComponent, IgxActionIconDirective],
        imports: [IgxButtonModule, IgxIconModule, _angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxNavDrawerItemDirective =
    /*#__PURE__*/
    function () {
      function IgxNavDrawerItemDirective() {
        _classCallCheck(this, IgxNavDrawerItemDirective);

        /**
         * @hidden
         */
        this.active = false;
        /**
         * @hidden
         */

        this.isHeader = false;
        /**
         * @hidden
         */

        this.activeClass = 'igx-nav-drawer__item--active';
      }
      /**
       * @hidden
       * @return {?}
       */


      _createClass(IgxNavDrawerItemDirective, [{
        key: "defaultCSS",
        get: function get() {
          return !this.active && !this.isHeader;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "currentCSS",
        get: function get() {
          return this.active && !this.isHeader;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "headerCSS",
        get: function get() {
          return this.isHeader;
        }
      }]);

      return IgxNavDrawerItemDirective;
    }();

    IgxNavDrawerItemDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxDrawerItem]',
        exportAs: 'igxDrawerItem'
      }]
    }];
    IgxNavDrawerItemDirective.propDecorators = {
      active: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['active']
      }],
      isHeader: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['isHeader']
      }],
      defaultCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-nav-drawer__item']
      }],
      currentCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-nav-drawer__item--active']
      }],
      headerCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-nav-drawer__item--header']
      }]
    };

    var IgxNavDrawerTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxNavDrawerTemplateDirective(template) {
      _classCallCheck(this, IgxNavDrawerTemplateDirective);

      this.template = template;
    };

    IgxNavDrawerTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxDrawer]'
      }]
    }];
    /** @nocollapse */

    IgxNavDrawerTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };

    var IgxNavDrawerMiniTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxNavDrawerMiniTemplateDirective(template) {
      _classCallCheck(this, IgxNavDrawerMiniTemplateDirective);

      this.template = template;
    };

    IgxNavDrawerMiniTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxDrawerMini]'
      }]
    }];
    /** @nocollapse */

    IgxNavDrawerMiniTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var NEXT_ID$q = 0;
    /**
     * **Ignite UI for Angular Navigation Drawer** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
     *
     * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
     *
     * Example:
     * ```html
     * <igx-nav-drawer id="navigation" [isOpen]="true">
     *   <ng-template igxDrawer>
     *     <nav>
     *       <span igxDrawerItem [isHeader]="true">Email</span>
     *       <span igxDrawerItem igxRipple>Inbox</span>
     *       <span igxDrawerItem igxRipple>Deleted</span>
     *       <span igxDrawerItem igxRipple>Sent</span>
     *     </nav>
     *   </ng-template>
     * </igx-nav-drawer>
     * ```
     */

    var IgxNavigationDrawerComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} _state
       * @param {?} renderer
       * @param {?} _touchManager
       * @param {?} platformUtil
       */
      function IgxNavigationDrawerComponent(elementRef, _state, renderer, _touchManager, platformUtil) {
        var _this361 = this;

        _classCallCheck(this, IgxNavigationDrawerComponent);

        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.platformUtil = platformUtil;
        this._isOpen = false;
        /**
         * @hidden \@internal
         */

        this.cssClass = true;
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */

        this.id = "igx-nav-drawer-".concat(NEXT_ID$q++);
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */

        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */

        this.enableGestures = true;
        /**
         * @hidden
         */

        this.isOpenChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */

        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */

        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */

        this.width = '280px';
        /**
         * Width of the drawer in its mini state. Defaults to 68px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */

        this.miniWidth = '68px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */

        this.pinChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"](true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */

        this.opening = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */

        this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */

        this.closing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */

        this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._gesturesAttached = false;
        this._widthCache = {
          width: null,
          miniWidth: null,
          windowWidth: null
        };
        this.css = {
          drawer: 'igx-nav-drawer__aside',
          mini: 'igx-nav-drawer__aside--mini',
          overlay: 'igx-nav-drawer__overlay',
          styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /**
         * Pan animation properties
         */

        this._panning = false;
        this._maxEdgeZone = 50;

        this.checkPinThreshold = function (evt) {
          if (!_this361.platformUtil.isBrowser) {
            return;
          }
          /** @type {?} */


          var windowWidth;

          if (_this361.pinThreshold) {
            windowWidth = _this361.getWindowWidth();

            if (evt && _this361._widthCache.windowWidth === windowWidth) {
              return;
            }

            _this361._widthCache.windowWidth = windowWidth;

            if (!_this361.pin && windowWidth >= _this361.pinThreshold) {
              _this361.pin = true;

              _this361.pinChange.emit(true);
            } else if (_this361.pin && windowWidth < _this361.pinThreshold) {
              _this361.pin = false;

              _this361.pinChange.emit(false);
            }
          }
        };

        this.swipe = function (evt) {
          // TODO: Could also force input type: http://stackoverflow.com/a/27108052
          if (!_this361.enableGestures || evt.pointerType !== 'touch') {
            return;
          } // HammerJS swipe is horizontal-only by default, don't check deltaY

          /** @type {?} */


          var deltaX;
          /** @type {?} */

          var startPosition;

          if (_this361.position === 'right') {
            // when on the right use inverse of deltaX
            deltaX = -evt.deltaX;
            startPosition = _this361.getWindowWidth() - (evt.center.x + evt.distance);
          } else {
            deltaX = evt.deltaX;
            startPosition = evt.center.x - evt.distance;
          } // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:


          if (_this361.isOpen && deltaX < 0 || // positive deltaX from the edge:
          deltaX > 0 && startPosition < _this361.maxEdgeZone) {
            _this361.toggle();
          }
        };

        this.panstart = function (evt) {
          if (!_this361.enableGestures || _this361.pin || evt.pointerType !== 'touch') {
            return;
          }
          /** @type {?} */


          var startPosition = _this361.position === 'right' ? _this361.getWindowWidth() - (evt.center.x + evt.distance) : evt.center.x - evt.distance; // cache width during animation, flag to allow further handling

          if (_this361.isOpen || startPosition < _this361.maxEdgeZone) {
            _this361._panning = true;
            _this361._panStartWidth = _this361.getExpectedWidth(!_this361.isOpen);
            _this361._panLimit = _this361.getExpectedWidth(_this361.isOpen);

            _this361.renderer.setElementClass(_this361.overlay, 'panning', true);

            _this361.renderer.setElementClass(_this361.drawer, 'panning', true);
          }
        };

        this.pan = function (evt) {
          // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
          // get actual delta (not total session one) from event?
          // pan WILL also fire after a full swipe, only resize on flag
          if (!_this361._panning) {
            return;
          }
          /** @type {?} */


          var right = _this361.position === 'right'; // when on the right use inverse of deltaX

          /** @type {?} */

          var deltaX = right ? -evt.deltaX : evt.deltaX;
          /** @type {?} */

          var visibleWidth;
          /** @type {?} */

          var newX;
          /** @type {?} */

          var percent;
          visibleWidth = _this361._panStartWidth + deltaX;

          if (_this361.isOpen && deltaX < 0) {
            // when visibleWidth hits limit - stop animating
            if (visibleWidth <= _this361._panLimit) {
              return;
            }

            if (_this361.hasAnimateWidth) {
              percent = (visibleWidth - _this361._panLimit) / (_this361._panStartWidth - _this361._panLimit);
              newX = visibleWidth;
            } else {
              percent = visibleWidth / _this361._panStartWidth;
              newX = evt.deltaX;
            }

            _this361.setXSize(newX, percent.toPrecision(2));
          } else if (!_this361.isOpen && deltaX > 0) {
            // when visibleWidth hits limit - stop animating
            if (visibleWidth >= _this361._panLimit) {
              return;
            }

            if (_this361.hasAnimateWidth) {
              percent = (visibleWidth - _this361._panStartWidth) / (_this361._panLimit - _this361._panStartWidth);
              newX = visibleWidth;
            } else {
              percent = visibleWidth / _this361._panLimit;
              newX = (_this361._panLimit - visibleWidth) * (right ? 1 : -1);
            }

            _this361.setXSize(newX, percent.toPrecision(2));
          }
        };

        this.panEnd = function (evt) {
          if (_this361._panning) {
            /** @type {?} */
            var deltaX = _this361.position === 'right' ? -evt.deltaX : evt.deltaX;
            /** @type {?} */

            var visibleWidth = _this361._panStartWidth + deltaX;

            _this361.resetPan(); // check if pan brought the drawer to 50%


            if (_this361.isOpen && visibleWidth <= _this361._panStartWidth / 2) {
              _this361.close();
            } else if (!_this361.isOpen && visibleWidth >= _this361._panLimit / 2) {
              _this361.open();
            }

            _this361._panStartWidth = null;
          }
        };

        this.toggleOpenedEvent = function (evt) {
          _this361.elementRef.nativeElement.removeEventListener('transitionend', _this361.toggleOpenedEvent, false);

          _this361.opened.emit();
        };

        this.toggleClosedEvent = function (evt) {
          _this361.elementRef.nativeElement.removeEventListener('transitionend', _this361.toggleClosedEvent, false);

          _this361.closed.emit();
        };
      }
      /**
       * State of the drawer.
       *
       * ```typescript
       * // get
       * let navDrawerIsOpen = this.navdrawer.isOpen;
       * ```
       *
       * ```html
       * <!--set-->
       * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
       * ```
       *
       * Two-way data binding.
       * ```html
       * <!--set-->
       * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
       * ```
       * @return {?}
       */


      _createClass(IgxNavigationDrawerComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          // DOM and @Input()-s initialized
          if (this._state) {
            this._state.add(this.id, this);
          }

          if (this.isOpen) {
            this.setDrawerWidth(this.width);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterContentInit",
        value: function ngAfterContentInit() {
          // wait for template and ng-content to be ready
          this.updateEdgeZone();
          this.checkPinThreshold();
          this.ensureEvents(); // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
          // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._touchManager.destroy();

          if (this._state) {
            this._state.remove(this.id);
          }

          if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
          }
        }
        /**
         * @hidden
         * @param {?} changes
         * @return {?}
         */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
          if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
          }

          if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');

            if (this.pin) {
              this._touchManager.destroy();

              this._gesturesAttached = false;
            } else {
              this.ensureEvents();
            }
          }

          if (changes.pinThreshold) {
            if (this.pinThreshold) {
              this.ensureEvents();
              this.checkPinThreshold();
            }
          }

          if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
          }

          if (changes.miniWidth) {
            if (!this.isOpen) {
              this.setDrawerWidth(changes.miniWidth.currentValue);
            }

            this.updateEdgeZone();
          }
        }
        /**
         * Toggle the open state of the Navigation Drawer.
         *
         * ```typescript
         * this.navdrawer.toggle();
         * ```
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          if (this.isOpen) {
            this.close();
          } else {
            this.open();
          }
        }
        /**
         * Open the Navigation Drawer. Has no effect if already opened.
         *
         * ```typescript
         * this.navdrawer.open();
         * ```
         * @return {?}
         */

      }, {
        key: "open",
        value: function open() {
          if (this._panning) {
            this.resetPan();
          }

          if (this.isOpen) {
            return;
          }

          this.opening.emit();
          this.isOpen = true; // TODO: Switch to animate API when available
          // var animationCss = this.animate.css();
          //     animationCss
          //         .setStyles({'width':'50px'}, {'width':'400px'})
          //         .start(this.elementRef.nativeElement)
          //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));

          this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
          this.setDrawerWidth(this.width);
        }
        /**
         * Close the Navigation Drawer. Has no effect if already closed.
         *
         * ```typescript
         * this.navdrawer.close();
         * ```
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          if (this._panning) {
            this.resetPan();
          }

          if (!this.isOpen) {
            return;
          }

          this.closing.emit();
          this.isOpen = false;
          this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
          this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
        }
        /**
         * @hidden
         * @protected
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "set_maxEdgeZone",
        value: function set_maxEdgeZone(value) {
          this._maxEdgeZone = value;
        }
        /**
         * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
         *
         * @hidden
         * @protected
         * @param {?=} mini
         * @return {?}
         */

      }, {
        key: "getExpectedWidth",
        value: function getExpectedWidth(mini) {
          if (mini) {
            if (!this.miniTemplate) {
              return 0;
            }

            if (this.miniWidth) {
              return parseFloat(this.miniWidth);
            } else {
              // if (!this.isOpen) { // This WON'T work due to transition timings...
              //     return this.elementRef.nativeElement.children[1].offsetWidth;
              // } else {
              if (this._widthCache.miniWidth === null) {
                // force class for width calc. TODO?
                this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                this.renderer.setElementClass(this.styleDummy, this.css.mini, true);
                this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
                this.renderer.setElementClass(this.styleDummy, this.css.mini, false);
              }

              return this._widthCache.miniWidth;
            }
          } else {
            if (this.width) {
              return parseFloat(this.width);
            } else {
              if (this._widthCache.width === null) {
                // force class for width calc. TODO?
                this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                this._widthCache.width = this.styleDummy.offsetWidth;
                this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
              }

              return this._widthCache.width;
            }
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "getWindowWidth",
        value: function getWindowWidth() {
          return window.innerWidth > 0 ? window.innerWidth : screen.width;
        }
        /**
         * Sets the drawer width.
         * @private
         * @param {?} width
         * @return {?}
         */

      }, {
        key: "setDrawerWidth",
        value: function setDrawerWidth(width) {
          var _this362 = this;

          if (this.platformUtil.isBrowser) {
            requestAnimationFrame(function () {
              if (_this362.drawer) {
                _this362.renderer.setElementStyle(_this362.drawer, 'width', width);
              }
            });
          } else {
            this.renderer.setElementStyle(this.drawer, 'width', width);
          }
        }
        /**
         * Get current Drawer width.
         * @private
         * @return {?}
         */

      }, {
        key: "getDrawerWidth",
        value: function getDrawerWidth() {
          return this.drawer.offsetWidth;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "ensureEvents",
        value: function ensureEvents() {
          var _this363 = this;

          // set listeners for swipe/pan only if needed, but just once
          if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);

            this._gesturesAttached = true; // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);

            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);

            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);

            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
          }

          if (!this._resizeObserver && this.platformUtil.isBrowser) {
            this._resizeObserver = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(window, 'resize').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["debounce"])(function () {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(150);
            })).subscribe(function (value) {
              _this363.checkPinThreshold(value);
            });
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "updateEdgeZone",
        value: function updateEdgeZone() {
          /** @type {?} */
          var maxValue;

          if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "resetPan",
        value: function resetPan() {
          this._panning = false;
          /* styles fail to apply when set on parent due to extra attributes, prob ng bug */

          this.renderer.setElementClass(this.overlay, 'panning', false);
          this.renderer.setElementClass(this.drawer, 'panning', false);
          this.setXSize(0, '');
        }
        /**
         * Sets the absolute position or width in case the drawer doesn't change position.
         * @private
         * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
         * @param {?=} opacity optional value to apply to the overlay
         * @return {?}
         */

      }, {
        key: "setXSize",
        value: function setXSize(x, opacity) {
          var _this364 = this;

          // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
          window.requestAnimationFrame(function () {
            if (_this364.hasAnimateWidth) {
              _this364.renderer.setElementStyle(_this364.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            } else {
              /** @type {?} */
              var transform = x ? 'translate3d(' + x + 'px,0,0)' : '';

              _this364.renderer.setElementStyle(_this364.drawer, 'transform', transform);

              _this364.renderer.setElementStyle(_this364.drawer, '-webkit-transform', transform);
            }

            if (opacity !== undefined) {
              _this364.renderer.setElementStyle(_this364.overlay, 'opacity', opacity);
            }
          });
        }
      }, {
        key: "isOpen",
        get: function get() {
          return this._isOpen;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._isOpen = value;
          this.isOpenChange.emit(this._isOpen);
        }
        /**
         * Returns nativeElement of the component.
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "element",
        get: function get() {
          return this.elementRef.nativeElement;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "template",
        get: function get() {
          if (this.miniTemplate && !this.isOpen) {
            return this.miniTemplate.template;
          } else if (this.contentTemplate) {
            return this.contentTemplate.template;
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "miniTemplate",
        get: function get() {
          return this._miniTemplate;
        }
        /**
         * @hidden
         * @param {?} v
         * @return {?}
         */
        ,
        set: function set(v) {
          if (!this.isOpen) {
            this.setDrawerWidth(v ? this.miniWidth : '');
          }

          this._miniTemplate = v;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "flexWidth",
        get: function get() {
          if (!this.pin) {
            return '0px';
          }

          if (this.isOpen) {
            return this.width;
          }

          if (this.miniTemplate && this.miniWidth) {
            return this.miniWidth;
          }

          return '0px';
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "isPinnedRight",
        get: function get() {
          return this.pin && this.position === 'right' ? '1' : '0';
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "drawer",
        get: function get() {
          return this._drawer.nativeElement;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "overlay",
        get: function get() {
          return this._overlay.nativeElement;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "styleDummy",
        get: function get() {
          return this._styleDummy.nativeElement;
        }
        /**
         * Property to decide whether to change width or translate the drawer from pan gesture.
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "hasAnimateWidth",
        get: function get() {
          return this.pin || !!this.miniTemplate;
        }
        /**
         * Used for touch gestures (swipe and pan).
         * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "maxEdgeZone",
        get: function get() {
          return this._maxEdgeZone;
        }
        /**
         * Gets the Drawer width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "expectedWidth",
        get: function get() {
          return this.getExpectedWidth(false);
        }
        /**
         * Get the Drawer mini width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "expectedMiniWidth",
        get: function get() {
          return this.getExpectedWidth(true);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "touchManager",
        get: function get() {
          return this._touchManager;
        }
        /**
         * Exposes optional navigation service
         *
         * @hidden
         * @return {?}
         */

      }, {
        key: "state",
        get: function get() {
          return this._state;
        }
      }]);

      return IgxNavigationDrawerComponent;
    }();

    IgxNavigationDrawerComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [HammerGesturesManager],
        selector: 'igx-nav-drawer',
        template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside>\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
        styles: ["\n        :host {\n            display: block;\n            height: 100%;\n        }\n    "]
      }]
    }];
    /** @nocollapse */

    IgxNavigationDrawerComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]]
        }]
      }, {
        type: IgxNavigationService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer"]
      }, {
        type: HammerGesturesManager
      }, {
        type: PlatformUtil
      }];
    };

    IgxNavigationDrawerComponent.propDecorators = {
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-nav-drawer']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      position: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      enableGestures: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isOpen: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isOpenChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      pin: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      pinThreshold: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      width: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      miniWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      pinChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      opening: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      opened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      closing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      closed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      miniTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxNavDrawerMiniTemplateDirective, {
          read: IgxNavDrawerMiniTemplateDirective,
          "static": false
        }]
      }],
      contentTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxNavDrawerTemplateDirective, {
          read: IgxNavDrawerTemplateDirective,
          "static": false
        }]
      }],
      flexWidth: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.flexBasis']
      }],
      isPinnedRight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['style.order']
      }],
      _drawer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['aside', {
          "static": true
        }]
      }],
      _overlay: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['overlay', {
          "static": true
        }]
      }],
      _styleDummy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['dummy', {
          "static": true
        }]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxNavigationDrawerModule = function IgxNavigationDrawerModule() {
      _classCallCheck(this, IgxNavigationDrawerModule);
    };

    IgxNavigationDrawerModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxNavigationDrawerComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective],
        exports: [IgxNavigationDrawerComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Template directive that allows you to set a custom template representing the lower label value of the {\@link IgxSliderComponent}
     *
     * ```html
     * <igx-slider>
     *  <ng-template igxSliderThumbFrom let-value let-labels>{{value}}</ng-template>
     * </igx-slider>
     * ```
     *
     * \@context {\@link IgxSliderComponent.context}
     */

    var IgxThumbFromTemplateDirective = function IgxThumbFromTemplateDirective() {
      _classCallCheck(this, IgxThumbFromTemplateDirective);
    };

    IgxThumbFromTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxSliderThumbFrom]'
      }]
    }];
    /**
     * Template directive that allows you to set a custom template representing the upper label value of the {\@link IgxSliderComponent}
     *
     * ```html
     * <igx-slider>
     *  <ng-template igxSliderThumbTo let-value let-labels>{{value}}</ng-template>
     * </igx-slider>
     * ```
     *
     * \@context {\@link IgxSliderComponent.context}
     */

    var IgxThumbToTemplateDirective = function IgxThumbToTemplateDirective() {
      _classCallCheck(this, IgxThumbToTemplateDirective);
    };

    IgxThumbToTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxSliderThumbTo]'
      }]
    }];
    /** @enum {number} */

    var SliderType = {
      /**
       * Slider with single thumb.
       */
      SLIDER: 0,

      /**
       *  Range slider with multiple thumbs, that can mark the range.
       */
      RANGE: 1
    };
    SliderType[SliderType.SLIDER] = 'SLIDER';
    SliderType[SliderType.RANGE] = 'RANGE';
    /** @enum {number} */

    var SliderHandle = {
      FROM: 0,
      TO: 1
    };
    SliderHandle[SliderHandle.FROM] = 'FROM';
    SliderHandle[SliderHandle.TO] = 'TO';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxSliderThumbComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _elementRef
       */
      function IgxSliderThumbComponent(_elementRef) {
        _classCallCheck(this, IgxSliderThumbComponent);

        this._elementRef = _elementRef;
        this._isActive = false;
        this._isPressed = false;
        this._destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this.isActive = false;
        this.onThumbValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.onHoverChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.tabindex = 0;
        this.zIndex = 0;
      }
      /**
       * @private
       * @return {?}
       */


      _createClass(IgxSliderThumbComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          var _this365 = this;

          this.onPan.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function (mouseX) {
            return _this365.updateThumbValue(mouseX);
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroy$.next(true);

          this._destroy$.complete();
        }
        /**
         * @return {?}
         */

      }, {
        key: "onPinterEnter",
        value: function onPinterEnter() {
          this.onHoverChange.emit(true);
        }
        /**
         * @return {?}
         */

      }, {
        key: "onPointerLeave",
        value: function onPointerLeave() {
          this.onHoverChange.emit(false);
        }
        /**
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeyDown",
        value: function onKeyDown(event) {
          if (this.disabled) {
            return;
          }
          /** @type {?} */


          var increment = 0;

          if (event.key.endsWith('Left')) {
            increment = this.step * -1;
          } else if (event.key.endsWith('Right')) {
            increment = this.step;
          } else {
            return;
          }

          this.onChange.emit();
          this.onThumbValueChange.emit(increment);
        }
        /**
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur() {
          this.isActive = false;
          this.zIndex = 0;
        }
        /**
         * @return {?}
         */

      }, {
        key: "onFocusListener",
        value: function onFocusListener() {
          this.isActive = true;
          this.zIndex = 1;
        }
        /**
         * Show thumb label and ripple.
         * @return {?}
         */

      }, {
        key: "showThumbIndicators",
        value: function showThumbIndicators() {
          this.toggleThumbIndicators(true);
        }
        /**
         * Hide thumb label and ripple.
         * @return {?}
         */

      }, {
        key: "hideThumbIndicators",
        value: function hideThumbIndicators() {
          this.toggleThumbIndicators(false);
        }
        /**
         * @private
         * @param {?} mouseX
         * @return {?}
         */

      }, {
        key: "updateThumbValue",
        value: function updateThumbValue(mouseX) {
          /** @type {?} */
          var updateValue = this.calculateTrackUpdate(mouseX);

          if (this.isActive && updateValue !== 0) {
            this.onThumbValueChange.emit(updateValue);
          }
        }
        /**
         * @private
         * @param {?} mouseX
         * @return {?}
         */

      }, {
        key: "calculateTrackUpdate",
        value: function calculateTrackUpdate(mouseX) {
          /** @type {?} */
          var scaleX = mouseX - this.thumbPositionX;
          /** @type {?} */

          var stepDistanceCenter = this.stepDistance / 2; // If the thumb scale range (slider update) is less thàn a half step,
          // the position stays the same.

          /** @type {?} */

          var scaleXPositive = Math.abs(scaleX);

          if (scaleXPositive < stepDistanceCenter) {
            return 0;
          }

          return this.stepToProceed(scaleX, this.stepDistance);
        }
        /**
         * @private
         * @param {?} scaleX
         * @param {?} stepDist
         * @return {?}
         */

      }, {
        key: "stepToProceed",
        value: function stepToProceed(scaleX, stepDist) {
          return Math.round(scaleX / stepDist) * this.step;
        }
        /**
         * @private
         * @param {?} visible
         * @return {?}
         */

      }, {
        key: "toggleThumbIndicators",
        value: function toggleThumbIndicators(visible) {
          this._isPressed = visible;

          if (!this.continuous) {
            this._isActive = visible;
          }
        }
      }, {
        key: "thumbPositionX",
        get: function get() {
          /** @type {?} */
          var thumbBounderies = this.nativeElement.getBoundingClientRect();
          /** @type {?} */

          var thumbCenter = (thumbBounderies.right - thumbBounderies.left) / 2;
          return thumbBounderies.left + thumbCenter;
        }
        /**
         * @return {?}
         */

      }, {
        key: "thumbFromClass",
        get: function get() {
          return this.type === SliderHandle.FROM;
        }
        /**
         * @return {?}
         */

      }, {
        key: "thumbToClass",
        get: function get() {
          return this.type === SliderHandle.TO;
        }
        /**
         * @return {?}
         */

      }, {
        key: "thumbFromActiveClass",
        get: function get() {
          return this.type === SliderHandle.FROM && this._isActive;
        }
        /**
         * @return {?}
         */

      }, {
        key: "thumbToActiveClass",
        get: function get() {
          return this.type === SliderHandle.TO && this._isActive;
        }
        /**
         * @return {?}
         */

      }, {
        key: "thumbPressedClass",
        get: function get() {
          return this.isActive && this._isPressed;
        }
        /**
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this._elementRef.nativeElement;
        }
        /**
         * @return {?}
         */

      }, {
        key: "destroy",
        get: function get() {
          return this._destroy$;
        }
      }]);

      return IgxSliderThumbComponent;
    }();

    IgxSliderThumbComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-thumb',
        template: "<div class=\"dot\"></div>\n"
      }]
    }];
    /** @nocollapse */

    IgxSliderThumbComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxSliderThumbComponent.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      continuous: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      thumbLabelVisibilityDuration: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onPan: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      stepDistance: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      step: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      templateRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      context: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onThumbValueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onHoverChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      zIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.z-index']
      }],
      thumbFromClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider__thumb-from']
      }],
      thumbToClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider__thumb-to']
      }],
      thumbFromActiveClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider__thumb-from--active']
      }],
      thumbToActiveClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider__thumb-to--active']
      }],
      thumbPressedClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider__thumb--pressed']
      }],
      onPinterEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['pointerenter']
      }],
      onPointerLeave: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['pointerleave']
      }],
      onKeyDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown', ['$event']]
      }],
      onBlur: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['blur']
      }],
      onFocusListener: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxThumbLabelComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _elementRef
       */
      function IgxThumbLabelComponent(_elementRef) {
        _classCallCheck(this, IgxThumbLabelComponent);

        this._elementRef = _elementRef;
      }
      /**
       * @return {?}
       */


      _createClass(IgxThumbLabelComponent, [{
        key: "thumbFromClass",
        get: function get() {
          return this.type === SliderHandle.FROM;
        }
        /**
         * @return {?}
         */

      }, {
        key: "thumbToClass",
        get: function get() {
          return this.type === SliderHandle.TO;
        }
        /**
         * @return {?}
         */

      }, {
        key: "thumbFromActiveClass",
        get: function get() {
          return this.type === SliderHandle.FROM && this.active;
        }
        /**
         * @return {?}
         */

      }, {
        key: "thumbToActiveClass",
        get: function get() {
          return this.type === SliderHandle.TO && this.active;
        }
        /**
         * @return {?}
         */

      }, {
        key: "nativeElement",
        get: function get() {
          return this._elementRef.nativeElement;
        }
        /**
         * @return {?}
         */

      }, {
        key: "active",
        get: function get() {
          return this._active;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          if (this.continuous) {
            return;
          }

          this._active = val;
        }
      }]);

      return IgxThumbLabelComponent;
    }();

    IgxThumbLabelComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-thumb-label',
        template: "<div class=\"label\">\n    <ng-container *ngTemplateOutlet=\"templateRef ? templateRef : thumbFromDefaultTemplate; context: context\"></ng-container>\n</div>\n\n<ng-template #thumbFromDefaultTemplate>\n    {{ value }}\n</ng-template>\n"
      }]
    }];
    /** @nocollapse */

    IgxThumbLabelComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxThumbLabelComponent.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      templateRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      context: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      continuous: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      thumbFromClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider__label-from']
      }],
      thumbToClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider__label-to']
      }],
      thumbFromActiveClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider__label-from--active']
      }],
      thumbToActiveClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider__label-to--active']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var noop$6 = function noop$6() {};
    /** @type {?} */


    var NEXT_ID$r = 0;
    /**
     * **Ignite UI for Angular Slider** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
     *
     * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
     * can be defined as continuous or stepped, and you can choose between single and range slider types.
     *
     * Example:
     * ```html
     * <igx-slider id="slider"
     *            [minValue]="0" [maxValue]="100"
     *            [continuous]=true [(ngModel)]="volume">
     * </igx-slider>
     * ```
     */

    var IgxSliderComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} renderer
       * @param {?} _el
       * @param {?} _cdr
       */
      function IgxSliderComponent(renderer, _el, _cdr) {
        _classCallCheck(this, IgxSliderComponent);

        this.renderer = renderer;
        this._el = _el;
        this._cdr = _cdr; // Limit handle travel zone

        this._pMin = 0;
        this._pMax = 1; // From/upperValue in percent values

        this._hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._continuous = false;
        this._disabled = false;
        this._step = 1;
        this._labels = new Array();
        this._type = SliderType.SLIDER;
        this._destroyer$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._indicatorsDestroyer$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._onChangeCallback = noop$6;
        this._onTouchedCallback = noop$6;
        /**
         * @hidden
         */

        this.thumbs = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */

        this.labelRefs = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["QueryList"]();
        /**
         * @hidden
         */

        this.stepDistance = this._step;
        /**
         * @hidden
         */

        this.onPan = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        /**
         * @hidden
         */

        this.role = 'slider';
        /**
         * @hidden
         */

        this.slierClass = true;
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */

        this.id = "igx-slider-".concat(NEXT_ID$r++);
        /**
         * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */

        this.thumbLabelVisibilityDuration = 750;
        /**
         * This event is emitted when user has stopped interacting the thumb and value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */

        this.onValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * @private
       * @return {?}
       */


      _createClass(IgxSliderComponent, [{
        key: "onPointerDown",

        /**
         * @hidden
         * @param {?} $event
         * @return {?}
         */
        value: function onPointerDown($event) {
          this.findClosestThumb($event);

          if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
          }
          /** @type {?} */


          var activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbFrom;
          activeThumb.nativeElement.setPointerCapture($event.pointerId);
          this.showSliderIndicators();
          $event.preventDefault();
        }
        /**
         * @hidden
         * @param {?} $event
         * @return {?}
         */

      }, {
        key: "onPointerUp",
        value: function onPointerUp($event) {
          if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
          }
          /** @type {?} */


          var activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbTo;
          activeThumb.nativeElement.releasePointerCapture($event.pointerId);
          this.hideSliderIndicators();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus() {
          this.toggleSliderIndicators();
        }
        /**
         * @hidden
         * @param {?} $event
         * @return {?}
         */

      }, {
        key: "onPanListener",
        value: function onPanListener($event) {
          this.update($event.srcEvent.clientX);
        }
        /**
         * @return {?}
         */

      }, {
        key: "onPanStart",
        value: function onPanStart() {
          this.showSliderIndicators();
        }
        /**
         * @return {?}
         */

      }, {
        key: "onPanEnd",
        value: function onPanEnd() {
          this.hideSliderIndicators();
        }
        /**
         * Returns whether the `IgxSliderComponent` type is RANGE.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderRange = this.slider.isRange;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this.sliderSetup(); // Set track travel zone

          this._pMin = this.valueToFraction(this.lowerBound) || 0;
          this._pMax = this.valueToFraction(this.upperBound) || 1;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this366 = this;

          this._hasViewInit = true;
          this.positionHandlesAndUpdateTrack();
          this.setTickInterval(this.labels);
          this.changeThumbFocusableState(this.disabled);
          this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
          this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
          this.thumbs.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroyer$)).subscribe(function (change) {
            /** @type {?} */
            var thumbFrom = change.find(function (thumb) {
              return thumb.type === SliderHandle.FROM;
            });
            /** @type {?} */

            var labelFrom = _this366.labelRefs.find(function (label) {
              return label.type === SliderHandle.FROM;
            });

            _this366.positionHandle(thumbFrom, labelFrom, _this366.lowerValue);

            _this366.subscribeTo(thumbFrom, _this366.thumbChanged.bind(_this366));

            _this366.changeThumbFocusableState(_this366.disabled);
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterContentChecked",
        value: function ngAfterContentChecked() {
          // Calculates the distance between every step in pixels.
          this.stepDistance = this.calculateStepDistance();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroyer$.next(true);

          this._destroyer$.complete();

          this._indicatorsDestroyer$.next(true);

          this._indicatorsDestroyer$.complete();
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          if (!value) {
            return;
          }

          this.normalizeByStep(value);
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getEditElement",
        value: function getEditElement() {
          return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
        }
        /**
         *
         * @hidden
         * @param {?} mouseX
         * @return {?}
         */

      }, {
        key: "update",
        value: function update(mouseX) {
          if (this.disabled) {
            return;
          } // Update To/From Values


          this.onPan.next(mouseX); // Finally do positionHandlesAndUpdateTrack the DOM
          // based on data values

          this.positionHandlesAndUpdateTrack();

          this._onTouchedCallback();
        }
        /**
         * @hidden
         * @param {?} value
         * @param {?} thumbType
         * @return {?}
         */

      }, {
        key: "thumbChanged",
        value: function thumbChanged(value, thumbType) {
          /** @type {?} */
          var oldValue = this.value;
          /** @type {?} */

          var newVal;

          if (this.isRange) {
            if (thumbType === SliderHandle.FROM) {
              newVal = {
                lower:
                /** @type {?} */
                this.value.lower + value,
                upper:
                /** @type {?} */
                this.value.upper
              };
            } else {
              newVal = {
                lower:
                /** @type {?} */
                this.value.lower,
                upper:
                /** @type {?} */
                this.value.upper + value
              };
            } // Swap the thumbs if a collision appears.


            if (newVal.lower >= newVal.upper) {
              this.value = this.swapThumb(newVal);
            } else {
              this.value = newVal;
            }
          } else {
            this.value =
            /** @type {?} */
            this.value + value;
          }

          if (this.hasValueChanged(oldValue)) {
            this.emitValueChanged(oldValue);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onThumbChange",
        value: function onThumbChange() {
          this.toggleSliderIndicators();
        }
        /**
         * @param {?} state
         * @return {?}
         */

      }, {
        key: "onHoverChange",
        value: function onHoverChange(state) {
          return state ? this.showSliderIndicators() : this.hideSliderIndicators();
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "swapThumb",
        value: function swapThumb(value) {
          if (this.thumbFrom.isActive) {
            value.upper = this.upperValue;
            value.lower = this.upperValue;
          } else {
            value.upper = this.lowerValue;
            value.lower = this.lowerValue;
          }

          this.toggleThumb();
          return value;
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "findClosestThumb",
        value: function findClosestThumb(event) {
          if (this.isRange) {
            this.closestHandle(event);
          } else {
            this.thumbTo.nativeElement.focus();
          }

          this.update(event.clientX);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "updateLowerBoundAndMinTravelZone",
        value: function updateLowerBoundAndMinTravelZone() {
          this.lowerBound = this.minValue;
          this._pMin = 0;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "updateUpperBoundAndMaxTravelZone",
        value: function updateUpperBoundAndMaxTravelZone() {
          this.upperBound = this.maxValue;
          this._pMax = 1;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "sliderSetup",
        value: function sliderSetup() {
          /**
           * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
           */
          if (!this.isRange && this.value === this.upperBound) {
            this.value = this.lowerBound;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "calculateStepDistance",
        value: function calculateStepDistance() {
          return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "toggleThumb",
        value: function toggleThumb() {
          return this.thumbFrom.isActive ? this.thumbTo.nativeElement.focus() : this.thumbFrom.nativeElement.focus();
        }
        /**
         * @private
         * @param {?} value
         * @param {?=} min
         * @param {?=} max
         * @return {?}
         */

      }, {
        key: "valueInRange",
        value: function valueInRange(value) {
          var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
          return Math.max(Math.min(value, max), min);
        }
        /**
         * @private
         * @param {?} color
         * @param {?} interval
         * @return {?}
         */

      }, {
        key: "generateTickMarks",
        value: function generateTickMarks(color, interval) {
          return interval !== null ? "repeating-linear-gradient(\n            ".concat('to left', ",\n            ", color, ",\n            ").concat(color, " 1.5px,\n            transparent 1.5px,\n            transparent ").concat(interval, "%\n        ), repeating-linear-gradient(\n            ", 'to right', ",\n            ").concat(color, ",\n            ").concat(color, " 1.5px,\n            transparent 1.5px,\n            transparent ").concat(interval, "%\n        )") : interval;
        }
        /**
         * @private
         * @param {?} thumbHandle
         * @param {?} labelHandle
         * @param {?} position
         * @return {?}
         */

      }, {
        key: "positionHandle",
        value: function positionHandle(thumbHandle, labelHandle, position) {
          /** @type {?} */
          var positionLeft = "".concat(this.valueToFraction(position) * 100, "%");

          if (thumbHandle) {
            thumbHandle.nativeElement.style.left = positionLeft;
          }

          if (labelHandle) {
            labelHandle.nativeElement.style.left = positionLeft;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "positionHandlesAndUpdateTrack",
        value: function positionHandlesAndUpdateTrack() {
          if (!this.isRange) {
            this.positionHandle(this.thumbTo, this.labelTo,
            /** @type {?} */
            this.value);
          } else {
            this.positionHandle(this.thumbTo, this.labelTo,
            /** @type {?} */
            this.value.upper);
            this.positionHandle(this.thumbFrom, this.labelFrom,
            /** @type {?} */
            this.value.lower);
          }

          this.updateTrack();
        }
        /**
         * @private
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "closestHandle",
        value: function closestHandle(event) {
          /** @type {?} */
          var fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
          /** @type {?} */

          var toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
          /** @type {?} */

          var xPointer = event.clientX - this._el.nativeElement.getBoundingClientRect().left;
          /** @type {?} */


          var match = this.closestTo(xPointer, [fromOffset, toOffset]);

          if (fromOffset === toOffset && toOffset < xPointer) {
            this.thumbTo.nativeElement.focus();
          } else if (fromOffset === toOffset && toOffset > xPointer) {
            this.thumbFrom.nativeElement.focus();
          } else if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
          } else {
            this.thumbTo.nativeElement.focus();
          }
        }
        /**
         * @private
         * @param {?} labels
         * @return {?}
         */

      }, {
        key: "setTickInterval",
        value: function setTickInterval(labels) {
          /** @type {?} */
          var interval;
          /** @type {?} */

          var trackProgress = 100;

          if (this.labelsViewEnabled) {
            // Calc ticks depending on the labels length;
            interval = trackProgress / (this.labels.length - 1) * 10 / 10;
          } else {
            /** @type {?} */
            var trackRange = this.maxValue - this.minValue;
            interval = this.step > 1 ? trackProgress / (trackRange / this.step) * 10 / 10 : null;
          }
          /** @type {?} */


          var renderCallbackExecution = !this.continuous ? this.generateTickMarks('white', interval) : null;
          this.renderer.setStyle(this.ticks.nativeElement, 'background', renderCallbackExecution);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "showSliderIndicators",
        value: function showSliderIndicators() {
          if (this.disabled) {
            return;
          }

          if (this._indicatorsTimer) {
            this._indicatorsDestroyer$.next(true);

            this._indicatorsTimer = null;
          }

          this.thumbTo.showThumbIndicators();
          this.labelTo.active = true;

          if (this.thumbFrom) {
            this.thumbFrom.showThumbIndicators();
          }

          if (this.labelFrom) {
            this.labelFrom.active = true;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "hideSliderIndicators",
        value: function hideSliderIndicators() {
          var _this367 = this;

          if (this.disabled) {
            return;
          }

          this._indicatorsTimer = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["timer"])(this.thumbLabelVisibilityDuration);

          this._indicatorsTimer.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._indicatorsDestroyer$)).subscribe(function () {
            _this367.thumbTo.hideThumbIndicators();

            _this367.labelTo.active = false;

            if (_this367.thumbFrom) {
              _this367.thumbFrom.hideThumbIndicators();
            }

            if (_this367.labelFrom) {
              _this367.labelFrom.active = false;
            }
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "toggleSliderIndicators",
        value: function toggleSliderIndicators() {
          this.showSliderIndicators();
          this.hideSliderIndicators();
        }
        /**
         * @private
         * @param {?} state
         * @return {?}
         */

      }, {
        key: "changeThumbFocusableState",
        value: function changeThumbFocusableState(state) {
          /** @type {?} */
          var value = state ? -1 : 1;

          if (this.isRange) {
            this.thumbFrom.tabindex = value;
          }

          this.thumbTo.tabindex = value;

          this._cdr.detectChanges();
        }
        /**
         * @private
         * @param {?} goal
         * @param {?} positions
         * @return {?}
         */

      }, {
        key: "closestTo",
        value: function closestTo(goal, positions) {
          return positions.reduce(function (previous, current) {
            return Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous;
          });
        }
        /**
         * @private
         * @param {?} value
         * @param {?=} pMin
         * @param {?=} pMax
         * @return {?}
         */

      }, {
        key: "valueToFraction",
        value: function valueToFraction(value) {
          var pMin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._pMin;
          var pMax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._pMax;
          return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
        }
        /**
         * @hidden
         * Normalizе the value when two-way data bind is used and {\@link this.step} is set.
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "normalizeByStep",
        value: function normalizeByStep(value) {
          if (this.isRange) {
            this.value = {
              lower:
              /** @type {?} */
              value.lower -
              /** @type {?} */
              value.lower % this.step,
              upper:
              /** @type {?} */
              value.upper -
              /** @type {?} */
              value.upper % this.step
            };
          } else {
            this.value =
            /** @type {?} */
            value -
            /** @type {?} */
            value % this.step;
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "updateTrack",
        value: function updateTrack() {
          /** @type {?} */
          var fromPosition = this.valueToFraction(this.lowerValue);
          /** @type {?} */

          var toPosition = this.valueToFraction(this.upperValue);
          /** @type {?} */

          var positionGap = toPosition - fromPosition;
          /** @type {?} */

          var trackLeftIndention = fromPosition;

          if (this.isRange) {
            if (positionGap) {
              trackLeftIndention = Math.round(1 / positionGap * fromPosition * 100);
            }

            this.renderer.setStyle(this.track.nativeElement, 'transform', "scaleX(".concat(positionGap, ") translateX(").concat(trackLeftIndention, "%)"));
          } else {
            this.renderer.setStyle(this.track.nativeElement, 'transform', "scaleX(".concat(toPosition, ")"));
          }
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "validateInitialValue",
        value: function validateInitialValue(value) {
          if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
            value.upper = this.lowerBound;
            value.lower = this.lowerBound;
          }

          if (value.lower > this.upperBound && value.upper > this.upperBound) {
            value.upper = this.upperBound;
            value.lower = this.upperBound;
          }

          if (value.upper < value.lower) {
            value.upper = this.upperValue;
            value.lower = this.lowerValue;
          }

          return value;
        }
        /**
         * @private
         * @param {?} thumb
         * @param {?} callback
         * @return {?}
         */

      }, {
        key: "subscribeTo",
        value: function subscribeTo(thumb, callback) {
          if (!thumb) {
            return;
          }

          thumb.onThumbValueChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this.unsubscriber(thumb))).subscribe(function (value) {
            return callback(value, thumb.type);
          });
        }
        /**
         * @private
         * @param {?} thumb
         * @return {?}
         */

      }, {
        key: "unsubscriber",
        value: function unsubscriber(thumb) {
          return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(this._destroyer$, thumb.destroy);
        }
        /**
         * @private
         * @param {?} oldValue
         * @return {?}
         */

      }, {
        key: "hasValueChanged",
        value: function hasValueChanged(oldValue) {
          /** @type {?} */
          var isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
          /** @type {?} */

          var isRangeWithOneDifferentValue = this.isRange && (
          /** @type {?} */
          oldValue.lower !==
          /** @type {?} */
          this.value.lower ||
          /** @type {?} */
          oldValue.upper !==
          /** @type {?} */
          this.value.upper);
          return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
        }
        /**
         * @private
         * @param {?} oldValue
         * @return {?}
         */

      }, {
        key: "emitValueChanged",
        value: function emitValueChanged(oldValue) {
          this.onValueChange.emit({
            oldValue: oldValue,
            value: this.value
          });
        }
      }, {
        key: "thumbFrom",
        get: function get() {
          return this.thumbs.find(function (thumb) {
            return thumb.type === SliderHandle.FROM;
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "thumbTo",
        get: function get() {
          return this.thumbs.find(function (thumb) {
            return thumb.type === SliderHandle.TO;
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "labelFrom",
        get: function get() {
          return this.labelRefs.find(function (label) {
            return label.type === SliderHandle.FROM;
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "labelTo",
        get: function get() {
          return this.labelRefs.find(function (label) {
            return label.type === SliderHandle.TO;
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "valuemin",
        get: function get() {
          return this.minValue;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "valuemax",
        get: function get() {
          return this.maxValue;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "readonly",
        get: function get() {
          return this.disabled;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "disabledClass",
        get: function get() {
          return this.disabled;
        }
        /**
         * An \@Input property that gets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let type = this.slider.type;
         * }
         * @return {?}
         */

      }, {
        key: "type",
        get: function get() {
          return this._type;
        }
        /**
         * An \@Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * sliderType: SliderType = SliderType.RANGE;
         * ```
         * ```html
         * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
         * ```
         * @param {?} type
         * @return {?}
         */
        ,
        set: function set(type) {
          this._type = type;

          if (type === SliderType.SLIDER) {
            this.lowerValue = 0;
          }

          if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
            this.upperValue = this.labels.length - 1;
          }

          if (this._hasViewInit) {
            this.updateTrack();
          }
        }
        /**
         * Enables `labelView`, by accepting a collection of primitive values with more than one element.
         * Each element will be equally spread over the slider and it will serve as a thumb label.
         * Once the property is set, it will precendence over {\@link maxValue}, {\@link minValue}, {\@link step}.
         * This means that the manipulation for those properties won't be allowed.
         * @return {?}
         */

      }, {
        key: "labels",
        get: function get() {
          return this._labels;
        }
        /**
         * @param {?} labels
         * @return {?}
         */
        ,
        set: function set(labels) {
          this._labels = labels;
          this._pMax = 1;

          if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.positionHandlesAndUpdateTrack();
            this.setTickInterval(labels);
          }
        }
        /**
         * Returns the template context corresponding
         * to {\@link IgxThumbFromTemplateDirective} and {\@link IgxThumbToTemplateDirective} templates.
         *
         * return {
         *  $implicit: {\@link value},
         *  labels: {\@link labels}
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          return {
            $implicit: this.value,
            labels: this.labels
          };
        }
        /**
         * An \@Input property that sets the incremental/decremental step of the value when dragging the thumb.
         * The default step is 1, and step should not be less or equal than 0.
         * ```html
         * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         * @param {?} step
         * @return {?}
         */

      }, {
        key: "step",
        set: function set(step) {
          this._step = step;

          if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.normalizeByStep(this.value);
            this.setTickInterval(this.labels);
          }
        }
        /**
         * Returns the incremental/decremental dragging step of the {\@link IgxSliderComponent}.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let step = this.slider.step;
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this.labelsViewEnabled ? 1 : this._step;
        }
        /**
         * Returns if the {\@link IgxSliderComponent} is disabled.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let isDisabled = this.slider.disabled;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled;
        }
        /**
         * An \@Input property that disables or enables UI interaction.
         * ```html
         * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         * @param {?} disable
         * @return {?}
         */
        ,
        set: function set(disable) {
          this._disabled = disable;

          if (this._hasViewInit) {
            this.changeThumbFocusableState(disable);
          }
        }
        /**
         * Returns if the {\@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "continuous",
        get: function get() {
          return this._continuous;
        }
        /**
         * An \@Input property that marks the {\@link IgxSliderComponent} as continuous.
         * By default is considered that the {\@link IgxSliderComponent} is discrete.
         * Discrete {\@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
         * ```html
         * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         * @param {?} continuous
         * @return {?}
         */
        ,
        set: function set(continuous) {
          this._continuous = continuous;
          this.setTickInterval(null);
        }
        /**
         * Returns if the {\@link IgxSliderComponent} is set as continuous.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *     let continuous = this.slider.continuous;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "isContinuous",
        get: function get() {
          return this.continuous;
        }
        /**
         * @hidden
         * \@internal
         * @param {?} continuous
         * @return {?}
         */
        ,
        set: function set(continuous) {
          this.continuous = continuous;
        }
        /**
         * Returns the maximum value for the {\@link IgxSliderComponent}.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderMax = this.slider.maxValue;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "maxValue",
        get: function get() {
          return this.labelsViewEnabled ? this.labels.length - 1 : this._maxValue;
        }
        /**
         * Sets the maximal value for the `IgxSliderComponent`.
         * The default maximum value is 100.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value <= this._minValue) {
            this._maxValue = this._minValue + 1;
          } else {
            this._maxValue = value;
          }

          if (value < this.lowerBound) {
            this.updateLowerBoundAndMinTravelZone();
            this.upperBound = value;
          } // refresh max travel zone limits.


          this._pMax = 1; // recalculate step distance.

          this.stepDistance = this.calculateStepDistance();
          this.positionHandlesAndUpdateTrack();
          this.setTickInterval(null);
        }
        /**
         * Returns the minimal value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderMin = this.slider.minValue;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "minValue",
        get: function get() {
          if (this.labelsViewEnabled) {
            return 0;
          }

          return this._minValue;
        }
        /**
         * Sets the minimal value for the `IgxSliderComponent`.
         * The default minimal value is 0.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value >= this.maxValue) {
            this._minValue = this.maxValue - 1;
          } else {
            this._minValue = value;
          }

          if (value > this.upperBound) {
            this.updateUpperBoundAndMaxTravelZone();
            this.lowerBound = value;
          } // Refresh min travel zone limit.


          this._pMin = 0; // Recalculate step distance.

          this.stepDistance = this.calculateStepDistance();
          this.positionHandlesAndUpdateTrack();
          this.setTickInterval(null);
        }
        /**
         * Returns the lower boundary of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderLowBound = this.slider.lowerBound;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "lowerBound",
        get: function get() {
          if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
            return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
          }

          return this.minValue;
        }
        /**
         * Sets the lower boundary of the `IgxSliderComponent`.
         * If not set is the same as min value.
         * ```html
         * <igx-slider [step]="5" [lowerBound]="20">
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value >= this.upperBound || this.labelsViewEnabled && value < 0) {
            return;
          }

          this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue); // Refresh time travel zone.

          this._pMin = this.valueToFraction(this._lowerBound) || 0;
          this.positionHandlesAndUpdateTrack();
        }
        /**
         * Returns the upper boundary of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderUpBound = this.slider.upperBound;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "upperBound",
        get: function get() {
          if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
            return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
          }

          return this.maxValue;
        }
        /**
         * Sets the upper boundary of the `IgxSliderComponent`.
         * If not set is the same as max value.
         * ```html
         * <igx-slider [step]="5" [upperBound]="20">
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (value <= this.lowerBound || this.labelsViewEnabled && value > this.labels.length - 1) {
            return;
          }

          this._upperBound = this.valueInRange(value, this.minValue, this.maxValue); // Refresh time travel zone.

          this._pMax = this.valueToFraction(this._upperBound) || 1;
          this.positionHandlesAndUpdateTrack();
        }
        /**
         * Returns the slider value. If the slider is of type {\@link SliderType.SLIDER} the returned value is number.
         * If the slider type is {\@link SliderType.RANGE} the returned value represents an object of {\@link lowerValue} and {\@link upperValue}.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public sliderValue(event){
         *    let sliderVal = this.slider.value;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "value",
        get: function get() {
          if (this.isRange) {
            return {
              lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
              upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
            };
          } else {
            return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
          }
        }
        /**
         * Sets the slider value.
         * If the slider is of type {\@link SliderType.SLIDER} the argument is number. By default the {\@link value} gets the {\@link lowerBound}.
         * If the slider type is {\@link SliderType.RANGE} the argument
         * represents an object of {\@link lowerValue} and {\@link upperValue} properties.
         * By default the object is associated with the {\@link lowerBound} and {\@link upperBound} property values.
         * ```typescript
         * rangeValue = {
         *   lower: 30,
         *   upper: 60
         * };
         * ```
         * ```html
         * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          if (!this.isRange) {
            this.upperValue =
            /** @type {?} */
            value;
          } else {
            value = this.validateInitialValue(
            /** @type {?} */
            value);
            this.upperValue =
            /** @type {?} */
            value.upper;
            this.lowerValue =
            /** @type {?} */
            value.lower;
          }

          this._onChangeCallback(this.value);

          if (this._hasViewInit) {
            this.positionHandlesAndUpdateTrack();
          }
        }
      }, {
        key: "isRange",
        get: function get() {
          return this.type === SliderType.RANGE;
        }
        /**
         * Returns the lower value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    let sliderLowValue = this.slider.lowerValue;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "lowerValue",
        get: function get() {
          if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
            return this._lowerValue;
          }

          return this.lowerBound;
        }
        /**
         * Sets the lower value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    this.slider.lowerValue = 120;
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          value = this.valueInRange(value, this.lowerBound, this.upperBound);
          this._lowerValue = value;
        }
        /**
         * Returns the upper value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public upperValue(event){
         *    let upperValue = this.slider.upperValue;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "upperValue",
        get: function get() {
          if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
            return this._upperValue;
          }

          return this.upperBound;
        }
        /**
         * Sets the upper value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public upperValue(event){
         *    this.slider.upperValue = 120;
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          value = this.valueInRange(value, this.lowerBound, this.upperBound);
          this._upperValue = value;
        }
        /**
         * Returns the value corresponding the lower label.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.lowerLabel;
         * ```
         * @return {?}
         */

      }, {
        key: "lowerLabel",
        get: function get() {
          return this.labelsViewEnabled ? this.labels[this.lowerValue] : this.lowerValue;
        }
        /**
         * Returns the value corresponding the upper label.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let label = this.slider.upperLabel;
         * ```
         * @return {?}
         */

      }, {
        key: "upperLabel",
        get: function get() {
          return this.labelsViewEnabled ? this.labels[this.upperValue] : this.upperValue;
        }
        /**
         * Returns if label view is enabled.
         * If the {\@link labels} is set, the view is automatically activated.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * let labelView = this.slider.labelsViewEnabled;
         * ```
         * @return {?}
         */

      }, {
        key: "labelsViewEnabled",
        get: function get() {
          return !!(this.labels && this.labels.length > 1);
        }
      }]);

      return IgxSliderComponent;
    }();

    IgxSliderComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxSliderComponent,
          multi: true
        }],
        selector: 'igx-slider',
        template: "<div class=\"igx-slider__track\">\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-ticks\"></div>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb-label\n        *ngIf=\"isRange\"\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"></igx-thumb-label>\n\n    <igx-thumb *ngIf=\"isRange\"\n        #thumbFrom\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n\n    <igx-thumb-label\n        [value]=\"upperLabel\"\n        [type]=\"1\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"></igx-thumb-label>\n\n    <igx-thumb\n        #thumbTo\n        [type]=\"1\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n"
      }]
    }];
    /** @nocollapse */

    IgxSliderComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]
      }];
    };

    IgxSliderComponent.propDecorators = {
      track: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['track', {
          "static": true
        }]
      }],
      ticks: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['ticks', {
          "static": true
        }]
      }],
      thumbs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxSliderThumbComponent]
      }],
      labelRefs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [IgxThumbLabelComponent]
      }],
      thumbFromTemplateRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxThumbFromTemplateDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      thumbToTemplateRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxThumbToTemplateDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": false
        }]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ["attr.role"]
      }],
      valuemin: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ["attr.aria-valuemin"]
      }],
      valuemax: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ["attr.aria-valuemax"]
      }],
      readonly: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ["attr.aria-readonly"]
      }],
      slierClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider']
      }],
      disabledClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-slider--disabled']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      thumbLabelVisibilityDuration: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      labels: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      step: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      continuous: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isContinuous: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      maxValue: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      minValue: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      lowerBound: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      upperBound: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onValueChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onPointerDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['pointerdown', ['$event']]
      }],
      onPointerUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['pointerup', ['$event']]
      }],
      onFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus']
      }],
      onPanListener: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['pan', ['$event']]
      }],
      onPanStart: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['panstart']
      }],
      onPanEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['panend']
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("IgxSliderComponent `isContinuous` property is deprecated.\nUse `continuous` instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", Boolean), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [Boolean])], IgxSliderComponent.prototype, "isContinuous", null);
    /**
     * @hidden
     */

    var IgxSliderModule = function IgxSliderModule() {
      _classCallCheck(this, IgxSliderModule);
    };

    IgxSliderModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxSliderComponent, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxSliderThumbComponent, IgxThumbLabelComponent],
        exports: [IgxSliderComponent, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxSliderThumbComponent, IgxThumbLabelComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$s = 0;
    /**
     * **Ignite UI for Angular Snackbar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/snackbar.html)
     *
     * The Ignite UI Snack Bar provides feedback about an operation with a single-line message, which can
     * include a link to an action such as Undo.
     *
     * Example:
     * ```html
     * <button (click)="snackbar.show()">Send message</button>
     * <div>
     *   <igx-snackbar #snackbar message="Message sent">
     *   </igx-snackbar>
     * </div>
     * ```
     */

    var IgxSnackbarComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} zone
       */
      function IgxSnackbarComponent(zone) {
        _classCallCheck(this, IgxSnackbarComponent);

        this.zone = zone;
        /**
         * Sets/gets the `id` of the snackbar.
         * If not set, the `id` of the first snackbar component  will be `"igx-snackbar-0"`;
         * ```html
         * <igx-snackbar id = "Snackbar1"></igx-snackbar>
         * ```
         * ```typescript
         * let snackbarId = this.snackbar.id;
         * ```
         * \@memberof IgxSnackbarComponent
         */

        this.id = "igx-snackbar-".concat(NEXT_ID$s++);
        /**
         * Enables/Disables the visibility of the snackbar.
         * If not set, the `isVisible` attribute will have value `false`.
         * ```html
         * <igx-snackbar [isVisible] = "true"></igx-snackbar>
         * ```
         * ```typescript
         * let isVisible =  this.snackbar.isVisible;
         * ```
         */

        this.isVisible = false;
        /**
         * Sets/gets if the snackbar will be automatically hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-snackbar [autoHide] = "false"></igx-snackbar>
         * ```
         * ```typescript
         * let autoHide =  this.snackbar.autoHide;
         * ```
         */

        this.autoHide = true;
        /**
         * Sets/gets the duration of time(in milliseconds) in which the snackbar will be visible after it is being shown.
         * Default value is 4000.
         * ```html
         * <igx-snackbar [displayTime] = "2000"></igx-snackbar>
         * ```
         * ```typescript
         * let displayTime = this.snackbar.displayTime;
         * ```
         */

        this.displayTime = 4000;
        /**
         * An event that will be emitted when the action is executed.
         * Provides reference to the `IgxSnackbarComponent` as an argument.
         * ```html
         * <igx-snackbar (onAction) = "onAction($event)"></igx-snackbar>
         * ```
         */

        this.onAction = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that will be emitted when the snackbar animation starts.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationStarted) = "animationStarted($event)"></igx-snackbar>
         * ```
         */

        this.animationStarted = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * An event that will be emitted when the snackbar animation ends.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationDone) = "animationDone($event)"></igx-snackbar>
         * ```
         */

        this.animationDone = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
      }
      /**
       * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
       * ```typescript
       * this.snackbar.show();
       * ```
       * @return {?}
       */


      _createClass(IgxSnackbarComponent, [{
        key: "show",
        value: function show() {
          var _this368 = this;

          clearTimeout(this.timeoutId);
          setTimeout(this.timeoutId);
          this.isVisible = true;

          if (this.autoHide) {
            this.timeoutId = setTimeout(function () {
              _this368.hide();
            }, this.displayTime);
          }
        }
        /**
         * Hides the snackbar.
         * ```typescript
         * this.snackbar.hide();
         * ```
         * @return {?}
         */

      }, {
        key: "hide",
        value: function hide() {
          this.isVisible = false;
          clearTimeout(this.timeoutId);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "triggerAction",
        value: function triggerAction() {
          this.onAction.emit(this);
        }
        /**
         * @hidden
         * \@memberof IgxSnackbarComponent
         * @param {?} evt
         * @return {?}
         */

      }, {
        key: "snackbarAnimationStarted",
        value: function snackbarAnimationStarted(evt) {
          if (evt.fromState === 'void') {
            this.animationStarted.emit(evt);
          }
        }
        /**
         * @hidden
         * \@memberof IgxSnackbarComponent
         * @param {?} evt
         * @return {?}
         */

      }, {
        key: "snackbarAnimationDone",
        value: function snackbarAnimationDone(evt) {
          if (evt.fromState === 'show') {
            this.animationDone.emit(evt);
          }
        }
      }]);

      return IgxSnackbarComponent;
    }();

    IgxSnackbarComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        animations: [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('slideInOut', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideInBottom, {
          params: {
            duration: '.35s',
            easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
            fromPosition: 'translateY(100%)',
            toPosition: 'translateY(0)'
          }
        })]), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(slideOutBottom, {
          params: {
            duration: '.2s',
            easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
            fromPosition: 'translateY(0)',
            toOpacity: 1,
            toPosition: 'translateY(100%)'
          }
        })])]), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('fadeInOut', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeIn, {
          params: {
            duration: '.35s',
            easing: 'ease-out'
          }
        })]), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["useAnimation"])(fadeOut, {
          params: {
            duration: '.2s',
            easing: 'ease-out'
          }
        })])])],
        selector: 'igx-snackbar',
        template: "<div class=\"igx-snackbar\" *ngIf=\"isVisible\" (@slideInOut.start)=\"snackbarAnimationStarted($event)\" (@slideInOut.done)=\"snackbarAnimationDone($event)\"\n    [@slideInOut]=\"isVisible\">\n    <div class=\"igx-snackbar__message\" [@fadeInOut]=\"isVisible\">\n        {{ message }}\n        <ng-content></ng-content>\n    </div>\n    <button class=\"igx-snackbar__button\" igxRipple=\"white\" *ngIf=\"actionText\" [@fadeInOut] (click)=\"triggerAction()\">\n        {{ actionText }}\n    </button>\n</div>\n",
        styles: ["\n        :host {\n            display: block;\n        }\n    "]
      }]
    }];
    /** @nocollapse */

    IgxSnackbarComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };

    IgxSnackbarComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      message: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isVisible: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      autoHide: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      displayTime: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      actionText: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onAction: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      animationStarted: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      animationDone: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }]
    };
    /**
     * @hidden
     */

    var IgxSnackbarModule = function IgxSnackbarModule() {
      _classCallCheck(this, IgxSnackbarModule);
    };

    IgxSnackbarModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxSnackbarComponent],
        exports: [IgxSnackbarComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var SwitchLabelPosition = {
      BEFORE: 'before',
      AFTER: 'after'
    };
    /** @type {?} */

    var noop$7 = function noop$7() {};
    /** @type {?} */


    var nextId$3 = 0;
    /**
     * **Ignite UI for Angular Switch** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/switch.html)
     *
     * The Ignite UI Switch lets the user toggle between on/off or true/false states.
     *
     * Example:
     * ```html
     * <igx-switch [checked]="true">
     *   Simple switch
     * </igx-switch>
     * ```
     */

    var IgxSwitchComponent =
    /*#__PURE__*/
    function () {
      function IgxSwitchComponent() {
        _classCallCheck(this, IgxSwitchComponent);

        /**
         * Sets/gets the `id` of the switch component.
         * If not set, the `id` of the first switch component will be `"igx-switch-0"`.
         * ```html
         * <igx-switch id="my-first-switch"></igx-switch>
         * ```
         * ```typescript
         * let switchId =  this.switch.id;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.id = "igx-switch-".concat(nextId$3++);
        /**
         * Sets/gets the id of the `label` element in the switch component.
         * If not set, the label of the first switch component will have value `"igx-switch-0-label"`.
         * ```html
         * <igx-switch labelId="Label1"></igx-switch>
         * ```
         * ```typescript
         * let labelId =  this.switch.labelId;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.labelId = "".concat(this.id, "-label");
        /**
         * Sets/gets the value of the `tabindex` attribute.
         * ```html
         * <igx-switch [tabindex]="1"></igx-switch>
         * ```
         * ```typescript
         * let tabIndex =  this.switch.tabindex;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.tabindex = null;
        /**
         * Sets/gets the position of the `label` in the switch component.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-switch labelPosition="before"></igx-switch>
         * ```
         * ```typescript
         * let labelPosition =  this.switch.labelPosition;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.labelPosition = 'after';
        /**
         * Enables/Disables the ripple effect
         * If not set, `disableRipple` will have value `false`.
         * ```html
         * <igx-switch [disableRipple]="true"></igx-switch>
         * ```
         * ```typescript
         * let isRippleDisabled = this.switch.disableRipple;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.disableRipple = false;
        /**
         * Sets/gets whether switch is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-switch [required]="true"></igx-switch>
         * ```
         * ```typescript
         * let isRequired = this.switch.required;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.required = false;
        /**
         * Sets/gets the `aria-labelledBy` attribute.
         * If not set, the  value of `aria-labelledBy` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-switch aria-labelledby = "Label1"></igx-switch>
         * ```
         * ```typescript
         * let ariaLabelledBy = this.switch.ariaLabelledBy;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         * ```html
         * <igx-switch aria-label="Label1"></igx-switch>
         * ```
         * ```typescript
         * let ariaLabel =  this.switch.ariaLabel;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.ariaLabel = null;
        /**
         * An event that is emitted after the switch state is changed.
         * Provides references to the `IgxSwitchComponent` and the `checked` property as event arguments.
         * \@memberof IgxSwitchComponent
         */

        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         * \@memberof IgxSwitchComponent
         */

        this._onTouchedCallback = noop$7;
        /**
         * @hidden
         * \@memberof IgxSwitchComponent
         */

        this._onChangeCallback = noop$7;
        /**
         * Returns the class of the switch component.
         * ```typescript
         * let switchClass = this.switch.cssClass;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.cssClass = 'igx-switch';
        /**
         * Sets/gets whether the switch is on or off.
         * Default value is 'false'.
         * ```html
         *  <igx-switch [checked] = "true"></igx-switch>
         * ```
         * ```typescript
         * let isChecked =  this.switch.checked;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.checked = false;
        /**
         * Sets/gets the `disabled` attribute.
         * Default value is `false`.
         * ```html
         * <igx-switch [disabled] = "true"><igx-switch>
         * ```
         * ```typescript
         * let isDisabled =  this.switch.disabled;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.disabled = false;
        /**
         * Sets/gets whether the switch component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.switch.focused = true;
         * ```
         * ```typescript
         * let isFocused =  this.switch.focused;
         * ```
         * \@memberof IgxSwitchComponent
         */

        this.focused = false;
        /**
         * @hidden
         */

        this.inputId = "".concat(this.id, "-input");
      }
      /**
       * Toggles the checked state of the switch.
       * ```typescript
       * this.switch.toggle();
       * ```
       * \@memberof IgxSwitchComponent
       * @return {?}
       */


      _createClass(IgxSwitchComponent, [{
        key: "toggle",
        value: function toggle() {
          if (this.disabled) {
            return;
          }

          this.checked = !this.checked;
          this.focused = false;
          this.change.emit({
            checked: this.checked,
            "switch": this
          });

          this._onChangeCallback(this.checked);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onSwitchChange",
        value: function _onSwitchChange(event) {
          event.stopPropagation();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onSwitchClick",
        value: function _onSwitchClick(event) {
          event.stopPropagation();
          this.toggle();

          if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "_onLabelClick",
        value: function _onLabelClick(event) {
          this.toggle();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus(event) {
          this.focused = true;
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur(event) {
          this.focused = false;

          this._onTouchedCallback();
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          this._value = value;
          this.checked = !!this._value;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getEditElement",
        value: function getEditElement() {
          return this.nativeCheckbox.nativeElement;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "registerOnChange",

        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
      }, {
        key: "labelClass",
        get: function get() {
          switch (this.labelPosition) {
            case SwitchLabelPosition.BEFORE:
              return "".concat(this.cssClass, "__label--before");

            case SwitchLabelPosition.AFTER:
            default:
              return "".concat(this.cssClass, "__label");
          }
        }
      }]);

      return IgxSwitchComponent;
    }();

    IgxSwitchComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxSwitchComponent,
          multi: true
        }],
        selector: 'igx-switch',
        template: "<input #checkbox class=\"igx-switch__input\" type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onSwitchChange($event)\"\n    (click)=\"_onSwitchClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<label #label class =\"igx-switch__composite\" [for]=\"inputId\"\n    igxRipple\n    igxRippleTarget=\".igx-switch__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\">\n    <div class=\"igx-switch__composite-thumb\">\n        <div class=\"igx-switch__ripple\"></div>\n    </div>\n</label>\n\n<span #placeholderLabel role=\"label\"\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
      }]
    }];
    IgxSwitchComponent.propDecorators = {
      nativeCheckbox: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['checkbox', {
          "static": true
        }]
      }],
      nativeLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['label', {
          "static": true
        }]
      }],
      placeholderLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['placeholderLabel', {
          "static": true
        }]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      labelId: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      name: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      labelPosition: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disableRipple: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      required: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      ariaLabelledBy: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['aria-labelledby']
      }],
      ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['aria-label']
      }],
      change: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-switch']
      }],
      checked: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-switch--checked']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-switch--disabled']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      focused: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-switch--focused']
      }]
    };
    /** @type {?} */

    var IGX_SWITCH_REQUIRED_VALIDATOR = {
      provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALIDATORS"],
      useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
        return IgxSwitchRequiredDirective;
      }),
      multi: true
    };
    /* tslint:disable directive-selector */

    var IgxSwitchRequiredDirective =
    /*#__PURE__*/
    function (_angular_forms__WEBPA2) {
      _inherits(IgxSwitchRequiredDirective, _angular_forms__WEBPA2);

      function IgxSwitchRequiredDirective() {
        _classCallCheck(this, IgxSwitchRequiredDirective);

        return _possibleConstructorReturn(this, _getPrototypeOf(IgxSwitchRequiredDirective).apply(this, arguments));
      }

      return IgxSwitchRequiredDirective;
    }(_angular_forms__WEBPACK_IMPORTED_MODULE_2__["CheckboxRequiredValidator"]);

    IgxSwitchRequiredDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: "igx-switch[required][formControlName],\n    igx-switch[required][formControl],\n    igx-switch[required][ngModel]",
        providers: [IGX_SWITCH_REQUIRED_VALIDATOR]
      }]
    }];
    /**
     * @hidden
     */

    var IgxSwitchModule = function IgxSwitchModule() {
      _classCallCheck(this, IgxSwitchModule);
    };

    IgxSwitchModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxSwitchComponent, IgxSwitchRequiredDirective],
        exports: [IgxSwitchComponent, IgxSwitchRequiredDirective],
        imports: [IgxRippleModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$t = 0;

    var IgxTabTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxTabTemplateDirective(template) {
      _classCallCheck(this, IgxTabTemplateDirective);

      this.template = template;
    };

    IgxTabTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxTab]'
      }]
    }];
    /** @nocollapse */

    IgxTabTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * **Ignite UI for Angular Tab Bar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tabbar.html)
     *
     * The Ignite UI Tab Bar enables the user to navigate among a number of content panels displayed in a single view.
     *
     * Example:
     * ```html
     * <igx-bottom-nav>
     *   <igx-tab-panel label="Tab 1">Tab 1 Content</igx-tab-panel>
     *   <igx-tab-panel label="Tab 2">Tab 2 Content</igx-tab-panel>
     *   <igx-tab-panel label="Tab 3">Tab 3 Content</igx-tab-panel>
     * </igx-bottom-nav>
     * ```
     */


    var IgxBottomNavComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _element
       */
      function IgxBottomNavComponent(_element) {
        _classCallCheck(this, IgxBottomNavComponent);

        this._element = _element;
        /**
         * Sets/gets the `id` of the tab bar.
         * If not set, the `id` of the first tab bar component will be `"igx-bottom-nav-0"`.
         * ```html
         * <igx-bottom-nav id = "my-first-tab-bar"></igx-bottom-nav>
         * ```
         * ```typescript
         * let tabBarId =  this.tabBar.id;
         * ```
         * \@memberof IgxBottomNavComponent
         */

        this.id = "igx-bottom-nav-".concat(NEXT_ID$t++);
        /**
         * Emits an event when a new tab is selected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTableSelected) = "onTabSelected($event)"><igx-bottom-nav>
         * ```
         * \@memberof IgxBottomNavComponent
         */

        this.onTabSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when a tab is deselected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTabDeselected) = "onTabDeselected($event)"><igx-bottom-nav>
         * ```
         * \@memberof IgxBottomNavComponent
         */

        this.onTabDeselected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Gets the `index` of selected tab/panel in the respective collection.
         * ```typescript
         * let index =  this.tabBar.selectedIndex;
         * ```
         * \@memberof IgxBottomNavComponent
         */

        this.selectedIndex = -1;
        /**
         * @hidden
         */

        this._itemStyle = 'igx-bottom-nav';
      }
      /**
       * Gets the `IgxTabComponent` elements for this bottom navigation component.
       * First try to get them as content children if not available get them as view children.
       * ```typescript
       * let tabs: QueryList<IgxTabComponent> =  this.tabBar.tabs;
       * ```
       * \@memberof IgxBottomNavComponent
       * @return {?}
       */


      _createClass(IgxBottomNavComponent, [{
        key: "ngAfterViewInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterViewInit() {
          var _this369 = this;

          // initial selection
          setTimeout(function () {
            if (_this369.selectedIndex === -1) {
              /** @type {?} */
              var selectablePanels = _this369.panels.filter(function (p) {
                return !p.disabled;
              });
              /** @type {?} */


              var panel = selectablePanels[0];

              if (panel) {
                panel.select();
              }
            }
          }, 0);
        }
        /**
         * @hidden
         * @param {?} args
         * @return {?}
         */

      }, {
        key: "_selectedPanelHandler",
        value: function _selectedPanelHandler(args) {
          var _this370 = this;

          if (this.hasContentTabs) {
            this.selectedIndex = args.tab.index;
            this.contentTabs.forEach(function (t) {
              if (t !== args.tab) {
                _this370._deselectTab(t);
              }
            });
          } else {
            if (args.panel) {
              this.selectedIndex = args.panel.index;
              this.panels.forEach(function (p) {
                if (p.index !== _this370.selectedIndex) {
                  _this370._deselectPanel(p);
                }
              });
            }
          }
        }
        /**
         * @hidden
         * @private
         * @param {?} panel
         * @return {?}
         */

      }, {
        key: "_deselectPanel",
        value: function _deselectPanel(panel) {
          // Cannot deselect the selected tab - this will mean that there will be not selected tab left
          if (panel.disabled || this.selectedTab.index === panel.index) {
            return;
          }

          panel.isSelected = false;
          this.onTabDeselected.emit({
            tab: this.tabs[panel.index],
            panel: panel
          });
        }
        /**
         * @private
         * @param {?} aTab
         * @return {?}
         */

      }, {
        key: "_deselectTab",
        value: function _deselectTab(aTab) {
          aTab.isSelected = false;
          this.onTabDeselected.emit({
            tab: aTab,
            panel: null
          });
        }
      }, {
        key: "tabs",
        get: function get() {
          return this.hasContentTabs ? this.contentTabs : this.viewTabs;
        }
        /**
         * Gets the `itemStyle` of the tab bar.
         * ```typescript
         * let itemStyle =  this.tabBar.itemStyle;
         * ```
         * \@memberof IgxBottomNavComponent
         * @return {?}
         */

      }, {
        key: "itemStyle",
        get: function get() {
          return this._itemStyle;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hasContentTabs",
        get: function get() {
          return this.contentTabs && this.contentTabs.length > 0;
        }
        /**
         * Gets the selected tab in the tab bar.
         * ```typescript
         * let tab =  this.tabBar.selectedTab;
         * ```
         * \@memberof IgxBottomNavComponent
         * @return {?}
         */

      }, {
        key: "selectedTab",
        get: function get() {
          if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
          }
        }
      }]);

      return IgxBottomNavComponent;
    }();

    IgxBottomNavComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-bottom-nav',
        template: "<div *ngIf=\"!hasContentTabs\">\n    <ng-content></ng-content>\n</div>\n<div #tablist class=\"{{itemStyle}}__menu {{itemStyle}}__menu--bottom\" role=\"tablist\" aria-orientation=\"horizontal\">\n    <ng-container *ngIf=\"!hasContentTabs\">    \n        <igx-tab *ngFor=\"let panel of panels\" [relatedPanel]=\"panel\">\n        </igx-tab>\n    </ng-container>\n    <ng-content select=\"igx-tab\"></ng-content>\n</div>",
        styles: ["\n        :host {\n            display: block;\n        }\n    "]
      }]
    }];
    /** @nocollapse */

    IgxBottomNavComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxBottomNavComponent.propDecorators = {
      viewTabs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxTabComponent;
        })]
      }],
      contentTabs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxTabComponent;
        })]
      }],
      panels: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxTabPanelComponent;
        })]
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onTabSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onTabDeselected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      _selectedPanelHandler: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['onTabSelected', ['$event']]
      }]
    }; // ================================= IgxTabPanelComponent ======================================

    var IgxTabPanelComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _tabBar
       * @param {?} _element
       */
      function IgxTabPanelComponent(_tabBar, _element) {
        _classCallCheck(this, IgxTabPanelComponent);

        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * @hidden
         */

        this._itemStyle = 'igx-tab-panel';
        /**
         * @hidden
         */

        this._isSelected = false;
        /**
         * Gets the role of the tab panel.
         * ```typescript
         * let tabPanelRole = this.tabPanel.role;
         * ```
         * \@memberof IgxTabPanelComponent
         */

        this.role = 'tabpanel';
      }
      /**
       * Gets whether a tab panel will have `igx-bottom-nav__panel` class.
       * ```typescript
       * let styleClass = this.tabPanel.styleClass;
       * ```
       * \@memberof IgxTabPanelComponent
       * @return {?}
       */


      _createClass(IgxTabPanelComponent, [{
        key: "ngAfterContentInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterContentInit() {
          if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewChecked",
        value: function ngAfterViewChecked() {
          this._element.nativeElement.setAttribute('aria-labelledby', "igx-tab-".concat(this.index));

          this._element.nativeElement.setAttribute('id', "igx-bottom-nav__panel-".concat(this.index));
        }
        /**
         * Selects the current tab and the tab panel.
         * ```typescript
         * this.tabPanel.select();
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */

      }, {
        key: "select",
        value: function select() {
          if (this.disabled || this._tabBar.selectedIndex === this.index) {
            return;
          }

          this._isSelected = true;

          this._tabBar.onTabSelected.emit({
            tab: this._tabBar.tabs.toArray()[this.index],
            panel: this
          });
        }
      }, {
        key: "styleClass",
        get: function get() {
          return !this.isSelected;
        }
        /**
         * Sets/gets whether a tab panel is selected.
         * ```typescript
         * this.tabPanel.isSelected = true;
         * ```
         * ```typescript
         * let isSelected =  this.tabPanel.isSelected;
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */

      }, {
        key: "isSelected",
        get: function get() {
          return this._isSelected;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this._isSelected !== newValue) {
            if (newValue) {
              this.select();
            } else {
              this._isSelected = newValue;
            }
          }
        }
        /**
         * Gets the `itemStyle` of the tab panel.
         * ```typescript
         * let itemStyle = this.tabPanel.itemStyle;
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */

      }, {
        key: "itemStyle",
        get: function get() {
          return this._itemStyle;
        }
        /**
         * Gets the tab associated with the panel.
         * ```typescript
         * let tab = this.tabPanel.relatedTab;
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */

      }, {
        key: "relatedTab",
        get: function get() {
          if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray()[this.index];
          }
        }
        /**
         * Gets the changes and updates accordingly applied to the tab/panel.
         *
         * \@memberof IgxTabComponent
         * @return {?}
         */

      }, {
        key: "changesCount",
        get: function get() {
          return this.relatedTab ? this.relatedTab.changesCount : 0;
        }
        /**
         * Gets the index of a panel in the panels collection.
         * ```typescript
         * let panelIndex =  this.tabPanel.index
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */

      }, {
        key: "index",
        get: function get() {
          if (this._tabBar.panels) {
            return this._tabBar.panels.toArray().indexOf(this);
          }
        }
        /**
         * Gets the tab template.
         * ```typescript
         * let tabTemplate = this.tabPanel.customTabTemplate
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */

      }, {
        key: "customTabTemplate",
        get: function get() {
          return this._tabTemplate;
        }
        /**
         * Sets the tab template.
         * ```typescript
         * this.tabPanel.customTabTemplate(tabTemplate);
         * ```
         * \@memberof IgxTabPanelComponent
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {
          this._tabTemplate = template;
        }
      }]);

      return IgxTabPanelComponent;
    }();

    IgxTabPanelComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-tab-panel',
        template: "<ng-content></ng-content>\n"
      }]
    }];
    /** @nocollapse */

    IgxTabPanelComponent.ctorParameters = function () {
      return [{
        type: IgxBottomNavComponent
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxTabPanelComponent.propDecorators = {
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      icon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      styleClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-bottom-nav__panel']
      }],
      isSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-bottom-nav__panel--selected']
      }],
      tabTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxTabTemplateDirective, {
          read: IgxTabTemplateDirective,
          "static": false
        }]
      }]
    }; // ======================================= IgxTabComponent ==========================================

    var IgxTabComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _tabBar
       * @param {?} _element
       */
      function IgxTabComponent(_tabBar, _element) {
        _classCallCheck(this, IgxTabComponent);

        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * Gets the `role` attribute.
         * ```typescript
         * let tabRole = this.tab.role;
         * ```
         * \@memberof IgxTabComponent
         */

        this.role = 'tab';
        /**
         * @hidden \@internal
         */

        this.id = 'igx-tab-' + this.index;
        /**
         * @hidden \@internal
         */

        this.ariaLabel = this.label;
        /**
         * @hidden \@internal
         */

        this.ariaDisabled = this.disabled;
        /**
         * @hidden \@internal
         */

        this.ariaSelected = this.isSelected;
        /**
         * @hidden \@internal
         */

        this.ariaControls = 'igx-tab-panel-' + this.index;
        /**
         * @hidden
         */

        this._changesCount = 0; // changes and updates accordingly applied to the tab.

        this._disabled = false;
        this._selected = false;
      }
      /**
       * Sets/gets the `label` of the tab panel.
       * ```html
       * <igx-tab [label] = "'Tab label'"><igx-tab>
       * ```
       * ```typescript
       * let tabLabel = this.tab.label;
       * ```
       * \@memberof IgxTabComponent
       * @return {?}
       */


      _createClass(IgxTabComponent, [{
        key: "select",

        /**
         * Selects the current tab and the associated panel.
         * ```typescript
         * this.tab.select();
         * ```
         * \@memberof IgxTabComponent
         * @return {?}
         */
        value: function select() {
          if (this.relatedPanel) {
            this.relatedPanel.select();
          } else {
            this._selected = true;

            this._tabBar.onTabSelected.emit({
              tab: this,
              panel: null
            });
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onClick",
        value: function onClick() {
          this.select();
        }
        /**
         * @return {?}
         */

      }, {
        key: "elementRef",
        value: function elementRef() {
          return this._element;
        }
      }, {
        key: "label",
        get: function get() {
          return this.relatedPanel ? this.relatedPanel.label : this._label;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this.relatedPanel) {
            this.relatedPanel.label = newValue;
          }

          this._label = newValue;
        }
        /**
         * Sets/gets  the `icon` of the tab panel.
         * ```html
         * <igx-tab [icon] = "tab_icon"><igx-tab>
         * ```
         * ```typescript
         * let tabIcon =  this.tab.icon;
         * ```
         * \@memberof IgxTabComponent
         * @return {?}
         */

      }, {
        key: "icon",
        get: function get() {
          return this.relatedPanel ? this.relatedPanel.icon : this._icon;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this.relatedPanel) {
            this.relatedPanel.icon = newValue;
          }

          this._icon = newValue;
        } // changes and updates accordingly applied to the tab.

        /**
         * Gets the changes and updates accordingly applied to the tab.
         *
         * \@memberof IgxTabComponent
         * @return {?}
         */

      }, {
        key: "changesCount",
        get: function get() {
          return this._changesCount;
        }
        /**
         * Gets whether the tab is disabled.
         * ```typescript
         * let isDisabled = this.tab.disabled;
         * ```
         * \@memberof IgxTabComponent
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this.relatedPanel ? this.relatedPanel.disabled : this._disabled;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this.relatedPanel) {
            this.relatedPanel.disabled = newValue;
          } else {
            this._disabled = newValue;
          }
        }
        /**
         * Gets whether the tab is selected.
         * ```typescript
         * let isSelected  = this.tab.isSelected;
         * ```
         * \@memberof IgxTabComponent
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "isSelected",
        set: function set(newValue) {
          if (this.relatedPanel) {
            this.relatedPanel.isSelected = newValue;
          } else if (this._selected !== newValue) {
            this._selected = newValue;

            if (this._selected) {
              this._tabBar.onTabSelected.emit({
                tab: this,
                panel: null
              });
            }
          }
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this.relatedPanel ? this.relatedPanel.isSelected : this._selected;
        }
        /**
         * @return {?}
         */

      }, {
        key: "cssClassSelected",
        get: function get() {
          return this.isSelected;
        }
        /**
         * @return {?}
         */

      }, {
        key: "cssClassDisabled",
        get: function get() {
          return this.disabled;
        }
        /**
         * @return {?}
         */

      }, {
        key: "cssClass",
        get: function get() {
          return !this.disabled && !this.isSelected;
        }
        /**
         * Gets the `index` of the tab.
         * ```typescript
         * let tabIndex = this.tab.index;
         * ```
         * \@memberof IgxTabComponent
         * @return {?}
         */

      }, {
        key: "index",
        get: function get() {
          if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray().indexOf(this);
          }
        }
        /**
         * Returns the `template` for this IgxTabComponent.
         * ```typescript
         * let tabItemTemplate = this.tabItem.template;
         * ```
         * \@memberof IgxTabComponent
         * @return {?}
         */

      }, {
        key: "template",
        get: function get() {
          if (this.relatedPanel && this.relatedPanel.customTabTemplate) {
            return this.relatedPanel.customTabTemplate;
          }

          if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
          }

          return this.defaultTabTemplate;
        }
        /**
         * Returns the `context` object for the template of this `IgxTabComponent`.
         * ```typescript
         * let tabItemContext = this.tabItem.context;
         * ```
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          return this.relatedPanel ? this.relatedPanel : this;
        }
      }]);

      return IgxTabComponent;
    }();

    IgxTabComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-tab',
        template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"tab-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"context.changesCount\" [hidden]=\"context.changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"tab-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
      }]
    }];
    /** @nocollapse */

    IgxTabComponent.ctorParameters = function () {
      return [{
        type: IgxBottomNavComponent
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxTabComponent.propDecorators = {
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }],
      ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-label']
      }],
      ariaDisabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-disabled']
      }],
      ariaSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-selected']
      }],
      ariaControls: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-controls']
      }],
      relatedPanel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      icon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cssClassSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-bottom-nav__menu-item--selected']
      }],
      cssClassDisabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-bottom-nav__menu-item--disabled']
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-bottom-nav__menu-item']
      }],
      defaultTabTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultTabTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      customTabTemplateDir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxTabTemplateDirective, {
          read: IgxTabTemplateDirective,
          "static": false
        }]
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click']
      }]
    };
    /**
     * @hidden
     */

    var IgxBottomNavModule = function IgxBottomNavModule() {
      _classCallCheck(this, IgxBottomNavModule);
    };

    IgxBottomNavModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
        exports: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxBadgeModule, IgxIconModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @abstract
     */

    var IgxTabsBase =
    /*#__PURE__*/
    function () {
      function IgxTabsBase() {
        _classCallCheck(this, IgxTabsBase);
      }

      _createClass(IgxTabsBase, [{
        key: "scrollElement",

        /**
         * @param {?} element
         * @param {?} scrollRight
         * @return {?}
         */
        value: function scrollElement(element, scrollRight) {}
        /**
         * @param {?} newTab
         * @return {?}
         */

      }, {
        key: "performSelectionChange",
        value: function performSelectionChange(newTab) {}
        /**
         * @param {?} tab
         * @param {?} duration
         * @return {?}
         */

      }, {
        key: "transformContentAnimation",
        value: function transformContentAnimation(tab, duration) {}
        /**
         * @param {?} element
         * @param {?=} duration
         * @return {?}
         */

      }, {
        key: "transformIndicatorAnimation",
        value: function transformIndicatorAnimation(element, duration) {}
      }]);

      return IgxTabsBase;
    }();
    /**
     * @hidden
     * @abstract
     */


    var IgxTabItemBase =
    /*#__PURE__*/
    function () {
      function IgxTabItemBase() {
        _classCallCheck(this, IgxTabItemBase);
      }

      _createClass(IgxTabItemBase, [{
        key: "select",

        /**
         * @return {?}
         */
        value: function select() {}
        /**
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "setSelectedInternal",
        value: function setSelectedInternal(newValue) {}
      }, {
        key: "index",

        /**
         * @return {?}
         */
        get: function get() {
          return 0;
        }
      }]);

      return IgxTabItemBase;
    }();
    /**
     * @hidden
     * @abstract
     */


    var IgxTabsGroupBase =
    /*#__PURE__*/
    function () {
      function IgxTabsGroupBase() {
        _classCallCheck(this, IgxTabsGroupBase);
      }

      _createClass(IgxTabsGroupBase, [{
        key: "select",

        /**
         * @return {?}
         */
        value: function select() {}
        /**
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "setSelectedInternal",
        value: function setSelectedInternal(newValue) {}
      }]);

      return IgxTabsGroupBase;
    }();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */


    var ButtonStyle = {
      VISIBLE: 'visible',
      HIDDEN: 'hidden',
      NOT_DISPLAYED: 'not_displayed'
    };

    var IgxRightButtonStyleDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} tabs
       */
      function IgxRightButtonStyleDirective(tabs) {
        _classCallCheck(this, IgxRightButtonStyleDirective);

        this.tabs = tabs;
      }
      /**
       * @return {?}
       */


      _createClass(IgxRightButtonStyleDirective, [{
        key: "getRightButtonStyle",

        /**
         * @private
         * @return {?}
         */
        value: function getRightButtonStyle() {
          /** @type {?} */
          var viewPortWidth = this.tabs.viewPort.nativeElement.offsetWidth; // We use this hacky way to get the width of the itemsContainer,
          // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.

          /** @type {?} */

          var itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
          /** @type {?} */

          var itemsContainerWidth = 0;

          if (itemsContainerChildrenCount > 1) {
            /** @type {?} */
            var lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
          }
          /** @type {?} */


          var headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
          /** @type {?} */

          var offset = this.tabs.offset;
          /** @type {?} */

          var total = offset + viewPortWidth; // Fix for IE 11, a difference is accumulated from the widths calculations.

          if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return ButtonStyle.NOT_DISPLAYED;
          }

          if (itemsContainerWidth > total) {
            return ButtonStyle.VISIBLE;
          } else {
            return ButtonStyle.HIDDEN;
          }
        }
      }, {
        key: "visibleCSS",
        get: function get() {
          return this.getRightButtonStyle() === ButtonStyle.VISIBLE ? true : false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "hiddenCSS",
        get: function get() {
          return this.getRightButtonStyle() === ButtonStyle.HIDDEN ? true : false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "notDisplayedCSS",
        get: function get() {
          return this.getRightButtonStyle() === ButtonStyle.NOT_DISPLAYED ? true : false;
        }
      }]);

      return IgxRightButtonStyleDirective;
    }();

    IgxRightButtonStyleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxRightButtonStyle]'
      }]
    }];
    /** @nocollapse */

    IgxRightButtonStyleDirective.ctorParameters = function () {
      return [{
        type: IgxTabsBase
      }];
    };

    IgxRightButtonStyleDirective.propDecorators = {
      visibleCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__header-button']
      }],
      hiddenCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__header-button--hidden']
      }],
      notDisplayedCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__header-button--none']
      }]
    };

    var IgxLeftButtonStyleDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} tabs
       */
      function IgxLeftButtonStyleDirective(tabs) {
        _classCallCheck(this, IgxLeftButtonStyleDirective);

        this.tabs = tabs;
      }
      /**
       * @return {?}
       */


      _createClass(IgxLeftButtonStyleDirective, [{
        key: "getLeftButtonStyle",

        /**
         * @private
         * @return {?}
         */
        value: function getLeftButtonStyle() {
          // We use this hacky way to get the width of the itemsContainer,
          // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.

          /** @type {?} */
          var itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
          /** @type {?} */

          var itemsContainerWidth = 0;

          if (itemsContainerChildrenCount > 1) {
            /** @type {?} */
            var lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
          }
          /** @type {?} */


          var headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
          /** @type {?} */

          var offset = this.tabs.offset;

          if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
              return ButtonStyle.NOT_DISPLAYED;
            }

            return ButtonStyle.HIDDEN;
          } else {
            return ButtonStyle.VISIBLE;
          }
        }
      }, {
        key: "visibleCSS",
        get: function get() {
          return this.getLeftButtonStyle() === ButtonStyle.VISIBLE ? true : false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "hiddenCSS",
        get: function get() {
          return this.getLeftButtonStyle() === ButtonStyle.HIDDEN ? true : false;
        }
        /**
         * @return {?}
         */

      }, {
        key: "notDisplayedCSS",
        get: function get() {
          return this.getLeftButtonStyle() === ButtonStyle.NOT_DISPLAYED ? true : false;
        }
      }]);

      return IgxLeftButtonStyleDirective;
    }();

    IgxLeftButtonStyleDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxLeftButtonStyle]'
      }]
    }];
    /** @nocollapse */

    IgxLeftButtonStyleDirective.ctorParameters = function () {
      return [{
        type: IgxTabsBase
      }];
    };

    IgxLeftButtonStyleDirective.propDecorators = {
      visibleCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__header-button']
      }],
      hiddenCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__header-button--hidden']
      }],
      notDisplayedCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__header-button--none']
      }]
    };

    var IgxTabItemTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxTabItemTemplateDirective(template) {
      _classCallCheck(this, IgxTabItemTemplateDirective);

      this.template = template;
    };

    IgxTabItemTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxTab]'
      }]
    }];
    /** @nocollapse */

    IgxTabItemTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var IgxTabsGroupComponent =
    /*#__PURE__*/
    function (_IgxTabsGroupBase) {
      _inherits(IgxTabsGroupComponent, _IgxTabsGroupBase);

      /**
       * @param {?} _tabs
       * @param {?} _element
       */
      function IgxTabsGroupComponent(_tabs, _element) {
        var _this371;

        _classCallCheck(this, IgxTabsGroupComponent);

        _this371 = _possibleConstructorReturn(this, _getPrototypeOf(IgxTabsGroupComponent).call(this));
        _this371._tabs = _tabs;
        _this371._element = _element;
        /**
         * An \@Input property that allows you to enable/disable the `IgxTabGroupComponent`.
         * ```html
         * <igx-tabs-group label="Tab 2  Lorem ipsum dolor sit" icon="home" [disabled]="true">
         * ```
         */

        _this371.disabled = false;
        _this371._isSelected = false;
        /**
         * @hidden
         */

        _this371.role = 'tabpanel';
        /**
         * @hidden
         */

        _this371.styleClass = true;
        return _this371;
      }
      /**
       * Sets/gets whether a tab group is selected.
       * ```typescript
       * this.tabGroup.isSelected = true;
       * ```
       * ```typescript
       * let isSelected = this.tabGroup.isSelected;
       * ```
       * \@memberof IgxTabsGroupComponent
       * @return {?}
       */


      _createClass(IgxTabsGroupComponent, [{
        key: "ngAfterContentInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterContentInit() {
          if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewChecked",
        value: function ngAfterViewChecked() {
          this._element.nativeElement.setAttribute('aria-labelledby', "igx-tab-item-".concat(this.index));

          this._element.nativeElement.setAttribute('id', "igx-tabs__group-".concat(this.index));
        }
        /**
         * A method that sets the focus on a tab.
         * \@memberof {\@link IgxTabsGroupComponent}
         * ```typescript
         * \@ViewChild("MyChild")
         * public tab : IgxTabsGroupComponent;
         * ngAfterViewInit(){
         *    this.tab.select();
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "select",
        value: function select() {
          if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this.relatedTab);
          }
        }
        /**
         * @hidden
         * @param {?} newValue
         * @return {?}
         */

      }, {
        key: "setSelectedInternal",
        value: function setSelectedInternal(newValue) {
          this._isSelected = newValue;
        }
      }, {
        key: "isSelected",
        get: function get() {
          return this._isSelected;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this.relatedTab : null);
          }
        }
        /**
         * An accessor that returns the `IgxTabItemComponent` component.
         * ```typescript
         * \@ViewChild("MyTabsGroup")
         * public tab: IgxTabsGroupComponent;
         * ngAfterViewInIt(){
         *    let tabComponent = this.tab.relatedTab;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "relatedTab",
        get: function get() {
          if (this._tabs.tabs) {
            return (
              /** @type {?} */
              this._tabs.tabs.toArray()[this.index]
            );
          }
        }
        /**
         * An accessor that returns the value of the index of the `IgxTabsGroupComponent`.
         * ```typescript
         * \@ViewChild("MyTabsGroup")
         * public tab: IgxTabsGroupComponent;
         * ngAfterViewInIt(){
         *    let tabIndex = this.tab.index;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "index",
        get: function get() {
          if (this._tabs.groups) {
            return this._tabs.groups.toArray().indexOf(this);
          }

          return -1;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "customTabTemplate",
        get: function get() {
          return this._tabTemplate;
        }
        /**
         * @hidden
         * @param {?} template
         * @return {?}
         */
        ,
        set: function set(template) {
          this._tabTemplate = template;
        }
      }]);

      return IgxTabsGroupComponent;
    }(IgxTabsGroupBase);

    IgxTabsGroupComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-tabs-group',
        template: "<ng-content *ngIf=\"isSelected\"></ng-content>\n"
      }]
    }];
    /** @nocollapse */

    IgxTabsGroupComponent.ctorParameters = function () {
      return [{
        type: IgxTabsBase
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxTabsGroupComponent.propDecorators = {
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      icon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      tabTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxTabItemTemplateDirective, {
          read: IgxTabItemTemplateDirective,
          "static": false
        }]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      styleClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__group']
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var IgxTabItemComponent =
    /*#__PURE__*/
    function (_IgxTabItemBase) {
      _inherits(IgxTabItemComponent, _IgxTabItemBase);

      /**
       * @param {?} _tabs
       * @param {?} _element
       * @param {?} _ngZone
       */
      function IgxTabItemComponent(_tabs, _element, _ngZone) {
        var _this372;

        _classCallCheck(this, IgxTabItemComponent);

        _this372 = _possibleConstructorReturn(this, _getPrototypeOf(IgxTabItemComponent).call(this));
        _this372._tabs = _tabs;
        _this372._element = _element;
        _this372._ngZone = _ngZone;
        _this372._changesCount = 0; // changes and updates accordingly applied to the tab.
        // changes and updates accordingly applied to the tab.

        _this372._isSelected = false;
        _this372._disabled = false;
        /**
         * @hidden \@internal
         */

        _this372.role = 'tab';
        /**
         * @hidden \@internal
         */

        _this372.id = 'igx-tab-item-' + _this372.index;
        /**
         * @hidden \@internal
         */

        _this372.ariaLabel = _this372.label;
        /**
         * @hidden \@internal
         */

        _this372.ariaDisabled = _this372.disabled;
        /**
         * @hidden \@internal
         */

        _this372.ariaSelected = _this372.isSelected;
        /**
         * @hidden \@internal
         */

        _this372.ariaControls = 'igx-tab-item-group-' + _this372.index;
        _this372._nativeTabItem = _element;
        return _this372;
      }
      /**
       * An \@Input property that sets the value of the `icon`.
       * The value should be valid icon name from {\@link https://material.io/tools/icons/?style=baseline}.
       * ```html
       * <igx-tab-item label="Tab 1" icon="home">
       * ```
       * @return {?}
       */


      _createClass(IgxTabItemComponent, [{
        key: "ngAfterViewInit",

        /**
         * @return {?}
         */
        value: function ngAfterViewInit() {
          var _this373 = this;

          this._ngZone.runOutsideAngular(function () {
            _this373._resizeObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](function () {
              _this373._tabs.transformIndicatorAnimation(_this373._nativeTabItem.nativeElement, 0);
            });
          });
        }
        /**
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _this374 = this;

          this._ngZone.runOutsideAngular(function () {
            _this374._resizeObserver.disconnect();
          });
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onClick",
        value: function onClick(event) {
          this.select();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowRight",
        value: function onKeydownArrowRight(event) {
          this.onKeyDown(false);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowLeft",
        value: function onKeydownArrowLeft(event) {
          this.onKeyDown(true);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownHome",
        value: function onKeydownHome(event) {
          event.preventDefault();
          this.onKeyDown(false, 0);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownEnd",
        value: function onKeydownEnd(event) {
          event.preventDefault();
          this.onKeyDown(false, this._tabs.tabs.toArray().length - 1);
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "select",

        /**
         * @hidden
         * @return {?}
         */
        value: function select() {
          if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "setSelectedInternal",

        /**
         * @hidden
         * @param {?} newValue
         * @return {?}
         */
        value: function setSelectedInternal(newValue) {
          var _this375 = this;

          this._isSelected = newValue;

          this._ngZone.runOutsideAngular(function () {
            if (_this375._resizeObserver) {
              if (_this375._isSelected) {
                _this375._resizeObserver.observe(_this375._element.nativeElement);
              } else {
                _this375._resizeObserver.disconnect();
              }
            }
          });

          this.tabindex = newValue ? 0 : -1;
        }
        /**
         * @private
         * @param {?} isLeftArrow
         * @param {?=} index
         * @return {?}
         */

      }, {
        key: "onKeyDown",
        value: function onKeyDown(isLeftArrow) {
          var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          /** @type {?} */
          var tabsArray = this._tabs.tabs.toArray();

          if (index === null) {
            index = isLeftArrow ? this._tabs.selectedIndex === 0 ? tabsArray.length - 1 : this._tabs.selectedIndex - 1 : this._tabs.selectedIndex === tabsArray.length - 1 ? 0 : this._tabs.selectedIndex + 1;
          }
          /** @type {?} */


          var tab = tabsArray[index];
          tab.select();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "icon",
        get: function get() {
          return this.relatedGroup ? this.relatedGroup.icon : this._icon;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this.relatedGroup) {
            this.relatedGroup.icon = newValue;
          }

          this._icon = newValue;
        }
        /**
         * An \@Input property that sets the value of the `label`.
         * ```html
         * <igx-tabs-item label="Tab 2" icon="folder">
         * ```
         * @return {?}
         */

      }, {
        key: "label",
        get: function get() {
          return this.relatedGroup ? this.relatedGroup.label : this._label;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this.relatedGroup) {
            this.relatedGroup.label = newValue;
          }

          this._label = newValue;
        }
        /**
         * @return {?}
         */

      }, {
        key: "provideCssClassSelected",
        get: function get() {
          return this.isSelected;
        }
        /**
         * @return {?}
         */

      }, {
        key: "provideCssClassDisabled",
        get: function get() {
          return this.disabled;
        }
        /**
         * @return {?}
         */

      }, {
        key: "provideCssClass",
        get: function get() {
          return !this.disabled && !this.isSelected;
        }
      }, {
        key: "changesCount",
        get: function get() {
          return this._changesCount;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "nativeTabItem",
        get: function get() {
          return this._nativeTabItem;
        }
        /**
         * 	Gets whether the tab is disabled.
         * ```
         * const disabledItem = this.myTabComponent.tabs.first.disabled;
         * ```
         * @return {?}
         */

      }, {
        key: "disabled",
        get: function get() {
          return this.relatedGroup ? this.relatedGroup.disabled : this._disabled;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (this.relatedGroup) {
            this.relatedGroup.disabled = newValue;
          } else {
            this._disabled = newValue;
          }
        }
        /**
         * Gets whether the tab is selected.
         * ```typescript
         * const selectedItem = this.myTabComponent.tabs.first.isSelected;
         * ```
         * @return {?}
         */

      }, {
        key: "isSelected",
        get: function get() {
          return this.relatedGroup ? this.relatedGroup.isSelected : this._isSelected;
        }
        /**
         * @param {?} newValue
         * @return {?}
         */
        ,
        set: function set(newValue) {
          if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this : null);
          }
        }
      }, {
        key: "index",
        get: function get() {
          if (this._tabs.tabs) {
            return this._tabs.tabs.toArray().indexOf(this);
          }

          return -1;
        }
      }, {
        key: "template",
        get: function get() {
          if (this.relatedGroup && this.relatedGroup.customTabTemplate) {
            return this.relatedGroup.customTabTemplate;
          }

          if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
          }

          return this.defaultTabTemplate;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          return this.relatedGroup ? this.relatedGroup : this;
        }
      }]);

      return IgxTabItemComponent;
    }(IgxTabItemBase);

    IgxTabItemComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-tab-item',
        template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"igx-tabs__header-menu-item-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"changesCount\" [hidden]=\"changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"igx-tabs__item-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
      }]
    }];
    /** @nocollapse */

    IgxTabItemComponent.ctorParameters = function () {
      return [{
        type: IgxTabsBase
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }];
    };

    IgxTabItemComponent.propDecorators = {
      relatedGroup: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      icon: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      label: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      defaultTabTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultTabTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      customTabTemplateDir: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxTabItemTemplateDirective, {
          read: IgxTabItemTemplateDirective,
          "static": false
        }]
      }],
      provideCssClassSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__header-menu-item--selected']
      }],
      provideCssClassDisabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__header-menu-item--disabled']
      }],
      provideCssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-tabs__header-menu-item']
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.role']
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }],
      ariaLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-label']
      }],
      ariaDisabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-disabled']
      }],
      ariaSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-selected']
      }],
      ariaControls: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-controls']
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['$event']]
      }],
      onKeydownArrowRight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowright', ['$event']]
      }],
      onKeydownArrowLeft: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowleft', ['$event']]
      }],
      onKeydownHome: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.home', ['$event']]
      }],
      onKeydownEnd: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.end', ['$event']]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {string} */

    var TabsType = {
      FIXED: 'fixed',
      CONTENTFIT: 'contentfit'
    };

    var IgxTabsComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} _element
       * @param {?} _ngZone
       * @param {?} platformUtil
       */
      function IgxTabsComponent(_element, _ngZone, platformUtil) {
        _classCallCheck(this, IgxTabsComponent);

        this._element = _element;
        this._ngZone = _ngZone;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         */

        this.selectedIndexChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs tabsType="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */

        this.tabsType = 'contentfit';
        /**
         * @hidden
         */

        this["class"] = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */

        this.onTabItemDeselected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (onTabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */

        this.onTabItemSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        this.offset = 0;
        this._selectedIndex = -1;
      }
      /**
       * An \@Input property that sets the value of the `selectedIndex`.
       * Default value is 0.
       * ```html
       * <igx-tabs selectedIndex="1">
       * ```
       *
       * Two-way data binding.
       * ```html
       * <igx-tabs [(selectedIndex)]="model.selectedIndex">
       * ```
       * @return {?}
       */


      _createClass(IgxTabsComponent, [{
        key: "scrollLeft",

        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */
        value: function scrollLeft(event) {
          this.scroll(false);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "scrollRight",
        value: function scrollRight(event) {
          this.scroll(true);
        }
        /**
         * @hidden
         * @param {?} element
         * @param {?} scrollRight
         * @return {?}
         */

      }, {
        key: "scrollElement",
        value: function scrollElement(element, scrollRight) {
          /** @type {?} */
          var viewPortWidth = this.viewPort.nativeElement.offsetWidth;
          this.offset = scrollRight ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
          this.itemsContainer.nativeElement.style.transform = "translate(".concat(-this.offset, "px)");
        }
        /**
         * Gets the selected `IgxTabItemComponent`.
         * ```
         * const selectedItem = this.myTabComponent.selectedTabItem;
         * ```
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngAfterViewInit() {
          var _this376 = this;

          if (this._selectedIndex === -1) {
            this.tabs.forEach(function (t) {
              if (t.isSelected) {
                _this376._selectedIndex = t.index;
              }
            });
          }

          if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
            this._selectedIndex = 0;
          }

          if (this.platformUtil.isBrowser) {
            requestAnimationFrame(function () {
              /** @type {?} */
              var newTab = _this376.tabs.toArray()[_this376._selectedIndex];

              if (newTab) {
                _this376.performSelection(newTab);
              } else {
                _this376.hideIndicator();
              }
            });

            this._ngZone.runOutsideAngular(function () {
              _this376._resizeObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_8__["default"](function () {
                if (!_this376.hasContentTabs && _this376._selectedIndex >= 0 && _this376._selectedIndex < _this376.tabs.length) {
                  /** @type {?} */
                  var newTab = _this376.tabs.toArray()[_this376._selectedIndex];

                  _this376.transformContentAnimation(newTab, 0);
                }
              });

              _this376._resizeObserver.observe(_this376.tabsContainer.nativeElement);
            });
          }

          this._groupChanges$ = this.groups.changes.subscribe(function () {
            _this376.resetSelectionOnCollectionChanged();
          });
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          var _this377 = this;

          if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
          }

          if (this._resizeObserver) {
            this._ngZone.runOutsideAngular(function () {
              _this377._resizeObserver.disconnect();
            });
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "resetSelectionOnCollectionChanged",
        value: function resetSelectionOnCollectionChanged() {
          var _this378 = this;

          requestAnimationFrame(function () {
            /** @type {?} */
            var currentTab = _this378.tabs.toArray()[_this378.selectedIndex];

            if (currentTab) {
              _this378.performSelectionChange(currentTab);
            } else if (_this378.selectedIndex >= _this378.tabs.length) {
              _this378.performSelectionChange(_this378.tabs.last);
            } else {
              _this378.hideIndicator();
            }
          });
        }
        /**
         * @private
         * @param {?} scrollRight
         * @return {?}
         */

      }, {
        key: "scroll",
        value: function scroll(scrollRight) {
          /** @type {?} */
          var tabsArray = this.tabs.toArray();
          var _iteratorNormalCompletion65 = true;
          var _didIteratorError65 = false;
          var _iteratorError65 = undefined;

          try {
            for (var _iterator65 = tabsArray[Symbol.iterator](), _step65; !(_iteratorNormalCompletion65 = (_step65 = _iterator65.next()).done); _iteratorNormalCompletion65 = true) {
              var tab = _step65.value;

              /** @type {?} */
              var element = tab.nativeTabItem.nativeElement;

              if (scrollRight) {
                if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                  this.scrollElement(element, scrollRight);
                  break;
                }
              } else {
                if (element.offsetWidth + element.offsetLeft >= this.offset) {
                  this.scrollElement(element, scrollRight);
                  break;
                }
              }
            }
          } catch (err) {
            _didIteratorError65 = true;
            _iteratorError65 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion65 && _iterator65["return"] != null) {
                _iterator65["return"]();
              }
            } finally {
              if (_didIteratorError65) {
                throw _iteratorError65;
              }
            }
          }
        }
        /**
         * @hidden
         * @param {?} newTab
         * @return {?}
         */

      }, {
        key: "performSelectionChange",
        value: function performSelectionChange(newTab) {
          /** @type {?} */
          var oldTab = this.selectedTabItem;

          if (oldTab) {
            this.performDeselection(oldTab);
          }

          if (newTab) {
            this.performSelection(newTab);
          } else {
            // if there is no new selected tab hide the selection indicator
            this.hideIndicator();
          }

          this.selectedIndexChange.emit(this._selectedIndex);
        }
        /**
         * @private
         * @param {?} oldTab
         * @return {?}
         */

      }, {
        key: "performDeselection",
        value: function performDeselection(oldTab) {
          oldTab.setSelectedInternal(false);
          /** @type {?} */

          var oldTabRelatedGroup = this.groups.toArray()[oldTab.index];

          if (oldTabRelatedGroup) {
            oldTabRelatedGroup.setSelectedInternal(false);
          }

          this._selectedIndex = -1;
          this.onTabItemDeselected.emit({
            tab: oldTab,
            group: oldTabRelatedGroup
          });
        }
        /**
         * @private
         * @param {?} newTab
         * @return {?}
         */

      }, {
        key: "performSelection",
        value: function performSelection(newTab) {
          var _this379 = this;

          newTab.setSelectedInternal(true);
          this._selectedIndex = newTab.index;
          /** @type {?} */

          var newTabRelatedGroup = null;

          if (!this.hasContentTabs && this.groups) {
            newTabRelatedGroup = this.groups.toArray()[newTab.index];

            if (newTabRelatedGroup) {
              newTabRelatedGroup.setSelectedInternal(true);
            }
          }

          this.onTabItemSelected.emit({
            tab: newTab,
            group: newTabRelatedGroup
          });
          requestAnimationFrame(function () {
            // bring the new selected tab into view if it is not
            _this379.bringNewTabIntoView(newTab); // animate the new selection indicator


            _this379.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement); // animate the new tab's group content


            if (!_this379.hasContentTabs) {
              _this379.transformContentAnimation(newTab, 0.2);
            }
          });
        }
        /**
         * @private
         * @param {?} newTab
         * @return {?}
         */

      }, {
        key: "bringNewTabIntoView",
        value: function bringNewTabIntoView(newTab) {
          /** @type {?} */
          var tabNativeElement = newTab.nativeTabItem.nativeElement; // Scroll left if there is need

          if (tabNativeElement.offsetLeft < this.offset) {
            this.scrollElement(tabNativeElement, false);
          } // Scroll right if there is need

          /** @type {?} */


          var viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
          /** @type {?} */

          var delta = tabNativeElement.offsetLeft + tabNativeElement.offsetWidth - (viewPortOffsetWidth + this.offset); // Fix for IE 11, a difference is accumulated from the widths calculations

          if (delta > 1) {
            this.scrollElement(tabNativeElement, true);
          }
        }
        /**
         * @hidden
         * @param {?} tab
         * @param {?} duration
         * @return {?}
         */
        // animation for the new panel/group (not needed for tab only mode)

      }, {
        key: "transformContentAnimation",
        value: function transformContentAnimation(tab, duration) {
          /** @type {?} */
          var contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
          this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? "".concat(duration, "s") : 'initial';
          this.contentsContainer.nativeElement.style.transform = "translate(".concat(-contentOffset, "px)");
        }
        /**
         * @hidden
         * @param {?} element
         * @param {?=} duration
         * @return {?}
         */

      }, {
        key: "transformIndicatorAnimation",
        value: function transformIndicatorAnimation(element) {
          var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.3;

          if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? "".concat(duration, "s") : 'initial';
            this.selectedIndicator.nativeElement.style.width = "".concat(element.offsetWidth, "px");
            this.selectedIndicator.nativeElement.style.transform = "translate(".concat(element.offsetLeft, "px)");
          }
        }
        /**
         * @return {?}
         */

      }, {
        key: "hideIndicator",
        value: function hideIndicator() {
          if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
          }
        }
      }, {
        key: "selectedIndex",
        get: function get() {
          return this._selectedIndex;
        }
        /**
         * @param {?} index
         * @return {?}
         */
        ,
        set: function set(index) {
          /** @type {?} */
          var newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;

          if (this._selectedIndex !== newIndex) {
            if (this.tabs && this.tabs.length > 0) {
              /** @type {?} */
              var newTab = this.tabs.toArray()[newIndex];

              if (newTab) {
                this.performSelectionChange(newTab);
              }
            } else {
              this._selectedIndex = newIndex;
            }
          }
        }
        /**
         * Provides an observable collection of all `IgxTabItemComponent`s.
         * First try to get them as content children if not available get them as view children.
         * ```typescript
         * const tabItems = this.myTabComponent.tabs;
         * ```
         * @return {?}
         */

      }, {
        key: "tabs",
        get: function get() {
          if (this.hasContentTabs) {
            return this.contentTabs;
          }

          return this.viewTabs;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hasContentTabs",
        get: function get() {
          return this.contentTabs && this.contentTabs.length > 0;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "cssClass",
        get: function get() {
          /** @type {?} */
          var defaultStyle = "igx-tabs";
          /** @type {?} */

          var fixedStyle = "igx-tabs--fixed";
          /** @type {?} */

          var iconStyle = "igx-tabs--icons";
          /** @type {?} */

          var iconLabelFoundInGroups = this.groups.find(function (group) {
            return group.icon != null && group.label != null;
          });
          /** @type {?} */

          var iconLabelFoundInTabs = this.contentTabs.find(function (tab) {
            return tab.icon != null && tab.label != null;
          });
          /** @type {?} */

          var css;

          switch (TabsType[this.tabsType.toUpperCase()]) {
            case TabsType.FIXED:
              {
                css = fixedStyle;
                break;
              }

            default:
              {
                css = defaultStyle;
                break;
              }
          } // Layout fix for items with icons


          if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
            css = "".concat(css, " ").concat(iconStyle);
          }

          return "".concat(css, " ").concat(this["class"]);
        }
      }, {
        key: "selectedTabItem",
        get: function get() {
          if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
          }
        }
      }]);

      return IgxTabsComponent;
    }();

    IgxTabsComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        selector: 'igx-tabs',
        template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple *ngFor=\"let group of groups\" [relatedGroup]=\"group\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>",
        providers: [{
          provide: IgxTabsBase,
          useExisting: IgxTabsComponent
        }]
      }]
    }];
    /** @nocollapse */

    IgxTabsComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]
      }, {
        type: PlatformUtil
      }];
    };

    IgxTabsComponent.propDecorators = {
      groups: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxTabsGroupComponent;
        })]
      }],
      contentTabs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxTabItemComponent;
        })]
      }],
      selectedIndex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      selectedIndexChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      tabsType: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['tabsType']
      }],
      "class": [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onTabItemDeselected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onTabItemSelected: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      contentsContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['contentsContainer', {
          "static": true
        }]
      }],
      headerContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['headerContainer', {
          "static": true
        }]
      }],
      itemsContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['itemsContainer', {
          "static": true
        }]
      }],
      selectedIndicator: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['selectedIndicator', {
          "static": false
        }]
      }],
      tabsContainer: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['tabsContainer', {
          "static": true
        }]
      }],
      viewPort: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['viewPort', {
          "static": true
        }]
      }],
      viewTabs: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChildren"],
        args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["forwardRef"])(function () {
          return IgxTabItemComponent;
        })]
      }],
      cssClass: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.class']
      }]
    };
    /**
     * @hidden
     */

    var IgxTabsModule = function IgxTabsModule() {
      _classCallCheck(this, IgxTabsModule);
    };

    IgxTabsModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxTabsComponent, IgxTabsGroupComponent, IgxTabItemComponent, IgxTabItemTemplateDirective, IgxRightButtonStyleDirective, IgxLeftButtonStyleDirective],
        exports: [IgxTabsComponent, IgxTabsGroupComponent, IgxTabItemComponent, IgxTabItemTemplateDirective, IgxRightButtonStyleDirective, IgxLeftButtonStyleDirective],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxBadgeModule, IgxIconModule, IgxRippleModule]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     * @type {?}
     */

    var IGX_TIME_PICKER_COMPONENT = 'IgxTimePickerComponentToken';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @hidden
     */

    var IgxItemListDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} timePicker
       * @param {?} elementRef
       */
      function IgxItemListDirective(timePicker, elementRef) {
        _classCallCheck(this, IgxItemListDirective);

        this.timePicker = timePicker;
        this.elementRef = elementRef;
        this.tabindex = 0;
      }
      /**
       * @return {?}
       */


      _createClass(IgxItemListDirective, [{
        key: "onFocus",

        /**
         * @return {?}
         */
        value: function onFocus() {
          this.isActive = true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur() {
          this.isActive = false;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "nextItem",
        value: function nextItem() {
          switch (this.type) {
            case 'hourList':
              {
                this.timePicker.nextHour();
                break;
              }

            case 'minuteList':
              {
                this.timePicker.nextMinute();
                break;
              }

            case 'ampmList':
              {
                this.timePicker.nextAmPm();
                break;
              }
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "prevItem",
        value: function prevItem() {
          switch (this.type) {
            case 'hourList':
              {
                this.timePicker.prevHour();
                break;
              }

            case 'minuteList':
              {
                this.timePicker.prevMinute();
                break;
              }

            case 'ampmList':
              {
                this.timePicker.prevAmPm();
                break;
              }
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowDown",
        value: function onKeydownArrowDown(event) {
          event.preventDefault();
          this.nextItem();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowUp",
        value: function onKeydownArrowUp(event) {
          event.preventDefault();
          this.prevItem();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowRight",
        value: function onKeydownArrowRight(event) {
          event.preventDefault();
          /** @type {?} */

          var listName =
          /** @type {?} */
          event.target.className;

          if (listName.indexOf('hourList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
          } else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.ampmList) {
            this.timePicker.ampmList.nativeElement.focus();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownArrowLeft",
        value: function onKeydownArrowLeft(event) {
          event.preventDefault();
          /** @type {?} */

          var listName =
          /** @type {?} */
          event.target.className;

          if (listName.indexOf('ampmList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
          } else if ((listName.indexOf('ampmList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.hourList) {
            this.timePicker.hourList.nativeElement.focus();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownEnter",
        value: function onKeydownEnter(event) {
          event.preventDefault();

          if (this.timePicker.mode === InteractionMode.DropDown) {
            this.timePicker.close();
            return;
          }

          this.timePicker.okButtonClick();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownEscape",
        value: function onKeydownEscape(event) {
          event.preventDefault();
          this.timePicker.cancelButtonClick();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onHover",
        value: function onHover() {
          this.elementRef.nativeElement.focus();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onScroll",
        value: function onScroll(event) {
          event.preventDefault();
          event.stopPropagation();

          if (event.deltaY > 0) {
            this.nextItem();
          } else if (event.deltaY < 0) {
            this.prevItem();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onPanMove",
        value: function onPanMove(event) {
          if (event.deltaY < 0) {
            this.nextItem();
          } else if (event.deltaY > 0) {
            this.prevItem();
          }
        }
      }, {
        key: "defaultCSS",
        get: function get() {
          return true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "hourCSS",
        get: function get() {
          return this.type === 'hourList';
        }
        /**
         * @return {?}
         */

      }, {
        key: "minuteCSS",
        get: function get() {
          return this.type === 'minuteList';
        }
        /**
         * @return {?}
         */

      }, {
        key: "ampmCSS",
        get: function get() {
          return this.type === 'ampmList';
        }
      }]);

      return IgxItemListDirective;
    }();

    IgxItemListDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxItemList]'
      }]
    }];
    /** @nocollapse */

    IgxItemListDirective.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_TIME_PICKER_COMPONENT]
        }]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }];
    };

    IgxItemListDirective.propDecorators = {
      type: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxItemList']
      }],
      tabindex: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.tabindex']
      }],
      defaultCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__column']
      }],
      hourCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__hourList']
      }],
      minuteCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__minuteList']
      }],
      ampmCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__ampmList']
      }],
      onFocus: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['focus']
      }],
      onBlur: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['blur']
      }],
      onKeydownArrowDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowdown', ['$event']]
      }],
      onKeydownArrowUp: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowup', ['$event']]
      }],
      onKeydownArrowRight: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowright', ['$event']]
      }],
      onKeydownArrowLeft: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.arrowleft', ['$event']]
      }],
      onKeydownEnter: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.enter', ['$event']]
      }],
      onKeydownEscape: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.escape', ['$event']]
      }],
      onHover: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['mouseover']
      }],
      onScroll: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['wheel', ['$event']]
      }],
      onPanMove: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['panmove', ['$event']]
      }]
    };
    /**
     * @hidden
     */

    var IgxHourItemDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} timePicker
       * @param {?} itemList
       */
      function IgxHourItemDirective(timePicker, itemList) {
        _classCallCheck(this, IgxHourItemDirective);

        this.timePicker = timePicker;
        this.itemList = itemList;
      }
      /**
       * @return {?}
       */


      _createClass(IgxHourItemDirective, [{
        key: "onClick",

        /**
         * @param {?} item
         * @return {?}
         */
        value: function onClick(item) {
          if (item !== '') {
            this.timePicker.scrollHourIntoView(item);
          }
        }
      }, {
        key: "defaultCSS",
        get: function get() {
          return true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "selectedCSS",
        get: function get() {
          return this.isSelectedHour;
        }
        /**
         * @return {?}
         */

      }, {
        key: "activeCSS",
        get: function get() {
          return this.isSelectedHour && this.itemList.isActive;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isSelectedHour",
        get: function get() {
          return this.timePicker.selectedHour === this.value;
        }
      }]);

      return IgxHourItemDirective;
    }();

    IgxHourItemDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxHourItem]'
      }]
    }];
    /** @nocollapse */

    IgxHourItemDirective.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_TIME_PICKER_COMPONENT]
        }]
      }, {
        type: IgxItemListDirective
      }];
    };

    IgxHourItemDirective.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxHourItem']
      }],
      defaultCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__item']
      }],
      selectedCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__item--selected']
      }],
      activeCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__item--active']
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['value']]
      }]
    };
    /**
     * @hidden
     */

    var IgxMinuteItemDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} timePicker
       * @param {?} itemList
       */
      function IgxMinuteItemDirective(timePicker, itemList) {
        _classCallCheck(this, IgxMinuteItemDirective);

        this.timePicker = timePicker;
        this.itemList = itemList;
      }
      /**
       * @return {?}
       */


      _createClass(IgxMinuteItemDirective, [{
        key: "onClick",

        /**
         * @param {?} item
         * @return {?}
         */
        value: function onClick(item) {
          if (item !== '') {
            this.timePicker.scrollMinuteIntoView(item);
          }
        }
      }, {
        key: "defaultCSS",
        get: function get() {
          return true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "selectedCSS",
        get: function get() {
          return this.isSelectedMinute;
        }
        /**
         * @return {?}
         */

      }, {
        key: "activeCSS",
        get: function get() {
          return this.isSelectedMinute && this.itemList.isActive;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isSelectedMinute",
        get: function get() {
          return this.timePicker.selectedMinute === this.value;
        }
      }]);

      return IgxMinuteItemDirective;
    }();

    IgxMinuteItemDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxMinuteItem]'
      }]
    }];
    /** @nocollapse */

    IgxMinuteItemDirective.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_TIME_PICKER_COMPONENT]
        }]
      }, {
        type: IgxItemListDirective
      }];
    };

    IgxMinuteItemDirective.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxMinuteItem']
      }],
      defaultCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__item']
      }],
      selectedCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__item--selected']
      }],
      activeCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__item--active']
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['value']]
      }]
    };
    /**
     * @hidden
     */

    var IgxAmPmItemDirective =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} timePicker
       * @param {?} itemList
       */
      function IgxAmPmItemDirective(timePicker, itemList) {
        _classCallCheck(this, IgxAmPmItemDirective);

        this.timePicker = timePicker;
        this.itemList = itemList;
      }
      /**
       * @return {?}
       */


      _createClass(IgxAmPmItemDirective, [{
        key: "onClick",

        /**
         * @param {?} item
         * @return {?}
         */
        value: function onClick(item) {
          if (item !== '') {
            this.timePicker.scrollAmPmIntoView(item);
          }
        }
      }, {
        key: "defaultCSS",
        get: function get() {
          return true;
        }
        /**
         * @return {?}
         */

      }, {
        key: "selectedCSS",
        get: function get() {
          return this.isSelectedAmPm;
        }
        /**
         * @return {?}
         */

      }, {
        key: "activeCSS",
        get: function get() {
          return this.isSelectedAmPm && this.itemList.isActive;
        }
        /**
         * @return {?}
         */

      }, {
        key: "isSelectedAmPm",
        get: function get() {
          return this.timePicker.selectedAmPm === this.value;
        }
      }]);

      return IgxAmPmItemDirective;
    }();

    IgxAmPmItemDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxAmPmItem]'
      }]
    }];
    /** @nocollapse */

    IgxAmPmItemDirective.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_TIME_PICKER_COMPONENT]
        }]
      }, {
        type: IgxItemListDirective
      }];
    };

    IgxAmPmItemDirective.propDecorators = {
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"],
        args: ['igxAmPmItem']
      }],
      defaultCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__item']
      }],
      selectedCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__item--selected']
      }],
      activeCSS: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.igx-time-picker__item--active']
      }],
      onClick: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['click', ['value']]
      }]
    };
    /**
     * This directive should be used to mark which ng-template will be used from IgxTimePicker when re-templating its input group.
     */

    var IgxTimePickerTemplateDirective =
    /**
     * @param {?} template
     */
    function IgxTimePickerTemplateDirective(template) {
      _classCallCheck(this, IgxTimePickerTemplateDirective);

      this.template = template;
    };

    IgxTimePickerTemplateDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxTimePickerTemplate]'
      }]
    }];
    /** @nocollapse */

    IgxTimePickerTemplateDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * This directive can be used to add custom action buttons to the dropdownb/dialog.
     */


    var IgxTimePickerActionsDirective =
    /**
     * @param {?} template
     */
    function IgxTimePickerActionsDirective(template) {
      _classCallCheck(this, IgxTimePickerActionsDirective);

      this.template = template;
    };

    IgxTimePickerActionsDirective.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
      args: [{
        selector: '[igxTimePickerActions]'
      }]
    }];
    /** @nocollapse */

    IgxTimePickerActionsDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Formats `IgxTimePickerComponent` display value according to the `format` property,
     * when the input element loses focus.
     *
     */


    var TimeDisplayFormatPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} timePicker
       */
      function TimeDisplayFormatPipe(timePicker) {
        _classCallCheck(this, TimeDisplayFormatPipe);

        this.timePicker = timePicker;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(TimeDisplayFormatPipe, [{
        key: "transform",
        value: function transform(value) {
          /** @type {?} */
          var hour;
          /** @type {?} */

          var minutes;
          /** @type {?} */

          var amPM;
          /** @type {?} */

          var maskAmPM = this.timePicker.parseMask();
          /** @type {?} */

          var mask = this.timePicker.parseMask(false);

          if (!value || value === mask || value === maskAmPM) {
            return '';
          }
          /** @type {?} */


          var sections = value.split(/[\s:]+/);

          if (this.timePicker.showHoursList) {
            hour = sections[0];
          }

          if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
          }

          if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
          }
          /** @type {?} */


          var format = this.timePicker.format;
          /** @type {?} */

          var prompt = this.timePicker.promptChar;
          /** @type {?} */

          var regExp = new RegExp(this.timePicker.promptChar, 'g');

          if (format.indexOf('hh') !== -1 || format.indexOf('HH') !== -1 && hour.indexOf(prompt) !== -1) {
            hour = hour === prompt + prompt ? '00' : hour.replace(regExp, '0');
          }

          if (format.indexOf('mm') !== -1 && minutes.indexOf(prompt) !== -1) {
            minutes = minutes === prompt + prompt ? '00' : minutes.replace(regExp, '0');
          }

          if (format.indexOf('hh') === -1 && format.indexOf('HH') === -1 && hour !== undefined) {
            hour = hour.indexOf(prompt) !== -1 ? hour.replace(regExp, '') : hour;
            /** @type {?} */

            var hourVal = parseInt(hour, 10);
            hour = !hourVal ? '0' : hourVal < 10 && hourVal !== 0 ? hour.replace('0', '') : hour;
          }

          if (format.indexOf('mm') === -1 && minutes !== undefined) {
            minutes = minutes.indexOf(prompt) !== -1 ? minutes.replace(regExp, '') : minutes;
            /** @type {?} */

            var minutesVal = parseInt(minutes, 10);
            minutes = !minutesVal ? '0' : minutesVal < 10 && minutesVal !== 0 ? minutes.replace('0', '') : minutes;
          }

          if (format.indexOf('tt') !== -1 && (amPM !== 'AM' || amPM !== 'PM')) {
            amPM = amPM.indexOf('p') !== -1 || amPM.indexOf('P') !== -1 ? 'PM' : 'AM';
          }
          /** @type {?} */


          var result = amPM ? "".concat(hour, ":").concat(minutes, " ").concat(amPM) : "".concat(hour, ":").concat(minutes);

          if (!hour) {
            result = result.slice(result.indexOf(':') + 1, result.length);
          }

          if (!minutes) {
            result = result.slice(0, result.indexOf(':'));

            if (amPM) {
              result = result + ' ' + amPM;
            }
          }

          return result;
        }
      }]);

      return TimeDisplayFormatPipe;
    }();

    TimeDisplayFormatPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'displayFormat'
      }]
    }];
    /** @nocollapse */

    TimeDisplayFormatPipe.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_TIME_PICKER_COMPONENT]
        }]
      }];
    };
    /**
     * Formats `IgxTimePickerComponent` display value according to the `format` property,
     * when the input element gets focus.
     *
     */


    var TimeInputFormatPipe =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} timePicker
       */
      function TimeInputFormatPipe(timePicker) {
        _classCallCheck(this, TimeInputFormatPipe);

        this.timePicker = timePicker;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(TimeInputFormatPipe, [{
        key: "transform",
        value: function transform(value) {
          /** @type {?} */
          var prompt = this.timePicker.promptChar;
          /** @type {?} */

          var regExp = new RegExp(prompt, 'g');
          /** @type {?} */

          var mask;
          /** @type {?} */

          var hour;
          /** @type {?} */

          var minutes;
          /** @type {?} */

          var amPM;

          if (this.timePicker.cleared) {
            this.timePicker.cleared = false;
            mask = this.timePicker.parseMask(false);
          } else {
            mask = this.timePicker.parseMask();
          }

          if (!value || value === mask) {
            return mask;
          }
          /** @type {?} */


          var sections = value.split(/[\s:]+/);

          if (this.timePicker.showHoursList) {
            hour = sections[0];
            hour = hour.replace(regExp, '');
            /** @type {?} */

            var leadZeroHour = parseInt(hour, 10) < 10 && !hour.startsWith('0') || hour === '0';
            hour = leadZeroHour ? '0' + hour : hour;
          }

          if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
            minutes = minutes.replace(regExp, '');
            /** @type {?} */

            var leadZeroMinutes = parseInt(minutes, 10) < 10 && !minutes.startsWith('0') || minutes === '0';
            minutes = leadZeroMinutes ? '0' + minutes : minutes;
          }

          if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
          }
          /** @type {?} */


          var result = amPM ? "".concat(hour, ":").concat(minutes, " ").concat(amPM) : "".concat(hour, ":").concat(minutes);

          if (!hour) {
            result = result.slice(result.indexOf(':') + 1, result.length);
          }

          if (!minutes) {
            result = result.slice(0, result.indexOf(':'));

            if (amPM) {
              result = result + ' ' + amPM;
            }
          }

          return result;
        }
      }]);

      return TimeInputFormatPipe;
    }();

    TimeInputFormatPipe.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Pipe"],
      args: [{
        name: 'inputFormat'
      }]
    }];
    /** @nocollapse */

    TimeInputFormatPipe.ctorParameters = function () {
      return [{
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [IGX_TIME_PICKER_COMPONENT]
        }]
      }];
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var NEXT_ID$u = 0;
    /** @type {?} */

    var HOURS_POS = [0, 1, 2];
    /** @type {?} */

    var MINUTES_POS = [3, 4, 5];
    /** @type {?} */

    var AMPM_POS = [6, 7, 8];
    /** @type {?} */

    var ITEMS_COUNT = 7;

    var TimePickerHammerConfig =
    /*#__PURE__*/
    function (_angular_platform_bro2) {
      _inherits(TimePickerHammerConfig, _angular_platform_bro2);

      function TimePickerHammerConfig() {
        var _this380;

        _classCallCheck(this, TimePickerHammerConfig);

        _this380 = _possibleConstructorReturn(this, _getPrototypeOf(TimePickerHammerConfig).apply(this, arguments));
        _this380.overrides = {
          pan: {
            direction: Hammer.DIRECTION_VERTICAL,
            threshold: 1
          }
        };
        return _this380;
      }

      return TimePickerHammerConfig;
    }(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HammerGestureConfig"]);

    TimePickerHammerConfig.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"]
    }];

    var IgxTimePickerComponent =
    /*#__PURE__*/
    function () {
      function IgxTimePickerComponent() {
        _classCallCheck(this, IgxTimePickerComponent);

        /**
         * An \@Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-time-picker [id]="'igx-time-picker-5'" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.id = "igx-time-picker-".concat(NEXT_ID$u++);
        /**
         * An \@Input property that allows you to disable the `igx-time-picker` component. By default `disabled` is set to false.
         * ```html
         * <igx-time-picker [disabled]="'true'" [vertical]="true" format="h:mm tt" ></igx-time-picker>
         * ```
         */

        this.disabled = false;
        /**
         * An \@Input property that gets/sets the delta by which hour and minute items would be changed <br>
         * when the user presses the Up/Down keys.
         * By default `itemsDelta` is set to `{hours: 1, minutes:1}`
         * ```html
         * <igx-time-picker [itemsDelta]="{hours:3, minutes:5}" id="time-picker"></igx-time-picker>
         * ```
         */

        this.itemsDelta = {
          hours: 1,
          minutes: 1
        };
        /**
         * An \@Input property that determines the spin behavior. By default `isSpinLoop` is set to true.
         * The minutes and hour spinning will wrap around by default.
         * ```html
         * <igx-time-picker [isSpinLoop]="false" id="time-picker"></igx-time-picker>
         * ```
         */

        this.isSpinLoop = true;
        /**
         * An \@Input property that Gets/Sets the orientation of the `igxTimePicker`. By default `vertical` is set to false.
         * ```html
         * <igx-time-picker [vertical]="true" id="time-picker"></igx-time-picker>
         * ```
         */

        this.vertical = false;
        /**
         * Sets the character used to prompt the user for input.
         * Default value is "'-'".
         * ```html
         * <igx-time-picker [promptChar] = "'_'">
         * ```
         * \@memberof IgxTimePickerComponent
         */

        this.promptChar = '-';
        /**
         * An \@Input property that allows you to switch the interaction mode between
         * a dialog picker or dropdown with editable masked input.
         * Deafult is dialog picker.
         * ```html
         * public mode = InteractionMode.DROPDOWN;
         *  //..
         * <igx-time-picker [mode]="mode"></igx-time-picker>
         * ```
         * \@memberof IgxTimePickerComponent
         */

        this.mode = InteractionMode.Dialog;
        /**
         * Emitted when selection is made. The event contains the selected value. Returns {`oldValue`: `Date`, `newValue`: `Date`}.
         * ```typescript
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValueChanged(timepicker){
         *    this.toast.show()
         * }
         * //...
         * ```
         * ```html
         * <igx-time-picker (onValueChanged)="onValueChanged($event)"></igx-time-picker>
         * <igx-toast #toast message="The value has been changed!"></igx-toast>
         * ```
         */

        this.onValueChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when an invalid value is being set. Returns {`timePicker`: `any`, `currentValue`: `Date`, `setThroughUI`: `boolean`}
         * ```typescript
         * public min: string = "09:00";
         * public max: string = "18:00";
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValidationFailed(timepicker){
         *    this.toast.show();
         * }
         * //...
         * ```
         * ```html
         * <igx-time-picker [minValue]="min" [maxValue]="max" (onValidationFailed)="onValidationFailed($event)"></igx-time-picker>
         * <igx-toast #toast message="Value must be between 09:00 and 18:00!"></igx-toast>
         * ```
         */

        this.onValidationFailed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a timePicker is opened.
         */

        this.onOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a timePicker is closed.
         */

        this.onClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emitted when a timePicker is being closed.
         */

        this.onClosing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * @hidden
         */

        this._hourItems = [];
        /**
         * @hidden
         */

        this._minuteItems = [];
        /**
         * @hidden
         */

        this._ampmItems = [];
        /**
         * @hidden
         */

        this.cleared = false;
        /**
         * @hidden
         */

        this.isNotEmpty = false;
        /**
         * @hidden
         */

        this.displayFormat = new TimeDisplayFormatPipe(this);
        /**
         * @hidden
         */

        this.inputFormat = new TimeInputFormatPipe(this);
        this._resourceStrings = CurrentResourceStrings.TimePickerResStrings;
        this._okButtonLabel = null;
        this._cancelButtonLabel = null;
        this._isHourListLoop = this.isSpinLoop;
        this._isMinuteListLoop = this.isSpinLoop;
        this._hourView = [];
        this._minuteView = [];
        this._ampmView = [];
        this._destroy$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
        this._onOpen = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this._onClose = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();

        this._onTouchedCallback = function () {};

        this._onChangeCallback = function () {};
      }
      /**
       * An accessor that allows you to set a time using the `value` input.
       * ```html
       * public date: Date = new Date(Date.now());
       *  //...
       * <igx-time-picker [value]="date" format="h:mm tt"></igx-time-picker>
       * ```
       * @param {?} value
       * @return {?}
       */


      _createClass(IgxTimePickerComponent, [{
        key: "ngOnInit",

        /**
         * @hidden
         * @return {?}
         */
        value: function ngOnInit() {
          this._generateHours();

          this._generateMinutes();

          if (this.format.indexOf('tt') !== -1) {
            this._generateAmPm();
          }

          this._dropDownOverlaySettings = {
            modal: false,
            closeOnOutsideClick: true,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy()
          };
          this._dialogOverlaySettings = {};
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          var _this381 = this;

          if (this.mode === InteractionMode.DropDown && this.input) {
            Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(this.input.nativeElement, 'keydown').pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["throttle"])(function () {
              return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["interval"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["animationFrameScheduler"]);
            }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function (event) {
              if (event.key === "ArrowUp"
              /* UP_ARROW */
              || event.key === "Up"
              /* UP_ARROW_IE */
              || event.key === "ArrowDown"
              /* DOWN_ARROW */
              || event.key === "Down"
              /* DOWN_ARROW_IE */
              ) {
                  _this381.spinOnEdit(event);
                }
            });
          }

          if (this.toggleRef && this.group) {
            this.toggleRef.element.style.width = this.group.element.nativeElement.getBoundingClientRect().width + 'px';
          }

          if (this.toggleRef) {
            this.toggleRef.onClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function () {
              if (_this381.mode === InteractionMode.DropDown) {
                _this381._onDropDownClosed();
              }

              _this381.onClosed.emit(_this381); // TODO: remove this line after deprecating 'onClose'


              _this381._onClose.emit(_this381);
            });
            this.toggleRef.onOpened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function () {
              _this381.onOpened.emit(_this381); // TODO: remove this line after deprecating 'onOpen'


              _this381._onOpen.emit(_this381);
            });
            this.toggleRef.onClosing.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__["takeUntil"])(this._destroy$)).subscribe(function (event) {
              _this381.onClosing.emit(event); // If canceled in a user onClosing handler


              if (event.cancel) {
                return;
              } // Do not focus the input if clicking outside in dropdown mode

              /** @type {?} */


              var input = _this381.getEditElement();

              if (input && !(event.event && _this381.mode === InteractionMode.DropDown)) {
                input.focus();
              }
            });
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          this._destroy$.next(true);

          this._destroy$.complete();
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onKeydownSpace",
        value: function onKeydownSpace(event) {
          this.openDialog(this.getInputGroupElement());
          event.preventDefault();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "onAltArrowDown",
        value: function onAltArrowDown() {
          this.openDialog(this.getInputGroupElement());
        }
        /**
         * @private
         * @param {?} item
         * @param {?} items
         * @param {?} selectedItem
         * @param {?} isListLoop
         * @param {?} viewType
         * @return {?}
         */

      }, {
        key: "_scrollItemIntoView",
        value: function _scrollItemIntoView(item, items, selectedItem, isListLoop, viewType) {
          /** @type {?} */
          var itemIntoView;

          if (items) {
            /** @type {?} */
            var index = item === 'AM' || item === 'PM' ? items.indexOf(item) : items.indexOf(parseInt(item, 10));
            /** @type {?} */

            var view;

            if (index !== -1) {
              if (isListLoop) {
                if (index > 0) {
                  selectedItem = this._itemToString(items[index - 1], viewType);
                  itemIntoView = this._nextItem(items, selectedItem, isListLoop, viewType);
                } else {
                  selectedItem = this._itemToString(items[1], viewType);
                  itemIntoView = this._prevItem(items, selectedItem, isListLoop, viewType);
                }
              } else {
                view = items.slice(index - 3, index + 4);
                selectedItem = this._itemToString(items[index], viewType);
                itemIntoView = {
                  selectedItem: selectedItem,
                  view: view
                };
              }

              itemIntoView.view = this._viewToString(itemIntoView.view, viewType);
            }
          }

          return itemIntoView;
        }
        /**
         * @private
         * @param {?} view
         * @param {?} viewType
         * @return {?}
         */

      }, {
        key: "_viewToString",
        value: function _viewToString(view, viewType) {
          for (var i = 0; i < view.length; i++) {
            if (typeof view[i] !== 'string') {
              view[i] = this._itemToString(view[i], viewType);
            }
          }

          return view;
        }
        /**
         * @private
         * @param {?} item
         * @param {?} viewType
         * @return {?}
         */

      }, {
        key: "_itemToString",
        value: function _itemToString(item, viewType) {
          if (item === null) {
            item = '';
          } else if (viewType && typeof item !== 'string') {
            /** @type {?} */
            var leadZeroHour = item < 10 && (this.format.indexOf('hh') !== -1 || this.format.indexOf('HH') !== -1);
            /** @type {?} */

            var leadZeroMinute = item < 10 && this.format.indexOf('mm') !== -1;
            /** @type {?} */

            var leadZero = viewType === 'hour' ? leadZeroHour : leadZeroMinute;
            item = leadZero ? '0' + item : "".concat(item);
          }

          return item;
        }
        /**
         * @private
         * @param {?} items
         * @param {?} selectedItem
         * @param {?} isListLoop
         * @param {?} viewType
         * @return {?}
         */

      }, {
        key: "_prevItem",
        value: function _prevItem(items, selectedItem, isListLoop, viewType) {
          /** @type {?} */
          var selectedIndex = items.indexOf(parseInt(selectedItem, 10));
          /** @type {?} */

          var itemsCount = items.length;
          /** @type {?} */

          var view;

          if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
          } else if (isListLoop) {
            if (selectedIndex - 4 < 0) {
              view = items.slice(itemsCount - (4 - selectedIndex), itemsCount);
              view = view.concat(items.slice(0, selectedIndex + 3));
            } else if (selectedIndex + 4 > itemsCount) {
              view = items.slice(selectedIndex - 4, itemsCount);
              view = view.concat(items.slice(0, selectedIndex + 3 - itemsCount));
            } else {
              view = items.slice(selectedIndex - 4, selectedIndex + 3);
            }

            selectedItem = selectedIndex === 0 ? items[itemsCount - 1] : items[selectedIndex - 1];
          } else if (selectedIndex > 3) {
            view = items.slice(selectedIndex - 4, selectedIndex + 3);
            selectedItem = items[selectedIndex - 1];
          } else if (selectedIndex === 3) {
            view = items.slice(0, 7);
          }

          view = this._viewToString(view, viewType);
          selectedItem = this._itemToString(selectedItem, viewType);
          return {
            selectedItem: selectedItem,
            view: view
          };
        }
        /**
         * @private
         * @param {?} items
         * @param {?} selectedItem
         * @param {?} isListLoop
         * @param {?} viewType
         * @return {?}
         */

      }, {
        key: "_nextItem",
        value: function _nextItem(items, selectedItem, isListLoop, viewType) {
          /** @type {?} */
          var selectedIndex = items.indexOf(parseInt(selectedItem, 10));
          /** @type {?} */

          var itemsCount = items.length;
          /** @type {?} */

          var view;

          if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
          } else if (isListLoop) {
            if (selectedIndex < 2) {
              view = items.slice(itemsCount - (2 - selectedIndex), itemsCount);
              view = view.concat(items.slice(0, selectedIndex + 5));
            } else if (selectedIndex + 4 >= itemsCount) {
              view = items.slice(selectedIndex - 2, itemsCount);
              view = view.concat(items.slice(0, selectedIndex + 5 - itemsCount));
            } else {
              view = items.slice(selectedIndex - 2, selectedIndex + 5);
            }

            selectedItem = selectedIndex === itemsCount - 1 ? items[0] : items[selectedIndex + 1];
          } else if (selectedIndex + 1 < itemsCount - 3) {
            view = items.slice(selectedIndex - 2, selectedIndex + 5);
            selectedItem = items[selectedIndex + 1];
          } else if (selectedIndex === itemsCount - 4) {
            view = items.slice(selectedIndex - 3, itemsCount);
          }

          view = this._viewToString(view, viewType);
          selectedItem = this._itemToString(selectedItem, viewType);
          return {
            selectedItem: selectedItem,
            view: view
          };
        }
        /**
         * @private
         * @param {?} value
         * @param {?} format
         * @return {?}
         */

      }, {
        key: "_formatTime",
        value: function _formatTime(value, format) {
          if (!value) {
            return '';
          } else {
            /** @type {?} */
            var hour = value.getHours();
            /** @type {?} */

            var formattedMinute;
            /** @type {?} */

            var formattedHour;
            /** @type {?} */

            var minute = value.getMinutes();
            /** @type {?} */

            var amPM = hour > 11 ? 'PM' : 'AM';

            if (format.indexOf('h') !== -1) {
              if (hour > 12) {
                hour -= 12;
                formattedHour = hour < 10 && format.indexOf('hh') !== -1 ? '0' + hour : "".concat(hour);
              } else if (hour === 0) {
                formattedHour = '12';
              } else if (hour < 10 && format.indexOf('hh') !== -1) {
                formattedHour = '0' + hour;
              } else {
                formattedHour = "".concat(hour);
              }
            } else {
              if (hour < 10 && format.indexOf('HH') !== -1) {
                formattedHour = '0' + hour;
              } else {
                formattedHour = "".concat(hour);
              }
            }

            formattedMinute = minute < 10 && format.indexOf('mm') !== -1 ? '0' + minute : "".concat(minute);
            return format.replace('hh', formattedHour).replace('h', formattedHour).replace('HH', formattedHour).replace('H', formattedHour).replace('mm', formattedMinute).replace('m', formattedMinute).replace('tt', amPM);
          }
        }
        /**
         * @private
         * @param {?} start
         * @param {?} end
         * @return {?}
         */

      }, {
        key: "_updateHourView",
        value: function _updateHourView(start, end) {
          this._hourView = this._viewToString(this._hourItems.slice(start, end), 'hour');
        }
        /**
         * @private
         * @param {?} start
         * @param {?} end
         * @return {?}
         */

      }, {
        key: "_updateMinuteView",
        value: function _updateMinuteView(start, end) {
          this._minuteView = this._viewToString(this._minuteItems.slice(start, end), 'minute');
        }
        /**
         * @private
         * @param {?} start
         * @param {?} end
         * @return {?}
         */

      }, {
        key: "_updateAmPmView",
        value: function _updateAmPmView(start, end) {
          this._ampmView = this._ampmItems.slice(start, end);
        }
        /**
         * @private
         * @param {?} items
         * @return {?}
         */

      }, {
        key: "_addEmptyItems",
        value: function _addEmptyItems(items) {
          for (var i = 0; i < 3; i++) {
            items.push(null);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_generateHours",
        value: function _generateHours() {
          /** @type {?} */
          var hourItemsCount = 24;

          if (this.format.indexOf('h') !== -1) {
            hourItemsCount = 13;
          }

          hourItemsCount /= this.itemsDelta.hours;
          /** @type {?} */

          var i = this.format.indexOf('H') !== -1 ? 0 : 1;

          if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);

            this._isHourListLoop = false;
          }

          if (hourItemsCount > 1) {
            for (i; i < hourItemsCount; i++) {
              this._hourItems.push(i * this.itemsDelta.hours);
            }
          } else {
            this._hourItems.push(0);
          }

          if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_generateMinutes",
        value: function _generateMinutes() {
          /** @type {?} */
          var minuteItemsCount = 60 / this.itemsDelta.minutes;

          if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);

            this._isMinuteListLoop = false;
          }

          for (var i = 0; i < minuteItemsCount; i++) {
            this._minuteItems.push(i * this.itemsDelta.minutes);
          }

          if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
          }
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_generateAmPm",
        value: function _generateAmPm() {
          this._addEmptyItems(this._ampmItems);

          this._ampmItems.push('AM');

          this._ampmItems.push('PM');

          this._addEmptyItems(this._ampmItems);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getSelectedTime",
        value: function _getSelectedTime() {
          /** @type {?} */
          var date = this.value ? new Date(this.value) : new Date();

          if (this.selectedHour) {
            date.setHours(parseInt(this.selectedHour, 10));
          }

          if (this.selectedMinute) {
            date.setMinutes(parseInt(this.selectedMinute, 10));
          }

          date.setSeconds(0);

          if ((this.showHoursList && this.selectedHour !== '12' || !this.showHoursList && this.selectedHour <= '11') && this.selectedAmPm === 'PM') {
            date.setHours(date.getHours() + 12);
          }

          if (!this.showHoursList && this.selectedAmPm === 'AM' && this.selectedHour > '11') {
            date.setHours(date.getHours() - 12);
          }

          if (this.selectedAmPm === 'AM' && this.selectedHour === '12') {
            date.setHours(0);
          }

          return date;
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_convertMinMaxValue",
        value: function _convertMinMaxValue(value) {
          /** @type {?} */
          var date = this.value ? new Date(this.value) : this._dateFromModel ? new Date(this._dateFromModel) : new Date();
          /** @type {?} */

          var sections = value.split(/[\s:]+/);
          /** @type {?} */

          var hour;
          /** @type {?} */

          var minutes;
          /** @type {?} */

          var amPM;
          date.setSeconds(0);

          if (this.showHoursList) {
            hour = sections[0];
            date.setHours(parseInt(hour, 10));
          }

          if (this.showMinutesList) {
            minutes = this.showHoursList ? sections[1] : sections[0];
            date.setMinutes(parseInt(minutes, 10));
          }

          if (this.showAmPmList) {
            amPM = sections[sections.length - 1];

            if ((this.showHoursList && date.getHours().toString() !== '12' || !this.showHoursList && date.getHours().toString() <= '11') && amPM === 'PM') {
              date.setHours(date.getHours() + 12);
            }

            if (!this.showHoursList && amPM === 'AM' && date.getHours().toString() > '11') {
              date.setHours(date.getHours() - 12);
            }

            if (this.showHoursList && date.getHours() === 12 && amPM === 'AM') {
              date.setHours(0);
            }
          }

          return date;
        }
        /**
         * @private
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "_isValueValid",
        value: function _isValueValid(value) {
          if (this.maxValue && value > this._convertMinMaxValue(this.maxValue)) {
            return false;
          } else if (this.minValue && value < this._convertMinMaxValue(this.minValue)) {
            return false;
          }

          return true;
        }
        /**
         * @private
         * @param {?} val
         * @return {?}
         */

      }, {
        key: "_isEntryValid",
        value: function _isEntryValid(val) {
          /** @type {?} */
          var validH = true;
          /** @type {?} */

          var validM = true;
          /** @type {?} */

          var sections = val.split(/[\s:]+/);
          /** @type {?} */

          var re = new RegExp(this.promptChar, 'g');

          if (this.showHoursList) {
            validH = this.validHourEntries.indexOf(parseInt(sections[0].replace(re, ''), 10)) !== -1;
          }

          if (this.showMinutesList) {
            /** @type {?} */
            var minutes = this.showHoursList ? sections[1] : sections[0];
            validM = this.validMinuteEntries.indexOf(parseInt(minutes.replace(re, ''), 10)) !== -1;
          }

          return validH && validM;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_getCursorPosition",
        value: function _getCursorPosition() {
          return this.input.nativeElement.selectionStart;
        }
        /**
         * @private
         * @param {?} start
         * @param {?=} end
         * @return {?}
         */

      }, {
        key: "_setCursorPosition",
        value: function _setCursorPosition(start) {
          var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;
          this.input.nativeElement.setSelectionRange(start, end);
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_updateEditableInput",
        value: function _updateEditableInput() {
          if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this._getSelectedTime(), this.format);
          }
        }
        /**
         * @private
         * @param {?} currentVal
         * @param {?} minVal
         * @param {?} maxVal
         * @param {?} hDelta
         * @param {?} sign
         * @return {?}
         */

      }, {
        key: "_spinHours",
        value: function _spinHours(currentVal, minVal, maxVal, hDelta, sign) {
          /** @type {?} */
          var oldVal = new Date(currentVal);
          currentVal.setMinutes(sign * hDelta);

          if (currentVal.getDate() !== oldVal.getDate() && this.isSpinLoop) {
            currentVal.setDate(oldVal.getDate());
          }
          /** @type {?} */


          var minutes = currentVal.getMinutes();

          if (currentVal.getTime() > maxVal.getTime()) {
            if (this.isSpinLoop) {
              minutes = minutes < minVal.getMinutes() ? 60 + minutes : minutes;
              minVal.setMinutes(sign * minutes);
              return minVal;
            } else {
              return oldVal;
            }
          } else if (currentVal.getTime() < minVal.getTime()) {
            if (this.isSpinLoop) {
              minutes = minutes <= maxVal.getMinutes() ? minutes : minutes - 60;
              maxVal.setMinutes(minutes);
              return maxVal;
            } else {
              return oldVal;
            }
          } else {
            return currentVal;
          }
        }
        /**
         * @private
         * @param {?} currentVal
         * @param {?} mDelta
         * @param {?} sign
         * @return {?}
         */

      }, {
        key: "_spinMinutes",
        value: function _spinMinutes(currentVal, mDelta, sign) {
          /** @type {?} */
          var minutes = currentVal.getMinutes() + sign * mDelta;

          if (minutes < 0 || minutes >= 60) {
            minutes = this.isSpinLoop ? minutes - sign * 60 : currentVal.getMinutes();
          }

          currentVal.setMinutes(minutes);
          return currentVal;
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_initializeContainer",
        value: function _initializeContainer() {
          var _this382 = this;

          if (this.value) {
            /** @type {?} */
            var formttedTime = this._formatTime(this.value, this.format);
            /** @type {?} */


            var sections = formttedTime.split(/[\s:]+/);

            if (this.showHoursList) {
              this.selectedHour = sections[0];
            }

            if (this.showMinutesList) {
              this.selectedMinute = this.showHoursList ? sections[1] : sections[0];
            }

            if (this.showAmPmList && this._ampmItems !== null) {
              this.selectedAmPm = sections[sections.length - 1];
            }
          }

          if (this.selectedHour === undefined) {
            this.selectedHour = !this.showHoursList && this.value ? this.value.getHours().toString() : this.showHoursList ? "".concat(this._hourItems[3]) : '0';
          }

          if (this.selectedMinute === undefined) {
            this.selectedMinute = !this.showMinutesList && this.value ? this.value.getMinutes().toString() : '0';
          }

          if (this.selectedAmPm === undefined && this._ampmItems !== null) {
            this.selectedAmPm = this._ampmItems[3];
          }

          this._prevSelectedHour = this.selectedHour;
          this._prevSelectedMinute = this.selectedMinute;
          this._prevSelectedAmPm = this.selectedAmPm;

          this._onTouchedCallback();

          this._updateHourView(0, ITEMS_COUNT);

          this._updateMinuteView(0, ITEMS_COUNT);

          this._updateAmPmView(0, ITEMS_COUNT);

          if (this.selectedHour) {
            this.scrollHourIntoView(this.selectedHour);
          }

          if (this.selectedMinute) {
            this.scrollMinuteIntoView(this.selectedMinute);
          }

          if (this.selectedAmPm) {
            this.scrollAmPmIntoView(this.selectedAmPm);
          }

          requestAnimationFrame(function () {
            if (_this382.hourList) {
              _this382.hourList.nativeElement.focus();
            } else if (_this382.minuteList) {
              _this382.minuteList.nativeElement.focus();
            }
          });
        }
        /**
         * @private
         * @return {?}
         */

      }, {
        key: "_onDropDownClosed",
        value: function _onDropDownClosed() {
          /** @type {?} */
          var oldValue = this.value;
          /** @type {?} */

          var newVal = this._convertMinMaxValue(this.displayValue);

          if (this.displayValue === this.parseMask(false)) {
            return;
          }

          if (this._isValueValid(newVal)) {
            if (!this.value || oldValue.getTime() !== newVal.getTime()) {
              this.value = newVal;
            }
          } else {
            this.displayValue = this.inputFormat.transform(this._formatTime(oldValue, this.format));
            /** @type {?} */

            var args = {
              timePicker: this,
              currentValue: newVal,
              setThroughUI: true
            };
            this.onValidationFailed.emit(args);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getEditElement",
        value: function getEditElement() {
          return this._input ? this._input.nativeElement : null;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "getInputGroupElement",
        value: function getInputGroupElement() {
          return this.group ? this.group.element.nativeElement : null;
        }
        /**
         * @hidden
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "writeValue",
        value: function writeValue(value) {
          // use this flag to make sure that min/maxValue are checked (in _convertMinMaxValue() method)
          // against the real value when initializing the component and value is bound via ngModel
          this._dateFromModel = value;
          this.value = value;

          if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this.value, this.format);
          }
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnChange",
        value: function registerOnChange(fn) {
          this._onChangeCallback = fn;
        }
        /**
         * @hidden
         * @param {?} isDisabled
         * @return {?}
         */

      }, {
        key: "setDisabledState",
        value: function setDisabledState(isDisabled) {
          this.disabled = isDisabled;
        }
        /**
         * @hidden
         * @param {?} fn
         * @return {?}
         */

      }, {
        key: "registerOnTouched",
        value: function registerOnTouched(fn) {
          this._onTouchedCallback = fn;
        }
        /**
         * opens the dialog.
         * @param {?=} target HTMLElement - the target element to use for positioning the drop down container according to
         * ```html
         * <igx-time-picker [value]="date" mode="dropdown" #retemplated>
         *   <ng-template igxTimePickerTemplate let-openDialog="openDialog"
         *                let-displayTime="displayTime">
         *     <igx-input-group>
         *       <input #dropDownTarget igxInput [value]="displayTime" />
         *       <igx-suffix (click)="openDialog(dropDownTarget)">
         *         <igx-icon>alarm</igx-icon>
         *       </igx-suffix>
         *     </igx-input-group>
         *   </ng-template>
         * </igx-time-picker>
         * ```
         * @return {?}
         */

      }, {
        key: "openDialog",
        value: function openDialog(target) {
          if (!this.toggleRef.collapsed) {
            return this._onDropDownClosed();
          }
          /** @type {?} */


          var settings = this.overlaySettings;

          if (target && settings && settings.positionStrategy) {
            settings.positionStrategy.settings.target = target;
          }

          if (this.outlet) {
            settings.outlet = this.outlet;
          }

          this.toggleRef.open(settings);

          this._initializeContainer();
        }
        /**
         * Scrolls a hour item into view.
         * ```typescript
         * scrhintoView(picker) {
         * picker.scrollHourIntoView('2');
         * }
         * ```
         * ```html
         * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrhintoView(picker)"></igx-time-picker>
         * ```
         * @param {?} item to be scrolled in view.
         * @return {?}
         */

      }, {
        key: "scrollHourIntoView",
        value: function scrollHourIntoView(item) {
          if (this.showHoursList) {
            /** @type {?} */
            var hourIntoView = this._scrollItemIntoView(item, this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');

            if (hourIntoView) {
              this._hourView = hourIntoView.view;
              this.selectedHour = hourIntoView.selectedItem;

              this._updateEditableInput();
            }
          }
        }
        /**
         * Scrolls a minute item into view.
         * ```typescript
         * scrMintoView(picker) {
         * picker.scrollMinuteIntoView('3');
         * }
         * ```
         * ```html
         * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrMintoView(picker)"></igx-time-picker>
         * ```
         * @param {?} item to be scrolled in view.
         * @return {?}
         */

      }, {
        key: "scrollMinuteIntoView",
        value: function scrollMinuteIntoView(item) {
          if (this.showMinutesList) {
            /** @type {?} */
            var minuteIntoView = this._scrollItemIntoView(item, this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');

            if (minuteIntoView) {
              this._minuteView = minuteIntoView.view;
              this.selectedMinute = minuteIntoView.selectedItem;

              this._updateEditableInput();
            }
          }
        }
        /**
         * Scrolls an ampm item into view.
         * ```typescript
         * scrAmPmIntoView(picker) {
         * picker.scrollAmPmIntoView('PM');
         * }
         * ```
         * ```html
         * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrAmPmIntoView(picker)"></igx-time-picker>
         * ```
         * @param {?} item to be scrolled in view.
         * @return {?}
         */

      }, {
        key: "scrollAmPmIntoView",
        value: function scrollAmPmIntoView(item) {
          if (this.showAmPmList) {
            /** @type {?} */
            var ampmIntoView = this._scrollItemIntoView(item, this._ampmItems, this.selectedAmPm, false, null);

            if (ampmIntoView) {
              this._ampmView = ampmIntoView.view;
              this.selectedAmPm = ampmIntoView.selectedItem;

              this._updateEditableInput();
            }
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "nextHour",
        value: function nextHour() {
          /** @type {?} */
          var nextHour = this._nextItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');

          this._hourView = nextHour.view;
          this.selectedHour = nextHour.selectedItem;

          this._updateEditableInput();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "prevHour",
        value: function prevHour() {
          /** @type {?} */
          var prevHour = this._prevItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');

          this._hourView = prevHour.view;
          this.selectedHour = prevHour.selectedItem;

          this._updateEditableInput();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "nextMinute",
        value: function nextMinute() {
          /** @type {?} */
          var nextMinute = this._nextItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');

          this._minuteView = nextMinute.view;
          this.selectedMinute = nextMinute.selectedItem;

          this._updateEditableInput();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "prevMinute",
        value: function prevMinute() {
          /** @type {?} */
          var prevMinute = this._prevItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');

          this._minuteView = prevMinute.view;
          this.selectedMinute = prevMinute.selectedItem;

          this._updateEditableInput();
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "nextAmPm",
        value: function nextAmPm() {
          /** @type {?} */
          var selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);

          if (selectedIndex + 1 < this._ampmItems.length - 3) {
            this._updateAmPmView(selectedIndex - 2, selectedIndex + 5);

            this.selectedAmPm = this._ampmItems[selectedIndex + 1];

            this._updateEditableInput();
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "prevAmPm",
        value: function prevAmPm() {
          /** @type {?} */
          var selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);

          if (selectedIndex > 3) {
            this._updateAmPmView(selectedIndex - 4, selectedIndex + 3);

            this.selectedAmPm = this._ampmItems[selectedIndex - 1];

            this._updateEditableInput();
          }
        }
        /**
         * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
         * ```html
         * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
         * //..
         * </igx-dialog>
         * ```
         * @return {?}
         */

      }, {
        key: "okButtonClick",
        value: function okButtonClick() {
          /** @type {?} */
          var time = this._getSelectedTime();

          if (this._isValueValid(time)) {
            this.close();
            this.value = time;
            return true;
          } else {
            /** @type {?} */
            var args = {
              timePicker: this,
              currentValue: time,
              setThroughUI: true
            };
            this.onValidationFailed.emit(args);
            return false;
          }
        }
        /**
         * Closes the dialog without selecting the current value.
         * ```html
         * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
         * //...
         * </igx-dialog>
         * ```
         * @return {?}
         */

      }, {
        key: "cancelButtonClick",
        value: function cancelButtonClick() {
          if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this.value ? this._formatTime(this.value, this.format) : this.parseMask(false);
          }

          this.close();
          this.selectedHour = this._prevSelectedHour;
          this.selectedMinute = this._prevSelectedMinute;
          this.selectedAmPm = this._prevSelectedAmPm;
        }
        /**
         * Returns an array of the hours currently in view.
         * ```html
         * \@ViewChild("MyChild")
         * private picker: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *    let hInView = this.picker.hoursInView;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "hoursInView",
        value: function hoursInView() {
          return this._hourView.filter(function (hour) {
            return hour !== '';
          });
        }
        /**
         * Returns an array of the minutes currently in view.
         * ```html
         * \@ViewChild("MyChild")
         * private picker: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *    let minInView = this.picker.minutesInView;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "minutesInView",
        value: function minutesInView() {
          return this._minuteView.filter(function (minute) {
            return minute !== '';
          });
        }
        /**
         * Returns an array of the AM/PM currently in view.
         * ```html
         * \@ViewChild("MyChild")
         * private picker: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *    let ApInView = this.picker.ampmInView;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "ampmInView",
        value: function ampmInView() {
          return this._ampmView.filter(function (ampm) {
            return ampm !== '';
          });
        }
        /**
         * Closes the dropdown/dialog.
         * ```html
         * <igx-time-picker #timePicker></igx-time-picker>
         * ```
         * ```typescript
         * \@ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
         * picker.close();
         * ```
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          this.toggleRef.close();
        }
        /**
         * @hidden
         * @param {?=} preserveAmPm
         * @return {?}
         */

      }, {
        key: "parseMask",
        value: function parseMask() {
          var preserveAmPm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          /** @type {?} */
          var maskWithAmPm = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace('LL', 'AM');
          /** @type {?} */

          var pureMask = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace(new RegExp('L', 'g'), this.promptChar);
          return preserveAmPm ? maskWithAmPm : pureMask;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "clear",
        value: function clear() {
          if (this.toggleRef.collapsed) {
            this.cleared = true;
            this.isNotEmpty = false;
            /** @type {?} */

            var oldVal = new Date(this.value);
            this.displayValue = '';
            this.value.setHours(0, 0);

            if (oldVal.getTime() !== this.value.getTime()) {
              /** @type {?} */
              var args = {
                oldValue: oldVal,
                newValue: this.value
              };
              this.onValueChanged.emit(args);
            }
          } else {
            this.close();
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onInput",
        value: function onInput(event) {
          /** @type {?} */
          var val = event.target.value;
          /** @type {?} */

          var oldVal = new Date(this.value);
          this.isNotEmpty = val !== this.parseMask(false); // handle cases where all empty positions (promts) are filled and we want to update
          // timepicker own value property if it is a valid Date

          if (val.indexOf(this.promptChar) === -1) {
            if (this._isEntryValid(val)) {
              /** @type {?} */
              var newVal = this._convertMinMaxValue(val);

              if (oldVal.getTime() !== newVal.getTime()) {
                this.value = newVal;
              }
            } else {
              /** @type {?} */
              var args = {
                timePicker: this,
                currentValue: val,
                setThroughUI: false
              };
              this.onValidationFailed.emit(args);
            } // handle cases where the user deletes the display value (when pressing backspace or delete)

          } else if (!this.value || !val || val === this.parseMask(false)) {
            this.isNotEmpty = false;
            this.value.setHours(0, 0);
            this.displayValue = val;

            if (oldVal.getTime() !== this.value.getTime()) {
              /** @type {?} */
              var _args2 = {
                oldValue: oldVal,
                newValue: this.value
              };
              this.onValueChanged.emit(_args2);
            }
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onFocus",
        value: function onFocus(event) {
          this.isNotEmpty = event.target.value !== this.parseMask(false);
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "onBlur",
        value: function onBlur(event) {
          /** @type {?} */
          var value = event.target.value;
          this.isNotEmpty = value !== '';
          this.displayValue = value;

          if (value && value !== this.parseMask()) {
            if (this._isEntryValid(value)) {
              /** @type {?} */
              var newVal = this._convertMinMaxValue(value);

              if (!this.value || this.value.getTime() !== newVal.getTime()) {
                this.value = newVal;
              }
            } else {
              /** @type {?} */
              var args = {
                timePicker: this,
                currentValue: value,
                setThroughUI: false
              };
              this.onValidationFailed.emit(args);
            }
          }
        }
        /**
         * @hidden
         * @param {?} event
         * @return {?}
         */

      }, {
        key: "spinOnEdit",
        value: function spinOnEdit(event) {
          var _this383 = this;

          event.preventDefault();
          /** @type {?} */

          var sign;
          /** @type {?} */

          var displayVal;
          /** @type {?} */

          var currentVal = new Date(this.value);
          /** @type {?} */

          var min = this.minValue ? this._convertMinMaxValue(this.minValue) : this._convertMinMaxValue('00:00');
          /** @type {?} */

          var max = this.maxValue ? this._convertMinMaxValue(this.maxValue) : this._convertMinMaxValue('24:00');
          /** @type {?} */

          var cursor = this._getCursorPosition();

          if (event.key) {
            /** @type {?} */
            var key = event.key;
            sign = key === "ArrowDown"
            /* DOWN_ARROW */
            || key === "Down"
            /* DOWN_ARROW_IE */
            ? -1 : 1;
          }

          if (event.deltaY) {
            sign = event.deltaY < 0 ? 1 : -1;
          }

          if (!this.displayValue) {
            this.value = min;
            displayVal = this._formatTime(this.value, this.format);
          } else {
            /** @type {?} */
            var hDelta = this.itemsDelta.hours * 60 + sign * this.value.getMinutes();
            /** @type {?} */

            var mDelta = this.itemsDelta.minutes;

            if (this.showHoursList && HOURS_POS.indexOf(cursor) !== -1) {
              this.value = this._spinHours(currentVal, min, max, hDelta, sign);
            }

            if (this.showMinutesList && (this.showHoursList && MINUTES_POS.indexOf(cursor) !== -1 || !this.showHoursList && HOURS_POS.indexOf(cursor) !== -1)) {
              this.value = this._spinMinutes(currentVal, mDelta, sign);
            }

            if (this.showAmPmList) {
              if ((!this.showHoursList || !this.showMinutesList) && MINUTES_POS.indexOf(cursor) !== -1 || this.showHoursList && this.showMinutesList && AMPM_POS.indexOf(cursor) !== -1) {
                /** @type {?} */
                var sections = this.displayValue.split(/[\s:]+/);
                sign = sections[sections.length - 1] === 'AM' ? 1 : -1;
                currentVal.setHours(currentVal.getHours() + sign * 12);
                this.value = currentVal;
              }
            }

            displayVal = this._formatTime(this.value, this.format);
          } // minor hack for preventing cursor jumping in IE


          this.displayValue = this.inputFormat.transform(displayVal);
          this.input.nativeElement.value = this.displayValue;

          this._setCursorPosition(cursor);

          requestAnimationFrame(function () {
            _this383._setCursorPosition(cursor);
          });
        }
      }, {
        key: "value",
        set: function set(value) {
          if (this._isValueValid(value)) {
            /** @type {?} */
            var oldVal = this._value;
            this._value = value;

            this._onChangeCallback(value);
            /** @type {?} */


            var dispVal = this._formatTime(this.value, this.format);

            if (this.mode === InteractionMode.DropDown && this._displayValue !== dispVal) {
              this.displayValue = dispVal;
            }
            /** @type {?} */


            var args = {
              oldValue: oldVal,
              newValue: value
            };
            this.onValueChanged.emit(args);
          } else {
            /** @type {?} */
            var _args3 = {
              timePicker: this,
              currentValue: value,
              setThroughUI: false
            };
            this.onValidationFailed.emit(_args3);
          }
        }
        /**
         * An accessor that returns the value of `igx-time-picker` component.
         * ```html
         * \@ViewChild("MyPick")
         * public pick: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *    let pickSelect = this.pick.value;
         * }
         * ```
         * @return {?}
         */
        ,
        get: function get() {
          return this._value;
        }
        /**
         * An accessor that sets the resource strings.
         * By default it uses EN resources.
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "resourceStrings",
        set: function set(value) {
          this._resourceStrings = Object.assign({}, this._resourceStrings, value);
        }
        /**
         * An accessor that returns the resource strings.
         * @return {?}
         */
        ,
        get: function get() {
          return this._resourceStrings;
        }
        /**
         * An \@Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.
         * ```html
         * <igx-time-picker okButtonLabel='SET' [value]="date" format="h:mm tt"></igx-time-picker>
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "okButtonLabel",
        set: function set(value) {
          this._okButtonLabel = value;
        }
        /**
         * An accessor that returns the label of ok button.
         * @return {?}
         */
        ,
        get: function get() {
          if (this._okButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_ok;
          }

          return this._okButtonLabel;
        }
        /**
         * An \@Input property that renders cancel button with custom text.
         * By default `cancelButtonLabel` is set to Cancel.
         * ```html
         * <igx-time-picker cancelButtonLabel='Exit' [value]="date" format="h:mm tt"></igx-time-picker>
         * ```
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "cancelButtonLabel",
        set: function set(value) {
          this._cancelButtonLabel = value;
        }
        /**
         * An accessor that returns the label of cancel button.
         * @return {?}
         */
        ,
        get: function get() {
          if (this._cancelButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_cancel;
          }

          return this._cancelButtonLabel;
        }
        /**
         * An \@Input property that Gets/Sets format of time while `igxTimePicker` does not have focus. <br>
         * By default `format` is set to hh:mm tt. <br>
         * List of time-flags: <br>
         * `h` : hours field in 12-hours format without leading zero <br>
         * `hh` : hours field in 12-hours format with leading zero <br>
         * `H` : hours field in 24-hours format without leading zero <br>
         * `HH` : hours field in 24-hours format with leading zero <br>
         * `m` : minutes field without leading zero <br>
         * `mm` : minutes field with leading zero <br>
         * `tt` : 2 character string which represents AM/PM field <br>
         * ```html
         * <igx-time-picker format="HH:m" id="time-picker"></igx-time-picker>
         * ```
         * @return {?}
         */

      }, {
        key: "format",
        get: function get() {
          return this._format || 'hh:mm tt';
        }
        /**
         * @param {?} formatValue
         * @return {?}
         */
        ,
        set: function set(formatValue) {
          this._format = formatValue;
          this.mask = this._format.indexOf('tt') !== -1 ? '00:00 LL' : '00:00';

          if (!this.showHoursList || !this.showMinutesList) {
            this.mask = this.mask.slice(this.mask.indexOf(':') + 1, this.mask.length);
          }

          if (this.displayValue) {
            this.displayValue = this._formatTime(this.value, this._format);
          }
        }
        /**
         * An \@Input property that allows you to modify overlay positioning, interaction and scroll behavior.
         * ```typescript
         * const settings: OverlaySettings = {
         *      closeOnOutsideClick: true,
         *      modal: false
         *  }
         * ```
         * ---
         * ```html
         * <igx-time-picker [overlaySettings]="settings"></igx-time-picker>
         * ```
         * \@memberof IgxTimePickerComponent
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "overlaySettings",
        set: function set(value) {
          this._overlaySettings = value;
        }
        /**
         * @return {?}
         */
        ,
        get: function get() {
          return this._overlaySettings ? this._overlaySettings : this.mode === InteractionMode.Dialog ? this._dialogOverlaySettings : this._dropDownOverlaySettings;
        }
        /**
         * @deprecated Use 'onOpened' instead.
         * Emitted when a timePicker is being opened.
         * ```html
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onOpen(timepicker){
         *    this.toast.show();
         * }
         * //...
         * ```
         * ```html
         * <igx-time-picker [minValue]="min" [maxValue]="max" (onOpen)="onOpen($event)"></igx-time-picker>
         * <igx-toast #toast message="The time picker has been opened!"></igx-toast>
         * ```
         * @return {?}
         */

      }, {
        key: "onOpen",
        get: function get() {
          return this._onOpen;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._onOpen = val;
        }
        /**
         * @deprecated Use 'onClosed' instead.
         * Emitted when a timePicker is being closed.
         * @return {?}
         */

      }, {
        key: "onClose",
        get: function get() {
          return this._onClose;
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._onClose = val;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "mask",
        get: function get() {
          return this._mask || '00:00 LL';
        }
        /**
         * @param {?} val
         * @return {?}
         */
        ,
        set: function set(val) {
          this._mask = val;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "displayValue",
        get: function get() {
          if (this._displayValue === undefined) {
            return this._formatTime(this.value, this.format);
          }

          return this._displayValue;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._displayValue = value;
        }
        /**
         * Returns the current time formatted as string using the `format` option.
         * If there is no set time the return is an empty string.
         * ```typescript
         * \@ViewChild("MyChild")
         * private picker: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *    let time = this.picker.displayTime;
         * }
         * ```
         * @return {?}
         */

      }, {
        key: "displayTime",
        get: function get() {
          if (this.value) {
            return this._formatTime(this.value, this.format);
          }

          return '';
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "hourView",
        get: function get() {
          return this._hourView;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "minuteView",
        get: function get() {
          return this._minuteView;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ampmView",
        get: function get() {
          return this._ampmView;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "showClearButton",
        get: function get() {
          return this.displayValue && this.displayValue !== this.parseMask(false) || this.isNotEmpty;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "showHoursList",
        get: function get() {
          return this.format.indexOf('h') !== -1 || this.format.indexOf('H') !== -1;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "showMinutesList",
        get: function get() {
          return this.format.indexOf('m') !== -1;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "showAmPmList",
        get: function get() {
          return this.format.indexOf('t') !== -1;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "validMinuteEntries",
        get: function get() {
          /** @type {?} */
          var minuteEntries = [];

          for (var i = 0; i < 60; i++) {
            minuteEntries.push(i);
          }

          return minuteEntries;
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "validHourEntries",
        get: function get() {
          /** @type {?} */
          var hourEntries = [];
          /** @type {?} */

          var index = this.format.indexOf('h') !== -1 ? 13 : 24;

          for (var i = 0; i < index; i++) {
            hourEntries.push(i);
          }

          return hourEntries;
        }
        /**
         * Gets the input group template.
         * ```typescript
         * let template = this.template();
         * ```
         * \@memberof IgxTimePickerComponent
         * @return {?}
         */

      }, {
        key: "template",
        get: function get() {
          if (this.timePickerTemplateDirective) {
            return this.timePickerTemplateDirective.template;
          }

          return this.mode === InteractionMode.Dialog ? this.defaultTimePickerTemplate : this.dropdownInputTemplate;
        }
        /**
         * Gets the context passed to the input group template.
         * \@memberof IgxTimePickerComponent
         * @return {?}
         */

      }, {
        key: "context",
        get: function get() {
          var _this384 = this;

          return {
            value: this.value,
            displayTime: this.displayTime,
            displayValue: this.displayValue,
            openDialog: function openDialog(target) {
              return _this384.openDialog(target);
            }
          };
        }
      }]);

      return IgxTimePickerComponent;
    }();

    IgxTimePickerComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        providers: [{
          provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALUE_ACCESSOR"],
          useExisting: IgxTimePickerComponent,
          multi: true
        }, {
          provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_9__["HAMMER_GESTURE_CONFIG"],
          useClass: TimePickerHammerConfig
        }, {
          provide: IGX_TIME_PICKER_COMPONENT,
          useExisting: IgxTimePickerComponent
        }],
        selector: 'igx-time-picker',
        template: "<ng-template #dropdownInputTemplate>\n    <igx-input-group #group>\n        <label igxLabel>Time</label>\n        <igx-prefix (click)=\"openDialog(group.element.nativeElement)\">\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <input #input type=\"text\" [igxMask]=\"mask\" igxInput [includeLiterals]=\"false\" [placeholder]=\"format\"\n            [displayValuePipe]=\"displayFormat\" [focusedValuePipe]=\"inputFormat\" [promptChar]=\"promptChar\"\n            [value]=\"displayValue\" (input)=\"onInput($event)\" (blur)=\"onBlur($event)\" (focus)=\"onFocus($event)\"\n            (wheel)=\"spinOnEdit($event)\" [disabled]=\"disabled\" />\n        <igx-suffix *ngIf=\"showClearButton\" igxRipple (click)=\"clear()\">\n            <igx-icon fontSet=\"material\">clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n<ng-template #defaultTimePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <igx-prefix>\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <label igxLabel>Time</label>\n        <input igxInput [value]=\"displayTime || ''\" [disabled]=\"disabled\" tabindex=\"0\" readonly />\n    </igx-input-group>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n\n<ng-template #defaultTimePickerActions>\n    <div *ngIf=\"cancelButtonLabel || okButtonLabel\" class=\"igx-time-picker__buttons\">\n        <button *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" (click)=\"cancelButtonClick()\">\n            {{cancelButtonLabel}}\n        </button>\n        <button *ngIf=\"okButtonLabel\" igxButton=\"flat\" (click)=\"okButtonClick()\">\n            {{okButtonLabel}}\n        </button>\n    </div>\n</ng-template>\n<div igxToggle class=\"igx-time-picker\"\n    [ngClass]=\"{'igx-time-picker--dropdown': mode === 'dropdown', 'igx-time-picker--vertical': vertical && mode === 'dialog'}\">\n    <div *ngIf=\"mode === 'dialog'\" class=\"igx-time-picker__header\">\n        <h5 class=\"igx-time-picker__header-ampm\">{{ selectedAmPm }}</h5>\n        <h2 class=\"igx-time-picker__header-hour\">\n            <span>{{ selectedHour }}</span>:<span>{{ selectedMinute }}</span>\n        </h2>\n    </div>\n    <div class=\"igx-time-picker__main\">\n        <div class=\"igx-time-picker__body\">\n            <div *ngIf=\"showHoursList\" #hourList [igxItemList]=\"'hourList'\">\n                <span [igxHourItem]=\"hour\" *ngFor=\"let hour of hourView\">{{ hour }}</span>\n            </div>\n            <div *ngIf=\"showMinutesList\" #minuteList [igxItemList]=\"'minuteList'\">\n                <span [igxMinuteItem]=\"minute\" *ngFor=\"let minute of minuteView\">{{ minute }}</span>\n            </div>\n            <div *ngIf=\"showAmPmList\" #ampmList [igxItemList]=\"'ampmList'\">\n                <span [igxAmPmItem]=\"ampm\" *ngFor=\"let ampm of ampmView\">{{ ampm }}</span>\n            </div>\n        </div>\n        <ng-container *ngTemplateOutlet=\"timePickerActionsDirective ? timePickerActionsDirective.template : defaultTimePickerActions\"></ng-container>\n    </div>\n</div>",
        styles: [":host {\n            display: block;\n        }"]
      }]
    }];
    IgxTimePickerComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      value: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      disabled: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      resourceStrings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      okButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      cancelButtonLabel: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      itemsDelta: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      minValue: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      maxValue: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isSpinLoop: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      vertical: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      format: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      promptChar: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      mode: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      outlet: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      overlaySettings: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onValueChanged: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onValidationFailed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onOpen: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onOpened: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClose: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onClosing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      hourList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['hourList', {
          "static": false
        }]
      }],
      minuteList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['minuteList', {
          "static": false
        }]
      }],
      ampmList: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['ampmList', {
          "static": false
        }]
      }],
      defaultTimePickerTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['defaultTimePickerTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      timePickerTemplateDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxTimePickerTemplateDirective, {
          read: IgxTimePickerTemplateDirective,
          "static": false
        }]
      }],
      timePickerActionsDirective: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"],
        args: [IgxTimePickerActionsDirective, {
          read: IgxTimePickerActionsDirective,
          "static": false
        }]
      }],
      _input: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxInputDirective, {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      toggleRef: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: [IgxToggleDirective, {
          "static": true
        }]
      }],
      input: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['input', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
          "static": false
        }]
      }],
      group: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['group', {
          read: IgxInputGroupComponent,
          "static": false
        }]
      }],
      dropdownInputTemplate: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"],
        args: ['dropdownInputTemplate', {
          read: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"],
          "static": true
        }]
      }],
      onKeydownSpace: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.spacebar', ['$event']]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.space', ['$event']]
      }],
      onAltArrowDown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostListener"],
        args: ['keydown.Alt.ArrowDown']
      }]
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("'onOpen' @Output property is deprecated. Use 'onOpened' instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]])], IgxTimePickerComponent.prototype, "onOpen", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__decorate"])([DeprecateProperty("'onClose' @Output property is deprecated. Use 'onClosed' instead."), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]), Object(tslib__WEBPACK_IMPORTED_MODULE_7__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]])], IgxTimePickerComponent.prototype, "onClose", null);
    /**
     * @hidden
     */

    var IgxTimePickerModule = function IgxTimePickerModule() {
      _classCallCheck(this, IgxTimePickerModule);
    };

    IgxTimePickerModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxTimePickerComponent, IgxHourItemDirective, IgxItemListDirective, IgxMinuteItemDirective, IgxAmPmItemDirective, IgxTimePickerTemplateDirective, IgxTimePickerActionsDirective, TimeDisplayFormatPipe, TimeInputFormatPipe],
        exports: [IgxTimePickerComponent, IgxTimePickerTemplateDirective, IgxTimePickerActionsDirective, TimeDisplayFormatPipe, TimeInputFormatPipe],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"], IgxInputGroupModule, IgxIconModule, IgxButtonModule, IgxMaskModule, IgxToggleModule],
        providers: []
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    var NEXT_ID$v = 0;
    /**
     * **Ignite UI for Angular Toast** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/toast.html)
     *
     * The Ignite UI Toast provides information and warning messages that are non-interactive and cannot
     * be dismissed by the user. Toasts can be displayed at the bottom, middle, or top of the page.
     *
     * Example:
     * ```html
     * <button (click)="toast.show()">Show notification</button>
     * <igx-toast #toast
     *           message="Notification displayed"
     *           displayTime="1000">
     * </igx-toast>
     * ```
     */

    var IgxToastComponent =
    /*#__PURE__*/
    function () {
      /**
       * @param {?} elementRef
       * @param {?} navService
       */
      function IgxToastComponent(elementRef, navService) {
        _classCallCheck(this, IgxToastComponent);

        this.elementRef = elementRef;
        this.navService = navService;
        this._isVisible = false;
        /**
         * Returns a list of available CSS classes.
         * ```typescript
         * let toastClasses =  this.toast.CSS_CLASSES;
         * ```
         * \@memberof IgxToastComponent
         */

        this.CSS_CLASSES = {
          IGX_TOAST_BOTTOM: 'igx-toast--bottom',
          IGX_TOAST_MIDDLE: 'igx-toast--middle',
          IGX_TOAST_TOP: 'igx-toast--top'
        };
        /**
         * Sets/gets the `id` of the toast.
         * If not set, the `id` will have value `"igx-toast-0"`.
         * ```html
         * <igx-toast id = "my-first-toast"></igx-toast>
         * ```
         * ```typescript
         * let toastId = this.toast.id;
         * ```
         */

        this.id = "igx-toast-".concat(NEXT_ID$v++);
        /**
         * Emits an event prior the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShowing) = "onShowing($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */

        this.onShowing = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event when the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShown) = "onShown($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */

        this.onShown = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Emits an event prior the toast is hidden.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHiding) = "onHiding($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */

        this.onHiding = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         *  Emits an event when the toast is hidden.
         *  Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHidden) = "onHidden($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */

        this.onHidden = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Sets/gets the `role` attribute.
         * If not set, `role` will have value `"alert"`.
         * ```html
         * <igx-toast [role] = "'notify'"></igx-toast>
         * ```
         * ```typescript
         * let toastRole = this.toast.role;
         * ```
         * \@memberof IgxToastComponent
         */

        this.role = 'alert';
        /**
         * Sets/gets whether the toast will be hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-toast [autoHide] = "false"></igx-toast>
         * ```
         * ```typescript
         * let autoHide = this.toast.autoHide;
         * ```
         * \@memberof IgxToastComponent
         */

        this.autoHide = true;
        /**
         * Sets/gets the duration of time span(in milliseconds) which the toast will be visible
         * after it is being shown.
         * Default value is `4000`.
         * ```html
         * <igx-toast [displayTime] = "2500"></igx-toast>
         * ```
         * ```typescript
         * let displayTime = this.toast.displayTime;
         * ```
         * \@memberof IgxToastComponent
         */

        this.displayTime = 4000;
        /**
         * @hidden
         */

        this.isVisibleChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * Sets/gets the position of the toast.
         * If not set, the `position` attribute will have value `IgxToastPosition.Bottom`.
         * ```html
         * <igx-toast [position] = "top"></igx-toast>
         * ```
         * ```typescript
         * let toastPosition = this.toast.position;
         * ```
         * \@memberof IgxToastComponent
         */

        this.position = IgxToastPosition.Bottom;
      }
      /**
       * Enables/Disables the visibility of the toast.
       * If not set, the `isVisible` attribute will have value `false`.
       * ```html
       * <igx-toast [isVisible] = "true"></igx-toast>
       * ```
       * ```typescript
       * let isVisible = this.toast.isVisible;
       * ```
       *
       * Two-way data binding.
       * ```html
       * <igx-toast [(isVisible)] = "model.isVisible"></igx-toast>
       * ```
       * \@memberof IgxToastComponent
       * @return {?}
       */


      _createClass(IgxToastComponent, [{
        key: "show",

        /**
         * Shows the toast.
         * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
         * ```typescript
         * this.toast.show();
         * ```
         * \@memberof IgxToastComponent
         * @return {?}
         */
        value: function show() {
          var _this385 = this;

          clearInterval(this.timeoutId);
          this.onShowing.emit(this);
          this.isVisible = true;

          if (this.autoHide) {
            this.timeoutId = setTimeout(function () {
              _this385.hide();
            }, this.displayTime);
          }

          this.onShown.emit(this);
        }
        /**
         * Hides the toast.
         * ```typescript
         * this.toast.hide();
         * ```
         * \@memberof IgxToastComponent
         * @return {?}
         */

      }, {
        key: "hide",
        value: function hide() {
          this.onHiding.emit(this);
          this.isVisible = false;
          this.onHidden.emit(this);
          clearInterval(this.timeoutId);
        }
        /**
         * Wraps \@show() method due \@IToggleView interface implementation.
         * @hidden
         * @return {?}
         */

      }, {
        key: "open",
        value: function open() {
          this.show();
        }
        /**
         * Wraps \@hide() method due \@IToggleView interface implementation.
         * @hidden
         * @return {?}
         */

      }, {
        key: "close",
        value: function close() {
          this.hide();
        }
        /**
         * Toggles the visible state of the toast.
         * ```typescript
         * this.toast.toggle();
         * ```
         * \@memberof IgxToastComponent
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          this.isVisible ? this.close() : this.open();
        }
        /**
         * Sets/gets the class name of the toast based on the `position` value.
         * ```typescript
         * let className =  this.toast.mapPositionToClassName();
         * ```
         * \@memberof IgxToastComponent
         * @return {?}
         */

      }, {
        key: "mapPositionToClassName",
        value: function mapPositionToClassName() {
          if (this.position === IgxToastPosition.Top) {
            return this.CSS_CLASSES.IGX_TOAST_TOP;
          }

          if (this.position === IgxToastPosition.Middle) {
            return this.CSS_CLASSES.IGX_TOAST_MIDDLE;
          }

          if (this.position === IgxToastPosition.Bottom) {
            return this.CSS_CLASSES.IGX_TOAST_BOTTOM;
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          if (this.navService && this.id) {
            this.navService.add(this.id, this);
          }
        }
        /**
         * @hidden
         * @return {?}
         */

      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.navService && this.id) {
            this.navService.remove(this.id);
          }
        }
      }, {
        key: "isVisible",
        get: function get() {
          return this._isVisible;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ,
        set: function set(value) {
          this._isVisible = value;
          this.isVisibleChange.emit(this._isVisible);
        }
        /**
         * Gets the nativeElement of the toast.
         * ```typescript
         * let nativeElement = this.toast.element;
         * ```
         * \@memberof IgxToastComponent
         * @return {?}
         */

      }, {
        key: "element",
        get: function get() {
          return this.elementRef.nativeElement;
        }
      }]);

      return IgxToastComponent;
    }();

    IgxToastComponent.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
      args: [{
        animations: [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('animate', [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('show', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
          opacity: 1
        })), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => show', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('.20s ease')), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('show => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('.40s ease-out'))])],
        selector: 'igx-toast',
        template: "<div [ngClass]=\"mapPositionToClassName()\" *ngIf=\"this.isVisible\" [@animate]=\"'show'\">\n    {{ message }}\n</div>\n",
        styles: ["\n        :host {\n            display: block;\n        }\n    "]
      }]
    }];
    /** @nocollapse */

    IgxToastComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: IgxNavigationService,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"]
        }]
      }];
    };

    IgxToastComponent.propDecorators = {
      id: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.id']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      onShowing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onShown: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onHiding: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      onHidden: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      role: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      autoHide: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      displayTime: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isVisible: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isVisibleChange: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      message: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      position: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /** @enum {number} */

    var IgxToastPosition = {
      Bottom: 0,
      Middle: 1,
      Top: 2
    };
    IgxToastPosition[IgxToastPosition.Bottom] = 'Bottom';
    IgxToastPosition[IgxToastPosition.Middle] = 'Middle';
    IgxToastPosition[IgxToastPosition.Top] = 'Top';
    /**
     * @hidden
     */

    var IgxToastModule = function IgxToastModule() {
      _classCallCheck(this, IgxToastModule);
    };

    IgxToastModule.decorators = [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
      args: [{
        declarations: [IgxToastComponent],
        exports: [IgxToastComponent],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["CommonModule"]]
      }]
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    //# sourceMappingURL=igniteui-angular.js.map

    /***/
  },

  /***/
  "../../node_modules/jszip/dist/jszip.js":
  /*!*************************************************************************************************!*\
    !*** C:/Users/KING/Desktop/Economic-Statistic/e-statistics/UI/node_modules/jszip/dist/jszip.js ***!
    \*************************************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesJszipDistJszipJs(module, exports, __webpack_require__) {
    var require;

    var require;
    /*!
    JSZip v3.2.1 - A JavaScript class for generating and reading zip files
    <http://stuartk.com/jszip>
    (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
    Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
    JSZip uses the library pako released under the MIT license :
    https://github.com/nodeca/pako/blob/master/LICENSE
    */


    (function (f) {
      if (true) {
        module.exports = f();
      } else {
        var g;
      }
    })(function () {
      var define, module, exports;
      return function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof require == "function" && require;
              if (!u && a) return require(o, !0);
              if (i) return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }

            var l = n[o] = {
              exports: {}
            };
            t[o][0].call(l.exports, function (e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
          }

          return n[o].exports;
        }

        var i = typeof require == "function" && require;

        for (var o = 0; o < r.length; o++) {
          s(r[o]);
        }

        return s;
      }({
        1: [function (require, module, exports) {
          'use strict';

          var utils = require('./utils');

          var support = require('./support'); // private property


          var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; // public method for encoding

          exports.encode = function (input) {
            var output = [];
            var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
            var i = 0,
                len = input.length,
                remainingBytes = len;
            var isArray = utils.getTypeOf(input) !== "string";

            while (i < input.length) {
              remainingBytes = len - i;

              if (!isArray) {
                chr1 = input.charCodeAt(i++);
                chr2 = i < len ? input.charCodeAt(i++) : 0;
                chr3 = i < len ? input.charCodeAt(i++) : 0;
              } else {
                chr1 = input[i++];
                chr2 = i < len ? input[i++] : 0;
                chr3 = i < len ? input[i++] : 0;
              }

              enc1 = chr1 >> 2;
              enc2 = (chr1 & 3) << 4 | chr2 >> 4;
              enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
              enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
              output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
            }

            return output.join("");
          }; // public method for decoding


          exports.decode = function (input) {
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0,
                resultIndex = 0;
            var dataUrlPrefix = "data:";

            if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
              // This is a common error: people give a data url
              // (data:image/png;base64,iVBOR...) with a {base64: true} and
              // wonders why things don't work.
              // We can detect that the string input looks like a data url but we
              // *can't* be sure it is one: removing everything up to the comma would
              // be too dangerous.
              throw new Error("Invalid base64 input, it looks like a data url.");
            }

            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            var totalLength = input.length * 3 / 4;

            if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
              totalLength--;
            }

            if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
              totalLength--;
            }

            if (totalLength % 1 !== 0) {
              // totalLength is not an integer, the length does not match a valid
              // base64 content. That can happen if:
              // - the input is not a base64 content
              // - the input is *almost* a base64 content, with a extra chars at the
              //   beginning or at the end
              // - the input uses a base64 variant (base64url for example)
              throw new Error("Invalid base64 input, bad content length.");
            }

            var output;

            if (support.uint8array) {
              output = new Uint8Array(totalLength | 0);
            } else {
              output = new Array(totalLength | 0);
            }

            while (i < input.length) {
              enc1 = _keyStr.indexOf(input.charAt(i++));
              enc2 = _keyStr.indexOf(input.charAt(i++));
              enc3 = _keyStr.indexOf(input.charAt(i++));
              enc4 = _keyStr.indexOf(input.charAt(i++));
              chr1 = enc1 << 2 | enc2 >> 4;
              chr2 = (enc2 & 15) << 4 | enc3 >> 2;
              chr3 = (enc3 & 3) << 6 | enc4;
              output[resultIndex++] = chr1;

              if (enc3 !== 64) {
                output[resultIndex++] = chr2;
              }

              if (enc4 !== 64) {
                output[resultIndex++] = chr3;
              }
            }

            return output;
          };
        }, {
          "./support": 30,
          "./utils": 32
        }],
        2: [function (require, module, exports) {
          'use strict';

          var external = require("./external");

          var DataWorker = require('./stream/DataWorker');

          var DataLengthProbe = require('./stream/DataLengthProbe');

          var Crc32Probe = require('./stream/Crc32Probe');

          var DataLengthProbe = require('./stream/DataLengthProbe');
          /**
           * Represent a compressed object, with everything needed to decompress it.
           * @constructor
           * @param {number} compressedSize the size of the data compressed.
           * @param {number} uncompressedSize the size of the data after decompression.
           * @param {number} crc32 the crc32 of the decompressed file.
           * @param {object} compression the type of compression, see lib/compressions.js.
           * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
           */


          function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
            this.compressedSize = compressedSize;
            this.uncompressedSize = uncompressedSize;
            this.crc32 = crc32;
            this.compression = compression;
            this.compressedContent = data;
          }

          CompressedObject.prototype = {
            /**
             * Create a worker to get the uncompressed content.
             * @return {GenericWorker} the worker.
             */
            getContentWorker: function getContentWorker() {
              var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
              var that = this;
              worker.on("end", function () {
                if (this.streamInfo['data_length'] !== that.uncompressedSize) {
                  throw new Error("Bug : uncompressed data size mismatch");
                }
              });
              return worker;
            },

            /**
             * Create a worker to get the compressed content.
             * @return {GenericWorker} the worker.
             */
            getCompressedWorker: function getCompressedWorker() {
              return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
            }
          };
          /**
           * Chain the given worker with other workers to compress the content with the
           * given compresion.
           * @param {GenericWorker} uncompressedWorker the worker to pipe.
           * @param {Object} compression the compression object.
           * @param {Object} compressionOptions the options to use when compressing.
           * @return {GenericWorker} the new worker compressing the content.
           */

          CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
            return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
          };

          module.exports = CompressedObject;
        }, {
          "./external": 6,
          "./stream/Crc32Probe": 25,
          "./stream/DataLengthProbe": 26,
          "./stream/DataWorker": 27
        }],
        3: [function (require, module, exports) {
          'use strict';

          var GenericWorker = require("./stream/GenericWorker");

          exports.STORE = {
            magic: "\x00\x00",
            compressWorker: function compressWorker(compressionOptions) {
              return new GenericWorker("STORE compression");
            },
            uncompressWorker: function uncompressWorker() {
              return new GenericWorker("STORE decompression");
            }
          };
          exports.DEFLATE = require('./flate');
        }, {
          "./flate": 7,
          "./stream/GenericWorker": 28
        }],
        4: [function (require, module, exports) {
          'use strict';

          var utils = require('./utils');
          /**
           * The following functions come from pako, from pako/lib/zlib/crc32.js
           * released under the MIT license, see pako https://github.com/nodeca/pako/
           */
          // Use ordinary array, since untyped makes no boost here


          function makeTable() {
            var c,
                table = [];

            for (var n = 0; n < 256; n++) {
              c = n;

              for (var k = 0; k < 8; k++) {
                c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
              }

              table[n] = c;
            }

            return table;
          } // Create table on load. Just 255 signed longs. Not a problem.


          var crcTable = makeTable();

          function crc32(crc, buf, len, pos) {
            var t = crcTable,
                end = pos + len;
            crc = crc ^ -1;

            for (var i = pos; i < end; i++) {
              crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
            }

            return crc ^ -1; // >>> 0;
          } // That's all for the pako functions.

          /**
           * Compute the crc32 of a string.
           * This is almost the same as the function crc32, but for strings. Using the
           * same function for the two use cases leads to horrible performances.
           * @param {Number} crc the starting value of the crc.
           * @param {String} str the string to use.
           * @param {Number} len the length of the string.
           * @param {Number} pos the starting position for the crc32 computation.
           * @return {Number} the computed crc32.
           */


          function crc32str(crc, str, len, pos) {
            var t = crcTable,
                end = pos + len;
            crc = crc ^ -1;

            for (var i = pos; i < end; i++) {
              crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
            }

            return crc ^ -1; // >>> 0;
          }

          module.exports = function crc32wrapper(input, crc) {
            if (typeof input === "undefined" || !input.length) {
              return 0;
            }

            var isArray = utils.getTypeOf(input) !== "string";

            if (isArray) {
              return crc32(crc | 0, input, input.length, 0);
            } else {
              return crc32str(crc | 0, input, input.length, 0);
            }
          };
        }, {
          "./utils": 32
        }],
        5: [function (require, module, exports) {
          'use strict';

          exports.base64 = false;
          exports.binary = false;
          exports.dir = false;
          exports.createFolders = true;
          exports.date = null;
          exports.compression = null;
          exports.compressionOptions = null;
          exports.comment = null;
          exports.unixPermissions = null;
          exports.dosPermissions = null;
        }, {}],
        6: [function (require, module, exports) {
          /* global Promise */
          'use strict'; // load the global object first:
          // - it should be better integrated in the system (unhandledRejection in node)
          // - the environment may have a custom Promise implementation (see zone.js)

          var ES6Promise = null;

          if (typeof Promise !== "undefined") {
            ES6Promise = Promise;
          } else {
            ES6Promise = require("lie");
          }
          /**
           * Let the user use/change some implementations.
           */


          module.exports = {
            Promise: ES6Promise
          };
        }, {
          "lie": 37
        }],
        7: [function (require, module, exports) {
          'use strict';

          var USE_TYPEDARRAY = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Uint32Array !== 'undefined';

          var pako = require("pako");

          var utils = require("./utils");

          var GenericWorker = require("./stream/GenericWorker");

          var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
          exports.magic = "\x08\x00";
          /**
           * Create a worker that uses pako to inflate/deflate.
           * @constructor
           * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
           * @param {Object} options the options to use when (de)compressing.
           */

          function FlateWorker(action, options) {
            GenericWorker.call(this, "FlateWorker/" + action);
            this._pako = null;
            this._pakoAction = action;
            this._pakoOptions = options; // the `meta` object from the last chunk received
            // this allow this worker to pass around metadata

            this.meta = {};
          }

          utils.inherits(FlateWorker, GenericWorker);
          /**
           * @see GenericWorker.processChunk
           */

          FlateWorker.prototype.processChunk = function (chunk) {
            this.meta = chunk.meta;

            if (this._pako === null) {
              this._createPako();
            }

            this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
          };
          /**
           * @see GenericWorker.flush
           */


          FlateWorker.prototype.flush = function () {
            GenericWorker.prototype.flush.call(this);

            if (this._pako === null) {
              this._createPako();
            }

            this._pako.push([], true);
          };
          /**
           * @see GenericWorker.cleanUp
           */


          FlateWorker.prototype.cleanUp = function () {
            GenericWorker.prototype.cleanUp.call(this);
            this._pako = null;
          };
          /**
           * Create the _pako object.
           * TODO: lazy-loading this object isn't the best solution but it's the
           * quickest. The best solution is to lazy-load the worker list. See also the
           * issue #446.
           */


          FlateWorker.prototype._createPako = function () {
            this._pako = new pako[this._pakoAction]({
              raw: true,
              level: this._pakoOptions.level || -1 // default compression

            });
            var self = this;

            this._pako.onData = function (data) {
              self.push({
                data: data,
                meta: self.meta
              });
            };
          };

          exports.compressWorker = function (compressionOptions) {
            return new FlateWorker("Deflate", compressionOptions);
          };

          exports.uncompressWorker = function () {
            return new FlateWorker("Inflate", {});
          };
        }, {
          "./stream/GenericWorker": 28,
          "./utils": 32,
          "pako": 38
        }],
        8: [function (require, module, exports) {
          'use strict';

          var utils = require('../utils');

          var GenericWorker = require('../stream/GenericWorker');

          var utf8 = require('../utf8');

          var crc32 = require('../crc32');

          var signature = require('../signature');
          /**
           * Transform an integer into a string in hexadecimal.
           * @private
           * @param {number} dec the number to convert.
           * @param {number} bytes the number of bytes to generate.
           * @returns {string} the result.
           */


          var decToHex = function decToHex(dec, bytes) {
            var hex = "",
                i;

            for (i = 0; i < bytes; i++) {
              hex += String.fromCharCode(dec & 0xff);
              dec = dec >>> 8;
            }

            return hex;
          };
          /**
           * Generate the UNIX part of the external file attributes.
           * @param {Object} unixPermissions the unix permissions or null.
           * @param {Boolean} isDir true if the entry is a directory, false otherwise.
           * @return {Number} a 32 bit integer.
           *
           * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
           *
           * TTTTsstrwxrwxrwx0000000000ADVSHR
           * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
           *     ^^^_________________________ setuid, setgid, sticky
           *        ^^^^^^^^^________________ permissions
           *                 ^^^^^^^^^^______ not used ?
           *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
           */


          var generateUnixExternalFileAttr = function generateUnixExternalFileAttr(unixPermissions, isDir) {
            var result = unixPermissions;

            if (!unixPermissions) {
              // I can't use octal values in strict mode, hence the hexa.
              //  040775 => 0x41fd
              // 0100664 => 0x81b4
              result = isDir ? 0x41fd : 0x81b4;
            }

            return (result & 0xFFFF) << 16;
          };
          /**
           * Generate the DOS part of the external file attributes.
           * @param {Object} dosPermissions the dos permissions or null.
           * @param {Boolean} isDir true if the entry is a directory, false otherwise.
           * @return {Number} a 32 bit integer.
           *
           * Bit 0     Read-Only
           * Bit 1     Hidden
           * Bit 2     System
           * Bit 3     Volume Label
           * Bit 4     Directory
           * Bit 5     Archive
           */


          var generateDosExternalFileAttr = function generateDosExternalFileAttr(dosPermissions, isDir) {
            // the dir flag is already set for compatibility
            return (dosPermissions || 0) & 0x3F;
          };
          /**
           * Generate the various parts used in the construction of the final zip file.
           * @param {Object} streamInfo the hash with informations about the compressed file.
           * @param {Boolean} streamedContent is the content streamed ?
           * @param {Boolean} streamingEnded is the stream finished ?
           * @param {number} offset the current offset from the start of the zip file.
           * @param {String} platform let's pretend we are this platform (change platform dependents fields)
           * @param {Function} encodeFileName the function to encode the file name / comment.
           * @return {Object} the zip parts.
           */


          var generateZipParts = function generateZipParts(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
            var file = streamInfo['file'],
                compression = streamInfo['compression'],
                useCustomEncoding = encodeFileName !== utf8.utf8encode,
                encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
                utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
                comment = file.comment,
                encodedComment = utils.transformTo("string", encodeFileName(comment)),
                utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
                useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
                useUTF8ForComment = utfEncodedComment.length !== comment.length,
                dosTime,
                dosDate,
                extraFields = "",
                unicodePathExtraField = "",
                unicodeCommentExtraField = "",
                dir = file.dir,
                date = file.date;
            var dataInfo = {
              crc32: 0,
              compressedSize: 0,
              uncompressedSize: 0
            }; // if the content is streamed, the sizes/crc32 are only available AFTER
            // the end of the stream.

            if (!streamedContent || streamingEnded) {
              dataInfo.crc32 = streamInfo['crc32'];
              dataInfo.compressedSize = streamInfo['compressedSize'];
              dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
            }

            var bitflag = 0;

            if (streamedContent) {
              // Bit 3: the sizes/crc32 are set to zero in the local header.
              // The correct values are put in the data descriptor immediately
              // following the compressed data.
              bitflag |= 0x0008;
            }

            if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
              // Bit 11: Language encoding flag (EFS).
              bitflag |= 0x0800;
            }

            var extFileAttr = 0;
            var versionMadeBy = 0;

            if (dir) {
              // dos or unix, we set the dos dir flag
              extFileAttr |= 0x00010;
            }

            if (platform === "UNIX") {
              versionMadeBy = 0x031E; // UNIX, version 3.0

              extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
            } else {
              // DOS or other, fallback to DOS
              versionMadeBy = 0x0014; // DOS, version 2.0

              extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
            } // date
            // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
            // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
            // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html


            dosTime = date.getUTCHours();
            dosTime = dosTime << 6;
            dosTime = dosTime | date.getUTCMinutes();
            dosTime = dosTime << 5;
            dosTime = dosTime | date.getUTCSeconds() / 2;
            dosDate = date.getUTCFullYear() - 1980;
            dosDate = dosDate << 4;
            dosDate = dosDate | date.getUTCMonth() + 1;
            dosDate = dosDate << 5;
            dosDate = dosDate | date.getUTCDate();

            if (useUTF8ForFileName) {
              // set the unicode path extra field. unzip needs at least one extra
              // field to correctly handle unicode path, so using the path is as good
              // as any other information. This could improve the situation with
              // other archive managers too.
              // This field is usually used without the utf8 flag, with a non
              // unicode path in the header (winrar, winzip). This helps (a bit)
              // with the messy Windows' default compressed folders feature but
              // breaks on p7zip which doesn't seek the unicode path extra field.
              // So for now, UTF-8 everywhere !
              unicodePathExtraField = // Version
              decToHex(1, 1) + // NameCRC32
              decToHex(crc32(encodedFileName), 4) + // UnicodeName
              utfEncodedFileName;
              extraFields += // Info-ZIP Unicode Path Extra Field
              "\x75\x70" + // size
              decToHex(unicodePathExtraField.length, 2) + // content
              unicodePathExtraField;
            }

            if (useUTF8ForComment) {
              unicodeCommentExtraField = // Version
              decToHex(1, 1) + // CommentCRC32
              decToHex(crc32(encodedComment), 4) + // UnicodeName
              utfEncodedComment;
              extraFields += // Info-ZIP Unicode Path Extra Field
              "\x75\x63" + // size
              decToHex(unicodeCommentExtraField.length, 2) + // content
              unicodeCommentExtraField;
            }

            var header = ""; // version needed to extract

            header += "\x0A\x00"; // general purpose bit flag

            header += decToHex(bitflag, 2); // compression method

            header += compression.magic; // last mod file time

            header += decToHex(dosTime, 2); // last mod file date

            header += decToHex(dosDate, 2); // crc-32

            header += decToHex(dataInfo.crc32, 4); // compressed size

            header += decToHex(dataInfo.compressedSize, 4); // uncompressed size

            header += decToHex(dataInfo.uncompressedSize, 4); // file name length

            header += decToHex(encodedFileName.length, 2); // extra field length

            header += decToHex(extraFields.length, 2);
            var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
            var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
            decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
            header + // file comment length
            decToHex(encodedComment.length, 2) + // disk number start
            "\x00\x00" + // internal file attributes TODO
            "\x00\x00" + // external file attributes
            decToHex(extFileAttr, 4) + // relative offset of local header
            decToHex(offset, 4) + // file name
            encodedFileName + // extra field
            extraFields + // file comment
            encodedComment;
            return {
              fileRecord: fileRecord,
              dirRecord: dirRecord
            };
          };
          /**
           * Generate the EOCD record.
           * @param {Number} entriesCount the number of entries in the zip file.
           * @param {Number} centralDirLength the length (in bytes) of the central dir.
           * @param {Number} localDirLength the length (in bytes) of the local dir.
           * @param {String} comment the zip file comment as a binary string.
           * @param {Function} encodeFileName the function to encode the comment.
           * @return {String} the EOCD record.
           */


          var generateCentralDirectoryEnd = function generateCentralDirectoryEnd(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
            var dirEnd = "";
            var encodedComment = utils.transformTo("string", encodeFileName(comment)); // end of central dir signature

            dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
            "\x00\x00" + // number of the disk with the start of the central directory
            "\x00\x00" + // total number of entries in the central directory on this disk
            decToHex(entriesCount, 2) + // total number of entries in the central directory
            decToHex(entriesCount, 2) + // size of the central directory   4 bytes
            decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
            decToHex(localDirLength, 4) + // .ZIP file comment length
            decToHex(encodedComment.length, 2) + // .ZIP file comment
            encodedComment;
            return dirEnd;
          };
          /**
           * Generate data descriptors for a file entry.
           * @param {Object} streamInfo the hash generated by a worker, containing informations
           * on the file entry.
           * @return {String} the data descriptors.
           */


          var generateDataDescriptors = function generateDataDescriptors(streamInfo) {
            var descriptor = "";
            descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
            decToHex(streamInfo['crc32'], 4) + // compressed size                 4 bytes
            decToHex(streamInfo['compressedSize'], 4) + // uncompressed size               4 bytes
            decToHex(streamInfo['uncompressedSize'], 4);
            return descriptor;
          };
          /**
           * A worker to concatenate other workers to create a zip file.
           * @param {Boolean} streamFiles `true` to stream the content of the files,
           * `false` to accumulate it.
           * @param {String} comment the comment to use.
           * @param {String} platform the platform to use, "UNIX" or "DOS".
           * @param {Function} encodeFileName the function to encode file names and comments.
           */


          function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
            GenericWorker.call(this, "ZipFileWorker"); // The number of bytes written so far. This doesn't count accumulated chunks.

            this.bytesWritten = 0; // The comment of the zip file

            this.zipComment = comment; // The platform "generating" the zip file.

            this.zipPlatform = platform; // the function to encode file names and comments.

            this.encodeFileName = encodeFileName; // Should we stream the content of the files ?

            this.streamFiles = streamFiles; // If `streamFiles` is false, we will need to accumulate the content of the
            // files to calculate sizes / crc32 (and write them *before* the content).
            // This boolean indicates if we are accumulating chunks (it will change a lot
            // during the lifetime of this worker).

            this.accumulate = false; // The buffer receiving chunks when accumulating content.

            this.contentBuffer = []; // The list of generated directory records.

            this.dirRecords = []; // The offset (in bytes) from the beginning of the zip file for the current source.

            this.currentSourceOffset = 0; // The total number of entries in this zip file.

            this.entriesCount = 0; // the name of the file currently being added, null when handling the end of the zip file.
            // Used for the emited metadata.

            this.currentFile = null;
            this._sources = [];
          }

          utils.inherits(ZipFileWorker, GenericWorker);
          /**
           * @see GenericWorker.push
           */

          ZipFileWorker.prototype.push = function (chunk) {
            var currentFilePercent = chunk.meta.percent || 0;
            var entriesCount = this.entriesCount;
            var remainingFiles = this._sources.length;

            if (this.accumulate) {
              this.contentBuffer.push(chunk);
            } else {
              this.bytesWritten += chunk.data.length;
              GenericWorker.prototype.push.call(this, {
                data: chunk.data,
                meta: {
                  currentFile: this.currentFile,
                  percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
                }
              });
            }
          };
          /**
           * The worker started a new source (an other worker).
           * @param {Object} streamInfo the streamInfo object from the new source.
           */


          ZipFileWorker.prototype.openedSource = function (streamInfo) {
            this.currentSourceOffset = this.bytesWritten;
            this.currentFile = streamInfo['file'].name;
            var streamedContent = this.streamFiles && !streamInfo['file'].dir; // don't stream folders (because they don't have any content)

            if (streamedContent) {
              var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
              this.push({
                data: record.fileRecord,
                meta: {
                  percent: 0
                }
              });
            } else {
              // we need to wait for the whole file before pushing anything
              this.accumulate = true;
            }
          };
          /**
           * The worker finished a source (an other worker).
           * @param {Object} streamInfo the streamInfo object from the finished source.
           */


          ZipFileWorker.prototype.closedSource = function (streamInfo) {
            this.accumulate = false;
            var streamedContent = this.streamFiles && !streamInfo['file'].dir;
            var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.dirRecords.push(record.dirRecord);

            if (streamedContent) {
              // after the streamed file, we put data descriptors
              this.push({
                data: generateDataDescriptors(streamInfo),
                meta: {
                  percent: 100
                }
              });
            } else {
              // the content wasn't streamed, we need to push everything now
              // first the file record, then the content
              this.push({
                data: record.fileRecord,
                meta: {
                  percent: 0
                }
              });

              while (this.contentBuffer.length) {
                this.push(this.contentBuffer.shift());
              }
            }

            this.currentFile = null;
          };
          /**
           * @see GenericWorker.flush
           */


          ZipFileWorker.prototype.flush = function () {
            var localDirLength = this.bytesWritten;

            for (var i = 0; i < this.dirRecords.length; i++) {
              this.push({
                data: this.dirRecords[i],
                meta: {
                  percent: 100
                }
              });
            }

            var centralDirLength = this.bytesWritten - localDirLength;
            var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
            this.push({
              data: dirEnd,
              meta: {
                percent: 100
              }
            });
          };
          /**
           * Prepare the next source to be read.
           */


          ZipFileWorker.prototype.prepareNextSource = function () {
            this.previous = this._sources.shift();
            this.openedSource(this.previous.streamInfo);

            if (this.isPaused) {
              this.previous.pause();
            } else {
              this.previous.resume();
            }
          };
          /**
           * @see GenericWorker.registerPrevious
           */


          ZipFileWorker.prototype.registerPrevious = function (previous) {
            this._sources.push(previous);

            var self = this;
            previous.on('data', function (chunk) {
              self.processChunk(chunk);
            });
            previous.on('end', function () {
              self.closedSource(self.previous.streamInfo);

              if (self._sources.length) {
                self.prepareNextSource();
              } else {
                self.end();
              }
            });
            previous.on('error', function (e) {
              self.error(e);
            });
            return this;
          };
          /**
           * @see GenericWorker.resume
           */


          ZipFileWorker.prototype.resume = function () {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false;
            }

            if (!this.previous && this._sources.length) {
              this.prepareNextSource();
              return true;
            }

            if (!this.previous && !this._sources.length && !this.generatedError) {
              this.end();
              return true;
            }
          };
          /**
           * @see GenericWorker.error
           */


          ZipFileWorker.prototype.error = function (e) {
            var sources = this._sources;

            if (!GenericWorker.prototype.error.call(this, e)) {
              return false;
            }

            for (var i = 0; i < sources.length; i++) {
              try {
                sources[i].error(e);
              } catch (e) {// the `error` exploded, nothing to do
              }
            }

            return true;
          };
          /**
           * @see GenericWorker.lock
           */


          ZipFileWorker.prototype.lock = function () {
            GenericWorker.prototype.lock.call(this);
            var sources = this._sources;

            for (var i = 0; i < sources.length; i++) {
              sources[i].lock();
            }
          };

          module.exports = ZipFileWorker;
        }, {
          "../crc32": 4,
          "../signature": 23,
          "../stream/GenericWorker": 28,
          "../utf8": 31,
          "../utils": 32
        }],
        9: [function (require, module, exports) {
          'use strict';

          var compressions = require('../compressions');

          var ZipFileWorker = require('./ZipFileWorker');
          /**
           * Find the compression to use.
           * @param {String} fileCompression the compression defined at the file level, if any.
           * @param {String} zipCompression the compression defined at the load() level.
           * @return {Object} the compression object to use.
           */


          var getCompression = function getCompression(fileCompression, zipCompression) {
            var compressionName = fileCompression || zipCompression;
            var compression = compressions[compressionName];

            if (!compression) {
              throw new Error(compressionName + " is not a valid compression method !");
            }

            return compression;
          };
          /**
           * Create a worker to generate a zip file.
           * @param {JSZip} zip the JSZip instance at the right root level.
           * @param {Object} options to generate the zip file.
           * @param {String} comment the comment to use.
           */


          exports.generateWorker = function (zip, options, comment) {
            var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
            var entriesCount = 0;

            try {
              zip.forEach(function (relativePath, file) {
                entriesCount++;
                var compression = getCompression(file.options.compression, options.compression);
                var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
                var dir = file.dir,
                    date = file.date;

                file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
                  name: relativePath,
                  dir: dir,
                  date: date,
                  comment: file.comment || "",
                  unixPermissions: file.unixPermissions,
                  dosPermissions: file.dosPermissions
                }).pipe(zipFileWorker);
              });
              zipFileWorker.entriesCount = entriesCount;
            } catch (e) {
              zipFileWorker.error(e);
            }

            return zipFileWorker;
          };
        }, {
          "../compressions": 3,
          "./ZipFileWorker": 8
        }],
        10: [function (require, module, exports) {
          'use strict';
          /**
           * Representation a of zip file in js
           * @constructor
           */

          function JSZip() {
            // if this constructor is used without `new`, it adds `new` before itself:
            if (!(this instanceof JSZip)) {
              return new JSZip();
            }

            if (arguments.length) {
              throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
            } // object containing the files :
            // {
            //   "folder/" : {...},
            //   "folder/data.txt" : {...}
            // }


            this.files = {};
            this.comment = null; // Where we are in the hierarchy

            this.root = "";

            this.clone = function () {
              var newObj = new JSZip();

              for (var i in this) {
                if (typeof this[i] !== "function") {
                  newObj[i] = this[i];
                }
              }

              return newObj;
            };
          }

          JSZip.prototype = require('./object');
          JSZip.prototype.loadAsync = require('./load');
          JSZip.support = require('./support');
          JSZip.defaults = require('./defaults'); // TODO find a better way to handle this version,
          // a require('package.json').version doesn't work with webpack, see #327

          JSZip.version = "3.2.0";

          JSZip.loadAsync = function (content, options) {
            return new JSZip().loadAsync(content, options);
          };

          JSZip.external = require("./external");
          module.exports = JSZip;
        }, {
          "./defaults": 5,
          "./external": 6,
          "./load": 11,
          "./object": 15,
          "./support": 30
        }],
        11: [function (require, module, exports) {
          'use strict';

          var utils = require('./utils');

          var external = require("./external");

          var utf8 = require('./utf8');

          var utils = require('./utils');

          var ZipEntries = require('./zipEntries');

          var Crc32Probe = require('./stream/Crc32Probe');

          var nodejsUtils = require("./nodejsUtils");
          /**
           * Check the CRC32 of an entry.
           * @param {ZipEntry} zipEntry the zip entry to check.
           * @return {Promise} the result.
           */


          function checkEntryCRC32(zipEntry) {
            return new external.Promise(function (resolve, reject) {
              var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
              worker.on("error", function (e) {
                reject(e);
              }).on("end", function () {
                if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                  reject(new Error("Corrupted zip : CRC32 mismatch"));
                } else {
                  resolve();
                }
              }).resume();
            });
          }

          module.exports = function (data, options) {
            var zip = this;
            options = utils.extend(options || {}, {
              base64: false,
              checkCRC32: false,
              optimizedBinaryString: false,
              createFolders: false,
              decodeFileName: utf8.utf8decode
            });

            if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
              return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
            }

            return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function (data) {
              var zipEntries = new ZipEntries(options);
              zipEntries.load(data);
              return zipEntries;
            }).then(function checkCRC32(zipEntries) {
              var promises = [external.Promise.resolve(zipEntries)];
              var files = zipEntries.files;

              if (options.checkCRC32) {
                for (var i = 0; i < files.length; i++) {
                  promises.push(checkEntryCRC32(files[i]));
                }
              }

              return external.Promise.all(promises);
            }).then(function addFiles(results) {
              var zipEntries = results.shift();
              var files = zipEntries.files;

              for (var i = 0; i < files.length; i++) {
                var input = files[i];
                zip.file(input.fileNameStr, input.decompressed, {
                  binary: true,
                  optimizedBinaryString: true,
                  date: input.date,
                  dir: input.dir,
                  comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                  unixPermissions: input.unixPermissions,
                  dosPermissions: input.dosPermissions,
                  createFolders: options.createFolders
                });
              }

              if (zipEntries.zipComment.length) {
                zip.comment = zipEntries.zipComment;
              }

              return zip;
            });
          };
        }, {
          "./external": 6,
          "./nodejsUtils": 14,
          "./stream/Crc32Probe": 25,
          "./utf8": 31,
          "./utils": 32,
          "./zipEntries": 33
        }],
        12: [function (require, module, exports) {
          "use strict";

          var utils = require('../utils');

          var GenericWorker = require('../stream/GenericWorker');
          /**
           * A worker that use a nodejs stream as source.
           * @constructor
           * @param {String} filename the name of the file entry for this stream.
           * @param {Readable} stream the nodejs stream.
           */


          function NodejsStreamInputAdapter(filename, stream) {
            GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
            this._upstreamEnded = false;

            this._bindStream(stream);
          }

          utils.inherits(NodejsStreamInputAdapter, GenericWorker);
          /**
           * Prepare the stream and bind the callbacks on it.
           * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
           * @param {Stream} stream the nodejs stream to use.
           */

          NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
            var self = this;
            this._stream = stream;
            stream.pause();
            stream.on("data", function (chunk) {
              self.push({
                data: chunk,
                meta: {
                  percent: 0
                }
              });
            }).on("error", function (e) {
              if (self.isPaused) {
                this.generatedError = e;
              } else {
                self.error(e);
              }
            }).on("end", function () {
              if (self.isPaused) {
                self._upstreamEnded = true;
              } else {
                self.end();
              }
            });
          };

          NodejsStreamInputAdapter.prototype.pause = function () {
            if (!GenericWorker.prototype.pause.call(this)) {
              return false;
            }

            this._stream.pause();

            return true;
          };

          NodejsStreamInputAdapter.prototype.resume = function () {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false;
            }

            if (this._upstreamEnded) {
              this.end();
            } else {
              this._stream.resume();
            }

            return true;
          };

          module.exports = NodejsStreamInputAdapter;
        }, {
          "../stream/GenericWorker": 28,
          "../utils": 32
        }],
        13: [function (require, module, exports) {
          'use strict';

          var Readable = require('readable-stream').Readable;

          var utils = require('../utils');

          utils.inherits(NodejsStreamOutputAdapter, Readable);
          /**
          * A nodejs stream using a worker as source.
          * @see the SourceWrapper in http://nodejs.org/api/stream.html
          * @constructor
          * @param {StreamHelper} helper the helper wrapping the worker
          * @param {Object} options the nodejs stream options
          * @param {Function} updateCb the update callback.
          */

          function NodejsStreamOutputAdapter(helper, options, updateCb) {
            Readable.call(this, options);
            this._helper = helper;
            var self = this;
            helper.on("data", function (data, meta) {
              if (!self.push(data)) {
                self._helper.pause();
              }

              if (updateCb) {
                updateCb(meta);
              }
            }).on("error", function (e) {
              self.emit('error', e);
            }).on("end", function () {
              self.push(null);
            });
          }

          NodejsStreamOutputAdapter.prototype._read = function () {
            this._helper.resume();
          };

          module.exports = NodejsStreamOutputAdapter;
        }, {
          "../utils": 32,
          "readable-stream": 16
        }],
        14: [function (require, module, exports) {
          'use strict';

          module.exports = {
            /**
             * True if this is running in Nodejs, will be undefined in a browser.
             * In a browser, browserify won't include this file and the whole module
             * will be resolved an empty object.
             */
            isNode: typeof Buffer !== "undefined",

            /**
             * Create a new nodejs Buffer from an existing content.
             * @param {Object} data the data to pass to the constructor.
             * @param {String} encoding the encoding to use.
             * @return {Buffer} a new Buffer.
             */
            newBufferFrom: function newBufferFrom(data, encoding) {
              if (Buffer.from && Buffer.from !== Uint8Array.from) {
                return Buffer.from(data, encoding);
              } else {
                if (typeof data === "number") {
                  // Safeguard for old Node.js versions. On newer versions,
                  // Buffer.from(number) / Buffer(number, encoding) already throw.
                  throw new Error("The \"data\" argument must not be a number");
                }

                return new Buffer(data, encoding);
              }
            },

            /**
             * Create a new nodejs Buffer with the specified size.
             * @param {Integer} size the size of the buffer.
             * @return {Buffer} a new Buffer.
             */
            allocBuffer: function allocBuffer(size) {
              if (Buffer.alloc) {
                return Buffer.alloc(size);
              } else {
                var buf = new Buffer(size);
                buf.fill(0);
                return buf;
              }
            },

            /**
             * Find out if an object is a Buffer.
             * @param {Object} b the object to test.
             * @return {Boolean} true if the object is a Buffer, false otherwise.
             */
            isBuffer: function isBuffer(b) {
              return Buffer.isBuffer(b);
            },
            isStream: function isStream(obj) {
              return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
            }
          };
        }, {}],
        15: [function (require, module, exports) {
          'use strict';

          var utf8 = require('./utf8');

          var utils = require('./utils');

          var GenericWorker = require('./stream/GenericWorker');

          var StreamHelper = require('./stream/StreamHelper');

          var defaults = require('./defaults');

          var CompressedObject = require('./compressedObject');

          var ZipObject = require('./zipObject');

          var generate = require("./generate");

          var nodejsUtils = require("./nodejsUtils");

          var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");
          /**
           * Add a file in the current folder.
           * @private
           * @param {string} name the name of the file
           * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
           * @param {Object} originalOptions the options of the file
           * @return {Object} the new file.
           */


          var fileAdd = function fileAdd(name, data, originalOptions) {
            // be sure sub folders exist
            var dataType = utils.getTypeOf(data),
                parent;
            /*
             * Correct options.
             */

            var o = utils.extend(originalOptions || {}, defaults);
            o.date = o.date || new Date();

            if (o.compression !== null) {
              o.compression = o.compression.toUpperCase();
            }

            if (typeof o.unixPermissions === "string") {
              o.unixPermissions = parseInt(o.unixPermissions, 8);
            } // UNX_IFDIR  0040000 see zipinfo.c


            if (o.unixPermissions && o.unixPermissions & 0x4000) {
              o.dir = true;
            } // Bit 4    Directory


            if (o.dosPermissions && o.dosPermissions & 0x0010) {
              o.dir = true;
            }

            if (o.dir) {
              name = forceTrailingSlash(name);
            }

            if (o.createFolders && (parent = parentFolder(name))) {
              folderAdd.call(this, parent, true);
            }

            var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;

            if (!originalOptions || typeof originalOptions.binary === "undefined") {
              o.binary = !isUnicodeString;
            }

            var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;

            if (isCompressedEmpty || o.dir || !data || data.length === 0) {
              o.base64 = false;
              o.binary = true;
              data = "";
              o.compression = "STORE";
              dataType = "string";
            }
            /*
             * Convert content to fit.
             */


            var zipObjectContent = null;

            if (data instanceof CompressedObject || data instanceof GenericWorker) {
              zipObjectContent = data;
            } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
              zipObjectContent = new NodejsStreamInputAdapter(name, data);
            } else {
              zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
            }

            var object = new ZipObject(name, zipObjectContent, o);
            this.files[name] = object;
            /*
            TODO: we can't throw an exception because we have async promises
            (we can have a promise of a Date() for example) but returning a
            promise is useless because file(name, data) returns the JSZip
            object for chaining. Should we break that to allow the user
            to catch the error ?
             return external.Promise.resolve(zipObjectContent)
            .then(function () {
                return object;
            });
            */
          };
          /**
           * Find the parent folder of the path.
           * @private
           * @param {string} path the path to use
           * @return {string} the parent folder, or ""
           */


          var parentFolder = function parentFolder(path) {
            if (path.slice(-1) === '/') {
              path = path.substring(0, path.length - 1);
            }

            var lastSlash = path.lastIndexOf('/');
            return lastSlash > 0 ? path.substring(0, lastSlash) : "";
          };
          /**
           * Returns the path with a slash at the end.
           * @private
           * @param {String} path the path to check.
           * @return {String} the path with a trailing slash.
           */


          var forceTrailingSlash = function forceTrailingSlash(path) {
            // Check the name ends with a /
            if (path.slice(-1) !== "/") {
              path += "/"; // IE doesn't like substr(-1)
            }

            return path;
          };
          /**
           * Add a (sub) folder in the current folder.
           * @private
           * @param {string} name the folder's name
           * @param {boolean=} [createFolders] If true, automatically create sub
           *  folders. Defaults to false.
           * @return {Object} the new folder.
           */


          var folderAdd = function folderAdd(name, createFolders) {
            createFolders = typeof createFolders !== 'undefined' ? createFolders : defaults.createFolders;
            name = forceTrailingSlash(name); // Does this folder already exist?

            if (!this.files[name]) {
              fileAdd.call(this, name, null, {
                dir: true,
                createFolders: createFolders
              });
            }

            return this.files[name];
          };
          /**
          * Cross-window, cross-Node-context regular expression detection
          * @param  {Object}  object Anything
          * @return {Boolean}        true if the object is a regular expression,
          * false otherwise
          */


          function isRegExp(object) {
            return Object.prototype.toString.call(object) === "[object RegExp]";
          } // return the actual prototype of JSZip


          var out = {
            /**
             * @see loadAsync
             */
            load: function load() {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            },

            /**
             * Call a callback function for each entry at this folder level.
             * @param {Function} cb the callback function:
             * function (relativePath, file) {...}
             * It takes 2 arguments : the relative path and the file.
             */
            forEach: function forEach(cb) {
              var filename, relativePath, file;

              for (filename in this.files) {
                if (!this.files.hasOwnProperty(filename)) {
                  continue;
                }

                file = this.files[filename];
                relativePath = filename.slice(this.root.length, filename.length);

                if (relativePath && filename.slice(0, this.root.length) === this.root) {
                  // the file is in the current root
                  cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
                }
              }
            },

            /**
             * Filter nested files/folders with the specified function.
             * @param {Function} search the predicate to use :
             * function (relativePath, file) {...}
             * It takes 2 arguments : the relative path and the file.
             * @return {Array} An array of matching elements.
             */
            filter: function filter(search) {
              var result = [];
              this.forEach(function (relativePath, entry) {
                if (search(relativePath, entry)) {
                  // the file matches the function
                  result.push(entry);
                }
              });
              return result;
            },

            /**
             * Add a file to the zip file, or search a file.
             * @param   {string|RegExp} name The name of the file to add (if data is defined),
             * the name of the file to find (if no data) or a regex to match files.
             * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
             * @param   {Object} o     File options
             * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
             * a file (when searching by string) or an array of files (when searching by regex).
             */
            file: function file(name, data, o) {
              if (arguments.length === 1) {
                if (isRegExp(name)) {
                  var regexp = name;
                  return this.filter(function (relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                  });
                } else {
                  // text
                  var obj = this.files[this.root + name];

                  if (obj && !obj.dir) {
                    return obj;
                  } else {
                    return null;
                  }
                }
              } else {
                // more than one argument : we have data !
                name = this.root + name;
                fileAdd.call(this, name, data, o);
              }

              return this;
            },

            /**
             * Add a directory to the zip file, or search.
             * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
             * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
             */
            folder: function folder(arg) {
              if (!arg) {
                return this;
              }

              if (isRegExp(arg)) {
                return this.filter(function (relativePath, file) {
                  return file.dir && arg.test(relativePath);
                });
              } // else, name is a new folder


              var name = this.root + arg;
              var newFolder = folderAdd.call(this, name); // Allow chaining by returning a new object with this folder as the root

              var ret = this.clone();
              ret.root = newFolder.name;
              return ret;
            },

            /**
             * Delete a file, or a directory and all sub-files, from the zip
             * @param {string} name the name of the file to delete
             * @return {JSZip} this JSZip object
             */
            remove: function remove(name) {
              name = this.root + name;
              var file = this.files[name];

              if (!file) {
                // Look for any folders
                if (name.slice(-1) !== "/") {
                  name += "/";
                }

                file = this.files[name];
              }

              if (file && !file.dir) {
                // file
                delete this.files[name];
              } else {
                // maybe a folder, delete recursively
                var kids = this.filter(function (relativePath, file) {
                  return file.name.slice(0, name.length) === name;
                });

                for (var i = 0; i < kids.length; i++) {
                  delete this.files[kids[i].name];
                }
              }

              return this;
            },

            /**
             * Generate the complete zip file
             * @param {Object} options the options to generate the zip file :
             * - compression, "STORE" by default.
             * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
             * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
             */
            generate: function generate(options) {
              throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
            },

            /**
             * Generate the complete zip file as an internal stream.
             * @param {Object} options the options to generate the zip file :
             * - compression, "STORE" by default.
             * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
             * @return {StreamHelper} the streamed zip file.
             */
            generateInternalStream: function generateInternalStream(options) {
              var worker,
                  opts = {};

              try {
                opts = utils.extend(options || {}, {
                  streamFiles: false,
                  compression: "STORE",
                  compressionOptions: null,
                  type: "",
                  platform: "DOS",
                  comment: null,
                  mimeType: 'application/zip',
                  encodeFileName: utf8.utf8encode
                });
                opts.type = opts.type.toLowerCase();
                opts.compression = opts.compression.toUpperCase(); // "binarystring" is prefered but the internals use "string".

                if (opts.type === "binarystring") {
                  opts.type = "string";
                }

                if (!opts.type) {
                  throw new Error("No output type specified.");
                }

                utils.checkSupport(opts.type); // accept nodejs `process.platform`

                if (opts.platform === 'darwin' || opts.platform === 'freebsd' || opts.platform === 'linux' || opts.platform === 'sunos') {
                  opts.platform = "UNIX";
                }

                if (opts.platform === 'win32') {
                  opts.platform = "DOS";
                }

                var comment = opts.comment || this.comment || "";
                worker = generate.generateWorker(this, opts, comment);
              } catch (e) {
                worker = new GenericWorker("error");
                worker.error(e);
              }

              return new StreamHelper(worker, opts.type || "string", opts.mimeType);
            },

            /**
             * Generate the complete zip file asynchronously.
             * @see generateInternalStream
             */
            generateAsync: function generateAsync(options, onUpdate) {
              return this.generateInternalStream(options).accumulate(onUpdate);
            },

            /**
             * Generate the complete zip file asynchronously.
             * @see generateInternalStream
             */
            generateNodeStream: function generateNodeStream(options, onUpdate) {
              options = options || {};

              if (!options.type) {
                options.type = "nodebuffer";
              }

              return this.generateInternalStream(options).toNodejsStream(onUpdate);
            }
          };
          module.exports = out;
        }, {
          "./compressedObject": 2,
          "./defaults": 5,
          "./generate": 9,
          "./nodejs/NodejsStreamInputAdapter": 12,
          "./nodejsUtils": 14,
          "./stream/GenericWorker": 28,
          "./stream/StreamHelper": 29,
          "./utf8": 31,
          "./utils": 32,
          "./zipObject": 35
        }],
        16: [function (require, module, exports) {
          /*
           * This file is used by module bundlers (browserify/webpack/etc) when
           * including a stream implementation. We use "readable-stream" to get a
           * consistent behavior between nodejs versions but bundlers often have a shim
           * for "stream". Using this shim greatly improve the compatibility and greatly
           * reduce the final size of the bundle (only one stream implementation, not
           * two).
           */
          module.exports = require("stream");
        }, {
          "stream": undefined
        }],
        17: [function (require, module, exports) {
          'use strict';

          var DataReader = require('./DataReader');

          var utils = require('../utils');

          function ArrayReader(data) {
            DataReader.call(this, data);

            for (var i = 0; i < this.data.length; i++) {
              data[i] = data[i] & 0xFF;
            }
          }

          utils.inherits(ArrayReader, DataReader);
          /**
           * @see DataReader.byteAt
           */

          ArrayReader.prototype.byteAt = function (i) {
            return this.data[this.zero + i];
          };
          /**
           * @see DataReader.lastIndexOfSignature
           */


          ArrayReader.prototype.lastIndexOfSignature = function (sig) {
            var sig0 = sig.charCodeAt(0),
                sig1 = sig.charCodeAt(1),
                sig2 = sig.charCodeAt(2),
                sig3 = sig.charCodeAt(3);

            for (var i = this.length - 4; i >= 0; --i) {
              if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
                return i - this.zero;
              }
            }

            return -1;
          };
          /**
           * @see DataReader.readAndCheckSignature
           */


          ArrayReader.prototype.readAndCheckSignature = function (sig) {
            var sig0 = sig.charCodeAt(0),
                sig1 = sig.charCodeAt(1),
                sig2 = sig.charCodeAt(2),
                sig3 = sig.charCodeAt(3),
                data = this.readData(4);
            return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
          };
          /**
           * @see DataReader.readData
           */


          ArrayReader.prototype.readData = function (size) {
            this.checkOffset(size);

            if (size === 0) {
              return [];
            }

            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
            this.index += size;
            return result;
          };

          module.exports = ArrayReader;
        }, {
          "../utils": 32,
          "./DataReader": 18
        }],
        18: [function (require, module, exports) {
          'use strict';

          var utils = require('../utils');

          function DataReader(data) {
            this.data = data; // type : see implementation

            this.length = data.length;
            this.index = 0;
            this.zero = 0;
          }

          DataReader.prototype = {
            /**
             * Check that the offset will not go too far.
             * @param {string} offset the additional offset to check.
             * @throws {Error} an Error if the offset is out of bounds.
             */
            checkOffset: function checkOffset(offset) {
              this.checkIndex(this.index + offset);
            },

            /**
             * Check that the specified index will not be too far.
             * @param {string} newIndex the index to check.
             * @throws {Error} an Error if the index is out of bounds.
             */
            checkIndex: function checkIndex(newIndex) {
              if (this.length < this.zero + newIndex || newIndex < 0) {
                throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
              }
            },

            /**
             * Change the index.
             * @param {number} newIndex The new index.
             * @throws {Error} if the new index is out of the data.
             */
            setIndex: function setIndex(newIndex) {
              this.checkIndex(newIndex);
              this.index = newIndex;
            },

            /**
             * Skip the next n bytes.
             * @param {number} n the number of bytes to skip.
             * @throws {Error} if the new index is out of the data.
             */
            skip: function skip(n) {
              this.setIndex(this.index + n);
            },

            /**
             * Get the byte at the specified index.
             * @param {number} i the index to use.
             * @return {number} a byte.
             */
            byteAt: function byteAt(i) {// see implementations
            },

            /**
             * Get the next number with a given byte size.
             * @param {number} size the number of bytes to read.
             * @return {number} the corresponding number.
             */
            readInt: function readInt(size) {
              var result = 0,
                  i;
              this.checkOffset(size);

              for (i = this.index + size - 1; i >= this.index; i--) {
                result = (result << 8) + this.byteAt(i);
              }

              this.index += size;
              return result;
            },

            /**
             * Get the next string with a given byte size.
             * @param {number} size the number of bytes to read.
             * @return {string} the corresponding string.
             */
            readString: function readString(size) {
              return utils.transformTo("string", this.readData(size));
            },

            /**
             * Get raw data without conversion, <size> bytes.
             * @param {number} size the number of bytes to read.
             * @return {Object} the raw data, implementation specific.
             */
            readData: function readData(size) {// see implementations
            },

            /**
             * Find the last occurence of a zip signature (4 bytes).
             * @param {string} sig the signature to find.
             * @return {number} the index of the last occurence, -1 if not found.
             */
            lastIndexOfSignature: function lastIndexOfSignature(sig) {// see implementations
            },

            /**
             * Read the signature (4 bytes) at the current position and compare it with sig.
             * @param {string} sig the expected signature
             * @return {boolean} true if the signature matches, false otherwise.
             */
            readAndCheckSignature: function readAndCheckSignature(sig) {// see implementations
            },

            /**
             * Get the next date.
             * @return {Date} the date.
             */
            readDate: function readDate() {
              var dostime = this.readInt(4);
              return new Date(Date.UTC((dostime >> 25 & 0x7f) + 1980, // year
              (dostime >> 21 & 0x0f) - 1, // month
              dostime >> 16 & 0x1f, // day
              dostime >> 11 & 0x1f, // hour
              dostime >> 5 & 0x3f, // minute
              (dostime & 0x1f) << 1)); // second
            }
          };
          module.exports = DataReader;
        }, {
          "../utils": 32
        }],
        19: [function (require, module, exports) {
          'use strict';

          var Uint8ArrayReader = require('./Uint8ArrayReader');

          var utils = require('../utils');

          function NodeBufferReader(data) {
            Uint8ArrayReader.call(this, data);
          }

          utils.inherits(NodeBufferReader, Uint8ArrayReader);
          /**
           * @see DataReader.readData
           */

          NodeBufferReader.prototype.readData = function (size) {
            this.checkOffset(size);
            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
            this.index += size;
            return result;
          };

          module.exports = NodeBufferReader;
        }, {
          "../utils": 32,
          "./Uint8ArrayReader": 21
        }],
        20: [function (require, module, exports) {
          'use strict';

          var DataReader = require('./DataReader');

          var utils = require('../utils');

          function StringReader(data) {
            DataReader.call(this, data);
          }

          utils.inherits(StringReader, DataReader);
          /**
           * @see DataReader.byteAt
           */

          StringReader.prototype.byteAt = function (i) {
            return this.data.charCodeAt(this.zero + i);
          };
          /**
           * @see DataReader.lastIndexOfSignature
           */


          StringReader.prototype.lastIndexOfSignature = function (sig) {
            return this.data.lastIndexOf(sig) - this.zero;
          };
          /**
           * @see DataReader.readAndCheckSignature
           */


          StringReader.prototype.readAndCheckSignature = function (sig) {
            var data = this.readData(4);
            return sig === data;
          };
          /**
           * @see DataReader.readData
           */


          StringReader.prototype.readData = function (size) {
            this.checkOffset(size); // this will work because the constructor applied the "& 0xff" mask.

            var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
            this.index += size;
            return result;
          };

          module.exports = StringReader;
        }, {
          "../utils": 32,
          "./DataReader": 18
        }],
        21: [function (require, module, exports) {
          'use strict';

          var ArrayReader = require('./ArrayReader');

          var utils = require('../utils');

          function Uint8ArrayReader(data) {
            ArrayReader.call(this, data);
          }

          utils.inherits(Uint8ArrayReader, ArrayReader);
          /**
           * @see DataReader.readData
           */

          Uint8ArrayReader.prototype.readData = function (size) {
            this.checkOffset(size);

            if (size === 0) {
              // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
              return new Uint8Array(0);
            }

            var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
            this.index += size;
            return result;
          };

          module.exports = Uint8ArrayReader;
        }, {
          "../utils": 32,
          "./ArrayReader": 17
        }],
        22: [function (require, module, exports) {
          'use strict';

          var utils = require('../utils');

          var support = require('../support');

          var ArrayReader = require('./ArrayReader');

          var StringReader = require('./StringReader');

          var NodeBufferReader = require('./NodeBufferReader');

          var Uint8ArrayReader = require('./Uint8ArrayReader');
          /**
           * Create a reader adapted to the data.
           * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
           * @return {DataReader} the data reader.
           */


          module.exports = function (data) {
            var type = utils.getTypeOf(data);
            utils.checkSupport(type);

            if (type === "string" && !support.uint8array) {
              return new StringReader(data);
            }

            if (type === "nodebuffer") {
              return new NodeBufferReader(data);
            }

            if (support.uint8array) {
              return new Uint8ArrayReader(utils.transformTo("uint8array", data));
            }

            return new ArrayReader(utils.transformTo("array", data));
          };
        }, {
          "../support": 30,
          "../utils": 32,
          "./ArrayReader": 17,
          "./NodeBufferReader": 19,
          "./StringReader": 20,
          "./Uint8ArrayReader": 21
        }],
        23: [function (require, module, exports) {
          'use strict';

          exports.LOCAL_FILE_HEADER = "PK\x03\x04";
          exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
          exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
          exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
          exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
          exports.DATA_DESCRIPTOR = "PK\x07\x08";
        }, {}],
        24: [function (require, module, exports) {
          'use strict';

          var GenericWorker = require('./GenericWorker');

          var utils = require('../utils');
          /**
           * A worker which convert chunks to a specified type.
           * @constructor
           * @param {String} destType the destination type.
           */


          function ConvertWorker(destType) {
            GenericWorker.call(this, "ConvertWorker to " + destType);
            this.destType = destType;
          }

          utils.inherits(ConvertWorker, GenericWorker);
          /**
           * @see GenericWorker.processChunk
           */

          ConvertWorker.prototype.processChunk = function (chunk) {
            this.push({
              data: utils.transformTo(this.destType, chunk.data),
              meta: chunk.meta
            });
          };

          module.exports = ConvertWorker;
        }, {
          "../utils": 32,
          "./GenericWorker": 28
        }],
        25: [function (require, module, exports) {
          'use strict';

          var GenericWorker = require('./GenericWorker');

          var crc32 = require('../crc32');

          var utils = require('../utils');
          /**
           * A worker which calculate the crc32 of the data flowing through.
           * @constructor
           */


          function Crc32Probe() {
            GenericWorker.call(this, "Crc32Probe");
            this.withStreamInfo("crc32", 0);
          }

          utils.inherits(Crc32Probe, GenericWorker);
          /**
           * @see GenericWorker.processChunk
           */

          Crc32Probe.prototype.processChunk = function (chunk) {
            this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
            this.push(chunk);
          };

          module.exports = Crc32Probe;
        }, {
          "../crc32": 4,
          "../utils": 32,
          "./GenericWorker": 28
        }],
        26: [function (require, module, exports) {
          'use strict';

          var utils = require('../utils');

          var GenericWorker = require('./GenericWorker');
          /**
           * A worker which calculate the total length of the data flowing through.
           * @constructor
           * @param {String} propName the name used to expose the length
           */


          function DataLengthProbe(propName) {
            GenericWorker.call(this, "DataLengthProbe for " + propName);
            this.propName = propName;
            this.withStreamInfo(propName, 0);
          }

          utils.inherits(DataLengthProbe, GenericWorker);
          /**
           * @see GenericWorker.processChunk
           */

          DataLengthProbe.prototype.processChunk = function (chunk) {
            if (chunk) {
              var length = this.streamInfo[this.propName] || 0;
              this.streamInfo[this.propName] = length + chunk.data.length;
            }

            GenericWorker.prototype.processChunk.call(this, chunk);
          };

          module.exports = DataLengthProbe;
        }, {
          "../utils": 32,
          "./GenericWorker": 28
        }],
        27: [function (require, module, exports) {
          'use strict';

          var utils = require('../utils');

          var GenericWorker = require('./GenericWorker'); // the size of the generated chunks
          // TODO expose this as a public variable


          var DEFAULT_BLOCK_SIZE = 16 * 1024;
          /**
           * A worker that reads a content and emits chunks.
           * @constructor
           * @param {Promise} dataP the promise of the data to split
           */

          function DataWorker(dataP) {
            GenericWorker.call(this, "DataWorker");
            var self = this;
            this.dataIsReady = false;
            this.index = 0;
            this.max = 0;
            this.data = null;
            this.type = "";
            this._tickScheduled = false;
            dataP.then(function (data) {
              self.dataIsReady = true;
              self.data = data;
              self.max = data && data.length || 0;
              self.type = utils.getTypeOf(data);

              if (!self.isPaused) {
                self._tickAndRepeat();
              }
            }, function (e) {
              self.error(e);
            });
          }

          utils.inherits(DataWorker, GenericWorker);
          /**
           * @see GenericWorker.cleanUp
           */

          DataWorker.prototype.cleanUp = function () {
            GenericWorker.prototype.cleanUp.call(this);
            this.data = null;
          };
          /**
           * @see GenericWorker.resume
           */


          DataWorker.prototype.resume = function () {
            if (!GenericWorker.prototype.resume.call(this)) {
              return false;
            }

            if (!this._tickScheduled && this.dataIsReady) {
              this._tickScheduled = true;
              utils.delay(this._tickAndRepeat, [], this);
            }

            return true;
          };
          /**
           * Trigger a tick a schedule an other call to this function.
           */


          DataWorker.prototype._tickAndRepeat = function () {
            this._tickScheduled = false;

            if (this.isPaused || this.isFinished) {
              return;
            }

            this._tick();

            if (!this.isFinished) {
              utils.delay(this._tickAndRepeat, [], this);
              this._tickScheduled = true;
            }
          };
          /**
           * Read and push a chunk.
           */


          DataWorker.prototype._tick = function () {
            if (this.isPaused || this.isFinished) {
              return false;
            }

            var size = DEFAULT_BLOCK_SIZE;
            var data = null,
                nextIndex = Math.min(this.max, this.index + size);

            if (this.index >= this.max) {
              // EOF
              return this.end();
            } else {
              switch (this.type) {
                case "string":
                  data = this.data.substring(this.index, nextIndex);
                  break;

                case "uint8array":
                  data = this.data.subarray(this.index, nextIndex);
                  break;

                case "array":
                case "nodebuffer":
                  data = this.data.slice(this.index, nextIndex);
                  break;
              }

              this.index = nextIndex;
              return this.push({
                data: data,
                meta: {
                  percent: this.max ? this.index / this.max * 100 : 0
                }
              });
            }
          };

          module.exports = DataWorker;
        }, {
          "../utils": 32,
          "./GenericWorker": 28
        }],
        28: [function (require, module, exports) {
          'use strict';
          /**
           * A worker that does nothing but passing chunks to the next one. This is like
           * a nodejs stream but with some differences. On the good side :
           * - it works on IE 6-9 without any issue / polyfill
           * - it weights less than the full dependencies bundled with browserify
           * - it forwards errors (no need to declare an error handler EVERYWHERE)
           *
           * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
           * object containing anything (`percent` for example), see each worker for more
           * details. The latter is the real data (String, Uint8Array, etc).
           *
           * @constructor
           * @param {String} name the name of the stream (mainly used for debugging purposes)
           */

          function GenericWorker(name) {
            // the name of the worker
            this.name = name || "default"; // an object containing metadata about the workers chain

            this.streamInfo = {}; // an error which happened when the worker was paused

            this.generatedError = null; // an object containing metadata to be merged by this worker into the general metadata

            this.extraStreamInfo = {}; // true if the stream is paused (and should not do anything), false otherwise

            this.isPaused = true; // true if the stream is finished (and should not do anything), false otherwise

            this.isFinished = false; // true if the stream is locked to prevent further structure updates (pipe), false otherwise

            this.isLocked = false; // the event listeners

            this._listeners = {
              'data': [],
              'end': [],
              'error': []
            }; // the previous worker, if any

            this.previous = null;
          }

          GenericWorker.prototype = {
            /**
             * Push a chunk to the next workers.
             * @param {Object} chunk the chunk to push
             */
            push: function push(chunk) {
              this.emit("data", chunk);
            },

            /**
             * End the stream.
             * @return {Boolean} true if this call ended the worker, false otherwise.
             */
            end: function end() {
              if (this.isFinished) {
                return false;
              }

              this.flush();

              try {
                this.emit("end");
                this.cleanUp();
                this.isFinished = true;
              } catch (e) {
                this.emit("error", e);
              }

              return true;
            },

            /**
             * End the stream with an error.
             * @param {Error} e the error which caused the premature end.
             * @return {Boolean} true if this call ended the worker with an error, false otherwise.
             */
            error: function error(e) {
              if (this.isFinished) {
                return false;
              }

              if (this.isPaused) {
                this.generatedError = e;
              } else {
                this.isFinished = true;
                this.emit("error", e); // in the workers chain exploded in the middle of the chain,
                // the error event will go downward but we also need to notify
                // workers upward that there has been an error.

                if (this.previous) {
                  this.previous.error(e);
                }

                this.cleanUp();
              }

              return true;
            },

            /**
             * Add a callback on an event.
             * @param {String} name the name of the event (data, end, error)
             * @param {Function} listener the function to call when the event is triggered
             * @return {GenericWorker} the current object for chainability
             */
            on: function on(name, listener) {
              this._listeners[name].push(listener);

              return this;
            },

            /**
             * Clean any references when a worker is ending.
             */
            cleanUp: function cleanUp() {
              this.streamInfo = this.generatedError = this.extraStreamInfo = null;
              this._listeners = [];
            },

            /**
             * Trigger an event. This will call registered callback with the provided arg.
             * @param {String} name the name of the event (data, end, error)
             * @param {Object} arg the argument to call the callback with.
             */
            emit: function emit(name, arg) {
              if (this._listeners[name]) {
                for (var i = 0; i < this._listeners[name].length; i++) {
                  this._listeners[name][i].call(this, arg);
                }
              }
            },

            /**
             * Chain a worker with an other.
             * @param {Worker} next the worker receiving events from the current one.
             * @return {worker} the next worker for chainability
             */
            pipe: function pipe(next) {
              return next.registerPrevious(this);
            },

            /**
             * Same as `pipe` in the other direction.
             * Using an API with `pipe(next)` is very easy.
             * Implementing the API with the point of view of the next one registering
             * a source is easier, see the ZipFileWorker.
             * @param {Worker} previous the previous worker, sending events to this one
             * @return {Worker} the current worker for chainability
             */
            registerPrevious: function registerPrevious(previous) {
              if (this.isLocked) {
                throw new Error("The stream '" + this + "' has already been used.");
              } // sharing the streamInfo...


              this.streamInfo = previous.streamInfo; // ... and adding our own bits

              this.mergeStreamInfo();
              this.previous = previous;
              var self = this;
              previous.on('data', function (chunk) {
                self.processChunk(chunk);
              });
              previous.on('end', function () {
                self.end();
              });
              previous.on('error', function (e) {
                self.error(e);
              });
              return this;
            },

            /**
             * Pause the stream so it doesn't send events anymore.
             * @return {Boolean} true if this call paused the worker, false otherwise.
             */
            pause: function pause() {
              if (this.isPaused || this.isFinished) {
                return false;
              }

              this.isPaused = true;

              if (this.previous) {
                this.previous.pause();
              }

              return true;
            },

            /**
             * Resume a paused stream.
             * @return {Boolean} true if this call resumed the worker, false otherwise.
             */
            resume: function resume() {
              if (!this.isPaused || this.isFinished) {
                return false;
              }

              this.isPaused = false; // if true, the worker tried to resume but failed

              var withError = false;

              if (this.generatedError) {
                this.error(this.generatedError);
                withError = true;
              }

              if (this.previous) {
                this.previous.resume();
              }

              return !withError;
            },

            /**
             * Flush any remaining bytes as the stream is ending.
             */
            flush: function flush() {},

            /**
             * Process a chunk. This is usually the method overridden.
             * @param {Object} chunk the chunk to process.
             */
            processChunk: function processChunk(chunk) {
              this.push(chunk);
            },

            /**
             * Add a key/value to be added in the workers chain streamInfo once activated.
             * @param {String} key the key to use
             * @param {Object} value the associated value
             * @return {Worker} the current worker for chainability
             */
            withStreamInfo: function withStreamInfo(key, value) {
              this.extraStreamInfo[key] = value;
              this.mergeStreamInfo();
              return this;
            },

            /**
             * Merge this worker's streamInfo into the chain's streamInfo.
             */
            mergeStreamInfo: function mergeStreamInfo() {
              for (var key in this.extraStreamInfo) {
                if (!this.extraStreamInfo.hasOwnProperty(key)) {
                  continue;
                }

                this.streamInfo[key] = this.extraStreamInfo[key];
              }
            },

            /**
             * Lock the stream to prevent further updates on the workers chain.
             * After calling this method, all calls to pipe will fail.
             */
            lock: function lock() {
              if (this.isLocked) {
                throw new Error("The stream '" + this + "' has already been used.");
              }

              this.isLocked = true;

              if (this.previous) {
                this.previous.lock();
              }
            },

            /**
             *
             * Pretty print the workers chain.
             */
            toString: function toString() {
              var me = "Worker " + this.name;

              if (this.previous) {
                return this.previous + " -> " + me;
              } else {
                return me;
              }
            }
          };
          module.exports = GenericWorker;
        }, {}],
        29: [function (require, module, exports) {
          'use strict';

          var utils = require('../utils');

          var ConvertWorker = require('./ConvertWorker');

          var GenericWorker = require('./GenericWorker');

          var base64 = require('../base64');

          var support = require("../support");

          var external = require("../external");

          var NodejsStreamOutputAdapter = null;

          if (support.nodestream) {
            try {
              NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
            } catch (e) {}
          }
          /**
           * Apply the final transformation of the data. If the user wants a Blob for
           * example, it's easier to work with an U8intArray and finally do the
           * ArrayBuffer/Blob conversion.
           * @param {String} type the name of the final type
           * @param {String|Uint8Array|Buffer} content the content to transform
           * @param {String} mimeType the mime type of the content, if applicable.
           * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
           */


          function transformZipOutput(type, content, mimeType) {
            switch (type) {
              case "blob":
                return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);

              case "base64":
                return base64.encode(content);

              default:
                return utils.transformTo(type, content);
            }
          }
          /**
           * Concatenate an array of data of the given type.
           * @param {String} type the type of the data in the given array.
           * @param {Array} dataArray the array containing the data chunks to concatenate
           * @return {String|Uint8Array|Buffer} the concatenated data
           * @throws Error if the asked type is unsupported
           */


          function concat(type, dataArray) {
            var i,
                index = 0,
                res = null,
                totalLength = 0;

            for (i = 0; i < dataArray.length; i++) {
              totalLength += dataArray[i].length;
            }

            switch (type) {
              case "string":
                return dataArray.join("");

              case "array":
                return Array.prototype.concat.apply([], dataArray);

              case "uint8array":
                res = new Uint8Array(totalLength);

                for (i = 0; i < dataArray.length; i++) {
                  res.set(dataArray[i], index);
                  index += dataArray[i].length;
                }

                return res;

              case "nodebuffer":
                return Buffer.concat(dataArray);

              default:
                throw new Error("concat : unsupported type '" + type + "'");
            }
          }
          /**
           * Listen a StreamHelper, accumulate its content and concatenate it into a
           * complete block.
           * @param {StreamHelper} helper the helper to use.
           * @param {Function} updateCallback a callback called on each update. Called
           * with one arg :
           * - the metadata linked to the update received.
           * @return Promise the promise for the accumulation.
           */


          function _accumulate(helper, updateCallback) {
            return new external.Promise(function (resolve, reject) {
              var dataArray = [];
              var chunkType = helper._internalType,
                  resultType = helper._outputType,
                  mimeType = helper._mimeType;
              helper.on('data', function (data, meta) {
                dataArray.push(data);

                if (updateCallback) {
                  updateCallback(meta);
                }
              }).on('error', function (err) {
                dataArray = [];
                reject(err);
              }).on('end', function () {
                try {
                  var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                  resolve(result);
                } catch (e) {
                  reject(e);
                }

                dataArray = [];
              }).resume();
            });
          }
          /**
           * An helper to easily use workers outside of JSZip.
           * @constructor
           * @param {Worker} worker the worker to wrap
           * @param {String} outputType the type of data expected by the use
           * @param {String} mimeType the mime type of the content, if applicable.
           */


          function StreamHelper(worker, outputType, mimeType) {
            var internalType = outputType;

            switch (outputType) {
              case "blob":
              case "arraybuffer":
                internalType = "uint8array";
                break;

              case "base64":
                internalType = "string";
                break;
            }

            try {
              // the type used internally
              this._internalType = internalType; // the type used to output results

              this._outputType = outputType; // the mime type

              this._mimeType = mimeType;
              utils.checkSupport(internalType);
              this._worker = worker.pipe(new ConvertWorker(internalType)); // the last workers can be rewired without issues but we need to
              // prevent any updates on previous workers.

              worker.lock();
            } catch (e) {
              this._worker = new GenericWorker("error");

              this._worker.error(e);
            }
          }

          StreamHelper.prototype = {
            /**
             * Listen a StreamHelper, accumulate its content and concatenate it into a
             * complete block.
             * @param {Function} updateCb the update callback.
             * @return Promise the promise for the accumulation.
             */
            accumulate: function accumulate(updateCb) {
              return _accumulate(this, updateCb);
            },

            /**
             * Add a listener on an event triggered on a stream.
             * @param {String} evt the name of the event
             * @param {Function} fn the listener
             * @return {StreamHelper} the current helper.
             */
            on: function on(evt, fn) {
              var self = this;

              if (evt === "data") {
                this._worker.on(evt, function (chunk) {
                  fn.call(self, chunk.data, chunk.meta);
                });
              } else {
                this._worker.on(evt, function () {
                  utils.delay(fn, arguments, self);
                });
              }

              return this;
            },

            /**
             * Resume the flow of chunks.
             * @return {StreamHelper} the current helper.
             */
            resume: function resume() {
              utils.delay(this._worker.resume, [], this._worker);
              return this;
            },

            /**
             * Pause the flow of chunks.
             * @return {StreamHelper} the current helper.
             */
            pause: function pause() {
              this._worker.pause();

              return this;
            },

            /**
             * Return a nodejs stream for this helper.
             * @param {Function} updateCb the update callback.
             * @return {NodejsStreamOutputAdapter} the nodejs stream.
             */
            toNodejsStream: function toNodejsStream(updateCb) {
              utils.checkSupport("nodestream");

              if (this._outputType !== "nodebuffer") {
                // an object stream containing blob/arraybuffer/uint8array/string
                // is strange and I don't know if it would be useful.
                // I you find this comment and have a good usecase, please open a
                // bug report !
                throw new Error(this._outputType + " is not supported by this method");
              }

              return new NodejsStreamOutputAdapter(this, {
                objectMode: this._outputType !== "nodebuffer"
              }, updateCb);
            }
          };
          module.exports = StreamHelper;
        }, {
          "../base64": 1,
          "../external": 6,
          "../nodejs/NodejsStreamOutputAdapter": 13,
          "../support": 30,
          "../utils": 32,
          "./ConvertWorker": 24,
          "./GenericWorker": 28
        }],
        30: [function (require, module, exports) {
          'use strict';

          exports.base64 = true;
          exports.array = true;
          exports.string = true;
          exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
          exports.nodebuffer = typeof Buffer !== "undefined"; // contains true if JSZip can read/generate Uint8Array, false otherwise.

          exports.uint8array = typeof Uint8Array !== "undefined";

          if (typeof ArrayBuffer === "undefined") {
            exports.blob = false;
          } else {
            var buffer = new ArrayBuffer(0);

            try {
              exports.blob = new Blob([buffer], {
                type: "application/zip"
              }).size === 0;
            } catch (e) {
              try {
                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
                var builder = new Builder();
                builder.append(buffer);
                exports.blob = builder.getBlob('application/zip').size === 0;
              } catch (e) {
                exports.blob = false;
              }
            }
          }

          try {
            exports.nodestream = !!require('readable-stream').Readable;
          } catch (e) {
            exports.nodestream = false;
          }
        }, {
          "readable-stream": 16
        }],
        31: [function (require, module, exports) {
          'use strict';

          var utils = require('./utils');

          var support = require('./support');

          var nodejsUtils = require('./nodejsUtils');

          var GenericWorker = require('./stream/GenericWorker');
          /**
           * The following functions come from pako, from pako/lib/utils/strings
           * released under the MIT license, see pako https://github.com/nodeca/pako/
           */
          // Table with utf8 lengths (calculated by first byte of sequence)
          // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
          // because max possible codepoint is 0x10ffff


          var _utf8len = new Array(256);

          for (var i = 0; i < 256; i++) {
            _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
          }

          _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
          // convert string to array (typed, when possible)

          var string2buf = function string2buf(str) {
            var buf,
                c,
                c2,
                m_pos,
                i,
                str_len = str.length,
                buf_len = 0; // count binary size

            for (m_pos = 0; m_pos < str_len; m_pos++) {
              c = str.charCodeAt(m_pos);

              if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);

                if ((c2 & 0xfc00) === 0xdc00) {
                  c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                  m_pos++;
                }
              }

              buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
            } // allocate buffer


            if (support.uint8array) {
              buf = new Uint8Array(buf_len);
            } else {
              buf = new Array(buf_len);
            } // convert


            for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
              c = str.charCodeAt(m_pos);

              if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);

                if ((c2 & 0xfc00) === 0xdc00) {
                  c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                  m_pos++;
                }
              }

              if (c < 0x80) {
                /* one byte */
                buf[i++] = c;
              } else if (c < 0x800) {
                /* two bytes */
                buf[i++] = 0xC0 | c >>> 6;
                buf[i++] = 0x80 | c & 0x3f;
              } else if (c < 0x10000) {
                /* three bytes */
                buf[i++] = 0xE0 | c >>> 12;
                buf[i++] = 0x80 | c >>> 6 & 0x3f;
                buf[i++] = 0x80 | c & 0x3f;
              } else {
                /* four bytes */
                buf[i++] = 0xf0 | c >>> 18;
                buf[i++] = 0x80 | c >>> 12 & 0x3f;
                buf[i++] = 0x80 | c >>> 6 & 0x3f;
                buf[i++] = 0x80 | c & 0x3f;
              }
            }

            return buf;
          }; // Calculate max possible position in utf8 buffer,
          // that will not break sequence. If that's not possible
          // - (very small limits) return max size as is.
          //
          // buf[] - utf8 bytes array
          // max   - length limit (mandatory);


          var utf8border = function utf8border(buf, max) {
            var pos;
            max = max || buf.length;

            if (max > buf.length) {
              max = buf.length;
            } // go back from last position, until start of sequence found


            pos = max - 1;

            while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
              pos--;
            } // Fuckup - very small and broken sequence,
            // return max, because we should return something anyway.


            if (pos < 0) {
              return max;
            } // If we came to start of buffer - that means vuffer is too small,
            // return max too.


            if (pos === 0) {
              return max;
            }

            return pos + _utf8len[buf[pos]] > max ? pos : max;
          }; // convert array to string


          var buf2string = function buf2string(buf) {
            var str, i, out, c, c_len;
            var len = buf.length; // Reserve max possible length (2 words per char)
            // NB: by unknown reasons, Array is significantly faster for
            //     String.fromCharCode.apply than Uint16Array.

            var utf16buf = new Array(len * 2);

            for (out = 0, i = 0; i < len;) {
              c = buf[i++]; // quick process ascii

              if (c < 0x80) {
                utf16buf[out++] = c;
                continue;
              }

              c_len = _utf8len[c]; // skip 5 & 6 byte codes

              if (c_len > 4) {
                utf16buf[out++] = 0xfffd;
                i += c_len - 1;
                continue;
              } // apply mask on first byte


              c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest

              while (c_len > 1 && i < len) {
                c = c << 6 | buf[i++] & 0x3f;
                c_len--;
              } // terminated by end of string?


              if (c_len > 1) {
                utf16buf[out++] = 0xfffd;
                continue;
              }

              if (c < 0x10000) {
                utf16buf[out++] = c;
              } else {
                c -= 0x10000;
                utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
                utf16buf[out++] = 0xdc00 | c & 0x3ff;
              }
            } // shrinkBuf(utf16buf, out)


            if (utf16buf.length !== out) {
              if (utf16buf.subarray) {
                utf16buf = utf16buf.subarray(0, out);
              } else {
                utf16buf.length = out;
              }
            } // return String.fromCharCode.apply(null, utf16buf);


            return utils.applyFromCharCode(utf16buf);
          }; // That's all for the pako functions.

          /**
           * Transform a javascript string into an array (typed if possible) of bytes,
           * UTF-8 encoded.
           * @param {String} str the string to encode
           * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
           */


          exports.utf8encode = function utf8encode(str) {
            if (support.nodebuffer) {
              return nodejsUtils.newBufferFrom(str, "utf-8");
            }

            return string2buf(str);
          };
          /**
           * Transform a bytes array (or a representation) representing an UTF-8 encoded
           * string into a javascript string.
           * @param {Array|Uint8Array|Buffer} buf the data de decode
           * @return {String} the decoded string.
           */


          exports.utf8decode = function utf8decode(buf) {
            if (support.nodebuffer) {
              return utils.transformTo("nodebuffer", buf).toString("utf-8");
            }

            buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
            return buf2string(buf);
          };
          /**
           * A worker to decode utf8 encoded binary chunks into string chunks.
           * @constructor
           */


          function Utf8DecodeWorker() {
            GenericWorker.call(this, "utf-8 decode"); // the last bytes if a chunk didn't end with a complete codepoint.

            this.leftOver = null;
          }

          utils.inherits(Utf8DecodeWorker, GenericWorker);
          /**
           * @see GenericWorker.processChunk
           */

          Utf8DecodeWorker.prototype.processChunk = function (chunk) {
            var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data); // 1st step, re-use what's left of the previous chunk

            if (this.leftOver && this.leftOver.length) {
              if (support.uint8array) {
                var previousData = data;
                data = new Uint8Array(previousData.length + this.leftOver.length);
                data.set(this.leftOver, 0);
                data.set(previousData, this.leftOver.length);
              } else {
                data = this.leftOver.concat(data);
              }

              this.leftOver = null;
            }

            var nextBoundary = utf8border(data);
            var usableData = data;

            if (nextBoundary !== data.length) {
              if (support.uint8array) {
                usableData = data.subarray(0, nextBoundary);
                this.leftOver = data.subarray(nextBoundary, data.length);
              } else {
                usableData = data.slice(0, nextBoundary);
                this.leftOver = data.slice(nextBoundary, data.length);
              }
            }

            this.push({
              data: exports.utf8decode(usableData),
              meta: chunk.meta
            });
          };
          /**
           * @see GenericWorker.flush
           */


          Utf8DecodeWorker.prototype.flush = function () {
            if (this.leftOver && this.leftOver.length) {
              this.push({
                data: exports.utf8decode(this.leftOver),
                meta: {}
              });
              this.leftOver = null;
            }
          };

          exports.Utf8DecodeWorker = Utf8DecodeWorker;
          /**
           * A worker to endcode string chunks into utf8 encoded binary chunks.
           * @constructor
           */

          function Utf8EncodeWorker() {
            GenericWorker.call(this, "utf-8 encode");
          }

          utils.inherits(Utf8EncodeWorker, GenericWorker);
          /**
           * @see GenericWorker.processChunk
           */

          Utf8EncodeWorker.prototype.processChunk = function (chunk) {
            this.push({
              data: exports.utf8encode(chunk.data),
              meta: chunk.meta
            });
          };

          exports.Utf8EncodeWorker = Utf8EncodeWorker;
        }, {
          "./nodejsUtils": 14,
          "./stream/GenericWorker": 28,
          "./support": 30,
          "./utils": 32
        }],
        32: [function (require, module, exports) {
          'use strict';

          var support = require('./support');

          var base64 = require('./base64');

          var nodejsUtils = require('./nodejsUtils');

          var setImmediate = require('set-immediate-shim');

          var external = require("./external");
          /**
           * Convert a string that pass as a "binary string": it should represent a byte
           * array but may have > 255 char codes. Be sure to take only the first byte
           * and returns the byte array.
           * @param {String} str the string to transform.
           * @return {Array|Uint8Array} the string in a binary format.
           */


          function string2binary(str) {
            var result = null;

            if (support.uint8array) {
              result = new Uint8Array(str.length);
            } else {
              result = new Array(str.length);
            }

            return stringToArrayLike(str, result);
          }
          /**
           * Create a new blob with the given content and the given type.
           * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
           * an Uint8Array because the stock browser of android 4 won't accept it (it
           * will be silently converted to a string, "[object Uint8Array]").
           *
           * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
           * when a large amount of Array is used to create the Blob, the amount of
           * memory consumed is nearly 100 times the original data amount.
           *
           * @param {String} type the mime type of the blob.
           * @return {Blob} the created blob.
           */


          exports.newBlob = function (part, type) {
            exports.checkSupport("blob");

            try {
              // Blob constructor
              return new Blob([part], {
                type: type
              });
            } catch (e) {
              try {
                // deprecated, browser only, old way
                var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
                var builder = new Builder();
                builder.append(part);
                return builder.getBlob(type);
              } catch (e) {
                // well, fuck ?!
                throw new Error("Bug : can't construct the Blob.");
              }
            }
          };
          /**
           * The identity function.
           * @param {Object} input the input.
           * @return {Object} the same input.
           */


          function identity(input) {
            return input;
          }
          /**
           * Fill in an array with a string.
           * @param {String} str the string to use.
           * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
           * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
           */


          function stringToArrayLike(str, array) {
            for (var i = 0; i < str.length; ++i) {
              array[i] = str.charCodeAt(i) & 0xFF;
            }

            return array;
          }
          /**
           * An helper for the function arrayLikeToString.
           * This contains static informations and functions that
           * can be optimized by the browser JIT compiler.
           */


          var arrayToStringHelper = {
            /**
             * Transform an array of int into a string, chunk by chunk.
             * See the performances notes on arrayLikeToString.
             * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
             * @param {String} type the type of the array.
             * @param {Integer} chunk the chunk size.
             * @return {String} the resulting string.
             * @throws Error if the chunk is too big for the stack.
             */
            stringifyByChunk: function stringifyByChunk(array, type, chunk) {
              var result = [],
                  k = 0,
                  len = array.length; // shortcut

              if (len <= chunk) {
                return String.fromCharCode.apply(null, array);
              }

              while (k < len) {
                if (type === "array" || type === "nodebuffer") {
                  result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
                } else {
                  result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
                }

                k += chunk;
              }

              return result.join("");
            },

            /**
             * Call String.fromCharCode on every item in the array.
             * This is the naive implementation, which generate A LOT of intermediate string.
             * This should be used when everything else fail.
             * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
             * @return {String} the result.
             */
            stringifyByChar: function stringifyByChar(array) {
              var resultStr = "";

              for (var i = 0; i < array.length; i++) {
                resultStr += String.fromCharCode(array[i]);
              }

              return resultStr;
            },
            applyCanBeUsed: {
              /**
               * true if the browser accepts to use String.fromCharCode on Uint8Array
               */
              uint8array: function () {
                try {
                  return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
                } catch (e) {
                  return false;
                }
              }(),

              /**
               * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
               */
              nodebuffer: function () {
                try {
                  return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
                } catch (e) {
                  return false;
                }
              }()
            }
          };
          /**
           * Transform an array-like object to a string.
           * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
           * @return {String} the result.
           */

          function arrayLikeToString(array) {
            // Performances notes :
            // --------------------
            // String.fromCharCode.apply(null, array) is the fastest, see
            // see http://jsperf.com/converting-a-uint8array-to-a-string/2
            // but the stack is limited (and we can get huge arrays !).
            //
            // result += String.fromCharCode(array[i]); generate too many strings !
            //
            // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
            // TODO : we now have workers that split the work. Do we still need that ?
            var chunk = 65536,
                type = exports.getTypeOf(array),
                canUseApply = true;

            if (type === "uint8array") {
              canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
            } else if (type === "nodebuffer") {
              canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
            }

            if (canUseApply) {
              while (chunk > 1) {
                try {
                  return arrayToStringHelper.stringifyByChunk(array, type, chunk);
                } catch (e) {
                  chunk = Math.floor(chunk / 2);
                }
              }
            } // no apply or chunk error : slow and painful algorithm
            // default browser on android 4.*


            return arrayToStringHelper.stringifyByChar(array);
          }

          exports.applyFromCharCode = arrayLikeToString;
          /**
           * Copy the data from an array-like to an other array-like.
           * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
           * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
           * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
           */

          function arrayLikeToArrayLike(arrayFrom, arrayTo) {
            for (var i = 0; i < arrayFrom.length; i++) {
              arrayTo[i] = arrayFrom[i];
            }

            return arrayTo;
          } // a matrix containing functions to transform everything into everything.


          var transform = {}; // string to ?

          transform["string"] = {
            "string": identity,
            "array": function array(input) {
              return stringToArrayLike(input, new Array(input.length));
            },
            "arraybuffer": function arraybuffer(input) {
              return transform["string"]["uint8array"](input).buffer;
            },
            "uint8array": function uint8array(input) {
              return stringToArrayLike(input, new Uint8Array(input.length));
            },
            "nodebuffer": function nodebuffer(input) {
              return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
            }
          }; // array to ?

          transform["array"] = {
            "string": arrayLikeToString,
            "array": identity,
            "arraybuffer": function arraybuffer(input) {
              return new Uint8Array(input).buffer;
            },
            "uint8array": function uint8array(input) {
              return new Uint8Array(input);
            },
            "nodebuffer": function nodebuffer(input) {
              return nodejsUtils.newBufferFrom(input);
            }
          }; // arraybuffer to ?

          transform["arraybuffer"] = {
            "string": function string(input) {
              return arrayLikeToString(new Uint8Array(input));
            },
            "array": function array(input) {
              return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
            },
            "arraybuffer": identity,
            "uint8array": function uint8array(input) {
              return new Uint8Array(input);
            },
            "nodebuffer": function nodebuffer(input) {
              return nodejsUtils.newBufferFrom(new Uint8Array(input));
            }
          }; // uint8array to ?

          transform["uint8array"] = {
            "string": arrayLikeToString,
            "array": function array(input) {
              return arrayLikeToArrayLike(input, new Array(input.length));
            },
            "arraybuffer": function arraybuffer(input) {
              return input.buffer;
            },
            "uint8array": identity,
            "nodebuffer": function nodebuffer(input) {
              return nodejsUtils.newBufferFrom(input);
            }
          }; // nodebuffer to ?

          transform["nodebuffer"] = {
            "string": arrayLikeToString,
            "array": function array(input) {
              return arrayLikeToArrayLike(input, new Array(input.length));
            },
            "arraybuffer": function arraybuffer(input) {
              return transform["nodebuffer"]["uint8array"](input).buffer;
            },
            "uint8array": function uint8array(input) {
              return arrayLikeToArrayLike(input, new Uint8Array(input.length));
            },
            "nodebuffer": identity
          };
          /**
           * Transform an input into any type.
           * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
           * If no output type is specified, the unmodified input will be returned.
           * @param {String} outputType the output type.
           * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
           * @throws {Error} an Error if the browser doesn't support the requested output type.
           */

          exports.transformTo = function (outputType, input) {
            if (!input) {
              // undefined, null, etc
              // an empty string won't harm.
              input = "";
            }

            if (!outputType) {
              return input;
            }

            exports.checkSupport(outputType);
            var inputType = exports.getTypeOf(input);
            var result = transform[inputType][outputType](input);
            return result;
          };
          /**
           * Return the type of the input.
           * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
           * @param {Object} input the input to identify.
           * @return {String} the (lowercase) type of the input.
           */


          exports.getTypeOf = function (input) {
            if (typeof input === "string") {
              return "string";
            }

            if (Object.prototype.toString.call(input) === "[object Array]") {
              return "array";
            }

            if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
              return "nodebuffer";
            }

            if (support.uint8array && input instanceof Uint8Array) {
              return "uint8array";
            }

            if (support.arraybuffer && input instanceof ArrayBuffer) {
              return "arraybuffer";
            }
          };
          /**
           * Throw an exception if the type is not supported.
           * @param {String} type the type to check.
           * @throws {Error} an Error if the browser doesn't support the requested type.
           */


          exports.checkSupport = function (type) {
            var supported = support[type.toLowerCase()];

            if (!supported) {
              throw new Error(type + " is not supported by this platform");
            }
          };

          exports.MAX_VALUE_16BITS = 65535;
          exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

          /**
           * Prettify a string read as binary.
           * @param {string} str the string to prettify.
           * @return {string} a pretty string.
           */

          exports.pretty = function (str) {
            var res = '',
                code,
                i;

            for (i = 0; i < (str || "").length; i++) {
              code = str.charCodeAt(i);
              res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
            }

            return res;
          };
          /**
           * Defer the call of a function.
           * @param {Function} callback the function to call asynchronously.
           * @param {Array} args the arguments to give to the callback.
           */


          exports.delay = function (callback, args, self) {
            setImmediate(function () {
              callback.apply(self || null, args || []);
            });
          };
          /**
           * Extends a prototype with an other, without calling a constructor with
           * side effects. Inspired by nodejs' `utils.inherits`
           * @param {Function} ctor the constructor to augment
           * @param {Function} superCtor the parent constructor to use
           */


          exports.inherits = function (ctor, superCtor) {
            var Obj = function Obj() {};

            Obj.prototype = superCtor.prototype;
            ctor.prototype = new Obj();
          };
          /**
           * Merge the objects passed as parameters into a new one.
           * @private
           * @param {...Object} var_args All objects to merge.
           * @return {Object} a new object with the data of the others.
           */


          exports.extend = function () {
            var result = {},
                i,
                attr;

            for (i = 0; i < arguments.length; i++) {
              // arguments is not enumerable in some browsers
              for (attr in arguments[i]) {
                if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                  result[attr] = arguments[i][attr];
                }
              }
            }

            return result;
          };
          /**
           * Transform arbitrary content into a Promise.
           * @param {String} name a name for the content being processed.
           * @param {Object} inputData the content to process.
           * @param {Boolean} isBinary true if the content is not an unicode string
           * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
           * @param {Boolean} isBase64 true if the string content is encoded with base64.
           * @return {Promise} a promise in a format usable by JSZip.
           */


          exports.prepareContent = function (name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
            // if inputData is already a promise, this flatten it.
            var promise = external.Promise.resolve(inputData).then(function (data) {
              var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

              if (isBlob && typeof FileReader !== "undefined") {
                return new external.Promise(function (resolve, reject) {
                  var reader = new FileReader();

                  reader.onload = function (e) {
                    resolve(e.target.result);
                  };

                  reader.onerror = function (e) {
                    reject(e.target.error);
                  };

                  reader.readAsArrayBuffer(data);
                });
              } else {
                return data;
              }
            });
            return promise.then(function (data) {
              var dataType = exports.getTypeOf(data);

              if (!dataType) {
                return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it " + "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
              } // special case : it's way easier to work with Uint8Array than with ArrayBuffer


              if (dataType === "arraybuffer") {
                data = exports.transformTo("uint8array", data);
              } else if (dataType === "string") {
                if (isBase64) {
                  data = base64.decode(data);
                } else if (isBinary) {
                  // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                  if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                  }
                }
              }

              return data;
            });
          };
        }, {
          "./base64": 1,
          "./external": 6,
          "./nodejsUtils": 14,
          "./support": 30,
          "set-immediate-shim": 54
        }],
        33: [function (require, module, exports) {
          'use strict';

          var readerFor = require('./reader/readerFor');

          var utils = require('./utils');

          var sig = require('./signature');

          var ZipEntry = require('./zipEntry');

          var utf8 = require('./utf8');

          var support = require('./support'); //  class ZipEntries {{{

          /**
           * All the entries in the zip file.
           * @constructor
           * @param {Object} loadOptions Options for loading the stream.
           */


          function ZipEntries(loadOptions) {
            this.files = [];
            this.loadOptions = loadOptions;
          }

          ZipEntries.prototype = {
            /**
             * Check that the reader is on the specified signature.
             * @param {string} expectedSignature the expected signature.
             * @throws {Error} if it is an other signature.
             */
            checkSignature: function checkSignature(expectedSignature) {
              if (!this.reader.readAndCheckSignature(expectedSignature)) {
                this.reader.index -= 4;
                var signature = this.reader.readString(4);
                throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
              }
            },

            /**
             * Check if the given signature is at the given index.
             * @param {number} askedIndex the index to check.
             * @param {string} expectedSignature the signature to expect.
             * @return {boolean} true if the signature is here, false otherwise.
             */
            isSignature: function isSignature(askedIndex, expectedSignature) {
              var currentIndex = this.reader.index;
              this.reader.setIndex(askedIndex);
              var signature = this.reader.readString(4);
              var result = signature === expectedSignature;
              this.reader.setIndex(currentIndex);
              return result;
            },

            /**
             * Read the end of the central directory.
             */
            readBlockEndOfCentral: function readBlockEndOfCentral() {
              this.diskNumber = this.reader.readInt(2);
              this.diskWithCentralDirStart = this.reader.readInt(2);
              this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
              this.centralDirRecords = this.reader.readInt(2);
              this.centralDirSize = this.reader.readInt(4);
              this.centralDirOffset = this.reader.readInt(4);
              this.zipCommentLength = this.reader.readInt(2); // warning : the encoding depends of the system locale
              // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
              // On a windows machine, this field is encoded with the localized windows code page.

              var zipComment = this.reader.readData(this.zipCommentLength);
              var decodeParamType = support.uint8array ? "uint8array" : "array"; // To get consistent behavior with the generation part, we will assume that
              // this is utf8 encoded unless specified otherwise.

              var decodeContent = utils.transformTo(decodeParamType, zipComment);
              this.zipComment = this.loadOptions.decodeFileName(decodeContent);
            },

            /**
             * Read the end of the Zip 64 central directory.
             * Not merged with the method readEndOfCentral :
             * The end of central can coexist with its Zip64 brother,
             * I don't want to read the wrong number of bytes !
             */
            readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
              this.zip64EndOfCentralSize = this.reader.readInt(8);
              this.reader.skip(4); // this.versionMadeBy = this.reader.readString(2);
              // this.versionNeeded = this.reader.readInt(2);

              this.diskNumber = this.reader.readInt(4);
              this.diskWithCentralDirStart = this.reader.readInt(4);
              this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
              this.centralDirRecords = this.reader.readInt(8);
              this.centralDirSize = this.reader.readInt(8);
              this.centralDirOffset = this.reader.readInt(8);
              this.zip64ExtensibleData = {};
              var extraDataSize = this.zip64EndOfCentralSize - 44,
                  index = 0,
                  extraFieldId,
                  extraFieldLength,
                  extraFieldValue;

              while (index < extraDataSize) {
                extraFieldId = this.reader.readInt(2);
                extraFieldLength = this.reader.readInt(4);
                extraFieldValue = this.reader.readData(extraFieldLength);
                this.zip64ExtensibleData[extraFieldId] = {
                  id: extraFieldId,
                  length: extraFieldLength,
                  value: extraFieldValue
                };
              }
            },

            /**
             * Read the end of the Zip 64 central directory locator.
             */
            readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
              this.diskWithZip64CentralDirStart = this.reader.readInt(4);
              this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
              this.disksCount = this.reader.readInt(4);

              if (this.disksCount > 1) {
                throw new Error("Multi-volumes zip are not supported");
              }
            },

            /**
             * Read the local files, based on the offset read in the central part.
             */
            readLocalFiles: function readLocalFiles() {
              var i, file;

              for (i = 0; i < this.files.length; i++) {
                file = this.files[i];
                this.reader.setIndex(file.localHeaderOffset);
                this.checkSignature(sig.LOCAL_FILE_HEADER);
                file.readLocalPart(this.reader);
                file.handleUTF8();
                file.processAttributes();
              }
            },

            /**
             * Read the central directory.
             */
            readCentralDir: function readCentralDir() {
              var file;
              this.reader.setIndex(this.centralDirOffset);

              while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
                file = new ZipEntry({
                  zip64: this.zip64
                }, this.loadOptions);
                file.readCentralPart(this.reader);
                this.files.push(file);
              }

              if (this.centralDirRecords !== this.files.length) {
                if (this.centralDirRecords !== 0 && this.files.length === 0) {
                  // We expected some records but couldn't find ANY.
                  // This is really suspicious, as if something went wrong.
                  throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                } else {// We found some records but not all.
                  // Something is wrong but we got something for the user: no error here.
                  // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
                }
              }
            },

            /**
             * Read the end of central directory.
             */
            readEndOfCentral: function readEndOfCentral() {
              var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);

              if (offset < 0) {
                // Check if the content is a truncated zip or complete garbage.
                // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
                // extractible zip for example) but it can give a good hint.
                // If an ajax request was used without responseType, we will also
                // get unreadable data.
                var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

                if (isGarbage) {
                  throw new Error("Can't find end of central directory : is this a zip file ? " + "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                } else {
                  throw new Error("Corrupted zip: can't find end of central directory");
                }
              }

              this.reader.setIndex(offset);
              var endOfCentralDirOffset = offset;
              this.checkSignature(sig.CENTRAL_DIRECTORY_END);
              this.readBlockEndOfCentral();
              /* extract from the zip spec :
                  4)  If one of the fields in the end of central directory
                      record is too small to hold required data, the field
                      should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                      ZIP64 format record should be created.
                  5)  The end of central directory record and the
                      Zip64 end of central directory locator record must
                      reside on the same disk when splitting or spanning
                      an archive.
               */

              if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
                this.zip64 = true;
                /*
                Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
                the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
                all numbers as 64-bit double precision IEEE 754 floating point numbers.
                So, we have 53bits for integers and bitwise operations treat everything as 32bits.
                see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
                and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
                */
                // should look for a zip64 EOCD locator

                offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);

                if (offset < 0) {
                  throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                }

                this.reader.setIndex(offset);
                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
                this.readBlockZip64EndOfCentralLocator(); // now the zip64 EOCD record

                if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                  // console.warn("ZIP64 end of central directory not where expected.");
                  this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);

                  if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                  }
                }

                this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
                this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                this.readBlockZip64EndOfCentral();
              }

              var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;

              if (this.zip64) {
                expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator

                expectedEndOfCentralDirOffset += 12
                /* should not include the leading 12 bytes */
                + this.zip64EndOfCentralSize;
              }

              var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

              if (extraBytes > 0) {
                // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
                if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {// The offsets seem wrong, but we have something at the specified offset.
                  // So… we keep it.
                } else {
                  // the offset is wrong, update the "zero" of the reader
                  // this happens if data has been prepended (crx files for example)
                  this.reader.zero = extraBytes;
                }
              } else if (extraBytes < 0) {
                throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
              }
            },
            prepareReader: function prepareReader(data) {
              this.reader = readerFor(data);
            },

            /**
             * Read a zip file and create ZipEntries.
             * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
             */
            load: function load(data) {
              this.prepareReader(data);
              this.readEndOfCentral();
              this.readCentralDir();
              this.readLocalFiles();
            }
          }; // }}} end of ZipEntries

          module.exports = ZipEntries;
        }, {
          "./reader/readerFor": 22,
          "./signature": 23,
          "./support": 30,
          "./utf8": 31,
          "./utils": 32,
          "./zipEntry": 34
        }],
        34: [function (require, module, exports) {
          'use strict';

          var readerFor = require('./reader/readerFor');

          var utils = require('./utils');

          var CompressedObject = require('./compressedObject');

          var crc32fn = require('./crc32');

          var utf8 = require('./utf8');

          var compressions = require('./compressions');

          var support = require('./support');

          var MADE_BY_DOS = 0x00;
          var MADE_BY_UNIX = 0x03;
          /**
           * Find a compression registered in JSZip.
           * @param {string} compressionMethod the method magic to find.
           * @return {Object|null} the JSZip compression object, null if none found.
           */

          var findCompression = function findCompression(compressionMethod) {
            for (var method in compressions) {
              if (!compressions.hasOwnProperty(method)) {
                continue;
              }

              if (compressions[method].magic === compressionMethod) {
                return compressions[method];
              }
            }

            return null;
          }; // class ZipEntry {{{

          /**
           * An entry in the zip file.
           * @constructor
           * @param {Object} options Options of the current file.
           * @param {Object} loadOptions Options for loading the stream.
           */


          function ZipEntry(options, loadOptions) {
            this.options = options;
            this.loadOptions = loadOptions;
          }

          ZipEntry.prototype = {
            /**
             * say if the file is encrypted.
             * @return {boolean} true if the file is encrypted, false otherwise.
             */
            isEncrypted: function isEncrypted() {
              // bit 1 is set
              return (this.bitFlag & 0x0001) === 0x0001;
            },

            /**
             * say if the file has utf-8 filename/comment.
             * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
             */
            useUTF8: function useUTF8() {
              // bit 11 is set
              return (this.bitFlag & 0x0800) === 0x0800;
            },

            /**
             * Read the local part of a zip file and add the info in this object.
             * @param {DataReader} reader the reader to use.
             */
            readLocalPart: function readLocalPart(reader) {
              var compression, localExtraFieldsLength; // we already know everything from the central dir !
              // If the central dir data are false, we are doomed.
              // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
              // The less data we get here, the more reliable this should be.
              // Let's skip the whole header and dash to the data !

              reader.skip(22); // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
              // Strangely, the filename here is OK.
              // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
              // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
              // Search "unzip mismatching "local" filename continuing with "central" filename version" on
              // the internet.
              //
              // I think I see the logic here : the central directory is used to display
              // content and the local directory is used to extract the files. Mixing / and \
              // may be used to display \ to windows users and use / when extracting the files.
              // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394

              this.fileNameLength = reader.readInt(2);
              localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
              // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.

              this.fileName = reader.readData(this.fileNameLength);
              reader.skip(localExtraFieldsLength);

              if (this.compressedSize === -1 || this.uncompressedSize === -1) {
                throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
              }

              compression = findCompression(this.compressionMethod);

              if (compression === null) {
                // no compression found
                throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
              }

              this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
            },

            /**
             * Read the central part of a zip file and add the info in this object.
             * @param {DataReader} reader the reader to use.
             */
            readCentralPart: function readCentralPart(reader) {
              this.versionMadeBy = reader.readInt(2);
              reader.skip(2); // this.versionNeeded = reader.readInt(2);

              this.bitFlag = reader.readInt(2);
              this.compressionMethod = reader.readString(2);
              this.date = reader.readDate();
              this.crc32 = reader.readInt(4);
              this.compressedSize = reader.readInt(4);
              this.uncompressedSize = reader.readInt(4);
              var fileNameLength = reader.readInt(2);
              this.extraFieldsLength = reader.readInt(2);
              this.fileCommentLength = reader.readInt(2);
              this.diskNumberStart = reader.readInt(2);
              this.internalFileAttributes = reader.readInt(2);
              this.externalFileAttributes = reader.readInt(4);
              this.localHeaderOffset = reader.readInt(4);

              if (this.isEncrypted()) {
                throw new Error("Encrypted zip are not supported");
              } // will be read in the local part, see the comments there


              reader.skip(fileNameLength);
              this.readExtraFields(reader);
              this.parseZIP64ExtraField(reader);
              this.fileComment = reader.readData(this.fileCommentLength);
            },

            /**
             * Parse the external file attributes and get the unix/dos permissions.
             */
            processAttributes: function processAttributes() {
              this.unixPermissions = null;
              this.dosPermissions = null;
              var madeBy = this.versionMadeBy >> 8; // Check if we have the DOS directory flag set.
              // We look for it in the DOS and UNIX permissions
              // but some unknown platform could set it as a compatibility flag.

              this.dir = this.externalFileAttributes & 0x0010 ? true : false;

              if (madeBy === MADE_BY_DOS) {
                // first 6 bits (0 to 5)
                this.dosPermissions = this.externalFileAttributes & 0x3F;
              }

              if (madeBy === MADE_BY_UNIX) {
                this.unixPermissions = this.externalFileAttributes >> 16 & 0xFFFF; // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
              } // fail safe : if the name ends with a / it probably means a folder


              if (!this.dir && this.fileNameStr.slice(-1) === '/') {
                this.dir = true;
              }
            },

            /**
             * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
             * @param {DataReader} reader the reader to use.
             */
            parseZIP64ExtraField: function parseZIP64ExtraField(reader) {
              if (!this.extraFields[0x0001]) {
                return;
              } // should be something, preparing the extra reader


              var extraReader = readerFor(this.extraFields[0x0001].value); // I really hope that these 64bits integer can fit in 32 bits integer, because js
              // won't let us have more.

              if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
                this.uncompressedSize = extraReader.readInt(8);
              }

              if (this.compressedSize === utils.MAX_VALUE_32BITS) {
                this.compressedSize = extraReader.readInt(8);
              }

              if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
                this.localHeaderOffset = extraReader.readInt(8);
              }

              if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
                this.diskNumberStart = extraReader.readInt(4);
              }
            },

            /**
             * Read the central part of a zip file and add the info in this object.
             * @param {DataReader} reader the reader to use.
             */
            readExtraFields: function readExtraFields(reader) {
              var end = reader.index + this.extraFieldsLength,
                  extraFieldId,
                  extraFieldLength,
                  extraFieldValue;

              if (!this.extraFields) {
                this.extraFields = {};
              }

              while (reader.index < end) {
                extraFieldId = reader.readInt(2);
                extraFieldLength = reader.readInt(2);
                extraFieldValue = reader.readData(extraFieldLength);
                this.extraFields[extraFieldId] = {
                  id: extraFieldId,
                  length: extraFieldLength,
                  value: extraFieldValue
                };
              }
            },

            /**
             * Apply an UTF8 transformation if needed.
             */
            handleUTF8: function handleUTF8() {
              var decodeParamType = support.uint8array ? "uint8array" : "array";

              if (this.useUTF8()) {
                this.fileNameStr = utf8.utf8decode(this.fileName);
                this.fileCommentStr = utf8.utf8decode(this.fileComment);
              } else {
                var upath = this.findExtraFieldUnicodePath();

                if (upath !== null) {
                  this.fileNameStr = upath;
                } else {
                  // ASCII text or unsupported code page
                  var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                  this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
                }

                var ucomment = this.findExtraFieldUnicodeComment();

                if (ucomment !== null) {
                  this.fileCommentStr = ucomment;
                } else {
                  // ASCII text or unsupported code page
                  var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                  this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
                }
              }
            },

            /**
             * Find the unicode path declared in the extra field, if any.
             * @return {String} the unicode path, null otherwise.
             */
            findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
              var upathField = this.extraFields[0x7075];

              if (upathField) {
                var extraReader = readerFor(upathField.value); // wrong version

                if (extraReader.readInt(1) !== 1) {
                  return null;
                } // the crc of the filename changed, this field is out of date.


                if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                  return null;
                }

                return utf8.utf8decode(extraReader.readData(upathField.length - 5));
              }

              return null;
            },

            /**
             * Find the unicode comment declared in the extra field, if any.
             * @return {String} the unicode comment, null otherwise.
             */
            findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
              var ucommentField = this.extraFields[0x6375];

              if (ucommentField) {
                var extraReader = readerFor(ucommentField.value); // wrong version

                if (extraReader.readInt(1) !== 1) {
                  return null;
                } // the crc of the comment changed, this field is out of date.


                if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                  return null;
                }

                return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
              }

              return null;
            }
          };
          module.exports = ZipEntry;
        }, {
          "./compressedObject": 2,
          "./compressions": 3,
          "./crc32": 4,
          "./reader/readerFor": 22,
          "./support": 30,
          "./utf8": 31,
          "./utils": 32
        }],
        35: [function (require, module, exports) {
          'use strict';

          var StreamHelper = require('./stream/StreamHelper');

          var DataWorker = require('./stream/DataWorker');

          var utf8 = require('./utf8');

          var CompressedObject = require('./compressedObject');

          var GenericWorker = require('./stream/GenericWorker');
          /**
           * A simple object representing a file in the zip file.
           * @constructor
           * @param {string} name the name of the file
           * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
           * @param {Object} options the options of the file
           */


          var ZipObject = function ZipObject(name, data, options) {
            this.name = name;
            this.dir = options.dir;
            this.date = options.date;
            this.comment = options.comment;
            this.unixPermissions = options.unixPermissions;
            this.dosPermissions = options.dosPermissions;
            this._data = data;
            this._dataBinary = options.binary; // keep only the compression

            this.options = {
              compression: options.compression,
              compressionOptions: options.compressionOptions
            };
          };

          ZipObject.prototype = {
            /**
             * Create an internal stream for the content of this object.
             * @param {String} type the type of each chunk.
             * @return StreamHelper the stream.
             */
            internalStream: function internalStream(type) {
              var result = null,
                  outputType = "string";

              try {
                if (!type) {
                  throw new Error("No output type specified.");
                }

                outputType = type.toLowerCase();
                var askUnicodeString = outputType === "string" || outputType === "text";

                if (outputType === "binarystring" || outputType === "text") {
                  outputType = "string";
                }

                result = this._decompressWorker();
                var isUnicodeString = !this._dataBinary;

                if (isUnicodeString && !askUnicodeString) {
                  result = result.pipe(new utf8.Utf8EncodeWorker());
                }

                if (!isUnicodeString && askUnicodeString) {
                  result = result.pipe(new utf8.Utf8DecodeWorker());
                }
              } catch (e) {
                result = new GenericWorker("error");
                result.error(e);
              }

              return new StreamHelper(result, outputType, "");
            },

            /**
             * Prepare the content in the asked type.
             * @param {String} type the type of the result.
             * @param {Function} onUpdate a function to call on each internal update.
             * @return Promise the promise of the result.
             */
            async: function async(type, onUpdate) {
              return this.internalStream(type).accumulate(onUpdate);
            },

            /**
             * Prepare the content as a nodejs stream.
             * @param {String} type the type of each chunk.
             * @param {Function} onUpdate a function to call on each internal update.
             * @return Stream the stream.
             */
            nodeStream: function nodeStream(type, onUpdate) {
              return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
            },

            /**
             * Return a worker for the compressed content.
             * @private
             * @param {Object} compression the compression object to use.
             * @param {Object} compressionOptions the options to use when compressing.
             * @return Worker the worker.
             */
            _compressWorker: function _compressWorker(compression, compressionOptions) {
              if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
                return this._data.getCompressedWorker();
              } else {
                var result = this._decompressWorker();

                if (!this._dataBinary) {
                  result = result.pipe(new utf8.Utf8EncodeWorker());
                }

                return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
              }
            },

            /**
             * Return a worker for the decompressed content.
             * @private
             * @return Worker the worker.
             */
            _decompressWorker: function _decompressWorker() {
              if (this._data instanceof CompressedObject) {
                return this._data.getContentWorker();
              } else if (this._data instanceof GenericWorker) {
                return this._data;
              } else {
                return new DataWorker(this._data);
              }
            }
          };
          var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];

          var removedFn = function removedFn() {
            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
          };

          for (var i = 0; i < removedMethods.length; i++) {
            ZipObject.prototype[removedMethods[i]] = removedFn;
          }

          module.exports = ZipObject;
        }, {
          "./compressedObject": 2,
          "./stream/DataWorker": 27,
          "./stream/GenericWorker": 28,
          "./stream/StreamHelper": 29,
          "./utf8": 31
        }],
        36: [function (require, module, exports) {
          (function (global) {
            'use strict';

            var Mutation = global.MutationObserver || global.WebKitMutationObserver;
            var scheduleDrain;
            {
              if (Mutation) {
                var called = 0;
                var observer = new Mutation(nextTick);
                var element = global.document.createTextNode('');
                observer.observe(element, {
                  characterData: true
                });

                scheduleDrain = function scheduleDrain() {
                  element.data = called = ++called % 2;
                };
              } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
                var channel = new global.MessageChannel();
                channel.port1.onmessage = nextTick;

                scheduleDrain = function scheduleDrain() {
                  channel.port2.postMessage(0);
                };
              } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
                scheduleDrain = function scheduleDrain() {
                  // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                  // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                  var scriptEl = global.document.createElement('script');

                  scriptEl.onreadystatechange = function () {
                    nextTick();
                    scriptEl.onreadystatechange = null;
                    scriptEl.parentNode.removeChild(scriptEl);
                    scriptEl = null;
                  };

                  global.document.documentElement.appendChild(scriptEl);
                };
              } else {
                scheduleDrain = function scheduleDrain() {
                  setTimeout(nextTick, 0);
                };
              }
            }
            var draining;
            var queue = []; //named nextTick for less confusing stack traces

            function nextTick() {
              draining = true;
              var i, oldQueue;
              var len = queue.length;

              while (len) {
                oldQueue = queue;
                queue = [];
                i = -1;

                while (++i < len) {
                  oldQueue[i]();
                }

                len = queue.length;
              }

              draining = false;
            }

            module.exports = immediate;

            function immediate(task) {
              if (queue.push(task) === 1 && !draining) {
                scheduleDrain();
              }
            }
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}],
        37: [function (require, module, exports) {
          'use strict';

          var immediate = require('immediate');
          /* istanbul ignore next */


          function INTERNAL() {}

          var handlers = {};
          var REJECTED = ['REJECTED'];
          var FULFILLED = ['FULFILLED'];
          var PENDING = ['PENDING'];
          module.exports = Promise;

          function Promise(resolver) {
            if (typeof resolver !== 'function') {
              throw new TypeError('resolver must be a function');
            }

            this.state = PENDING;
            this.queue = [];
            this.outcome = void 0;

            if (resolver !== INTERNAL) {
              safelyResolveThenable(this, resolver);
            }
          }

          Promise.prototype["finally"] = function (callback) {
            if (typeof callback !== 'function') {
              return this;
            }

            var p = this.constructor;
            return this.then(resolve, reject);

            function resolve(value) {
              function yes() {
                return value;
              }

              return p.resolve(callback()).then(yes);
            }

            function reject(reason) {
              function no() {
                throw reason;
              }

              return p.resolve(callback()).then(no);
            }
          };

          Promise.prototype["catch"] = function (onRejected) {
            return this.then(null, onRejected);
          };

          Promise.prototype.then = function (onFulfilled, onRejected) {
            if (typeof onFulfilled !== 'function' && this.state === FULFILLED || typeof onRejected !== 'function' && this.state === REJECTED) {
              return this;
            }

            var promise = new this.constructor(INTERNAL);

            if (this.state !== PENDING) {
              var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
              unwrap(promise, resolver, this.outcome);
            } else {
              this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
            }

            return promise;
          };

          function QueueItem(promise, onFulfilled, onRejected) {
            this.promise = promise;

            if (typeof onFulfilled === 'function') {
              this.onFulfilled = onFulfilled;
              this.callFulfilled = this.otherCallFulfilled;
            }

            if (typeof onRejected === 'function') {
              this.onRejected = onRejected;
              this.callRejected = this.otherCallRejected;
            }
          }

          QueueItem.prototype.callFulfilled = function (value) {
            handlers.resolve(this.promise, value);
          };

          QueueItem.prototype.otherCallFulfilled = function (value) {
            unwrap(this.promise, this.onFulfilled, value);
          };

          QueueItem.prototype.callRejected = function (value) {
            handlers.reject(this.promise, value);
          };

          QueueItem.prototype.otherCallRejected = function (value) {
            unwrap(this.promise, this.onRejected, value);
          };

          function unwrap(promise, func, value) {
            immediate(function () {
              var returnValue;

              try {
                returnValue = func(value);
              } catch (e) {
                return handlers.reject(promise, e);
              }

              if (returnValue === promise) {
                handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
              } else {
                handlers.resolve(promise, returnValue);
              }
            });
          }

          handlers.resolve = function (self, value) {
            var result = tryCatch(getThen, value);

            if (result.status === 'error') {
              return handlers.reject(self, result.value);
            }

            var thenable = result.value;

            if (thenable) {
              safelyResolveThenable(self, thenable);
            } else {
              self.state = FULFILLED;
              self.outcome = value;
              var i = -1;
              var len = self.queue.length;

              while (++i < len) {
                self.queue[i].callFulfilled(value);
              }
            }

            return self;
          };

          handlers.reject = function (self, error) {
            self.state = REJECTED;
            self.outcome = error;
            var i = -1;
            var len = self.queue.length;

            while (++i < len) {
              self.queue[i].callRejected(error);
            }

            return self;
          };

          function getThen(obj) {
            // Make sure we only access the accessor once as required by the spec
            var then = obj && obj.then;

            if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
              return function appyThen() {
                then.apply(obj, arguments);
              };
            }
          }

          function safelyResolveThenable(self, thenable) {
            // Either fulfill, reject or reject with error
            var called = false;

            function onError(value) {
              if (called) {
                return;
              }

              called = true;
              handlers.reject(self, value);
            }

            function onSuccess(value) {
              if (called) {
                return;
              }

              called = true;
              handlers.resolve(self, value);
            }

            function tryToUnwrap() {
              thenable(onSuccess, onError);
            }

            var result = tryCatch(tryToUnwrap);

            if (result.status === 'error') {
              onError(result.value);
            }
          }

          function tryCatch(func, value) {
            var out = {};

            try {
              out.value = func(value);
              out.status = 'success';
            } catch (e) {
              out.status = 'error';
              out.value = e;
            }

            return out;
          }

          Promise.resolve = resolve;

          function resolve(value) {
            if (value instanceof this) {
              return value;
            }

            return handlers.resolve(new this(INTERNAL), value);
          }

          Promise.reject = reject;

          function reject(reason) {
            var promise = new this(INTERNAL);
            return handlers.reject(promise, reason);
          }

          Promise.all = all;

          function all(iterable) {
            var self = this;

            if (Object.prototype.toString.call(iterable) !== '[object Array]') {
              return this.reject(new TypeError('must be an array'));
            }

            var len = iterable.length;
            var called = false;

            if (!len) {
              return this.resolve([]);
            }

            var values = new Array(len);
            var resolved = 0;
            var i = -1;
            var promise = new this(INTERNAL);

            while (++i < len) {
              allResolver(iterable[i], i);
            }

            return promise;

            function allResolver(value, i) {
              self.resolve(value).then(resolveFromAll, function (error) {
                if (!called) {
                  called = true;
                  handlers.reject(promise, error);
                }
              });

              function resolveFromAll(outValue) {
                values[i] = outValue;

                if (++resolved === len && !called) {
                  called = true;
                  handlers.resolve(promise, values);
                }
              }
            }
          }

          Promise.race = race;

          function race(iterable) {
            var self = this;

            if (Object.prototype.toString.call(iterable) !== '[object Array]') {
              return this.reject(new TypeError('must be an array'));
            }

            var len = iterable.length;
            var called = false;

            if (!len) {
              return this.resolve([]);
            }

            var i = -1;
            var promise = new this(INTERNAL);

            while (++i < len) {
              resolver(iterable[i]);
            }

            return promise;

            function resolver(value) {
              self.resolve(value).then(function (response) {
                if (!called) {
                  called = true;
                  handlers.resolve(promise, response);
                }
              }, function (error) {
                if (!called) {
                  called = true;
                  handlers.reject(promise, error);
                }
              });
            }
          }
        }, {
          "immediate": 36
        }],
        38: [function (require, module, exports) {
          // Top level file is just a mixin of submodules & constants
          'use strict';

          var assign = require('./lib/utils/common').assign;

          var deflate = require('./lib/deflate');

          var inflate = require('./lib/inflate');

          var constants = require('./lib/zlib/constants');

          var pako = {};
          assign(pako, deflate, inflate, constants);
          module.exports = pako;
        }, {
          "./lib/deflate": 39,
          "./lib/inflate": 40,
          "./lib/utils/common": 41,
          "./lib/zlib/constants": 44
        }],
        39: [function (require, module, exports) {
          'use strict';

          var zlib_deflate = require('./zlib/deflate');

          var utils = require('./utils/common');

          var strings = require('./utils/strings');

          var msg = require('./zlib/messages');

          var ZStream = require('./zlib/zstream');

          var toString = Object.prototype.toString;
          /* Public constants ==========================================================*/

          /* ===========================================================================*/

          var Z_NO_FLUSH = 0;
          var Z_FINISH = 4;
          var Z_OK = 0;
          var Z_STREAM_END = 1;
          var Z_SYNC_FLUSH = 2;
          var Z_DEFAULT_COMPRESSION = -1;
          var Z_DEFAULT_STRATEGY = 0;
          var Z_DEFLATED = 8;
          /* ===========================================================================*/

          /**
           * class Deflate
           *
           * Generic JS-style wrapper for zlib calls. If you don't need
           * streaming behaviour - use more simple functions: [[deflate]],
           * [[deflateRaw]] and [[gzip]].
           **/

          /* internal
           * Deflate.chunks -> Array
           *
           * Chunks of output data, if [[Deflate#onData]] not overriden.
           **/

          /**
           * Deflate.result -> Uint8Array|Array
           *
           * Compressed result, generated by default [[Deflate#onData]]
           * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
           * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
           * push a chunk with explicit flush (call [[Deflate#push]] with
           * `Z_SYNC_FLUSH` param).
           **/

          /**
           * Deflate.err -> Number
           *
           * Error code after deflate finished. 0 (Z_OK) on success.
           * You will not need it in real life, because deflate errors
           * are possible only on wrong options or bad `onData` / `onEnd`
           * custom handlers.
           **/

          /**
           * Deflate.msg -> String
           *
           * Error message, if [[Deflate.err]] != 0
           **/

          /**
           * new Deflate(options)
           * - options (Object): zlib deflate options.
           *
           * Creates new deflator instance with specified params. Throws exception
           * on bad params. Supported options:
           *
           * - `level`
           * - `windowBits`
           * - `memLevel`
           * - `strategy`
           * - `dictionary`
           *
           * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
           * for more information on these.
           *
           * Additional options, for internal needs:
           *
           * - `chunkSize` - size of generated data chunks (16K by default)
           * - `raw` (Boolean) - do raw deflate
           * - `gzip` (Boolean) - create gzip wrapper
           * - `to` (String) - if equal to 'string', then result will be "binary string"
           *    (each char code [0..255])
           * - `header` (Object) - custom header for gzip
           *   - `text` (Boolean) - true if compressed data believed to be text
           *   - `time` (Number) - modification time, unix timestamp
           *   - `os` (Number) - operation system code
           *   - `extra` (Array) - array of bytes with extra data (max 65536)
           *   - `name` (String) - file name (binary string)
           *   - `comment` (String) - comment (binary string)
           *   - `hcrc` (Boolean) - true if header crc should be added
           *
           * ##### Example:
           *
           * ```javascript
           * var pako = require('pako')
           *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
           *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
           *
           * var deflate = new pako.Deflate({ level: 3});
           *
           * deflate.push(chunk1, false);
           * deflate.push(chunk2, true);  // true -> last chunk
           *
           * if (deflate.err) { throw new Error(deflate.err); }
           *
           * console.log(deflate.result);
           * ```
           **/

          function Deflate(options) {
            if (!(this instanceof Deflate)) return new Deflate(options);
            this.options = utils.assign({
              level: Z_DEFAULT_COMPRESSION,
              method: Z_DEFLATED,
              chunkSize: 16384,
              windowBits: 15,
              memLevel: 8,
              strategy: Z_DEFAULT_STRATEGY,
              to: ''
            }, options || {});
            var opt = this.options;

            if (opt.raw && opt.windowBits > 0) {
              opt.windowBits = -opt.windowBits;
            } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
              opt.windowBits += 16;
            }

            this.err = 0; // error code, if happens (0 = Z_OK)

            this.msg = ''; // error message

            this.ended = false; // used to avoid multiple onEnd() calls

            this.chunks = []; // chunks of compressed data

            this.strm = new ZStream();
            this.strm.avail_out = 0;
            var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);

            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }

            if (opt.header) {
              zlib_deflate.deflateSetHeader(this.strm, opt.header);
            }

            if (opt.dictionary) {
              var dict; // Convert data if needed

              if (typeof opt.dictionary === 'string') {
                // If we need to compress text, change encoding to utf8.
                dict = strings.string2buf(opt.dictionary);
              } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
                dict = new Uint8Array(opt.dictionary);
              } else {
                dict = opt.dictionary;
              }

              status = zlib_deflate.deflateSetDictionary(this.strm, dict);

              if (status !== Z_OK) {
                throw new Error(msg[status]);
              }

              this._dict_set = true;
            }
          }
          /**
           * Deflate#push(data[, mode]) -> Boolean
           * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
           *   converted to utf8 byte sequence.
           * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
           *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
           *
           * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
           * new compressed chunks. Returns `true` on success. The last data block must have
           * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
           * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
           * can use mode Z_SYNC_FLUSH, keeping the compression context.
           *
           * On fail call [[Deflate#onEnd]] with error code and return false.
           *
           * We strongly recommend to use `Uint8Array` on input for best speed (output
           * array format is detected automatically). Also, don't skip last param and always
           * use the same type in your code (boolean or number). That will improve JS speed.
           *
           * For regular `Array`-s make sure all elements are [0..255].
           *
           * ##### Example
           *
           * ```javascript
           * push(chunk, false); // push one of data chunks
           * ...
           * push(chunk, true);  // push last chunk
           * ```
           **/


          Deflate.prototype.push = function (data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;

            var status, _mode;

            if (this.ended) {
              return false;
            }

            _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH; // Convert data if needed

            if (typeof data === 'string') {
              // If we need to compress text, change encoding to utf8.
              strm.input = strings.string2buf(data);
            } else if (toString.call(data) === '[object ArrayBuffer]') {
              strm.input = new Uint8Array(data);
            } else {
              strm.input = data;
            }

            strm.next_in = 0;
            strm.avail_in = strm.input.length;

            do {
              if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
              }

              status = zlib_deflate.deflate(strm, _mode);
              /* no bad return value */

              if (status !== Z_STREAM_END && status !== Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
              }

              if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
                if (this.options.to === 'string') {
                  this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
                } else {
                  this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
              }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END); // Finalize on the last chunk.


            if (_mode === Z_FINISH) {
              status = zlib_deflate.deflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return status === Z_OK;
            } // callback interim results if Z_SYNC_FLUSH.


            if (_mode === Z_SYNC_FLUSH) {
              this.onEnd(Z_OK);
              strm.avail_out = 0;
              return true;
            }

            return true;
          };
          /**
           * Deflate#onData(chunk) -> Void
           * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
           *   on js engine support. When string output requested, each chunk
           *   will be string.
           *
           * By default, stores data blocks in `chunks[]` property and glue
           * those in `onEnd`. Override this handler, if you need another behaviour.
           **/


          Deflate.prototype.onData = function (chunk) {
            this.chunks.push(chunk);
          };
          /**
           * Deflate#onEnd(status) -> Void
           * - status (Number): deflate status. 0 (Z_OK) on success,
           *   other if not.
           *
           * Called once after you tell deflate that the input stream is
           * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
           * or if an error happened. By default - join collected chunks,
           * free memory and fill `results` / `err` properties.
           **/


          Deflate.prototype.onEnd = function (status) {
            // On success - join
            if (status === Z_OK) {
              if (this.options.to === 'string') {
                this.result = this.chunks.join('');
              } else {
                this.result = utils.flattenChunks(this.chunks);
              }
            }

            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
          };
          /**
           * deflate(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to compress.
           * - options (Object): zlib deflate options.
           *
           * Compress `data` with deflate algorithm and `options`.
           *
           * Supported options are:
           *
           * - level
           * - windowBits
           * - memLevel
           * - strategy
           * - dictionary
           *
           * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
           * for more information on these.
           *
           * Sugar (options):
           *
           * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
           *   negative windowBits implicitly.
           * - `to` (String) - if equal to 'string', then result will be "binary string"
           *    (each char code [0..255])
           *
           * ##### Example:
           *
           * ```javascript
           * var pako = require('pako')
           *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
           *
           * console.log(pako.deflate(data));
           * ```
           **/


          function deflate(input, options) {
            var deflator = new Deflate(options);
            deflator.push(input, true); // That will never happens, if you don't cheat with options :)

            if (deflator.err) {
              throw deflator.msg || msg[deflator.err];
            }

            return deflator.result;
          }
          /**
           * deflateRaw(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to compress.
           * - options (Object): zlib deflate options.
           *
           * The same as [[deflate]], but creates raw data, without wrapper
           * (header and adler32 crc).
           **/


          function deflateRaw(input, options) {
            options = options || {};
            options.raw = true;
            return deflate(input, options);
          }
          /**
           * gzip(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to compress.
           * - options (Object): zlib deflate options.
           *
           * The same as [[deflate]], but create gzip wrapper instead of
           * deflate one.
           **/


          function gzip(input, options) {
            options = options || {};
            options.gzip = true;
            return deflate(input, options);
          }

          exports.Deflate = Deflate;
          exports.deflate = deflate;
          exports.deflateRaw = deflateRaw;
          exports.gzip = gzip;
        }, {
          "./utils/common": 41,
          "./utils/strings": 42,
          "./zlib/deflate": 46,
          "./zlib/messages": 51,
          "./zlib/zstream": 53
        }],
        40: [function (require, module, exports) {
          'use strict';

          var zlib_inflate = require('./zlib/inflate');

          var utils = require('./utils/common');

          var strings = require('./utils/strings');

          var c = require('./zlib/constants');

          var msg = require('./zlib/messages');

          var ZStream = require('./zlib/zstream');

          var GZheader = require('./zlib/gzheader');

          var toString = Object.prototype.toString;
          /**
           * class Inflate
           *
           * Generic JS-style wrapper for zlib calls. If you don't need
           * streaming behaviour - use more simple functions: [[inflate]]
           * and [[inflateRaw]].
           **/

          /* internal
           * inflate.chunks -> Array
           *
           * Chunks of output data, if [[Inflate#onData]] not overriden.
           **/

          /**
           * Inflate.result -> Uint8Array|Array|String
           *
           * Uncompressed result, generated by default [[Inflate#onData]]
           * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
           * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
           * push a chunk with explicit flush (call [[Inflate#push]] with
           * `Z_SYNC_FLUSH` param).
           **/

          /**
           * Inflate.err -> Number
           *
           * Error code after inflate finished. 0 (Z_OK) on success.
           * Should be checked if broken data possible.
           **/

          /**
           * Inflate.msg -> String
           *
           * Error message, if [[Inflate.err]] != 0
           **/

          /**
           * new Inflate(options)
           * - options (Object): zlib inflate options.
           *
           * Creates new inflator instance with specified params. Throws exception
           * on bad params. Supported options:
           *
           * - `windowBits`
           * - `dictionary`
           *
           * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
           * for more information on these.
           *
           * Additional options, for internal needs:
           *
           * - `chunkSize` - size of generated data chunks (16K by default)
           * - `raw` (Boolean) - do raw inflate
           * - `to` (String) - if equal to 'string', then result will be converted
           *   from utf8 to utf16 (javascript) string. When string output requested,
           *   chunk length can differ from `chunkSize`, depending on content.
           *
           * By default, when no options set, autodetect deflate/gzip data format via
           * wrapper header.
           *
           * ##### Example:
           *
           * ```javascript
           * var pako = require('pako')
           *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
           *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
           *
           * var inflate = new pako.Inflate({ level: 3});
           *
           * inflate.push(chunk1, false);
           * inflate.push(chunk2, true);  // true -> last chunk
           *
           * if (inflate.err) { throw new Error(inflate.err); }
           *
           * console.log(inflate.result);
           * ```
           **/

          function Inflate(options) {
            if (!(this instanceof Inflate)) return new Inflate(options);
            this.options = utils.assign({
              chunkSize: 16384,
              windowBits: 0,
              to: ''
            }, options || {});
            var opt = this.options; // Force window size for `raw` data, if not set directly,
            // because we have no header for autodetect.

            if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
              opt.windowBits = -opt.windowBits;

              if (opt.windowBits === 0) {
                opt.windowBits = -15;
              }
            } // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate


            if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
              opt.windowBits += 32;
            } // Gzip header has no info about windows size, we can do autodetect only
            // for deflate. So, if window size not set, force it to max when gzip possible


            if (opt.windowBits > 15 && opt.windowBits < 48) {
              // bit 3 (16) -> gzipped data
              // bit 4 (32) -> autodetect gzip/deflate
              if ((opt.windowBits & 15) === 0) {
                opt.windowBits |= 15;
              }
            }

            this.err = 0; // error code, if happens (0 = Z_OK)

            this.msg = ''; // error message

            this.ended = false; // used to avoid multiple onEnd() calls

            this.chunks = []; // chunks of compressed data

            this.strm = new ZStream();
            this.strm.avail_out = 0;
            var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);

            if (status !== c.Z_OK) {
              throw new Error(msg[status]);
            }

            this.header = new GZheader();
            zlib_inflate.inflateGetHeader(this.strm, this.header);
          }
          /**
           * Inflate#push(data[, mode]) -> Boolean
           * - data (Uint8Array|Array|ArrayBuffer|String): input data
           * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
           *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
           *
           * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
           * new output chunks. Returns `true` on success. The last data block must have
           * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
           * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
           * can use mode Z_SYNC_FLUSH, keeping the decompression context.
           *
           * On fail call [[Inflate#onEnd]] with error code and return false.
           *
           * We strongly recommend to use `Uint8Array` on input for best speed (output
           * format is detected automatically). Also, don't skip last param and always
           * use the same type in your code (boolean or number). That will improve JS speed.
           *
           * For regular `Array`-s make sure all elements are [0..255].
           *
           * ##### Example
           *
           * ```javascript
           * push(chunk, false); // push one of data chunks
           * ...
           * push(chunk, true);  // push last chunk
           * ```
           **/


          Inflate.prototype.push = function (data, mode) {
            var strm = this.strm;
            var chunkSize = this.options.chunkSize;
            var dictionary = this.options.dictionary;

            var status, _mode;

            var next_out_utf8, tail, utf8str;
            var dict; // Flag to properly process Z_BUF_ERROR on testing inflate call
            // when we check that all output data was flushed.

            var allowBufError = false;

            if (this.ended) {
              return false;
            }

            _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH; // Convert data if needed

            if (typeof data === 'string') {
              // Only binary strings can be decompressed on practice
              strm.input = strings.binstring2buf(data);
            } else if (toString.call(data) === '[object ArrayBuffer]') {
              strm.input = new Uint8Array(data);
            } else {
              strm.input = data;
            }

            strm.next_in = 0;
            strm.avail_in = strm.input.length;

            do {
              if (strm.avail_out === 0) {
                strm.output = new utils.Buf8(chunkSize);
                strm.next_out = 0;
                strm.avail_out = chunkSize;
              }

              status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
              /* no bad return value */

              if (status === c.Z_NEED_DICT && dictionary) {
                // Convert data if needed
                if (typeof dictionary === 'string') {
                  dict = strings.string2buf(dictionary);
                } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
                  dict = new Uint8Array(dictionary);
                } else {
                  dict = dictionary;
                }

                status = zlib_inflate.inflateSetDictionary(this.strm, dict);
              }

              if (status === c.Z_BUF_ERROR && allowBufError === true) {
                status = c.Z_OK;
                allowBufError = false;
              }

              if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
                this.onEnd(status);
                this.ended = true;
                return false;
              }

              if (strm.next_out) {
                if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                  if (this.options.to === 'string') {
                    next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                    tail = strm.next_out - next_out_utf8;
                    utf8str = strings.buf2string(strm.output, next_out_utf8); // move tail

                    strm.next_out = tail;
                    strm.avail_out = chunkSize - tail;

                    if (tail) {
                      utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                    }

                    this.onData(utf8str);
                  } else {
                    this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                  }
                }
              } // When no more input data, we should check that internal inflate buffers
              // are flushed. The only way to do it when avail_out = 0 - run one more
              // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
              // Here we set flag to process this error properly.
              //
              // NOTE. Deflate does not return error in this case and does not needs such
              // logic.


              if (strm.avail_in === 0 && strm.avail_out === 0) {
                allowBufError = true;
              }
            } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

            if (status === c.Z_STREAM_END) {
              _mode = c.Z_FINISH;
            } // Finalize on the last chunk.


            if (_mode === c.Z_FINISH) {
              status = zlib_inflate.inflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return status === c.Z_OK;
            } // callback interim results if Z_SYNC_FLUSH.


            if (_mode === c.Z_SYNC_FLUSH) {
              this.onEnd(c.Z_OK);
              strm.avail_out = 0;
              return true;
            }

            return true;
          };
          /**
           * Inflate#onData(chunk) -> Void
           * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
           *   on js engine support. When string output requested, each chunk
           *   will be string.
           *
           * By default, stores data blocks in `chunks[]` property and glue
           * those in `onEnd`. Override this handler, if you need another behaviour.
           **/


          Inflate.prototype.onData = function (chunk) {
            this.chunks.push(chunk);
          };
          /**
           * Inflate#onEnd(status) -> Void
           * - status (Number): inflate status. 0 (Z_OK) on success,
           *   other if not.
           *
           * Called either after you tell inflate that the input stream is
           * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
           * or if an error happened. By default - join collected chunks,
           * free memory and fill `results` / `err` properties.
           **/


          Inflate.prototype.onEnd = function (status) {
            // On success - join
            if (status === c.Z_OK) {
              if (this.options.to === 'string') {
                // Glue & convert here, until we teach pako to send
                // utf8 alligned strings to onData
                this.result = this.chunks.join('');
              } else {
                this.result = utils.flattenChunks(this.chunks);
              }
            }

            this.chunks = [];
            this.err = status;
            this.msg = this.strm.msg;
          };
          /**
           * inflate(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to decompress.
           * - options (Object): zlib inflate options.
           *
           * Decompress `data` with inflate/ungzip and `options`. Autodetect
           * format via wrapper header by default. That's why we don't provide
           * separate `ungzip` method.
           *
           * Supported options are:
           *
           * - windowBits
           *
           * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
           * for more information.
           *
           * Sugar (options):
           *
           * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
           *   negative windowBits implicitly.
           * - `to` (String) - if equal to 'string', then result will be converted
           *   from utf8 to utf16 (javascript) string. When string output requested,
           *   chunk length can differ from `chunkSize`, depending on content.
           *
           *
           * ##### Example:
           *
           * ```javascript
           * var pako = require('pako')
           *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
           *   , output;
           *
           * try {
           *   output = pako.inflate(input);
           * } catch (err)
           *   console.log(err);
           * }
           * ```
           **/


          function inflate(input, options) {
            var inflator = new Inflate(options);
            inflator.push(input, true); // That will never happens, if you don't cheat with options :)

            if (inflator.err) {
              throw inflator.msg || msg[inflator.err];
            }

            return inflator.result;
          }
          /**
           * inflateRaw(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to decompress.
           * - options (Object): zlib inflate options.
           *
           * The same as [[inflate]], but creates raw data, without wrapper
           * (header and adler32 crc).
           **/


          function inflateRaw(input, options) {
            options = options || {};
            options.raw = true;
            return inflate(input, options);
          }
          /**
           * ungzip(data[, options]) -> Uint8Array|Array|String
           * - data (Uint8Array|Array|String): input data to decompress.
           * - options (Object): zlib inflate options.
           *
           * Just shortcut to [[inflate]], because it autodetects format
           * by header.content. Done for convenience.
           **/


          exports.Inflate = Inflate;
          exports.inflate = inflate;
          exports.inflateRaw = inflateRaw;
          exports.ungzip = inflate;
        }, {
          "./utils/common": 41,
          "./utils/strings": 42,
          "./zlib/constants": 44,
          "./zlib/gzheader": 47,
          "./zlib/inflate": 49,
          "./zlib/messages": 51,
          "./zlib/zstream": 53
        }],
        41: [function (require, module, exports) {
          'use strict';

          var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

          exports.assign = function (obj
          /*from1, from2, from3, ...*/
          ) {
            var sources = Array.prototype.slice.call(arguments, 1);

            while (sources.length) {
              var source = sources.shift();

              if (!source) {
                continue;
              }

              if (typeof source !== 'object') {
                throw new TypeError(source + 'must be non-object');
              }

              for (var p in source) {
                if (source.hasOwnProperty(p)) {
                  obj[p] = source[p];
                }
              }
            }

            return obj;
          }; // reduce buffer size, avoiding mem copy


          exports.shrinkBuf = function (buf, size) {
            if (buf.length === size) {
              return buf;
            }

            if (buf.subarray) {
              return buf.subarray(0, size);
            }

            buf.length = size;
            return buf;
          };

          var fnTyped = {
            arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
              if (src.subarray && dest.subarray) {
                dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                return;
              } // Fallback to ordinary array


              for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
              }
            },
            // Join array of chunks to single array.
            flattenChunks: function flattenChunks(chunks) {
              var i, l, len, pos, chunk, result; // calculate data length

              len = 0;

              for (i = 0, l = chunks.length; i < l; i++) {
                len += chunks[i].length;
              } // join chunks


              result = new Uint8Array(len);
              pos = 0;

              for (i = 0, l = chunks.length; i < l; i++) {
                chunk = chunks[i];
                result.set(chunk, pos);
                pos += chunk.length;
              }

              return result;
            }
          };
          var fnUntyped = {
            arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
              for (var i = 0; i < len; i++) {
                dest[dest_offs + i] = src[src_offs + i];
              }
            },
            // Join array of chunks to single array.
            flattenChunks: function flattenChunks(chunks) {
              return [].concat.apply([], chunks);
            }
          }; // Enable/Disable typed arrays use, for testing
          //

          exports.setTyped = function (on) {
            if (on) {
              exports.Buf8 = Uint8Array;
              exports.Buf16 = Uint16Array;
              exports.Buf32 = Int32Array;
              exports.assign(exports, fnTyped);
            } else {
              exports.Buf8 = Array;
              exports.Buf16 = Array;
              exports.Buf32 = Array;
              exports.assign(exports, fnUntyped);
            }
          };

          exports.setTyped(TYPED_OK);
        }, {}],
        42: [function (require, module, exports) {
          // String encode/decode helpers
          'use strict';

          var utils = require('./common'); // Quick check if we can use fast array to bin string conversion
          //
          // - apply(Array) can fail on Android 2.2
          // - apply(Uint8Array) can fail on iOS 5.1 Safary
          //


          var STR_APPLY_OK = true;
          var STR_APPLY_UIA_OK = true;

          try {
            String.fromCharCode.apply(null, [0]);
          } catch (__) {
            STR_APPLY_OK = false;
          }

          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (__) {
            STR_APPLY_UIA_OK = false;
          } // Table with utf8 lengths (calculated by first byte of sequence)
          // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
          // because max possible codepoint is 0x10ffff


          var _utf8len = new utils.Buf8(256);

          for (var q = 0; q < 256; q++) {
            _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
          }

          _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
          // convert string to array (typed, when possible)

          exports.string2buf = function (str) {
            var buf,
                c,
                c2,
                m_pos,
                i,
                str_len = str.length,
                buf_len = 0; // count binary size

            for (m_pos = 0; m_pos < str_len; m_pos++) {
              c = str.charCodeAt(m_pos);

              if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);

                if ((c2 & 0xfc00) === 0xdc00) {
                  c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                  m_pos++;
                }
              }

              buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
            } // allocate buffer


            buf = new utils.Buf8(buf_len); // convert

            for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
              c = str.charCodeAt(m_pos);

              if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
                c2 = str.charCodeAt(m_pos + 1);

                if ((c2 & 0xfc00) === 0xdc00) {
                  c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
                  m_pos++;
                }
              }

              if (c < 0x80) {
                /* one byte */
                buf[i++] = c;
              } else if (c < 0x800) {
                /* two bytes */
                buf[i++] = 0xC0 | c >>> 6;
                buf[i++] = 0x80 | c & 0x3f;
              } else if (c < 0x10000) {
                /* three bytes */
                buf[i++] = 0xE0 | c >>> 12;
                buf[i++] = 0x80 | c >>> 6 & 0x3f;
                buf[i++] = 0x80 | c & 0x3f;
              } else {
                /* four bytes */
                buf[i++] = 0xf0 | c >>> 18;
                buf[i++] = 0x80 | c >>> 12 & 0x3f;
                buf[i++] = 0x80 | c >>> 6 & 0x3f;
                buf[i++] = 0x80 | c & 0x3f;
              }
            }

            return buf;
          }; // Helper (used in 2 places)


          function buf2binstring(buf, len) {
            // use fallback for big arrays to avoid stack overflow
            if (len < 65537) {
              if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
                return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
              }
            }

            var result = '';

            for (var i = 0; i < len; i++) {
              result += String.fromCharCode(buf[i]);
            }

            return result;
          } // Convert byte array to binary string


          exports.buf2binstring = function (buf) {
            return buf2binstring(buf, buf.length);
          }; // Convert binary string (typed, when possible)


          exports.binstring2buf = function (str) {
            var buf = new utils.Buf8(str.length);

            for (var i = 0, len = buf.length; i < len; i++) {
              buf[i] = str.charCodeAt(i);
            }

            return buf;
          }; // convert array to string


          exports.buf2string = function (buf, max) {
            var i, out, c, c_len;
            var len = max || buf.length; // Reserve max possible length (2 words per char)
            // NB: by unknown reasons, Array is significantly faster for
            //     String.fromCharCode.apply than Uint16Array.

            var utf16buf = new Array(len * 2);

            for (out = 0, i = 0; i < len;) {
              c = buf[i++]; // quick process ascii

              if (c < 0x80) {
                utf16buf[out++] = c;
                continue;
              }

              c_len = _utf8len[c]; // skip 5 & 6 byte codes

              if (c_len > 4) {
                utf16buf[out++] = 0xfffd;
                i += c_len - 1;
                continue;
              } // apply mask on first byte


              c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest

              while (c_len > 1 && i < len) {
                c = c << 6 | buf[i++] & 0x3f;
                c_len--;
              } // terminated by end of string?


              if (c_len > 1) {
                utf16buf[out++] = 0xfffd;
                continue;
              }

              if (c < 0x10000) {
                utf16buf[out++] = c;
              } else {
                c -= 0x10000;
                utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
                utf16buf[out++] = 0xdc00 | c & 0x3ff;
              }
            }

            return buf2binstring(utf16buf, out);
          }; // Calculate max possible position in utf8 buffer,
          // that will not break sequence. If that's not possible
          // - (very small limits) return max size as is.
          //
          // buf[] - utf8 bytes array
          // max   - length limit (mandatory);


          exports.utf8border = function (buf, max) {
            var pos;
            max = max || buf.length;

            if (max > buf.length) {
              max = buf.length;
            } // go back from last position, until start of sequence found


            pos = max - 1;

            while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
              pos--;
            } // Fuckup - very small and broken sequence,
            // return max, because we should return something anyway.


            if (pos < 0) {
              return max;
            } // If we came to start of buffer - that means vuffer is too small,
            // return max too.


            if (pos === 0) {
              return max;
            }

            return pos + _utf8len[buf[pos]] > max ? pos : max;
          };
        }, {
          "./common": 41
        }],
        43: [function (require, module, exports) {
          'use strict'; // Note: adler32 takes 12% for level 0 and 2% for level 6.
          // It doesn't worth to make additional optimizationa as in original.
          // Small size is preferable.
          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          function adler32(adler, buf, len, pos) {
            var s1 = adler & 0xffff | 0,
                s2 = adler >>> 16 & 0xffff | 0,
                n = 0;

            while (len !== 0) {
              // Set limit ~ twice less than 5552, to keep
              // s2 in 31-bits, because we force signed ints.
              // in other case %= will fail.
              n = len > 2000 ? 2000 : len;
              len -= n;

              do {
                s1 = s1 + buf[pos++] | 0;
                s2 = s2 + s1 | 0;
              } while (--n);

              s1 %= 65521;
              s2 %= 65521;
            }

            return s1 | s2 << 16 | 0;
          }

          module.exports = adler32;
        }, {}],
        44: [function (require, module, exports) {
          'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          module.exports = {
            /* Allowed flush values; see deflate() and inflate() below for details */
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,

            /* Return codes for the compression/decompression functions. Negative values
            * are errors, positive values are used for special but normal events.
            */
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            //Z_MEM_ERROR:     -4,
            Z_BUF_ERROR: -5,
            //Z_VERSION_ERROR: -6,

            /* compression levels */
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,

            /* Possible values of the data_type field (though see inflate()) */
            Z_BINARY: 0,
            Z_TEXT: 1,
            //Z_ASCII:                1, // = Z_TEXT (deprecated)
            Z_UNKNOWN: 2,

            /* The deflate compression method */
            Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type

          };
        }, {}],
        45: [function (require, module, exports) {
          'use strict'; // Note: we can't get significant speed boost here.
          // So write code to minimize size - no pregenerated tables
          // and array tools dependencies.
          // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.
          // Use ordinary array, since untyped makes no boost here

          function makeTable() {
            var c,
                table = [];

            for (var n = 0; n < 256; n++) {
              c = n;

              for (var k = 0; k < 8; k++) {
                c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
              }

              table[n] = c;
            }

            return table;
          } // Create table on load. Just 255 signed longs. Not a problem.


          var crcTable = makeTable();

          function crc32(crc, buf, len, pos) {
            var t = crcTable,
                end = pos + len;
            crc ^= -1;

            for (var i = pos; i < end; i++) {
              crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
            }

            return crc ^ -1; // >>> 0;
          }

          module.exports = crc32;
        }, {}],
        46: [function (require, module, exports) {
          'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          var utils = require('../utils/common');

          var trees = require('./trees');

          var adler32 = require('./adler32');

          var crc32 = require('./crc32');

          var msg = require('./messages');
          /* Public constants ==========================================================*/

          /* ===========================================================================*/

          /* Allowed flush values; see deflate() and inflate() below for details */


          var Z_NO_FLUSH = 0;
          var Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;

          var Z_FULL_FLUSH = 3;
          var Z_FINISH = 4;
          var Z_BLOCK = 5; //var Z_TREES         = 6;

          /* Return codes for the compression/decompression functions. Negative values
           * are errors, positive values are used for special but normal events.
           */

          var Z_OK = 0;
          var Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;
          //var Z_ERRNO         = -1;

          var Z_STREAM_ERROR = -2;
          var Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;

          var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

          /* compression levels */
          //var Z_NO_COMPRESSION      = 0;
          //var Z_BEST_SPEED          = 1;
          //var Z_BEST_COMPRESSION    = 9;

          var Z_DEFAULT_COMPRESSION = -1;
          var Z_FILTERED = 1;
          var Z_HUFFMAN_ONLY = 2;
          var Z_RLE = 3;
          var Z_FIXED = 4;
          var Z_DEFAULT_STRATEGY = 0;
          /* Possible values of the data_type field (though see inflate()) */
          //var Z_BINARY              = 0;
          //var Z_TEXT                = 1;
          //var Z_ASCII               = 1; // = Z_TEXT

          var Z_UNKNOWN = 2;
          /* The deflate compression method */

          var Z_DEFLATED = 8;
          /*============================================================================*/

          var MAX_MEM_LEVEL = 9;
          /* Maximum value for memLevel in deflateInit2 */

          var MAX_WBITS = 15;
          /* 32K LZ77 window */

          var DEF_MEM_LEVEL = 8;
          var LENGTH_CODES = 29;
          /* number of length codes, not counting the special END_BLOCK code */

          var LITERALS = 256;
          /* number of literal bytes 0..255 */

          var L_CODES = LITERALS + 1 + LENGTH_CODES;
          /* number of Literal or Length codes, including the END_BLOCK code */

          var D_CODES = 30;
          /* number of distance codes */

          var BL_CODES = 19;
          /* number of codes used to transfer the bit lengths */

          var HEAP_SIZE = 2 * L_CODES + 1;
          /* maximum heap size */

          var MAX_BITS = 15;
          /* All codes must not exceed MAX_BITS bits */

          var MIN_MATCH = 3;
          var MAX_MATCH = 258;
          var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
          var PRESET_DICT = 0x20;
          var INIT_STATE = 42;
          var EXTRA_STATE = 69;
          var NAME_STATE = 73;
          var COMMENT_STATE = 91;
          var HCRC_STATE = 103;
          var BUSY_STATE = 113;
          var FINISH_STATE = 666;
          var BS_NEED_MORE = 1;
          /* block not completed, need more input or more output */

          var BS_BLOCK_DONE = 2;
          /* block flush performed */

          var BS_FINISH_STARTED = 3;
          /* finish started, need only more output at next deflate */

          var BS_FINISH_DONE = 4;
          /* finish done, accept no more input or output */

          var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

          function err(strm, errorCode) {
            strm.msg = msg[errorCode];
            return errorCode;
          }

          function rank(f) {
            return (f << 1) - (f > 4 ? 9 : 0);
          }

          function zero(buf) {
            var len = buf.length;

            while (--len >= 0) {
              buf[len] = 0;
            }
          }
          /* =========================================================================
           * Flush as much pending output as possible. All deflate() output goes
           * through this function so some applications may wish to modify it
           * to avoid allocating a large strm->output buffer and copying into it.
           * (See also read_buf()).
           */


          function flush_pending(strm) {
            var s = strm.state; //_tr_flush_bits(s);

            var len = s.pending;

            if (len > strm.avail_out) {
              len = strm.avail_out;
            }

            if (len === 0) {
              return;
            }

            utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
            strm.next_out += len;
            s.pending_out += len;
            strm.total_out += len;
            strm.avail_out -= len;
            s.pending -= len;

            if (s.pending === 0) {
              s.pending_out = 0;
            }
          }

          function flush_block_only(s, last) {
            trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);

            s.block_start = s.strstart;
            flush_pending(s.strm);
          }

          function put_byte(s, b) {
            s.pending_buf[s.pending++] = b;
          }
          /* =========================================================================
           * Put a short in the pending buffer. The 16-bit value is put in MSB order.
           * IN assertion: the stream state is correct and there is enough room in
           * pending_buf.
           */


          function putShortMSB(s, b) {
            //  put_byte(s, (Byte)(b >> 8));
            //  put_byte(s, (Byte)(b & 0xff));
            s.pending_buf[s.pending++] = b >>> 8 & 0xff;
            s.pending_buf[s.pending++] = b & 0xff;
          }
          /* ===========================================================================
           * Read a new buffer from the current input stream, update the adler32
           * and total number of bytes read.  All deflate() input goes through
           * this function so some applications may wish to modify it to avoid
           * allocating a large strm->input buffer and copying from it.
           * (See also flush_pending()).
           */


          function read_buf(strm, buf, start, size) {
            var len = strm.avail_in;

            if (len > size) {
              len = size;
            }

            if (len === 0) {
              return 0;
            }

            strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);

            utils.arraySet(buf, strm.input, strm.next_in, len, start);

            if (strm.state.wrap === 1) {
              strm.adler = adler32(strm.adler, buf, len, start);
            } else if (strm.state.wrap === 2) {
              strm.adler = crc32(strm.adler, buf, len, start);
            }

            strm.next_in += len;
            strm.total_in += len;
            return len;
          }
          /* ===========================================================================
           * Set match_start to the longest match starting at the given string and
           * return its length. Matches shorter or equal to prev_length are discarded,
           * in which case the result is equal to prev_length and match_start is
           * garbage.
           * IN assertions: cur_match is the head of the hash chain for the current
           *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
           * OUT assertion: the match length is not greater than s->lookahead.
           */


          function longest_match(s, cur_match) {
            var chain_length = s.max_chain_length;
            /* max hash chain length */

            var scan = s.strstart;
            /* current string */

            var match;
            /* matched string */

            var len;
            /* length of current match */

            var best_len = s.prev_length;
            /* best match length so far */

            var nice_match = s.nice_match;
            /* stop if match long enough */

            var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0
            /*NIL*/
            ;
            var _win = s.window; // shortcut

            var wmask = s.w_mask;
            var prev = s.prev;
            /* Stop when cur_match becomes <= limit. To simplify the code,
             * we prevent matches with the string of window index 0.
             */

            var strend = s.strstart + MAX_MATCH;
            var scan_end1 = _win[scan + best_len - 1];
            var scan_end = _win[scan + best_len];
            /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
             * It is easy to get rid of this optimization if necessary.
             */
            // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

            /* Do not waste too much time if we already have a good match: */

            if (s.prev_length >= s.good_match) {
              chain_length >>= 2;
            }
            /* Do not look for matches beyond the end of the input. This is necessary
             * to make deflate deterministic.
             */


            if (nice_match > s.lookahead) {
              nice_match = s.lookahead;
            } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");


            do {
              // Assert(cur_match < s->strstart, "no future");
              match = cur_match;
              /* Skip to next match if the match length cannot increase
               * or if the match length is less than 2.  Note that the checks below
               * for insufficient lookahead only occur occasionally for performance
               * reasons.  Therefore uninitialized memory will be accessed, and
               * conditional jumps will be made that depend on those values.
               * However the length of the match is limited to the lookahead, so
               * the output of deflate is not affected by the uninitialized values.
               */

              if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
                continue;
              }
              /* The check at best_len-1 can be removed because it will be made
               * again later. (This heuristic is not always a win.)
               * It is not necessary to compare scan[2] and match[2] since they
               * are always equal when the other bytes match, given that
               * the hash keys are equal and that HASH_BITS >= 8.
               */


              scan += 2;
              match++; // Assert(*scan == *match, "match[2]?");

              /* We check for insufficient lookahead only every 8th comparison;
               * the 256th check will be made at strstart+258.
               */

              do {
                /*jshint noempty:false*/
              } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");


              len = MAX_MATCH - (strend - scan);
              scan = strend - MAX_MATCH;

              if (len > best_len) {
                s.match_start = cur_match;
                best_len = len;

                if (len >= nice_match) {
                  break;
                }

                scan_end1 = _win[scan + best_len - 1];
                scan_end = _win[scan + best_len];
              }
            } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

            if (best_len <= s.lookahead) {
              return best_len;
            }

            return s.lookahead;
          }
          /* ===========================================================================
           * Fill the window when the lookahead becomes insufficient.
           * Updates strstart and lookahead.
           *
           * IN assertion: lookahead < MIN_LOOKAHEAD
           * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
           *    At least one byte has been read, or avail_in == 0; reads are
           *    performed for at least two bytes (required for the zip translate_eol
           *    option -- not supported here).
           */


          function fill_window(s) {
            var _w_size = s.w_size;
            var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

            do {
              more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed

              /* Deal with !@#$% 64K limit: */
              //if (sizeof(int) <= 2) {
              //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
              //        more = wsize;
              //
              //  } else if (more == (unsigned)(-1)) {
              //        /* Very unlikely, but possible on 16 bit machine if
              //         * strstart == 0 && lookahead == 1 (input done a byte at time)
              //         */
              //        more--;
              //    }
              //}

              /* If the window is almost full and there is insufficient lookahead,
               * move the upper half to the lower one to make room in the upper half.
               */

              if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                s.match_start -= _w_size;
                s.strstart -= _w_size;
                /* we now have strstart >= MAX_DIST */

                s.block_start -= _w_size;
                /* Slide the hash table (could be avoided with 32 bit values
                 at the expense of memory usage). We slide even when level == 0
                 to keep the hash table consistent if we switch back to level > 0
                 later. (Using level 0 permanently is not an optimal usage of
                 zlib, so we don't care about this pathological case.)
                 */

                n = s.hash_size;
                p = n;

                do {
                  m = s.head[--p];
                  s.head[p] = m >= _w_size ? m - _w_size : 0;
                } while (--n);

                n = _w_size;
                p = n;

                do {
                  m = s.prev[--p];
                  s.prev[p] = m >= _w_size ? m - _w_size : 0;
                  /* If n is not on any hash chain, prev[n] is garbage but
                   * its value will never be used.
                   */
                } while (--n);

                more += _w_size;
              }

              if (s.strm.avail_in === 0) {
                break;
              }
              /* If there was no sliding:
               *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
               *    more == window_size - lookahead - strstart
               * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
               * => more >= window_size - 2*WSIZE + 2
               * In the BIG_MEM or MMAP case (not yet supported),
               *   window_size == input_size + MIN_LOOKAHEAD  &&
               *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
               * Otherwise, window_size == 2*WSIZE so more >= 2.
               * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
               */
              //Assert(more >= 2, "more < 2");


              n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
              s.lookahead += n;
              /* Initialize the hash value now that we have some input: */

              if (s.lookahead + s.insert >= MIN_MATCH) {
                str = s.strstart - s.insert;
                s.ins_h = s.window[str];
                /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */

                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3
                //        Call update_hash() MIN_MATCH-3 more times
                //#endif

                while (s.insert) {
                  /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                  s.prev[str & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = str;
                  str++;
                  s.insert--;

                  if (s.lookahead + s.insert < MIN_MATCH) {
                    break;
                  }
                }
              }
              /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
               * but this is not important since only literal bytes will be emitted.
               */

            } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
            /* If the WIN_INIT bytes after the end of the current data have never been
             * written, then zero those bytes in order to avoid memory check reports of
             * the use of uninitialized (or uninitialised as Julian writes) bytes by
             * the longest match routines.  Update the high water mark for the next
             * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
             * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
             */
            //  if (s.high_water < s.window_size) {
            //    var curr = s.strstart + s.lookahead;
            //    var init = 0;
            //
            //    if (s.high_water < curr) {
            //      /* Previous high water mark below current data -- zero WIN_INIT
            //       * bytes or up to end of window, whichever is less.
            //       */
            //      init = s.window_size - curr;
            //      if (init > WIN_INIT)
            //        init = WIN_INIT;
            //      zmemzero(s->window + curr, (unsigned)init);
            //      s->high_water = curr + init;
            //    }
            //    else if (s->high_water < (ulg)curr + WIN_INIT) {
            //      /* High water mark at or above current data, but below current data
            //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
            //       * to end of window, whichever is less.
            //       */
            //      init = (ulg)curr + WIN_INIT - s->high_water;
            //      if (init > s->window_size - s->high_water)
            //        init = s->window_size - s->high_water;
            //      zmemzero(s->window + s->high_water, (unsigned)init);
            //      s->high_water += init;
            //    }
            //  }
            //
            //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
            //    "not enough room for search");

          }
          /* ===========================================================================
           * Copy without compression as much as possible from the input stream, return
           * the current block state.
           * This function does not insert new strings in the dictionary since
           * uncompressible data is probably not useful. This function is used
           * only for the level=0 compression option.
           * NOTE: this function should be optimized to avoid extra copying from
           * window to pending_buf.
           */


          function deflate_stored(s, flush) {
            /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
             * to pending_buf_size, and each stored block has a 5 byte header:
             */
            var max_block_size = 0xffff;

            if (max_block_size > s.pending_buf_size - 5) {
              max_block_size = s.pending_buf_size - 5;
            }
            /* Copy as much as possible from input to output: */


            for (;;) {
              /* Fill the window as much as possible: */
              if (s.lookahead <= 1) {
                //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                //  s->block_start >= (long)s->w_size, "slide too late");
                //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
                //        s.block_start >= s.w_size)) {
                //        throw  new Error("slide too late");
                //      }
                fill_window(s);

                if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }

                if (s.lookahead === 0) {
                  break;
                }
                /* flush the current block */

              } //Assert(s->block_start >= 0L, "block gone");
              //    if (s.block_start < 0) throw new Error("block gone");


              s.strstart += s.lookahead;
              s.lookahead = 0;
              /* Emit a stored block if pending_buf will be full: */

              var max_start = s.block_start + max_block_size;

              if (s.strstart === 0 || s.strstart >= max_start) {
                /* strstart == 0 is possible when wraparound on 16-bit machine */
                s.lookahead = s.strstart - max_start;
                s.strstart = max_start;
                /*** FLUSH_BLOCK(s, 0); ***/

                flush_block_only(s, false);

                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
                /***/

              }
              /* Flush if we may have to slide, otherwise block_start may become
               * negative and the data will be gone:
               */


              if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);

                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
                /***/

              }
            }

            s.insert = 0;

            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true);

              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              /***/


              return BS_FINISH_DONE;
            }

            if (s.strstart > s.block_start) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false);

              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
              /***/

            }

            return BS_NEED_MORE;
          }
          /* ===========================================================================
           * Compress as much as possible from the input stream, return the current
           * block state.
           * This function does not perform lazy evaluation of matches and inserts
           * new strings in the dictionary only for unmatched strings or for short
           * matches. It is used only for the fast compression options.
           */


          function deflate_fast(s, flush) {
            var hash_head;
            /* head of the hash chain */

            var bflush;
            /* set if current block must be flushed */

            for (;;) {
              /* Make sure that we always have enough lookahead, except
               * at the end of the input file. We need MAX_MATCH bytes
               * for the next match, plus MIN_MATCH bytes to insert the
               * string following the next match.
               */
              if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);

                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }

                if (s.lookahead === 0) {
                  break;
                  /* flush the current block */
                }
              }
              /* Insert the string window[strstart .. strstart+2] in the
               * dictionary, and set hash_head to the head of the hash chain:
               */


              hash_head = 0
              /*NIL*/
              ;

              if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
              }
              /* Find the longest match, discarding those <= prev_length.
               * At this point we have always match_length < MIN_MATCH
               */


              if (hash_head !== 0
              /*NIL*/
              && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
                /* To simplify the code, we prevent matches with the string
                 * of window index 0 (in particular we have to avoid a match
                 * of the string with itself at the start of the input file).
                 */
                s.match_length = longest_match(s, hash_head);
                /* longest_match() sets match_start */
              }

              if (s.match_length >= MIN_MATCH) {
                // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

                /*** _tr_tally_dist(s, s.strstart - s.match_start,
                               s.match_length - MIN_MATCH, bflush); ***/
                bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                /* Insert new strings in the hash table only if the match length
                 * is not too large. This saves time but degrades compression.
                 */

                if (s.match_length <= s.max_lazy_match
                /*max_insert_length*/
                && s.lookahead >= MIN_MATCH) {
                  s.match_length--;
                  /* string at strstart already in table */

                  do {
                    s.strstart++;
                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/

                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                    /***/

                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                  } while (--s.match_length !== 0);

                  s.strstart++;
                } else {
                  s.strstart += s.match_length;
                  s.match_length = 0;
                  s.ins_h = s.window[s.strstart];
                  /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */

                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3
                  //                Call UPDATE_HASH() MIN_MATCH-3 more times
                  //#endif

                  /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                   * matter since it will be recomputed at next deflate call.
                   */
                }
              } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s.window[s.strstart]));

                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
              }

              if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);

                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
                /***/

              }
            }

            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true);

              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              /***/


              return BS_FINISH_DONE;
            }

            if (s.last_lit) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false);

              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
              /***/

            }

            return BS_BLOCK_DONE;
          }
          /* ===========================================================================
           * Same as above, but achieves better compression. We use a lazy
           * evaluation for matches: a match is finally adopted only if there is
           * no better match at the next window position.
           */


          function deflate_slow(s, flush) {
            var hash_head;
            /* head of hash chain */

            var bflush;
            /* set if current block must be flushed */

            var max_insert;
            /* Process the input block. */

            for (;;) {
              /* Make sure that we always have enough lookahead, except
               * at the end of the input file. We need MAX_MATCH bytes
               * for the next match, plus MIN_MATCH bytes to insert the
               * string following the next match.
               */
              if (s.lookahead < MIN_LOOKAHEAD) {
                fill_window(s);

                if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }

                if (s.lookahead === 0) {
                  break;
                }
                /* flush the current block */

              }
              /* Insert the string window[strstart .. strstart+2] in the
               * dictionary, and set hash_head to the head of the hash chain:
               */


              hash_head = 0
              /*NIL*/
              ;

              if (s.lookahead >= MIN_MATCH) {
                /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
                /***/
              }
              /* Find the longest match, discarding those <= prev_length.
               */


              s.prev_length = s.match_length;
              s.prev_match = s.match_start;
              s.match_length = MIN_MATCH - 1;

              if (hash_head !== 0
              /*NIL*/
              && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
              /*MAX_DIST(s)*/
              ) {
                  /* To simplify the code, we prevent matches with the string
                   * of window index 0 (in particular we have to avoid a match
                   * of the string with itself at the start of the input file).
                   */
                  s.match_length = longest_match(s, hash_head);
                  /* longest_match() sets match_start */

                  if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096
                  /*TOO_FAR*/
                  )) {
                    /* If prev_match is also MIN_MATCH, match_start is garbage
                     * but we will ignore the current match anyway.
                     */
                    s.match_length = MIN_MATCH - 1;
                  }
                }
              /* If there was a match at the previous step and the current
               * match is not better, output the previous match:
               */


              if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                max_insert = s.strstart + s.lookahead - MIN_MATCH;
                /* Do not insert strings in hash table beyond this. */
                //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

                /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                               s.prev_length - MIN_MATCH, bflush);***/

                bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                /* Insert in hash table all strings up to the end of the match.
                 * strstart-1 and strstart are already inserted. If there is not
                 * enough lookahead, the last two strings are not inserted in
                 * the hash table.
                 */

                s.lookahead -= s.prev_length - 1;
                s.prev_length -= 2;

                do {
                  if (++s.strstart <= max_insert) {
                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                    s.head[s.ins_h] = s.strstart;
                    /***/
                  }
                } while (--s.prev_length !== 0);

                s.match_available = 0;
                s.match_length = MIN_MATCH - 1;
                s.strstart++;

                if (bflush) {
                  /*** FLUSH_BLOCK(s, 0); ***/
                  flush_block_only(s, false);

                  if (s.strm.avail_out === 0) {
                    return BS_NEED_MORE;
                  }
                  /***/

                }
              } else if (s.match_available) {
                /* If there was no match at the previous position, output a
                 * single literal. If there was a match but the current match
                 * is longer, truncate the previous match to a single literal.
                 */
                //Tracevv((stderr,"%c", s->window[s->strstart-1]));

                /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

                if (bflush) {
                  /*** FLUSH_BLOCK_ONLY(s, 0) ***/
                  flush_block_only(s, false);
                  /***/
                }

                s.strstart++;
                s.lookahead--;

                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              } else {
                /* There is no previous match to compare with, wait for
                 * the next step to decide.
                 */
                s.match_available = 1;
                s.strstart++;
                s.lookahead--;
              }
            } //Assert (flush != Z_NO_FLUSH, "no flush?");


            if (s.match_available) {
              //Tracevv((stderr,"%c", s->window[s->strstart-1]));

              /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
              bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
              s.match_available = 0;
            }

            s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true);

              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              /***/


              return BS_FINISH_DONE;
            }

            if (s.last_lit) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false);

              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
              /***/

            }

            return BS_BLOCK_DONE;
          }
          /* ===========================================================================
           * For Z_RLE, simply look for runs of bytes, generate matches only of distance
           * one.  Do not maintain a hash table.  (It will be regenerated if this run of
           * deflate switches away from Z_RLE.)
           */


          function deflate_rle(s, flush) {
            var bflush;
            /* set if current block must be flushed */

            var prev;
            /* byte at distance one to match */

            var scan, strend;
            /* scan goes up to strend for length of run */

            var _win = s.window;

            for (;;) {
              /* Make sure that we always have enough lookahead, except
               * at the end of the input file. We need MAX_MATCH bytes
               * for the longest run, plus one for the unrolled loop.
               */
              if (s.lookahead <= MAX_MATCH) {
                fill_window(s);

                if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }

                if (s.lookahead === 0) {
                  break;
                }
                /* flush the current block */

              }
              /* See how many times the previous byte repeats */


              s.match_length = 0;

              if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                scan = s.strstart - 1;
                prev = _win[scan];

                if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                  strend = s.strstart + MAX_MATCH;

                  do {
                    /*jshint noempty:false*/
                  } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

                  s.match_length = MAX_MATCH - (strend - scan);

                  if (s.match_length > s.lookahead) {
                    s.match_length = s.lookahead;
                  }
                } //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");

              }
              /* Emit match if have run of MIN_MATCH or longer, else emit literal */


              if (s.match_length >= MIN_MATCH) {
                //check_match(s, s.strstart, s.strstart - 1, s.match_length);

                /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
                bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                s.lookahead -= s.match_length;
                s.strstart += s.match_length;
                s.match_length = 0;
              } else {
                /* No match, output a literal byte */
                //Tracevv((stderr,"%c", s->window[s->strstart]));

                /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
                bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                s.lookahead--;
                s.strstart++;
              }

              if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);

                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
                /***/

              }
            }

            s.insert = 0;

            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true);

              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              /***/


              return BS_FINISH_DONE;
            }

            if (s.last_lit) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false);

              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
              /***/

            }

            return BS_BLOCK_DONE;
          }
          /* ===========================================================================
           * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
           * (It will be regenerated if this run of deflate switches away from Huffman.)
           */


          function deflate_huff(s, flush) {
            var bflush;
            /* set if current block must be flushed */

            for (;;) {
              /* Make sure that we have a literal to write. */
              if (s.lookahead === 0) {
                fill_window(s);

                if (s.lookahead === 0) {
                  if (flush === Z_NO_FLUSH) {
                    return BS_NEED_MORE;
                  }

                  break;
                  /* flush the current block */
                }
              }
              /* Output a literal byte */


              s.match_length = 0; //Tracevv((stderr,"%c", s->window[s->strstart]));

              /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/

              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;

              if (bflush) {
                /*** FLUSH_BLOCK(s, 0); ***/
                flush_block_only(s, false);

                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
                /***/

              }
            }

            s.insert = 0;

            if (flush === Z_FINISH) {
              /*** FLUSH_BLOCK(s, 1); ***/
              flush_block_only(s, true);

              if (s.strm.avail_out === 0) {
                return BS_FINISH_STARTED;
              }
              /***/


              return BS_FINISH_DONE;
            }

            if (s.last_lit) {
              /*** FLUSH_BLOCK(s, 0); ***/
              flush_block_only(s, false);

              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
              /***/

            }

            return BS_BLOCK_DONE;
          }
          /* Values for max_lazy_match, good_match and max_chain_length, depending on
           * the desired pack level (0..9). The values given below have been tuned to
           * exclude worst case performance for pathological files. Better values may be
           * found for specific files.
           */


          function Config(good_length, max_lazy, nice_length, max_chain, func) {
            this.good_length = good_length;
            this.max_lazy = max_lazy;
            this.nice_length = nice_length;
            this.max_chain = max_chain;
            this.func = func;
          }

          var configuration_table;
          configuration_table = [
          /*      good lazy nice chain */
          new Config(0, 0, 0, 0, deflate_stored),
          /* 0 store only */
          new Config(4, 4, 8, 4, deflate_fast),
          /* 1 max speed, no lazy matches */
          new Config(4, 5, 16, 8, deflate_fast),
          /* 2 */
          new Config(4, 6, 32, 32, deflate_fast),
          /* 3 */
          new Config(4, 4, 16, 16, deflate_slow),
          /* 4 lazy matches */
          new Config(8, 16, 32, 32, deflate_slow),
          /* 5 */
          new Config(8, 16, 128, 128, deflate_slow),
          /* 6 */
          new Config(8, 32, 128, 256, deflate_slow),
          /* 7 */
          new Config(32, 128, 258, 1024, deflate_slow),
          /* 8 */
          new Config(32, 258, 258, 4096, deflate_slow)
          /* 9 max compression */
          ];
          /* ===========================================================================
           * Initialize the "longest match" routines for a new zlib stream
           */

          function lm_init(s) {
            s.window_size = 2 * s.w_size;
            /*** CLEAR_HASH(s); ***/

            zero(s.head); // Fill with NIL (= 0);

            /* Set the default configuration parameters:
             */

            s.max_lazy_match = configuration_table[s.level].max_lazy;
            s.good_match = configuration_table[s.level].good_length;
            s.nice_match = configuration_table[s.level].nice_length;
            s.max_chain_length = configuration_table[s.level].max_chain;
            s.strstart = 0;
            s.block_start = 0;
            s.lookahead = 0;
            s.insert = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            s.ins_h = 0;
          }

          function DeflateState() {
            this.strm = null;
            /* pointer back to this zlib stream */

            this.status = 0;
            /* as the name implies */

            this.pending_buf = null;
            /* output still pending */

            this.pending_buf_size = 0;
            /* size of pending_buf */

            this.pending_out = 0;
            /* next pending byte to output to the stream */

            this.pending = 0;
            /* nb of bytes in the pending buffer */

            this.wrap = 0;
            /* bit 0 true for zlib, bit 1 true for gzip */

            this.gzhead = null;
            /* gzip header information to write */

            this.gzindex = 0;
            /* where in extra, name, or comment */

            this.method = Z_DEFLATED;
            /* can only be DEFLATED */

            this.last_flush = -1;
            /* value of flush param for previous deflate call */

            this.w_size = 0;
            /* LZ77 window size (32K by default) */

            this.w_bits = 0;
            /* log2(w_size)  (8..16) */

            this.w_mask = 0;
            /* w_size - 1 */

            this.window = null;
            /* Sliding window. Input bytes are read into the second half of the window,
             * and move to the first half later to keep a dictionary of at least wSize
             * bytes. With this organization, matches are limited to a distance of
             * wSize-MAX_MATCH bytes, but this ensures that IO is always
             * performed with a length multiple of the block size.
             */

            this.window_size = 0;
            /* Actual size of window: 2*wSize, except when the user input buffer
             * is directly used as sliding window.
             */

            this.prev = null;
            /* Link to older string with same hash index. To limit the size of this
             * array to 64K, this link is maintained only for the last 32K strings.
             * An index in this array is thus a window index modulo 32K.
             */

            this.head = null;
            /* Heads of the hash chains or NIL. */

            this.ins_h = 0;
            /* hash index of string to be inserted */

            this.hash_size = 0;
            /* number of elements in hash table */

            this.hash_bits = 0;
            /* log2(hash_size) */

            this.hash_mask = 0;
            /* hash_size-1 */

            this.hash_shift = 0;
            /* Number of bits by which ins_h must be shifted at each input
             * step. It must be such that after MIN_MATCH steps, the oldest
             * byte no longer takes part in the hash key, that is:
             *   hash_shift * MIN_MATCH >= hash_bits
             */

            this.block_start = 0;
            /* Window position at the beginning of the current output block. Gets
             * negative when the window is moved backwards.
             */

            this.match_length = 0;
            /* length of best match */

            this.prev_match = 0;
            /* previous match */

            this.match_available = 0;
            /* set if previous match exists */

            this.strstart = 0;
            /* start of string to insert */

            this.match_start = 0;
            /* start of matching string */

            this.lookahead = 0;
            /* number of valid bytes ahead in window */

            this.prev_length = 0;
            /* Length of the best match at previous step. Matches not greater than this
             * are discarded. This is used in the lazy match evaluation.
             */

            this.max_chain_length = 0;
            /* To speed up deflation, hash chains are never searched beyond this
             * length.  A higher limit improves compression ratio but degrades the
             * speed.
             */

            this.max_lazy_match = 0;
            /* Attempt to find a better match only when the current match is strictly
             * smaller than this value. This mechanism is used only for compression
             * levels >= 4.
             */
            // That's alias to max_lazy_match, don't use directly
            //this.max_insert_length = 0;

            /* Insert new strings in the hash table only if the match length is not
             * greater than this length. This saves time but degrades compression.
             * max_insert_length is used only for compression levels <= 3.
             */

            this.level = 0;
            /* compression level (1..9) */

            this.strategy = 0;
            /* favor or force Huffman coding*/

            this.good_match = 0;
            /* Use a faster search when the previous match is longer than this */

            this.nice_match = 0;
            /* Stop searching when current match exceeds this */

            /* used by trees.c: */

            /* Didn't use ct_data typedef below to suppress compiler warning */
            // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
            // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
            // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
            // Use flat array of DOUBLE size, with interleaved fata,
            // because JS does not support effective

            this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
            this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
            this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
            zero(this.dyn_ltree);
            zero(this.dyn_dtree);
            zero(this.bl_tree);
            this.l_desc = null;
            /* desc. for literal tree */

            this.d_desc = null;
            /* desc. for distance tree */

            this.bl_desc = null;
            /* desc. for bit length tree */
            //ush bl_count[MAX_BITS+1];

            this.bl_count = new utils.Buf16(MAX_BITS + 1);
            /* number of codes at each bit length for an optimal tree */
            //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */

            this.heap = new utils.Buf16(2 * L_CODES + 1);
            /* heap used to build the Huffman trees */

            zero(this.heap);
            this.heap_len = 0;
            /* number of elements in the heap */

            this.heap_max = 0;
            /* element of largest frequency */

            /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
             * The same heap array is used to build all trees.
             */

            this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];

            zero(this.depth);
            /* Depth of each subtree used as tie breaker for trees of equal frequency
             */

            this.l_buf = 0;
            /* buffer index for literals or lengths */

            this.lit_bufsize = 0;
            /* Size of match buffer for literals/lengths.  There are 4 reasons for
             * limiting lit_bufsize to 64K:
             *   - frequencies can be kept in 16 bit counters
             *   - if compression is not successful for the first block, all input
             *     data is still in the window so we can still emit a stored block even
             *     when input comes from standard input.  (This can also be done for
             *     all blocks if lit_bufsize is not greater than 32K.)
             *   - if compression is not successful for a file smaller than 64K, we can
             *     even emit a stored file instead of a stored block (saving 5 bytes).
             *     This is applicable only for zip (not gzip or zlib).
             *   - creating new Huffman trees less frequently may not provide fast
             *     adaptation to changes in the input data statistics. (Take for
             *     example a binary file with poorly compressible code followed by
             *     a highly compressible string table.) Smaller buffer sizes give
             *     fast adaptation but have of course the overhead of transmitting
             *     trees more frequently.
             *   - I can't count above 4
             */

            this.last_lit = 0;
            /* running index in l_buf */

            this.d_buf = 0;
            /* Buffer index for distances. To simplify the code, d_buf and l_buf have
             * the same number of elements. To use different lengths, an extra flag
             * array would be necessary.
             */

            this.opt_len = 0;
            /* bit length of current block with optimal trees */

            this.static_len = 0;
            /* bit length of current block with static trees */

            this.matches = 0;
            /* number of string matches in current block */

            this.insert = 0;
            /* bytes at end of window left to insert */

            this.bi_buf = 0;
            /* Output buffer. bits are inserted starting at the bottom (least
             * significant bits).
             */

            this.bi_valid = 0;
            /* Number of valid bits in bi_buf.  All bits above the last valid bit
             * are always zero.
             */
            // Used for window memory init. We safely ignore it for JS. That makes
            // sense only for pointers and memory check tools.
            //this.high_water = 0;

            /* High water mark offset in window for initialized bytes -- bytes above
             * this are set to zero in order to avoid memory check warnings when
             * longest match routines access bytes past the input.  This is then
             * updated to the new high water mark.
             */
          }

          function deflateResetKeep(strm) {
            var s;

            if (!strm || !strm.state) {
              return err(strm, Z_STREAM_ERROR);
            }

            strm.total_in = strm.total_out = 0;
            strm.data_type = Z_UNKNOWN;
            s = strm.state;
            s.pending = 0;
            s.pending_out = 0;

            if (s.wrap < 0) {
              s.wrap = -s.wrap;
              /* was made negative by deflate(..., Z_FINISH); */
            }

            s.status = s.wrap ? INIT_STATE : BUSY_STATE;
            strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
            : 1; // adler32(0, Z_NULL, 0)

            s.last_flush = Z_NO_FLUSH;

            trees._tr_init(s);

            return Z_OK;
          }

          function deflateReset(strm) {
            var ret = deflateResetKeep(strm);

            if (ret === Z_OK) {
              lm_init(strm.state);
            }

            return ret;
          }

          function deflateSetHeader(strm, head) {
            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }

            if (strm.state.wrap !== 2) {
              return Z_STREAM_ERROR;
            }

            strm.state.gzhead = head;
            return Z_OK;
          }

          function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
            if (!strm) {
              // === Z_NULL
              return Z_STREAM_ERROR;
            }

            var wrap = 1;

            if (level === Z_DEFAULT_COMPRESSION) {
              level = 6;
            }

            if (windowBits < 0) {
              /* suppress zlib wrapper */
              wrap = 0;
              windowBits = -windowBits;
            } else if (windowBits > 15) {
              wrap = 2;
              /* write gzip wrapper instead */

              windowBits -= 16;
            }

            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
              return err(strm, Z_STREAM_ERROR);
            }

            if (windowBits === 8) {
              windowBits = 9;
            }
            /* until 256-byte window bug fixed */


            var s = new DeflateState();
            strm.state = s;
            s.strm = strm;
            s.wrap = wrap;
            s.gzhead = null;
            s.w_bits = windowBits;
            s.w_size = 1 << s.w_bits;
            s.w_mask = s.w_size - 1;
            s.hash_bits = memLevel + 7;
            s.hash_size = 1 << s.hash_bits;
            s.hash_mask = s.hash_size - 1;
            s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
            s.window = new utils.Buf8(s.w_size * 2);
            s.head = new utils.Buf16(s.hash_size);
            s.prev = new utils.Buf16(s.w_size); // Don't need mem init magic for JS.
            //s.high_water = 0;  /* nothing written to s->window yet */

            s.lit_bufsize = 1 << memLevel + 6;
            /* 16K elements by default */

            s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
            //s->pending_buf = (uchf *) overlay;

            s.pending_buf = new utils.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
            //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

            s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

            s.l_buf = (1 + 2) * s.lit_bufsize;
            s.level = level;
            s.strategy = strategy;
            s.method = method;
            return deflateReset(strm);
          }

          function deflateInit(strm, level) {
            return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
          }

          function deflate(strm, flush) {
            var old_flush, s;
            var beg, val; // for gzip header write only

            if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
              return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
            }

            s = strm.state;

            if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
              return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
            }

            s.strm = strm;
            /* just in case */

            old_flush = s.last_flush;
            s.last_flush = flush;
            /* Write the header */

            if (s.status === INIT_STATE) {
              if (s.wrap === 2) {
                // GZIP header
                strm.adler = 0; //crc32(0L, Z_NULL, 0);

                put_byte(s, 31);
                put_byte(s, 139);
                put_byte(s, 8);

                if (!s.gzhead) {
                  // s->gzhead == Z_NULL
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, 0);
                  put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                  put_byte(s, OS_CODE);
                  s.status = BUSY_STATE;
                } else {
                  put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
                  put_byte(s, s.gzhead.time & 0xff);
                  put_byte(s, s.gzhead.time >> 8 & 0xff);
                  put_byte(s, s.gzhead.time >> 16 & 0xff);
                  put_byte(s, s.gzhead.time >> 24 & 0xff);
                  put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                  put_byte(s, s.gzhead.os & 0xff);

                  if (s.gzhead.extra && s.gzhead.extra.length) {
                    put_byte(s, s.gzhead.extra.length & 0xff);
                    put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
                  }

                  if (s.gzhead.hcrc) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                  }

                  s.gzindex = 0;
                  s.status = EXTRA_STATE;
                }
              } else // DEFLATE header
                {
                  var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                  var level_flags = -1;

                  if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                    level_flags = 0;
                  } else if (s.level < 6) {
                    level_flags = 1;
                  } else if (s.level === 6) {
                    level_flags = 2;
                  } else {
                    level_flags = 3;
                  }

                  header |= level_flags << 6;

                  if (s.strstart !== 0) {
                    header |= PRESET_DICT;
                  }

                  header += 31 - header % 31;
                  s.status = BUSY_STATE;
                  putShortMSB(s, header);
                  /* Save the adler32 of the preset dictionary: */

                  if (s.strstart !== 0) {
                    putShortMSB(s, strm.adler >>> 16);
                    putShortMSB(s, strm.adler & 0xffff);
                  }

                  strm.adler = 1; // adler32(0L, Z_NULL, 0);
                }
            } //#ifdef GZIP


            if (s.status === EXTRA_STATE) {
              if (s.gzhead.extra
              /* != Z_NULL*/
              ) {
                  beg = s.pending;
                  /* start of bytes to update crc */

                  while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
                    if (s.pending === s.pending_buf_size) {
                      if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                      }

                      flush_pending(strm);
                      beg = s.pending;

                      if (s.pending === s.pending_buf_size) {
                        break;
                      }
                    }

                    put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
                    s.gzindex++;
                  }

                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }

                  if (s.gzindex === s.gzhead.extra.length) {
                    s.gzindex = 0;
                    s.status = NAME_STATE;
                  }
                } else {
                s.status = NAME_STATE;
              }
            }

            if (s.status === NAME_STATE) {
              if (s.gzhead.name
              /* != Z_NULL*/
              ) {
                  beg = s.pending;
                  /* start of bytes to update crc */
                  //int val;

                  do {
                    if (s.pending === s.pending_buf_size) {
                      if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                      }

                      flush_pending(strm);
                      beg = s.pending;

                      if (s.pending === s.pending_buf_size) {
                        val = 1;
                        break;
                      }
                    } // JS specific: little magic to add zero terminator to end of string


                    if (s.gzindex < s.gzhead.name.length) {
                      val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                    } else {
                      val = 0;
                    }

                    put_byte(s, val);
                  } while (val !== 0);

                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }

                  if (val === 0) {
                    s.gzindex = 0;
                    s.status = COMMENT_STATE;
                  }
                } else {
                s.status = COMMENT_STATE;
              }
            }

            if (s.status === COMMENT_STATE) {
              if (s.gzhead.comment
              /* != Z_NULL*/
              ) {
                  beg = s.pending;
                  /* start of bytes to update crc */
                  //int val;

                  do {
                    if (s.pending === s.pending_buf_size) {
                      if (s.gzhead.hcrc && s.pending > beg) {
                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                      }

                      flush_pending(strm);
                      beg = s.pending;

                      if (s.pending === s.pending_buf_size) {
                        val = 1;
                        break;
                      }
                    } // JS specific: little magic to add zero terminator to end of string


                    if (s.gzindex < s.gzhead.comment.length) {
                      val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                    } else {
                      val = 0;
                    }

                    put_byte(s, val);
                  } while (val !== 0);

                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }

                  if (val === 0) {
                    s.status = HCRC_STATE;
                  }
                } else {
                s.status = HCRC_STATE;
              }
            }

            if (s.status === HCRC_STATE) {
              if (s.gzhead.hcrc) {
                if (s.pending + 2 > s.pending_buf_size) {
                  flush_pending(strm);
                }

                if (s.pending + 2 <= s.pending_buf_size) {
                  put_byte(s, strm.adler & 0xff);
                  put_byte(s, strm.adler >> 8 & 0xff);
                  strm.adler = 0; //crc32(0L, Z_NULL, 0);

                  s.status = BUSY_STATE;
                }
              } else {
                s.status = BUSY_STATE;
              }
            } //#endif

            /* Flush as much pending output as possible */


            if (s.pending !== 0) {
              flush_pending(strm);

              if (strm.avail_out === 0) {
                /* Since avail_out is 0, deflate will be called again with
                 * more output space, but possibly with both pending and
                 * avail_in equal to zero. There won't be anything to do,
                 * but this is not an error situation so make sure we
                 * return OK instead of BUF_ERROR at next call of deflate:
                 */
                s.last_flush = -1;
                return Z_OK;
              }
              /* Make sure there is something to do and avoid duplicate consecutive
               * flushes. For repeated and useless calls with Z_FINISH, we keep
               * returning Z_STREAM_END instead of Z_BUF_ERROR.
               */

            } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
              return err(strm, Z_BUF_ERROR);
            }
            /* User must not provide more input after the first FINISH: */


            if (s.status === FINISH_STATE && strm.avail_in !== 0) {
              return err(strm, Z_BUF_ERROR);
            }
            /* Start a new block or continue the current one.
             */


            if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
              var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

              if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                s.status = FINISH_STATE;
              }

              if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                if (strm.avail_out === 0) {
                  s.last_flush = -1;
                  /* avoid BUF_ERROR next call, see above */
                }

                return Z_OK;
                /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
                 * of deflate should use the same flush parameter to make sure
                 * that the flush is complete. So we don't have to output an
                 * empty block here, this will be done at next call. This also
                 * ensures that for a very small output buffer, we emit at most
                 * one empty block.
                 */
              }

              if (bstate === BS_BLOCK_DONE) {
                if (flush === Z_PARTIAL_FLUSH) {
                  trees._tr_align(s);
                } else if (flush !== Z_BLOCK) {
                  /* FULL_FLUSH or SYNC_FLUSH */
                  trees._tr_stored_block(s, 0, 0, false);
                  /* For a full flush, this empty block will be recognized
                   * as a special marker by inflate_sync().
                   */


                  if (flush === Z_FULL_FLUSH) {
                    /*** CLEAR_HASH(s); ***/

                    /* forget history */
                    zero(s.head); // Fill with NIL (= 0);

                    if (s.lookahead === 0) {
                      s.strstart = 0;
                      s.block_start = 0;
                      s.insert = 0;
                    }
                  }
                }

                flush_pending(strm);

                if (strm.avail_out === 0) {
                  s.last_flush = -1;
                  /* avoid BUF_ERROR at next call, see above */

                  return Z_OK;
                }
              }
            } //Assert(strm->avail_out > 0, "bug2");
            //if (strm.avail_out <= 0) { throw new Error("bug2");}


            if (flush !== Z_FINISH) {
              return Z_OK;
            }

            if (s.wrap <= 0) {
              return Z_STREAM_END;
            }
            /* Write the trailer */


            if (s.wrap === 2) {
              put_byte(s, strm.adler & 0xff);
              put_byte(s, strm.adler >> 8 & 0xff);
              put_byte(s, strm.adler >> 16 & 0xff);
              put_byte(s, strm.adler >> 24 & 0xff);
              put_byte(s, strm.total_in & 0xff);
              put_byte(s, strm.total_in >> 8 & 0xff);
              put_byte(s, strm.total_in >> 16 & 0xff);
              put_byte(s, strm.total_in >> 24 & 0xff);
            } else {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 0xffff);
            }

            flush_pending(strm);
            /* If avail_out is zero, the application will call deflate again
             * to flush the rest.
             */

            if (s.wrap > 0) {
              s.wrap = -s.wrap;
            }
            /* write the trailer only once! */


            return s.pending !== 0 ? Z_OK : Z_STREAM_END;
          }

          function deflateEnd(strm) {
            var status;

            if (!strm
            /*== Z_NULL*/
            || !strm.state
            /*== Z_NULL*/
            ) {
                return Z_STREAM_ERROR;
              }

            status = strm.state.status;

            if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
              return err(strm, Z_STREAM_ERROR);
            }

            strm.state = null;
            return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
          }
          /* =========================================================================
           * Initializes the compression dictionary from the given byte
           * sequence without producing any compressed output.
           */


          function deflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;
            var s;
            var str, n;
            var wrap;
            var avail;
            var next;
            var input;
            var tmpDict;

            if (!strm
            /*== Z_NULL*/
            || !strm.state
            /*== Z_NULL*/
            ) {
                return Z_STREAM_ERROR;
              }

            s = strm.state;
            wrap = s.wrap;

            if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
              return Z_STREAM_ERROR;
            }
            /* when using zlib wrappers, compute Adler-32 for provided dictionary */


            if (wrap === 1) {
              /* adler32(strm->adler, dictionary, dictLength); */
              strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
            }

            s.wrap = 0;
            /* avoid computing Adler-32 in read_buf */

            /* if dictionary would fill window, just replace the history */

            if (dictLength >= s.w_size) {
              if (wrap === 0) {
                /* already empty otherwise */

                /*** CLEAR_HASH(s); ***/
                zero(s.head); // Fill with NIL (= 0);

                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
              /* use the tail */
              // dictionary = dictionary.slice(dictLength - s.w_size);


              tmpDict = new utils.Buf8(s.w_size);
              utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
              dictionary = tmpDict;
              dictLength = s.w_size;
            }
            /* insert dictionary into window and hash */


            avail = strm.avail_in;
            next = strm.next_in;
            input = strm.input;
            strm.avail_in = dictLength;
            strm.next_in = 0;
            strm.input = dictionary;
            fill_window(s);

            while (s.lookahead >= MIN_MATCH) {
              str = s.strstart;
              n = s.lookahead - (MIN_MATCH - 1);

              do {
                /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
              } while (--n);

              s.strstart = str;
              s.lookahead = MIN_MATCH - 1;
              fill_window(s);
            }

            s.strstart += s.lookahead;
            s.block_start = s.strstart;
            s.insert = s.lookahead;
            s.lookahead = 0;
            s.match_length = s.prev_length = MIN_MATCH - 1;
            s.match_available = 0;
            strm.next_in = next;
            strm.input = input;
            strm.avail_in = avail;
            s.wrap = wrap;
            return Z_OK;
          }

          exports.deflateInit = deflateInit;
          exports.deflateInit2 = deflateInit2;
          exports.deflateReset = deflateReset;
          exports.deflateResetKeep = deflateResetKeep;
          exports.deflateSetHeader = deflateSetHeader;
          exports.deflate = deflate;
          exports.deflateEnd = deflateEnd;
          exports.deflateSetDictionary = deflateSetDictionary;
          exports.deflateInfo = 'pako deflate (from Nodeca project)';
          /* Not implemented
          exports.deflateBound = deflateBound;
          exports.deflateCopy = deflateCopy;
          exports.deflateParams = deflateParams;
          exports.deflatePending = deflatePending;
          exports.deflatePrime = deflatePrime;
          exports.deflateTune = deflateTune;
          */
        }, {
          "../utils/common": 41,
          "./adler32": 43,
          "./crc32": 45,
          "./messages": 51,
          "./trees": 52
        }],
        47: [function (require, module, exports) {
          'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          function GZheader() {
            /* true if compressed data believed to be text */
            this.text = 0;
            /* modification time */

            this.time = 0;
            /* extra flags (not used when writing a gzip file) */

            this.xflags = 0;
            /* operating system */

            this.os = 0;
            /* pointer to extra field or Z_NULL if none */

            this.extra = null;
            /* extra field length (valid if extra != Z_NULL) */

            this.extra_len = 0; // Actually, we don't need it in JS,
            // but leave for few code modifications
            //
            // Setup limits is not necessary because in js we should not preallocate memory
            // for inflate use constant limit in 65536 bytes
            //

            /* space at extra (only when reading header) */
            // this.extra_max  = 0;

            /* pointer to zero-terminated file name or Z_NULL */

            this.name = '';
            /* space at name (only when reading header) */
            // this.name_max   = 0;

            /* pointer to zero-terminated comment or Z_NULL */

            this.comment = '';
            /* space at comment (only when reading header) */
            // this.comm_max   = 0;

            /* true if there was or will be a header crc */

            this.hcrc = 0;
            /* true when done reading gzip header (not used when writing a gzip file) */

            this.done = false;
          }

          module.exports = GZheader;
        }, {}],
        48: [function (require, module, exports) {
          'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.
          // See state defs from inflate.js

          var BAD = 30;
          /* got a data error -- remain here until reset */

          var TYPE = 12;
          /* i: waiting for type bits, including last-flag bit */

          /*
             Decode literal, length, and distance codes and write out the resulting
             literal and match bytes until either not enough input or output is
             available, an end-of-block is encountered, or a data error is encountered.
             When large enough input and output buffers are supplied to inflate(), for
             example, a 16K input buffer and a 64K output buffer, more than 95% of the
             inflate execution time is spent in this routine.
          
             Entry assumptions:
          
                  state.mode === LEN
                  strm.avail_in >= 6
                  strm.avail_out >= 258
                  start >= strm.avail_out
                  state.bits < 8
          
             On return, state.mode is one of:
          
                  LEN -- ran out of enough output space or enough available input
                  TYPE -- reached end of block code, inflate() to interpret next block
                  BAD -- error in block data
          
             Notes:
          
              - The maximum input bits used by a length/distance pair is 15 bits for the
                length code, 5 bits for the length extra, 15 bits for the distance code,
                and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
                Therefore if strm.avail_in >= 6, then there is enough input to avoid
                checking for available input while decoding.
          
              - The maximum bytes that a single length/distance pair can output is 258
                bytes, which is the maximum length that can be coded.  inflate_fast()
                requires strm.avail_out >= 258 for each loop to avoid checking for
                output space.
           */

          module.exports = function inflate_fast(strm, start) {
            var state;

            var _in;
            /* local strm.input */


            var last;
            /* have enough input while in < last */

            var _out;
            /* local strm.output */


            var beg;
            /* inflate()'s initial strm.output */

            var end;
            /* while out < end, enough space available */
            //#ifdef INFLATE_STRICT

            var dmax;
            /* maximum distance from zlib header */
            //#endif

            var wsize;
            /* window size or zero if not using window */

            var whave;
            /* valid bytes in the window */

            var wnext;
            /* window write index */
            // Use `s_window` instead `window`, avoid conflict with instrumentation tools

            var s_window;
            /* allocated sliding window, if wsize != 0 */

            var hold;
            /* local strm.hold */

            var bits;
            /* local strm.bits */

            var lcode;
            /* local strm.lencode */

            var dcode;
            /* local strm.distcode */

            var lmask;
            /* mask for first level of length codes */

            var dmask;
            /* mask for first level of distance codes */

            var here;
            /* retrieved table entry */

            var op;
            /* code bits, operation, extra bits, or */

            /*  window position, window bytes to copy */

            var len;
            /* match length, unused bytes */

            var dist;
            /* match distance */

            var from;
            /* where to copy match from */

            var from_source;
            var input, output; // JS specific, because we have no pointers

            /* copy state to local variables */

            state = strm.state; //here = state.here;

            _in = strm.next_in;
            input = strm.input;
            last = _in + (strm.avail_in - 5);
            _out = strm.next_out;
            output = strm.output;
            beg = _out - (start - strm.avail_out);
            end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT

            dmax = state.dmax; //#endif

            wsize = state.wsize;
            whave = state.whave;
            wnext = state.wnext;
            s_window = state.window;
            hold = state.hold;
            bits = state.bits;
            lcode = state.lencode;
            dcode = state.distcode;
            lmask = (1 << state.lenbits) - 1;
            dmask = (1 << state.distbits) - 1;
            /* decode literals and length/distances until end-of-block or not enough
               input data or output space */

            top: do {
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }

              here = lcode[hold & lmask];

              dolen: for (;;) {
                // Goto emulation
                op = here >>> 24
                /*here.bits*/
                ;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 0xff
                /*here.op*/
                ;

                if (op === 0) {
                  /* literal */
                  //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                  //        "inflate:         literal '%c'\n" :
                  //        "inflate:         literal 0x%02x\n", here.val));
                  output[_out++] = here & 0xffff
                  /*here.val*/
                  ;
                } else if (op & 16) {
                  /* length base */
                  len = here & 0xffff
                  /*here.val*/
                  ;
                  op &= 15;
                  /* number of extra bits */

                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }

                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  } //Tracevv((stderr, "inflate:         length %u\n", len));


                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }

                  here = dcode[hold & dmask];

                  dodist: for (;;) {
                    // goto emulation
                    op = here >>> 24
                    /*here.bits*/
                    ;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 0xff
                    /*here.op*/
                    ;

                    if (op & 16) {
                      /* distance base */
                      dist = here & 0xffff
                      /*here.val*/
                      ;
                      op &= 15;
                      /* number of extra bits */

                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;

                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }

                      dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT

                      if (dist > dmax) {
                        strm.msg = 'invalid distance too far back';
                        state.mode = BAD;
                        break top;
                      } //#endif


                      hold >>>= op;
                      bits -= op; //Tracevv((stderr, "inflate:         distance %u\n", dist));

                      op = _out - beg;
                      /* max distance in output */

                      if (dist > op) {
                        /* see if copy from window */
                        op = dist - op;
                        /* distance back in window */

                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = 'invalid distance too far back';
                            state.mode = BAD;
                            break top;
                          } // (!) This block is disabled in zlib defailts,
                          // don't enable it for binary compatibility
                          //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                          //                if (len <= op - whave) {
                          //                  do {
                          //                    output[_out++] = 0;
                          //                  } while (--len);
                          //                  continue top;
                          //                }
                          //                len -= op - whave;
                          //                do {
                          //                  output[_out++] = 0;
                          //                } while (--op > whave);
                          //                if (op === 0) {
                          //                  from = _out - dist;
                          //                  do {
                          //                    output[_out++] = output[from++];
                          //                  } while (--len);
                          //                  continue top;
                          //                }
                          //#endif

                        }

                        from = 0; // window index

                        from_source = s_window;

                        if (wnext === 0) {
                          /* very common case */
                          from += wsize - op;

                          if (op < len) {
                            /* some from window */
                            len -= op;

                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);

                            from = _out - dist;
                            /* rest from output */

                            from_source = output;
                          }
                        } else if (wnext < op) {
                          /* wrap around window */
                          from += wsize + wnext - op;
                          op -= wnext;

                          if (op < len) {
                            /* some from end of window */
                            len -= op;

                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);

                            from = 0;

                            if (wnext < len) {
                              /* some from start of window */
                              op = wnext;
                              len -= op;

                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);

                              from = _out - dist;
                              /* rest from output */

                              from_source = output;
                            }
                          }
                        } else {
                          /* contiguous in window */
                          from += wnext - op;

                          if (op < len) {
                            /* some from window */
                            len -= op;

                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);

                            from = _out - dist;
                            /* rest from output */

                            from_source = output;
                          }
                        }

                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }

                        if (len) {
                          output[_out++] = from_source[from++];

                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        /* copy direct from output */

                        do {
                          /* minimum length is three */
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);

                        if (len) {
                          output[_out++] = output[from++];

                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      /* 2nd level distance code */
                      here = dcode[(here & 0xffff) + (
                      /*here.val*/
                      hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = 'invalid distance code';
                      state.mode = BAD;
                      break top;
                    }

                    break; // need to emulate goto via "continue"
                  }
                } else if ((op & 64) === 0) {
                  /* 2nd level length code */
                  here = lcode[(here & 0xffff) + (
                  /*here.val*/
                  hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  /* end-of-block */
                  //Tracevv((stderr, "inflate:         end of block\n"));
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = 'invalid literal/length code';
                  state.mode = BAD;
                  break top;
                }

                break; // need to emulate goto via "continue"
              }
            } while (_in < last && _out < end);
            /* return unused bytes (on entry, bits < 8, so in won't go too far back) */


            len = bits >> 3;
            _in -= len;
            bits -= len << 3;
            hold &= (1 << bits) - 1;
            /* update state and return */

            strm.next_in = _in;
            strm.next_out = _out;
            strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
            strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
            state.hold = hold;
            state.bits = bits;
            return;
          };
        }, {}],
        49: [function (require, module, exports) {
          'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          var utils = require('../utils/common');

          var adler32 = require('./adler32');

          var crc32 = require('./crc32');

          var inflate_fast = require('./inffast');

          var inflate_table = require('./inftrees');

          var CODES = 0;
          var LENS = 1;
          var DISTS = 2;
          /* Public constants ==========================================================*/

          /* ===========================================================================*/

          /* Allowed flush values; see deflate() and inflate() below for details */
          //var Z_NO_FLUSH      = 0;
          //var Z_PARTIAL_FLUSH = 1;
          //var Z_SYNC_FLUSH    = 2;
          //var Z_FULL_FLUSH    = 3;

          var Z_FINISH = 4;
          var Z_BLOCK = 5;
          var Z_TREES = 6;
          /* Return codes for the compression/decompression functions. Negative values
           * are errors, positive values are used for special but normal events.
           */

          var Z_OK = 0;
          var Z_STREAM_END = 1;
          var Z_NEED_DICT = 2; //var Z_ERRNO         = -1;

          var Z_STREAM_ERROR = -2;
          var Z_DATA_ERROR = -3;
          var Z_MEM_ERROR = -4;
          var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

          /* The deflate compression method */

          var Z_DEFLATED = 8;
          /* STATES ====================================================================*/

          /* ===========================================================================*/

          var HEAD = 1;
          /* i: waiting for magic header */

          var FLAGS = 2;
          /* i: waiting for method and flags (gzip) */

          var TIME = 3;
          /* i: waiting for modification time (gzip) */

          var OS = 4;
          /* i: waiting for extra flags and operating system (gzip) */

          var EXLEN = 5;
          /* i: waiting for extra length (gzip) */

          var EXTRA = 6;
          /* i: waiting for extra bytes (gzip) */

          var NAME = 7;
          /* i: waiting for end of file name (gzip) */

          var COMMENT = 8;
          /* i: waiting for end of comment (gzip) */

          var HCRC = 9;
          /* i: waiting for header crc (gzip) */

          var DICTID = 10;
          /* i: waiting for dictionary check value */

          var DICT = 11;
          /* waiting for inflateSetDictionary() call */

          var TYPE = 12;
          /* i: waiting for type bits, including last-flag bit */

          var TYPEDO = 13;
          /* i: same, but skip check to exit inflate on new block */

          var STORED = 14;
          /* i: waiting for stored size (length and complement) */

          var COPY_ = 15;
          /* i/o: same as COPY below, but only first time in */

          var COPY = 16;
          /* i/o: waiting for input or output to copy stored block */

          var TABLE = 17;
          /* i: waiting for dynamic block table lengths */

          var LENLENS = 18;
          /* i: waiting for code length code lengths */

          var CODELENS = 19;
          /* i: waiting for length/lit and distance code lengths */

          var LEN_ = 20;
          /* i: same as LEN below, but only first time in */

          var LEN = 21;
          /* i: waiting for length/lit/eob code */

          var LENEXT = 22;
          /* i: waiting for length extra bits */

          var DIST = 23;
          /* i: waiting for distance code */

          var DISTEXT = 24;
          /* i: waiting for distance extra bits */

          var MATCH = 25;
          /* o: waiting for output space to copy string */

          var LIT = 26;
          /* o: waiting for output space to write literal */

          var CHECK = 27;
          /* i: waiting for 32-bit check value */

          var LENGTH = 28;
          /* i: waiting for 32-bit length (gzip) */

          var DONE = 29;
          /* finished check, done -- remain here until reset */

          var BAD = 30;
          /* got a data error -- remain here until reset */

          var MEM = 31;
          /* got an inflate() memory error -- remain here until reset */

          var SYNC = 32;
          /* looking for synchronization bytes to restart inflate() */

          /* ===========================================================================*/

          var ENOUGH_LENS = 852;
          var ENOUGH_DISTS = 592; //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

          var MAX_WBITS = 15;
          /* 32K LZ77 window */

          var DEF_WBITS = MAX_WBITS;

          function zswap32(q) {
            return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
          }

          function InflateState() {
            this.mode = 0;
            /* current inflate mode */

            this.last = false;
            /* true if processing last block */

            this.wrap = 0;
            /* bit 0 true for zlib, bit 1 true for gzip */

            this.havedict = false;
            /* true if dictionary provided */

            this.flags = 0;
            /* gzip header method and flags (0 if zlib) */

            this.dmax = 0;
            /* zlib header max distance (INFLATE_STRICT) */

            this.check = 0;
            /* protected copy of check value */

            this.total = 0;
            /* protected copy of output count */
            // TODO: may be {}

            this.head = null;
            /* where to save gzip header information */

            /* sliding window */

            this.wbits = 0;
            /* log base 2 of requested window size */

            this.wsize = 0;
            /* window size or zero if not using window */

            this.whave = 0;
            /* valid bytes in the window */

            this.wnext = 0;
            /* window write index */

            this.window = null;
            /* allocated sliding window, if needed */

            /* bit accumulator */

            this.hold = 0;
            /* input bit accumulator */

            this.bits = 0;
            /* number of bits in "in" */

            /* for string and stored block copying */

            this.length = 0;
            /* literal or length of data to copy */

            this.offset = 0;
            /* distance back to copy string from */

            /* for table and code decoding */

            this.extra = 0;
            /* extra bits needed */

            /* fixed and dynamic code tables */

            this.lencode = null;
            /* starting table for length/literal codes */

            this.distcode = null;
            /* starting table for distance codes */

            this.lenbits = 0;
            /* index bits for lencode */

            this.distbits = 0;
            /* index bits for distcode */

            /* dynamic table building */

            this.ncode = 0;
            /* number of code length code lengths */

            this.nlen = 0;
            /* number of length code lengths */

            this.ndist = 0;
            /* number of distance code lengths */

            this.have = 0;
            /* number of code lengths in lens[] */

            this.next = null;
            /* next available space in codes[] */

            this.lens = new utils.Buf16(320);
            /* temporary storage for code lengths */

            this.work = new utils.Buf16(288);
            /* work area for code table building */

            /*
             because we don't have pointers in js, we use lencode and distcode directly
             as buffers so we don't need codes
            */
            //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */

            this.lendyn = null;
            /* dynamic table for length/literal codes (JS specific) */

            this.distdyn = null;
            /* dynamic table for distance codes (JS specific) */

            this.sane = 0;
            /* if false, allow invalid distance too far */

            this.back = 0;
            /* bits back of last unprocessed length/lit */

            this.was = 0;
            /* initial length of match */
          }

          function inflateResetKeep(strm) {
            var state;

            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }

            state = strm.state;
            strm.total_in = strm.total_out = state.total = 0;
            strm.msg = '';
            /*Z_NULL*/

            if (state.wrap) {
              /* to support ill-conceived Java test suite */
              strm.adler = state.wrap & 1;
            }

            state.mode = HEAD;
            state.last = 0;
            state.havedict = 0;
            state.dmax = 32768;
            state.head = null
            /*Z_NULL*/
            ;
            state.hold = 0;
            state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;

            state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
            state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
            state.sane = 1;
            state.back = -1; //Tracev((stderr, "inflate: reset\n"));

            return Z_OK;
          }

          function inflateReset(strm) {
            var state;

            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }

            state = strm.state;
            state.wsize = 0;
            state.whave = 0;
            state.wnext = 0;
            return inflateResetKeep(strm);
          }

          function inflateReset2(strm, windowBits) {
            var wrap;
            var state;
            /* get the state */

            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }

            state = strm.state;
            /* extract wrap request from windowBits parameter */

            if (windowBits < 0) {
              wrap = 0;
              windowBits = -windowBits;
            } else {
              wrap = (windowBits >> 4) + 1;

              if (windowBits < 48) {
                windowBits &= 15;
              }
            }
            /* set number of window bits, free window if different */


            if (windowBits && (windowBits < 8 || windowBits > 15)) {
              return Z_STREAM_ERROR;
            }

            if (state.window !== null && state.wbits !== windowBits) {
              state.window = null;
            }
            /* update state and reset the rest of it */


            state.wrap = wrap;
            state.wbits = windowBits;
            return inflateReset(strm);
          }

          function inflateInit2(strm, windowBits) {
            var ret;
            var state;

            if (!strm) {
              return Z_STREAM_ERROR;
            } //strm.msg = Z_NULL;                 /* in case we return an error */


            state = new InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;
            //Tracev((stderr, "inflate: allocated\n"));

            strm.state = state;
            state.window = null
            /*Z_NULL*/
            ;
            ret = inflateReset2(strm, windowBits);

            if (ret !== Z_OK) {
              strm.state = null
              /*Z_NULL*/
              ;
            }

            return ret;
          }

          function inflateInit(strm) {
            return inflateInit2(strm, DEF_WBITS);
          }
          /*
           Return state with length and distance decoding tables and index sizes set to
           fixed code decoding.  Normally this returns fixed tables from inffixed.h.
           If BUILDFIXED is defined, then instead this routine builds the tables the
           first time it's called, and returns those tables the first time and
           thereafter.  This reduces the size of the code by about 2K bytes, in
           exchange for a little execution time.  However, BUILDFIXED should not be
           used for threaded applications, since the rewriting of the tables and virgin
           may not be thread-safe.
           */


          var virgin = true;
          var lenfix, distfix; // We have no pointers in JS, so keep tables separate

          function fixedtables(state) {
            /* build fixed huffman tables if first call (may not be thread safe) */
            if (virgin) {
              var sym;
              lenfix = new utils.Buf32(512);
              distfix = new utils.Buf32(32);
              /* literal/length table */

              sym = 0;

              while (sym < 144) {
                state.lens[sym++] = 8;
              }

              while (sym < 256) {
                state.lens[sym++] = 9;
              }

              while (sym < 280) {
                state.lens[sym++] = 7;
              }

              while (sym < 288) {
                state.lens[sym++] = 8;
              }

              inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                bits: 9
              });
              /* distance table */

              sym = 0;

              while (sym < 32) {
                state.lens[sym++] = 5;
              }

              inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                bits: 5
              });
              /* do this just once */

              virgin = false;
            }

            state.lencode = lenfix;
            state.lenbits = 9;
            state.distcode = distfix;
            state.distbits = 5;
          }
          /*
           Update the window with the last wsize (normally 32K) bytes written before
           returning.  If window does not exist yet, create it.  This is only called
           when a window is already in use, or when output has been written during this
           inflate call, but the end of the deflate stream has not been reached yet.
           It is also called to create a window for dictionary data when a dictionary
           is loaded.
          
           Providing output buffers larger than 32K to inflate() should provide a speed
           advantage, since only the last 32K of output is copied to the sliding window
           upon return from inflate(), and since all distances after the first 32K of
           output will fall in the output data, making match copies simpler and faster.
           The advantage may be dependent on the size of the processor's data caches.
           */


          function updatewindow(strm, src, end, copy) {
            var dist;
            var state = strm.state;
            /* if it hasn't been done already, allocate space for the window */

            if (state.window === null) {
              state.wsize = 1 << state.wbits;
              state.wnext = 0;
              state.whave = 0;
              state.window = new utils.Buf8(state.wsize);
            }
            /* copy state->wsize or less output bytes into the circular window */


            if (copy >= state.wsize) {
              utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
              state.wnext = 0;
              state.whave = state.wsize;
            } else {
              dist = state.wsize - state.wnext;

              if (dist > copy) {
                dist = copy;
              } //zmemcpy(state->window + state->wnext, end - copy, dist);


              utils.arraySet(state.window, src, end - copy, dist, state.wnext);
              copy -= dist;

              if (copy) {
                //zmemcpy(state->window, end - copy, copy);
                utils.arraySet(state.window, src, end - copy, copy, 0);
                state.wnext = copy;
                state.whave = state.wsize;
              } else {
                state.wnext += dist;

                if (state.wnext === state.wsize) {
                  state.wnext = 0;
                }

                if (state.whave < state.wsize) {
                  state.whave += dist;
                }
              }
            }

            return 0;
          }

          function inflate(strm, flush) {
            var state;
            var input, output; // input/output buffers

            var next;
            /* next input INDEX */

            var put;
            /* next output INDEX */

            var have, left;
            /* available input and output */

            var hold;
            /* bit buffer */

            var bits;
            /* bits in bit buffer */

            var _in, _out;
            /* save starting available input and output */


            var copy;
            /* number of stored or match bytes to copy */

            var from;
            /* where to copy match bytes from */

            var from_source;
            var here = 0;
            /* current decoding table entry */

            var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
            //var last;                   /* parent table entry */

            var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)

            var len;
            /* length to copy for repeats, bits to drop */

            var ret;
            /* return code */

            var hbuf = new utils.Buf8(4);
            /* buffer for gzip header crc calculation */

            var opts;
            var n; // temporary var for NEED_BITS

            var order =
            /* permutation of code lengths */
            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

            if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
              return Z_STREAM_ERROR;
            }

            state = strm.state;

            if (state.mode === TYPE) {
              state.mode = TYPEDO;
            }
            /* skip check */
            //--- LOAD() ---


            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits; //---

            _in = have;
            _out = left;
            ret = Z_OK;

            inf_leave: // goto emulation
            for (;;) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                  } //=== NEEDBITS(16);


                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  } //===//


                  if (state.wrap & 2 && hold === 0x8b1f) {
                    /* gzip header */
                    state.check = 0
                    /*crc32(0L, Z_NULL, 0)*/
                    ; //=== CRC2(state.check, hold);

                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32(state.check, hbuf, 2, 0); //===//
                    //=== INITBITS();

                    hold = 0;
                    bits = 0; //===//

                    state.mode = FLAGS;
                    break;
                  }

                  state.flags = 0;
                  /* expect zlib header */

                  if (state.head) {
                    state.head.done = false;
                  }

                  if (!(state.wrap & 1) ||
                  /* check if zlib header allowed */
                  (((hold & 0xff) <<
                  /*BITS(8)*/
                  8) + (hold >> 8)) % 31) {
                    strm.msg = 'incorrect header check';
                    state.mode = BAD;
                    break;
                  }

                  if ((hold & 0x0f) !==
                  /*BITS(4)*/
                  Z_DEFLATED) {
                    strm.msg = 'unknown compression method';
                    state.mode = BAD;
                    break;
                  } //--- DROPBITS(4) ---//


                  hold >>>= 4;
                  bits -= 4; //---//

                  len = (hold & 0x0f) +
                  /*BITS(4)*/
                  8;

                  if (state.wbits === 0) {
                    state.wbits = len;
                  } else if (len > state.wbits) {
                    strm.msg = 'invalid window size';
                    state.mode = BAD;
                    break;
                  }

                  state.dmax = 1 << len; //Tracev((stderr, "inflate:   zlib header ok\n"));

                  strm.adler = state.check = 1
                  /*adler32(0L, Z_NULL, 0)*/
                  ;
                  state.mode = hold & 0x200 ? DICTID : TYPE; //=== INITBITS();

                  hold = 0;
                  bits = 0; //===//

                  break;

                case FLAGS:
                  //=== NEEDBITS(16); */
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  } //===//


                  state.flags = hold;

                  if ((state.flags & 0xff) !== Z_DEFLATED) {
                    strm.msg = 'unknown compression method';
                    state.mode = BAD;
                    break;
                  }

                  if (state.flags & 0xe000) {
                    strm.msg = 'unknown header flags set';
                    state.mode = BAD;
                    break;
                  }

                  if (state.head) {
                    state.head.text = hold >> 8 & 1;
                  }

                  if (state.flags & 0x0200) {
                    //=== CRC2(state.check, hold);
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32(state.check, hbuf, 2, 0); //===//
                  } //=== INITBITS();


                  hold = 0;
                  bits = 0; //===//

                  state.mode = TIME;

                /* falls through */

                case TIME:
                  //=== NEEDBITS(32); */
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  } //===//


                  if (state.head) {
                    state.head.time = hold;
                  }

                  if (state.flags & 0x0200) {
                    //=== CRC4(state.check, hold)
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    hbuf[2] = hold >>> 16 & 0xff;
                    hbuf[3] = hold >>> 24 & 0xff;
                    state.check = crc32(state.check, hbuf, 4, 0); //===
                  } //=== INITBITS();


                  hold = 0;
                  bits = 0; //===//

                  state.mode = OS;

                /* falls through */

                case OS:
                  //=== NEEDBITS(16); */
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  } //===//


                  if (state.head) {
                    state.head.xflags = hold & 0xff;
                    state.head.os = hold >> 8;
                  }

                  if (state.flags & 0x0200) {
                    //=== CRC2(state.check, hold);
                    hbuf[0] = hold & 0xff;
                    hbuf[1] = hold >>> 8 & 0xff;
                    state.check = crc32(state.check, hbuf, 2, 0); //===//
                  } //=== INITBITS();


                  hold = 0;
                  bits = 0; //===//

                  state.mode = EXLEN;

                /* falls through */

                case EXLEN:
                  if (state.flags & 0x0400) {
                    //=== NEEDBITS(16); */
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    } //===//


                    state.length = hold;

                    if (state.head) {
                      state.head.extra_len = hold;
                    }

                    if (state.flags & 0x0200) {
                      //=== CRC2(state.check, hold);
                      hbuf[0] = hold & 0xff;
                      hbuf[1] = hold >>> 8 & 0xff;
                      state.check = crc32(state.check, hbuf, 2, 0); //===//
                    } //=== INITBITS();


                    hold = 0;
                    bits = 0; //===//
                  } else if (state.head) {
                    state.head.extra = null
                    /*Z_NULL*/
                    ;
                  }

                  state.mode = EXTRA;

                /* falls through */

                case EXTRA:
                  if (state.flags & 0x0400) {
                    copy = state.length;

                    if (copy > have) {
                      copy = have;
                    }

                    if (copy) {
                      if (state.head) {
                        len = state.head.extra_len - state.length;

                        if (!state.head.extra) {
                          // Use untyped array for more conveniend processing later
                          state.head.extra = new Array(state.head.extra_len);
                        }

                        utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        copy,
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        len); //zmemcpy(state.head.extra + len, next,
                        //        len + copy > state.head.extra_max ?
                        //        state.head.extra_max - len : copy);
                      }

                      if (state.flags & 0x0200) {
                        state.check = crc32(state.check, input, copy, next);
                      }

                      have -= copy;
                      next += copy;
                      state.length -= copy;
                    }

                    if (state.length) {
                      break inf_leave;
                    }
                  }

                  state.length = 0;
                  state.mode = NAME;

                /* falls through */

                case NAME:
                  if (state.flags & 0x0800) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    copy = 0;

                    do {
                      // TODO: 2 or 1 bytes?
                      len = input[next + copy++];
                      /* use constant limit because in js we should not preallocate memory */

                      if (state.head && len && state.length < 65536
                      /*state.head.name_max*/
                      ) {
                        state.head.name += String.fromCharCode(len);
                      }
                    } while (len && copy < have);

                    if (state.flags & 0x0200) {
                      state.check = crc32(state.check, input, copy, next);
                    }

                    have -= copy;
                    next += copy;

                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.name = null;
                  }

                  state.length = 0;
                  state.mode = COMMENT;

                /* falls through */

                case COMMENT:
                  if (state.flags & 0x1000) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    copy = 0;

                    do {
                      len = input[next + copy++];
                      /* use constant limit because in js we should not preallocate memory */

                      if (state.head && len && state.length < 65536
                      /*state.head.comm_max*/
                      ) {
                        state.head.comment += String.fromCharCode(len);
                      }
                    } while (len && copy < have);

                    if (state.flags & 0x0200) {
                      state.check = crc32(state.check, input, copy, next);
                    }

                    have -= copy;
                    next += copy;

                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.comment = null;
                  }

                  state.mode = HCRC;

                /* falls through */

                case HCRC:
                  if (state.flags & 0x0200) {
                    //=== NEEDBITS(16); */
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    } //===//


                    if (hold !== (state.check & 0xffff)) {
                      strm.msg = 'header crc mismatch';
                      state.mode = BAD;
                      break;
                    } //=== INITBITS();


                    hold = 0;
                    bits = 0; //===//
                  }

                  if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                  }

                  strm.adler = state.check = 0;
                  state.mode = TYPE;
                  break;

                case DICTID:
                  //=== NEEDBITS(32); */
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  } //===//


                  strm.adler = state.check = zswap32(hold); //=== INITBITS();

                  hold = 0;
                  bits = 0; //===//

                  state.mode = DICT;

                /* falls through */

                case DICT:
                  if (state.havedict === 0) {
                    //--- RESTORE() ---
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits; //---

                    return Z_NEED_DICT;
                  }

                  strm.adler = state.check = 1
                  /*adler32(0L, Z_NULL, 0)*/
                  ;
                  state.mode = TYPE;

                /* falls through */

                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                  }

                /* falls through */

                case TYPEDO:
                  if (state.last) {
                    //--- BYTEBITS() ---//
                    hold >>>= bits & 7;
                    bits -= bits & 7; //---//

                    state.mode = CHECK;
                    break;
                  } //=== NEEDBITS(3); */


                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  } //===//


                  state.last = hold & 0x01
                  /*BITS(1)*/
                  ; //--- DROPBITS(1) ---//

                  hold >>>= 1;
                  bits -= 1; //---//

                  switch (hold & 0x03) {
                    /*BITS(2)*/
                    case 0:
                      /* stored block */
                      //Tracev((stderr, "inflate:     stored block%s\n",
                      //        state.last ? " (last)" : ""));
                      state.mode = STORED;
                      break;

                    case 1:
                      /* fixed block */
                      fixedtables(state); //Tracev((stderr, "inflate:     fixed codes block%s\n",
                      //        state.last ? " (last)" : ""));

                      state.mode = LEN_;
                      /* decode codes */

                      if (flush === Z_TREES) {
                        //--- DROPBITS(2) ---//
                        hold >>>= 2;
                        bits -= 2; //---//

                        break inf_leave;
                      }

                      break;

                    case 2:
                      /* dynamic block */
                      //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                      //        state.last ? " (last)" : ""));
                      state.mode = TABLE;
                      break;

                    case 3:
                      strm.msg = 'invalid block type';
                      state.mode = BAD;
                  } //--- DROPBITS(2) ---//


                  hold >>>= 2;
                  bits -= 2; //---//

                  break;

                case STORED:
                  //--- BYTEBITS() ---// /* go to byte boundary */
                  hold >>>= bits & 7;
                  bits -= bits & 7; //---//
                  //=== NEEDBITS(32); */

                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  } //===//


                  if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
                    strm.msg = 'invalid stored block lengths';
                    state.mode = BAD;
                    break;
                  }

                  state.length = hold & 0xffff; //Tracev((stderr, "inflate:       stored length %u\n",
                  //        state.length));
                  //=== INITBITS();

                  hold = 0;
                  bits = 0; //===//

                  state.mode = COPY_;

                  if (flush === Z_TREES) {
                    break inf_leave;
                  }

                /* falls through */

                case COPY_:
                  state.mode = COPY;

                /* falls through */

                case COPY:
                  copy = state.length;

                  if (copy) {
                    if (copy > have) {
                      copy = have;
                    }

                    if (copy > left) {
                      copy = left;
                    }

                    if (copy === 0) {
                      break inf_leave;
                    } //--- zmemcpy(put, next, copy); ---


                    utils.arraySet(output, input, next, copy, put); //---//

                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                  } //Tracev((stderr, "inflate:       stored end\n"));


                  state.mode = TYPE;
                  break;

                case TABLE:
                  //=== NEEDBITS(14); */
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  } //===//


                  state.nlen = (hold & 0x1f) +
                  /*BITS(5)*/
                  257; //--- DROPBITS(5) ---//

                  hold >>>= 5;
                  bits -= 5; //---//

                  state.ndist = (hold & 0x1f) +
                  /*BITS(5)*/
                  1; //--- DROPBITS(5) ---//

                  hold >>>= 5;
                  bits -= 5; //---//

                  state.ncode = (hold & 0x0f) +
                  /*BITS(4)*/
                  4; //--- DROPBITS(4) ---//

                  hold >>>= 4;
                  bits -= 4; //---//
                  //#ifndef PKZIP_BUG_WORKAROUND

                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = 'too many length or distance symbols';
                    state.mode = BAD;
                    break;
                  } //#endif
                  //Tracev((stderr, "inflate:       table sizes ok\n"));


                  state.have = 0;
                  state.mode = LENLENS;

                /* falls through */

                case LENLENS:
                  while (state.have < state.ncode) {
                    //=== NEEDBITS(3);
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    } //===//


                    state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
                    //--- DROPBITS(3) ---//

                    hold >>>= 3;
                    bits -= 3; //---//
                  }

                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                  } // We have separate tables & no pointers. 2 commented lines below not needed.
                  //state.next = state.codes;
                  //state.lencode = state.next;
                  // Switch to use dynamic table


                  state.lencode = state.lendyn;
                  state.lenbits = 7;
                  opts = {
                    bits: state.lenbits
                  };
                  ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;

                  if (ret) {
                    strm.msg = 'invalid code lengths set';
                    state.mode = BAD;
                    break;
                  } //Tracev((stderr, "inflate:       code lengths ok\n"));


                  state.have = 0;
                  state.mode = CODELENS;

                /* falls through */

                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (;;) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      /*BITS(state.lenbits)*/

                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 0xff;
                      here_val = here & 0xffff;

                      if (here_bits <= bits) {
                        break;
                      } //--- PULLBYTE() ---//


                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8; //---//
                    }

                    if (here_val < 16) {
                      //--- DROPBITS(here.bits) ---//
                      hold >>>= here_bits;
                      bits -= here_bits; //---//

                      state.lens[state.have++] = here_val;
                    } else {
                      if (here_val === 16) {
                        //=== NEEDBITS(here.bits + 2);
                        n = here_bits + 2;

                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }

                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        } //===//
                        //--- DROPBITS(here.bits) ---//


                        hold >>>= here_bits;
                        bits -= here_bits; //---//

                        if (state.have === 0) {
                          strm.msg = 'invalid bit length repeat';
                          state.mode = BAD;
                          break;
                        }

                        len = state.lens[state.have - 1];
                        copy = 3 + (hold & 0x03); //BITS(2);
                        //--- DROPBITS(2) ---//

                        hold >>>= 2;
                        bits -= 2; //---//
                      } else if (here_val === 17) {
                        //=== NEEDBITS(here.bits + 3);
                        n = here_bits + 3;

                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }

                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        } //===//
                        //--- DROPBITS(here.bits) ---//


                        hold >>>= here_bits;
                        bits -= here_bits; //---//

                        len = 0;
                        copy = 3 + (hold & 0x07); //BITS(3);
                        //--- DROPBITS(3) ---//

                        hold >>>= 3;
                        bits -= 3; //---//
                      } else {
                        //=== NEEDBITS(here.bits + 7);
                        n = here_bits + 7;

                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }

                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        } //===//
                        //--- DROPBITS(here.bits) ---//


                        hold >>>= here_bits;
                        bits -= here_bits; //---//

                        len = 0;
                        copy = 11 + (hold & 0x7f); //BITS(7);
                        //--- DROPBITS(7) ---//

                        hold >>>= 7;
                        bits -= 7; //---//
                      }

                      if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = 'invalid bit length repeat';
                        state.mode = BAD;
                        break;
                      }

                      while (copy--) {
                        state.lens[state.have++] = len;
                      }
                    }
                  }
                  /* handle error breaks in while */


                  if (state.mode === BAD) {
                    break;
                  }
                  /* check for end-of-block code (better have one) */


                  if (state.lens[256] === 0) {
                    strm.msg = 'invalid code -- missing end-of-block';
                    state.mode = BAD;
                    break;
                  }
                  /* build code tables -- note: do not change the lenbits or distbits
                     values here (9 and 6) without reading the comments in inftrees.h
                     concerning the ENOUGH constants, which depend on those values */


                  state.lenbits = 9;
                  opts = {
                    bits: state.lenbits
                  };
                  ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
                  // state.next_index = opts.table_index;

                  state.lenbits = opts.bits; // state.lencode = state.next;

                  if (ret) {
                    strm.msg = 'invalid literal/lengths set';
                    state.mode = BAD;
                    break;
                  }

                  state.distbits = 6; //state.distcode.copy(state.codes);
                  // Switch to use dynamic table

                  state.distcode = state.distdyn;
                  opts = {
                    bits: state.distbits
                  };
                  ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
                  // state.next_index = opts.table_index;

                  state.distbits = opts.bits; // state.distcode = state.next;

                  if (ret) {
                    strm.msg = 'invalid distances set';
                    state.mode = BAD;
                    break;
                  } //Tracev((stderr, 'inflate:       codes ok\n'));


                  state.mode = LEN_;

                  if (flush === Z_TREES) {
                    break inf_leave;
                  }

                /* falls through */

                case LEN_:
                  state.mode = LEN;

                /* falls through */

                case LEN:
                  if (have >= 6 && left >= 258) {
                    //--- RESTORE() ---
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits; //---

                    inflate_fast(strm, _out); //--- LOAD() ---

                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits; //---

                    if (state.mode === TYPE) {
                      state.back = -1;
                    }

                    break;
                  }

                  state.back = 0;

                  for (;;) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    /*BITS(state.lenbits)*/

                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 0xff;
                    here_val = here & 0xffff;

                    if (here_bits <= bits) {
                      break;
                    } //--- PULLBYTE() ---//


                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8; //---//
                  }

                  if (here_op && (here_op & 0xf0) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;

                    for (;;) {
                      here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
                      /*BITS(last.bits + last.op)*/
                      last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 0xff;
                      here_val = here & 0xffff;

                      if (last_bits + here_bits <= bits) {
                        break;
                      } //--- PULLBYTE() ---//


                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8; //---//
                    } //--- DROPBITS(last.bits) ---//


                    hold >>>= last_bits;
                    bits -= last_bits; //---//

                    state.back += last_bits;
                  } //--- DROPBITS(here.bits) ---//


                  hold >>>= here_bits;
                  bits -= here_bits; //---//

                  state.back += here_bits;
                  state.length = here_val;

                  if (here_op === 0) {
                    //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                    //        "inflate:         literal '%c'\n" :
                    //        "inflate:         literal 0x%02x\n", here.val));
                    state.mode = LIT;
                    break;
                  }

                  if (here_op & 32) {
                    //Tracevv((stderr, "inflate:         end of block\n"));
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                  }

                  if (here_op & 64) {
                    strm.msg = 'invalid literal/length code';
                    state.mode = BAD;
                    break;
                  }

                  state.extra = here_op & 15;
                  state.mode = LENEXT;

                /* falls through */

                case LENEXT:
                  if (state.extra) {
                    //=== NEEDBITS(state.extra);
                    n = state.extra;

                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    } //===//


                    state.length += hold & (1 << state.extra) - 1
                    /*BITS(state.extra)*/
                    ; //--- DROPBITS(state.extra) ---//

                    hold >>>= state.extra;
                    bits -= state.extra; //---//

                    state.back += state.extra;
                  } //Tracevv((stderr, "inflate:         length %u\n", state.length));


                  state.was = state.length;
                  state.mode = DIST;

                /* falls through */

                case DIST:
                  for (;;) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    /*BITS(state.distbits)*/

                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 0xff;
                    here_val = here & 0xffff;

                    if (here_bits <= bits) {
                      break;
                    } //--- PULLBYTE() ---//


                    if (have === 0) {
                      break inf_leave;
                    }

                    have--;
                    hold += input[next++] << bits;
                    bits += 8; //---//
                  }

                  if ((here_op & 0xf0) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;

                    for (;;) {
                      here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
                      /*BITS(last.bits + last.op)*/
                      last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 0xff;
                      here_val = here & 0xffff;

                      if (last_bits + here_bits <= bits) {
                        break;
                      } //--- PULLBYTE() ---//


                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8; //---//
                    } //--- DROPBITS(last.bits) ---//


                    hold >>>= last_bits;
                    bits -= last_bits; //---//

                    state.back += last_bits;
                  } //--- DROPBITS(here.bits) ---//


                  hold >>>= here_bits;
                  bits -= here_bits; //---//

                  state.back += here_bits;

                  if (here_op & 64) {
                    strm.msg = 'invalid distance code';
                    state.mode = BAD;
                    break;
                  }

                  state.offset = here_val;
                  state.extra = here_op & 15;
                  state.mode = DISTEXT;

                /* falls through */

                case DISTEXT:
                  if (state.extra) {
                    //=== NEEDBITS(state.extra);
                    n = state.extra;

                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    } //===//


                    state.offset += hold & (1 << state.extra) - 1
                    /*BITS(state.extra)*/
                    ; //--- DROPBITS(state.extra) ---//

                    hold >>>= state.extra;
                    bits -= state.extra; //---//

                    state.back += state.extra;
                  } //#ifdef INFLATE_STRICT


                  if (state.offset > state.dmax) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break;
                  } //#endif
                  //Tracevv((stderr, "inflate:         distance %u\n", state.offset));


                  state.mode = MATCH;

                /* falls through */

                case MATCH:
                  if (left === 0) {
                    break inf_leave;
                  }

                  copy = _out - left;

                  if (state.offset > copy) {
                    /* copy from window */
                    copy = state.offset - copy;

                    if (copy > state.whave) {
                      if (state.sane) {
                        strm.msg = 'invalid distance too far back';
                        state.mode = BAD;
                        break;
                      } // (!) This block is disabled in zlib defailts,
                      // don't enable it for binary compatibility
                      //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                      //          Trace((stderr, "inflate.c too far\n"));
                      //          copy -= state.whave;
                      //          if (copy > state.length) { copy = state.length; }
                      //          if (copy > left) { copy = left; }
                      //          left -= copy;
                      //          state.length -= copy;
                      //          do {
                      //            output[put++] = 0;
                      //          } while (--copy);
                      //          if (state.length === 0) { state.mode = LEN; }
                      //          break;
                      //#endif

                    }

                    if (copy > state.wnext) {
                      copy -= state.wnext;
                      from = state.wsize - copy;
                    } else {
                      from = state.wnext - copy;
                    }

                    if (copy > state.length) {
                      copy = state.length;
                    }

                    from_source = state.window;
                  } else {
                    /* copy from output */
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                  }

                  if (copy > left) {
                    copy = left;
                  }

                  left -= copy;
                  state.length -= copy;

                  do {
                    output[put++] = from_source[from++];
                  } while (--copy);

                  if (state.length === 0) {
                    state.mode = LEN;
                  }

                  break;

                case LIT:
                  if (left === 0) {
                    break inf_leave;
                  }

                  output[put++] = state.length;
                  left--;
                  state.mode = LEN;
                  break;

                case CHECK:
                  if (state.wrap) {
                    //=== NEEDBITS(32);
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--; // Use '|' insdead of '+' to make sure that result is signed

                      hold |= input[next++] << bits;
                      bits += 8;
                    } //===//


                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;

                    if (_out) {
                      strm.adler = state.check =
                      /*UPDATE(state.check, put - _out, _out);*/
                      state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }

                    _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too

                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                      strm.msg = 'incorrect data check';
                      state.mode = BAD;
                      break;
                    } //=== INITBITS();


                    hold = 0;
                    bits = 0; //===//
                    //Tracev((stderr, "inflate:   check matches trailer\n"));
                  }

                  state.mode = LENGTH;

                /* falls through */

                case LENGTH:
                  if (state.wrap && state.flags) {
                    //=== NEEDBITS(32);
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }

                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    } //===//


                    if (hold !== (state.total & 0xffffffff)) {
                      strm.msg = 'incorrect length check';
                      state.mode = BAD;
                      break;
                    } //=== INITBITS();


                    hold = 0;
                    bits = 0; //===//
                    //Tracev((stderr, "inflate:   length matches trailer\n"));
                  }

                  state.mode = DONE;

                /* falls through */

                case DONE:
                  ret = Z_STREAM_END;
                  break inf_leave;

                case BAD:
                  ret = Z_DATA_ERROR;
                  break inf_leave;

                case MEM:
                  return Z_MEM_ERROR;

                case SYNC:
                /* falls through */

                default:
                  return Z_STREAM_ERROR;
              }
            } // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

            /*
               Return from inflate(), updating the total counts and the check value.
               If there was no progress during the inflate() call, return a buffer
               error.  Call updatewindow() to create and/or update the window state.
               Note: a memory error from inflate() is non-recoverable.
             */
            //--- RESTORE() ---


            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits; //---

            if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
              if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                state.mode = MEM;
                return Z_MEM_ERROR;
              }
            }

            _in -= strm.avail_in;
            _out -= strm.avail_out;
            strm.total_in += _in;
            strm.total_out += _out;
            state.total += _out;

            if (state.wrap && _out) {
              strm.adler = state.check =
              /*UPDATE(state.check, strm.next_out - _out, _out);*/
              state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
            }

            strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);

            if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
              ret = Z_BUF_ERROR;
            }

            return ret;
          }

          function inflateEnd(strm) {
            if (!strm || !strm.state
            /*|| strm->zfree == (free_func)0*/
            ) {
                return Z_STREAM_ERROR;
              }

            var state = strm.state;

            if (state.window) {
              state.window = null;
            }

            strm.state = null;
            return Z_OK;
          }

          function inflateGetHeader(strm, head) {
            var state;
            /* check state */

            if (!strm || !strm.state) {
              return Z_STREAM_ERROR;
            }

            state = strm.state;

            if ((state.wrap & 2) === 0) {
              return Z_STREAM_ERROR;
            }
            /* save header structure */


            state.head = head;
            head.done = false;
            return Z_OK;
          }

          function inflateSetDictionary(strm, dictionary) {
            var dictLength = dictionary.length;
            var state;
            var dictid;
            var ret;
            /* check state */

            if (!strm
            /* == Z_NULL */
            || !strm.state
            /* == Z_NULL */
            ) {
                return Z_STREAM_ERROR;
              }

            state = strm.state;

            if (state.wrap !== 0 && state.mode !== DICT) {
              return Z_STREAM_ERROR;
            }
            /* check for correct dictionary identifier */


            if (state.mode === DICT) {
              dictid = 1;
              /* adler32(0, null, 0)*/

              /* dictid = adler32(dictid, dictionary, dictLength); */

              dictid = adler32(dictid, dictionary, dictLength, 0);

              if (dictid !== state.check) {
                return Z_DATA_ERROR;
              }
            }
            /* copy dictionary to window using updatewindow(), which will amend the
             existing dictionary if appropriate */


            ret = updatewindow(strm, dictionary, dictLength, dictLength);

            if (ret) {
              state.mode = MEM;
              return Z_MEM_ERROR;
            }

            state.havedict = 1; // Tracev((stderr, "inflate:   dictionary set\n"));

            return Z_OK;
          }

          exports.inflateReset = inflateReset;
          exports.inflateReset2 = inflateReset2;
          exports.inflateResetKeep = inflateResetKeep;
          exports.inflateInit = inflateInit;
          exports.inflateInit2 = inflateInit2;
          exports.inflate = inflate;
          exports.inflateEnd = inflateEnd;
          exports.inflateGetHeader = inflateGetHeader;
          exports.inflateSetDictionary = inflateSetDictionary;
          exports.inflateInfo = 'pako inflate (from Nodeca project)';
          /* Not implemented
          exports.inflateCopy = inflateCopy;
          exports.inflateGetDictionary = inflateGetDictionary;
          exports.inflateMark = inflateMark;
          exports.inflatePrime = inflatePrime;
          exports.inflateSync = inflateSync;
          exports.inflateSyncPoint = inflateSyncPoint;
          exports.inflateUndermine = inflateUndermine;
          */
        }, {
          "../utils/common": 41,
          "./adler32": 43,
          "./crc32": 45,
          "./inffast": 48,
          "./inftrees": 50
        }],
        50: [function (require, module, exports) {
          'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          var utils = require('../utils/common');

          var MAXBITS = 15;
          var ENOUGH_LENS = 852;
          var ENOUGH_DISTS = 592; //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

          var CODES = 0;
          var LENS = 1;
          var DISTS = 2;
          var lbase = [
          /* Length codes 257..285 base */
          3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
          var lext = [
          /* Length codes 257..285 extra */
          16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
          var dbase = [
          /* Distance codes 0..29 base */
          1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
          var dext = [
          /* Distance codes 0..29 extra */
          16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

          module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
            var bits = opts.bits; //here = opts.here; /* table entry for duplication */

            var len = 0;
            /* a code's length in bits */

            var sym = 0;
            /* index of code symbols */

            var min = 0,
                max = 0;
            /* minimum and maximum code lengths */

            var root = 0;
            /* number of index bits for root table */

            var curr = 0;
            /* number of index bits for current table */

            var drop = 0;
            /* code bits to drop for sub-table */

            var left = 0;
            /* number of prefix codes available */

            var used = 0;
            /* code entries in table used */

            var huff = 0;
            /* Huffman code */

            var incr;
            /* for incrementing code, index */

            var fill;
            /* index for replicating entries */

            var low;
            /* low bits for current root entry */

            var mask;
            /* mask for low root bits */

            var next;
            /* next available space in table */

            var base = null;
            /* base value table to use */

            var base_index = 0; //  var shoextra;    /* extra bits table to use */

            var end;
            /* use base and extra for symbol > end */

            var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */

            var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */

            var extra = null;
            var extra_index = 0;
            var here_bits, here_op, here_val;
            /*
             Process a set of code lengths to create a canonical Huffman code.  The
             code lengths are lens[0..codes-1].  Each length corresponds to the
             symbols 0..codes-1.  The Huffman code is generated by first sorting the
             symbols by length from short to long, and retaining the symbol order
             for codes with equal lengths.  Then the code starts with all zero bits
             for the first code of the shortest length, and the codes are integer
             increments for the same length, and zeros are appended as the length
             increases.  For the deflate format, these bits are stored backwards
             from their more natural integer increment ordering, and so when the
             decoding tables are built in the large loop below, the integer codes
             are incremented backwards.
              This routine assumes, but does not check, that all of the entries in
             lens[] are in the range 0..MAXBITS.  The caller must assure this.
             1..MAXBITS is interpreted as that code length.  zero means that that
             symbol does not occur in this code.
              The codes are sorted by computing a count of codes for each length,
             creating from that a table of starting indices for each length in the
             sorted table, and then entering the symbols in order in the sorted
             table.  The sorted table is work[], with that space being provided by
             the caller.
              The length counts are used for other purposes as well, i.e. finding
             the minimum and maximum length codes, determining if there are any
             codes at all, checking for a valid set of lengths, and looking ahead
             at length counts to determine sub-table sizes when building the
             decoding tables.
             */

            /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */

            for (len = 0; len <= MAXBITS; len++) {
              count[len] = 0;
            }

            for (sym = 0; sym < codes; sym++) {
              count[lens[lens_index + sym]]++;
            }
            /* bound code lengths, force root to be within code lengths */


            root = bits;

            for (max = MAXBITS; max >= 1; max--) {
              if (count[max] !== 0) {
                break;
              }
            }

            if (root > max) {
              root = max;
            }

            if (max === 0) {
              /* no symbols to code at all */
              //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
              //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
              //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
              table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;
              //table.bits[opts.table_index] = 1;
              //table.val[opts.table_index++] = 0;

              table[table_index++] = 1 << 24 | 64 << 16 | 0;
              opts.bits = 1;
              return 0;
              /* no symbols, but wait for decoding to report error */
            }

            for (min = 1; min < max; min++) {
              if (count[min] !== 0) {
                break;
              }
            }

            if (root < min) {
              root = min;
            }
            /* check for an over-subscribed or incomplete set of lengths */


            left = 1;

            for (len = 1; len <= MAXBITS; len++) {
              left <<= 1;
              left -= count[len];

              if (left < 0) {
                return -1;
              }
              /* over-subscribed */

            }

            if (left > 0 && (type === CODES || max !== 1)) {
              return -1;
              /* incomplete set */
            }
            /* generate offsets into symbol table for each length for sorting */


            offs[1] = 0;

            for (len = 1; len < MAXBITS; len++) {
              offs[len + 1] = offs[len] + count[len];
            }
            /* sort symbols by length, by symbol order within each length */


            for (sym = 0; sym < codes; sym++) {
              if (lens[lens_index + sym] !== 0) {
                work[offs[lens[lens_index + sym]]++] = sym;
              }
            }
            /*
             Create and fill in decoding tables.  In this loop, the table being
             filled is at next and has curr index bits.  The code being used is huff
             with length len.  That code is converted to an index by dropping drop
             bits off of the bottom.  For codes where len is less than drop + curr,
             those top drop + curr - len bits are incremented through all values to
             fill the table with replicated entries.
              root is the number of index bits for the root table.  When len exceeds
             root, sub-tables are created pointed to by the root entry with an index
             of the low root bits of huff.  This is saved in low to check for when a
             new sub-table should be started.  drop is zero when the root table is
             being filled, and drop is root when sub-tables are being filled.
              When a new sub-table is needed, it is necessary to look ahead in the
             code lengths to determine what size sub-table is needed.  The length
             counts are used for this, and so count[] is decremented as codes are
             entered in the tables.
              used keeps track of how many table entries have been allocated from the
             provided *table space.  It is checked for LENS and DIST tables against
             the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
             the initial root table size constants.  See the comments in inftrees.h
             for more information.
              sym increments through all symbols, and the loop terminates when
             all codes of length max, i.e. all codes, have been processed.  This
             routine permits incomplete codes, so another loop after this one fills
             in the rest of the decoding tables with invalid code markers.
             */

            /* set up for code type */
            // poor man optimization - use if-else instead of switch,
            // to avoid deopts in old v8


            if (type === CODES) {
              base = extra = work;
              /* dummy value--not used */

              end = 19;
            } else if (type === LENS) {
              base = lbase;
              base_index -= 257;
              extra = lext;
              extra_index -= 257;
              end = 256;
            } else {
              /* DISTS */
              base = dbase;
              extra = dext;
              end = -1;
            }
            /* initialize opts for loop */


            huff = 0;
            /* starting code */

            sym = 0;
            /* starting code symbol */

            len = min;
            /* starting code length */

            next = table_index;
            /* current table to fill in */

            curr = root;
            /* current table index bits */

            drop = 0;
            /* current bits to drop from code for index */

            low = -1;
            /* trigger new sub-table when len > root */

            used = 1 << root;
            /* use root table entries */

            mask = used - 1;
            /* mask for comparing low */

            /* check available table space */

            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            /* process all codes and make table entries */


            for (;;) {
              /* create table entry */
              here_bits = len - drop;

              if (work[sym] < end) {
                here_op = 0;
                here_val = work[sym];
              } else if (work[sym] > end) {
                here_op = extra[extra_index + work[sym]];
                here_val = base[base_index + work[sym]];
              } else {
                here_op = 32 + 64;
                /* end of block */

                here_val = 0;
              }
              /* replicate for those indices with low len bits equal to huff */


              incr = 1 << len - drop;
              fill = 1 << curr;
              min = fill;
              /* save offset to next table */

              do {
                fill -= incr;
                table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
              } while (fill !== 0);
              /* backwards increment the len-bit code huff */


              incr = 1 << len - 1;

              while (huff & incr) {
                incr >>= 1;
              }

              if (incr !== 0) {
                huff &= incr - 1;
                huff += incr;
              } else {
                huff = 0;
              }
              /* go to next symbol, update count, len */


              sym++;

              if (--count[len] === 0) {
                if (len === max) {
                  break;
                }

                len = lens[lens_index + work[sym]];
              }
              /* create new sub-table if needed */


              if (len > root && (huff & mask) !== low) {
                /* if first time, transition to sub-tables */
                if (drop === 0) {
                  drop = root;
                }
                /* increment past last table */


                next += min;
                /* here min is 1 << curr */

                /* determine length of next table */

                curr = len - drop;
                left = 1 << curr;

                while (curr + drop < max) {
                  left -= count[curr + drop];

                  if (left <= 0) {
                    break;
                  }

                  curr++;
                  left <<= 1;
                }
                /* check for enough space */


                used += 1 << curr;

                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                  return 1;
                }
                /* point entry in root table to sub-table */


                low = huff & mask;
                /*table.op[low] = curr;
                table.bits[low] = root;
                table.val[low] = next - opts.table_index;*/

                table[low] = root << 24 | curr << 16 | next - table_index | 0;
              }
            }
            /* fill in remaining table entry if code is incomplete (guaranteed to have
             at most one remaining entry, since if the code is incomplete, the
             maximum code length that was allowed to get this far is one bit) */


            if (huff !== 0) {
              //table.op[next + huff] = 64;            /* invalid code marker */
              //table.bits[next + huff] = len - drop;
              //table.val[next + huff] = 0;
              table[next + huff] = len - drop << 24 | 64 << 16 | 0;
            }
            /* set return parameters */
            //opts.table_index += used;


            opts.bits = root;
            return 0;
          };
        }, {
          "../utils/common": 41
        }],
        51: [function (require, module, exports) {
          'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          module.exports = {
            2: 'need dictionary',

            /* Z_NEED_DICT       2  */
            1: 'stream end',

            /* Z_STREAM_END      1  */
            0: '',

            /* Z_OK              0  */
            '-1': 'file error',

            /* Z_ERRNO         (-1) */
            '-2': 'stream error',

            /* Z_STREAM_ERROR  (-2) */
            '-3': 'data error',

            /* Z_DATA_ERROR    (-3) */
            '-4': 'insufficient memory',

            /* Z_MEM_ERROR     (-4) */
            '-5': 'buffer error',

            /* Z_BUF_ERROR     (-5) */
            '-6': 'incompatible version'
            /* Z_VERSION_ERROR (-6) */

          };
        }, {}],
        52: [function (require, module, exports) {
          'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          var utils = require('../utils/common');
          /* Public constants ==========================================================*/

          /* ===========================================================================*/
          //var Z_FILTERED          = 1;
          //var Z_HUFFMAN_ONLY      = 2;
          //var Z_RLE               = 3;


          var Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;

          /* Possible values of the data_type field (though see inflate()) */

          var Z_BINARY = 0;
          var Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT

          var Z_UNKNOWN = 2;
          /*============================================================================*/

          function zero(buf) {
            var len = buf.length;

            while (--len >= 0) {
              buf[len] = 0;
            }
          } // From zutil.h


          var STORED_BLOCK = 0;
          var STATIC_TREES = 1;
          var DYN_TREES = 2;
          /* The three kinds of block type */

          var MIN_MATCH = 3;
          var MAX_MATCH = 258;
          /* The minimum and maximum match lengths */
          // From deflate.h

          /* ===========================================================================
           * Internal compression state.
           */

          var LENGTH_CODES = 29;
          /* number of length codes, not counting the special END_BLOCK code */

          var LITERALS = 256;
          /* number of literal bytes 0..255 */

          var L_CODES = LITERALS + 1 + LENGTH_CODES;
          /* number of Literal or Length codes, including the END_BLOCK code */

          var D_CODES = 30;
          /* number of distance codes */

          var BL_CODES = 19;
          /* number of codes used to transfer the bit lengths */

          var HEAP_SIZE = 2 * L_CODES + 1;
          /* maximum heap size */

          var MAX_BITS = 15;
          /* All codes must not exceed MAX_BITS bits */

          var Buf_size = 16;
          /* size of bit buffer in bi_buf */

          /* ===========================================================================
           * Constants
           */

          var MAX_BL_BITS = 7;
          /* Bit length codes must not exceed MAX_BL_BITS bits */

          var END_BLOCK = 256;
          /* end of block literal code */

          var REP_3_6 = 16;
          /* repeat previous bit length 3-6 times (2 bits of repeat count) */

          var REPZ_3_10 = 17;
          /* repeat a zero length 3-10 times  (3 bits of repeat count) */

          var REPZ_11_138 = 18;
          /* repeat a zero length 11-138 times  (7 bits of repeat count) */

          /* eslint-disable comma-spacing,array-bracket-spacing */

          var extra_lbits =
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
          var extra_dbits =
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
          var extra_blbits =
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
          var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          /* eslint-enable comma-spacing,array-bracket-spacing */

          /* The lengths of the bit length codes are sent in order of decreasing
           * probability, to avoid transmitting the lengths for unused bit length codes.
           */

          /* ===========================================================================
           * Local data. These are initialized only once.
           */
          // We pre-fill arrays with 0 to avoid uninitialized gaps

          var DIST_CODE_LEN = 512;
          /* see definition of array dist_code below */
          // !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1

          var static_ltree = new Array((L_CODES + 2) * 2);
          zero(static_ltree);
          /* The static literal tree. Since the bit lengths are imposed, there is no
           * need for the L_CODES extra codes used during heap construction. However
           * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
           * below).
           */

          var static_dtree = new Array(D_CODES * 2);
          zero(static_dtree);
          /* The static distance tree. (Actually a trivial tree since all codes use
           * 5 bits.)
           */

          var _dist_code = new Array(DIST_CODE_LEN);

          zero(_dist_code);
          /* Distance codes. The first 256 values correspond to the distances
           * 3 .. 258, the last 256 values correspond to the top 8 bits of
           * the 15 bit distances.
           */

          var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);

          zero(_length_code);
          /* length code for each normalized match length (0 == MIN_MATCH) */

          var base_length = new Array(LENGTH_CODES);
          zero(base_length);
          /* First normalized length for each code (0 = MIN_MATCH) */

          var base_dist = new Array(D_CODES);
          zero(base_dist);
          /* First normalized distance for each code (0 = distance of 1) */

          function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
            this.static_tree = static_tree;
            /* static tree or NULL */

            this.extra_bits = extra_bits;
            /* extra bits for each code or NULL */

            this.extra_base = extra_base;
            /* base index for extra_bits */

            this.elems = elems;
            /* max number of elements in the tree */

            this.max_length = max_length;
            /* max bit length for the codes */
            // show if `static_tree` has data or dummy - needed for monomorphic objects

            this.has_stree = static_tree && static_tree.length;
          }

          var static_l_desc;
          var static_d_desc;
          var static_bl_desc;

          function TreeDesc(dyn_tree, stat_desc) {
            this.dyn_tree = dyn_tree;
            /* the dynamic tree */

            this.max_code = 0;
            /* largest code with non zero frequency */

            this.stat_desc = stat_desc;
            /* the corresponding static tree */
          }

          function d_code(dist) {
            return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
          }
          /* ===========================================================================
           * Output a short LSB first on the stream.
           * IN assertion: there is enough room in pendingBuf.
           */


          function put_short(s, w) {
            //    put_byte(s, (uch)((w) & 0xff));
            //    put_byte(s, (uch)((ush)(w) >> 8));
            s.pending_buf[s.pending++] = w & 0xff;
            s.pending_buf[s.pending++] = w >>> 8 & 0xff;
          }
          /* ===========================================================================
           * Send a value on a given number of bits.
           * IN assertion: length <= 16 and value fits in length bits.
           */


          function send_bits(s, value, length) {
            if (s.bi_valid > Buf_size - length) {
              s.bi_buf |= value << s.bi_valid & 0xffff;
              put_short(s, s.bi_buf);
              s.bi_buf = value >> Buf_size - s.bi_valid;
              s.bi_valid += length - Buf_size;
            } else {
              s.bi_buf |= value << s.bi_valid & 0xffff;
              s.bi_valid += length;
            }
          }

          function send_code(s, c, tree) {
            send_bits(s, tree[c * 2]
            /*.Code*/
            , tree[c * 2 + 1]
            /*.Len*/
            );
          }
          /* ===========================================================================
           * Reverse the first len bits of a code, using straightforward code (a faster
           * method would use a table)
           * IN assertion: 1 <= len <= 15
           */


          function bi_reverse(code, len) {
            var res = 0;

            do {
              res |= code & 1;
              code >>>= 1;
              res <<= 1;
            } while (--len > 0);

            return res >>> 1;
          }
          /* ===========================================================================
           * Flush the bit buffer, keeping at most 7 bits in it.
           */


          function bi_flush(s) {
            if (s.bi_valid === 16) {
              put_short(s, s.bi_buf);
              s.bi_buf = 0;
              s.bi_valid = 0;
            } else if (s.bi_valid >= 8) {
              s.pending_buf[s.pending++] = s.bi_buf & 0xff;
              s.bi_buf >>= 8;
              s.bi_valid -= 8;
            }
          }
          /* ===========================================================================
           * Compute the optimal bit lengths for a tree and update the total bit length
           * for the current block.
           * IN assertion: the fields freq and dad are set, heap[heap_max] and
           *    above are the tree nodes sorted by increasing frequency.
           * OUT assertions: the field len is set to the optimal bit length, the
           *     array bl_count contains the frequencies for each bit length.
           *     The length opt_len is updated; static_len is also updated if stree is
           *     not null.
           */


          function gen_bitlen(s, desc) //    deflate_state *s;
          //    tree_desc *desc;    /* the tree descriptor */
          {
            var tree = desc.dyn_tree;
            var max_code = desc.max_code;
            var stree = desc.stat_desc.static_tree;
            var has_stree = desc.stat_desc.has_stree;
            var extra = desc.stat_desc.extra_bits;
            var base = desc.stat_desc.extra_base;
            var max_length = desc.stat_desc.max_length;
            var h;
            /* heap index */

            var n, m;
            /* iterate over the tree elements */

            var bits;
            /* bit length */

            var xbits;
            /* extra bits */

            var f;
            /* frequency */

            var overflow = 0;
            /* number of elements with bit length too large */

            for (bits = 0; bits <= MAX_BITS; bits++) {
              s.bl_count[bits] = 0;
            }
            /* In a first pass, compute the optimal bit lengths (which may
             * overflow in the case of the bit length tree).
             */


            tree[s.heap[s.heap_max] * 2 + 1]
            /*.Len*/
            = 0;
            /* root of the heap */

            for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
              n = s.heap[h];
              bits = tree[tree[n * 2 + 1]
              /*.Dad*/
              * 2 + 1]
              /*.Len*/
              + 1;

              if (bits > max_length) {
                bits = max_length;
                overflow++;
              }

              tree[n * 2 + 1]
              /*.Len*/
              = bits;
              /* We overwrite tree[n].Dad which is no longer needed */

              if (n > max_code) {
                continue;
              }
              /* not a leaf node */


              s.bl_count[bits]++;
              xbits = 0;

              if (n >= base) {
                xbits = extra[n - base];
              }

              f = tree[n * 2]
              /*.Freq*/
              ;
              s.opt_len += f * (bits + xbits);

              if (has_stree) {
                s.static_len += f * (stree[n * 2 + 1]
                /*.Len*/
                + xbits);
              }
            }

            if (overflow === 0) {
              return;
            } // Trace((stderr,"\nbit length overflow\n"));

            /* This happens for example on obj2 and pic of the Calgary corpus */

            /* Find the first bit length which could increase: */


            do {
              bits = max_length - 1;

              while (s.bl_count[bits] === 0) {
                bits--;
              }

              s.bl_count[bits]--;
              /* move one leaf down the tree */

              s.bl_count[bits + 1] += 2;
              /* move one overflow item as its brother */

              s.bl_count[max_length]--;
              /* The brother of the overflow item also moves one step up,
               * but this does not affect bl_count[max_length]
               */

              overflow -= 2;
            } while (overflow > 0);
            /* Now recompute all bit lengths, scanning in increasing frequency.
             * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
             * lengths instead of fixing only the wrong ones. This idea is taken
             * from 'ar' written by Haruhiko Okumura.)
             */


            for (bits = max_length; bits !== 0; bits--) {
              n = s.bl_count[bits];

              while (n !== 0) {
                m = s.heap[--h];

                if (m > max_code) {
                  continue;
                }

                if (tree[m * 2 + 1]
                /*.Len*/
                !== bits) {
                  // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                  s.opt_len += (bits - tree[m * 2 + 1]
                  /*.Len*/
                  ) * tree[m * 2]
                  /*.Freq*/
                  ;
                  tree[m * 2 + 1]
                  /*.Len*/
                  = bits;
                }

                n--;
              }
            }
          }
          /* ===========================================================================
           * Generate the codes for a given tree and bit counts (which need not be
           * optimal).
           * IN assertion: the array bl_count contains the bit length statistics for
           * the given tree and the field len is set for all tree elements.
           * OUT assertion: the field code is set for all tree elements of non
           *     zero code length.
           */


          function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
          //    int max_code;              /* largest code with non zero frequency */
          //    ushf *bl_count;            /* number of codes at each bit length */
          {
            var next_code = new Array(MAX_BITS + 1);
            /* next code value for each bit length */

            var code = 0;
            /* running code value */

            var bits;
            /* bit index */

            var n;
            /* code index */

            /* The distribution counts are first used to generate the code values
             * without bit reversal.
             */

            for (bits = 1; bits <= MAX_BITS; bits++) {
              next_code[bits] = code = code + bl_count[bits - 1] << 1;
            }
            /* Check that the bit counts in bl_count are consistent. The last code
             * must be all ones.
             */
            //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            //        "inconsistent bit counts");
            //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


            for (n = 0; n <= max_code; n++) {
              var len = tree[n * 2 + 1]
              /*.Len*/
              ;

              if (len === 0) {
                continue;
              }
              /* Now reverse the bits */


              tree[n * 2]
              /*.Code*/
              = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
              //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
            }
          }
          /* ===========================================================================
           * Initialize the various 'constant' tables.
           */


          function tr_static_init() {
            var n;
            /* iterates over tree elements */

            var bits;
            /* bit counter */

            var length;
            /* length value */

            var code;
            /* code value */

            var dist;
            /* distance index */

            var bl_count = new Array(MAX_BITS + 1);
            /* number of codes at each bit length for an optimal tree */
            // do check in _tr_init()
            //if (static_init_done) return;

            /* For some embedded targets, global variables are not initialized: */

            /*#ifdef NO_INIT_GLOBAL_POINTERS
              static_l_desc.static_tree = static_ltree;
              static_l_desc.extra_bits = extra_lbits;
              static_d_desc.static_tree = static_dtree;
              static_d_desc.extra_bits = extra_dbits;
              static_bl_desc.extra_bits = extra_blbits;
            #endif*/

            /* Initialize the mapping length (0..255) -> length code (0..28) */

            length = 0;

            for (code = 0; code < LENGTH_CODES - 1; code++) {
              base_length[code] = length;

              for (n = 0; n < 1 << extra_lbits[code]; n++) {
                _length_code[length++] = code;
              }
            } //Assert (length == 256, "tr_static_init: length != 256");

            /* Note that the length 255 (match length 258) can be represented
             * in two different ways: code 284 + 5 bits or code 285, so we
             * overwrite length_code[255] to use the best encoding:
             */


            _length_code[length - 1] = code;
            /* Initialize the mapping dist (0..32K) -> dist code (0..29) */

            dist = 0;

            for (code = 0; code < 16; code++) {
              base_dist[code] = dist;

              for (n = 0; n < 1 << extra_dbits[code]; n++) {
                _dist_code[dist++] = code;
              }
            } //Assert (dist == 256, "tr_static_init: dist != 256");


            dist >>= 7;
            /* from now on, all distances are divided by 128 */

            for (; code < D_CODES; code++) {
              base_dist[code] = dist << 7;

              for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
                _dist_code[256 + dist++] = code;
              }
            } //Assert (dist == 256, "tr_static_init: 256+dist != 512");

            /* Construct the codes of the static literal tree */


            for (bits = 0; bits <= MAX_BITS; bits++) {
              bl_count[bits] = 0;
            }

            n = 0;

            while (n <= 143) {
              static_ltree[n * 2 + 1]
              /*.Len*/
              = 8;
              n++;
              bl_count[8]++;
            }

            while (n <= 255) {
              static_ltree[n * 2 + 1]
              /*.Len*/
              = 9;
              n++;
              bl_count[9]++;
            }

            while (n <= 279) {
              static_ltree[n * 2 + 1]
              /*.Len*/
              = 7;
              n++;
              bl_count[7]++;
            }

            while (n <= 287) {
              static_ltree[n * 2 + 1]
              /*.Len*/
              = 8;
              n++;
              bl_count[8]++;
            }
            /* Codes 286 and 287 do not exist, but we must include them in the
             * tree construction to get a canonical Huffman tree (longest code
             * all ones)
             */


            gen_codes(static_ltree, L_CODES + 1, bl_count);
            /* The static distance tree is trivial: */

            for (n = 0; n < D_CODES; n++) {
              static_dtree[n * 2 + 1]
              /*.Len*/
              = 5;
              static_dtree[n * 2]
              /*.Code*/
              = bi_reverse(n, 5);
            } // Now data ready and we can init static trees


            static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
            static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
            static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;
          }
          /* ===========================================================================
           * Initialize a new block.
           */


          function init_block(s) {
            var n;
            /* iterates over tree elements */

            /* Initialize the trees. */

            for (n = 0; n < L_CODES; n++) {
              s.dyn_ltree[n * 2]
              /*.Freq*/
              = 0;
            }

            for (n = 0; n < D_CODES; n++) {
              s.dyn_dtree[n * 2]
              /*.Freq*/
              = 0;
            }

            for (n = 0; n < BL_CODES; n++) {
              s.bl_tree[n * 2]
              /*.Freq*/
              = 0;
            }

            s.dyn_ltree[END_BLOCK * 2]
            /*.Freq*/
            = 1;
            s.opt_len = s.static_len = 0;
            s.last_lit = s.matches = 0;
          }
          /* ===========================================================================
           * Flush the bit buffer and align the output on a byte boundary
           */


          function bi_windup(s) {
            if (s.bi_valid > 8) {
              put_short(s, s.bi_buf);
            } else if (s.bi_valid > 0) {
              //put_byte(s, (Byte)s->bi_buf);
              s.pending_buf[s.pending++] = s.bi_buf;
            }

            s.bi_buf = 0;
            s.bi_valid = 0;
          }
          /* ===========================================================================
           * Copy a stored block, storing first the length and its
           * one's complement if requested.
           */


          function copy_block(s, buf, len, header) //DeflateState *s;
          //charf    *buf;    /* the input data */
          //unsigned len;     /* its length */
          //int      header;  /* true if block header must be written */
          {
            bi_windup(s);
            /* align on byte boundary */

            if (header) {
              put_short(s, len);
              put_short(s, ~len);
            } //  while (len--) {
            //    put_byte(s, *buf++);
            //  }


            utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
            s.pending += len;
          }
          /* ===========================================================================
           * Compares to subtrees, using the tree depth as tie breaker when
           * the subtrees have equal frequency. This minimizes the worst case length.
           */


          function smaller(tree, n, m, depth) {
            var _n2 = n * 2;

            var _m2 = m * 2;

            return tree[_n2]
            /*.Freq*/
            < tree[_m2]
            /*.Freq*/
            || tree[_n2]
            /*.Freq*/
            === tree[_m2]
            /*.Freq*/
            && depth[n] <= depth[m];
          }
          /* ===========================================================================
           * Restore the heap property by moving down the tree starting at node k,
           * exchanging a node with the smallest of its two sons if necessary, stopping
           * when the heap property is re-established (each father smaller than its
           * two sons).
           */


          function pqdownheap(s, tree, k) //    deflate_state *s;
          //    ct_data *tree;  /* the tree to restore */
          //    int k;               /* node to move down */
          {
            var v = s.heap[k];
            var j = k << 1;
            /* left son of k */

            while (j <= s.heap_len) {
              /* Set j to the smallest of the two sons: */
              if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                j++;
              }
              /* Exit if v is smaller than both sons */


              if (smaller(tree, v, s.heap[j], s.depth)) {
                break;
              }
              /* Exchange v with the smallest son */


              s.heap[k] = s.heap[j];
              k = j;
              /* And continue down the tree, setting j to the left son of k */

              j <<= 1;
            }

            s.heap[k] = v;
          } // inlined manually
          // var SMALLEST = 1;

          /* ===========================================================================
           * Send the block data compressed using the given Huffman trees
           */


          function compress_block(s, ltree, dtree) //    deflate_state *s;
          //    const ct_data *ltree; /* literal tree */
          //    const ct_data *dtree; /* distance tree */
          {
            var dist;
            /* distance of matched string */

            var lc;
            /* match length or unmatched char (if dist == 0) */

            var lx = 0;
            /* running index in l_buf */

            var code;
            /* the code to send */

            var extra;
            /* number of extra bits to send */

            if (s.last_lit !== 0) {
              do {
                dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
                lc = s.pending_buf[s.l_buf + lx];
                lx++;

                if (dist === 0) {
                  send_code(s, lc, ltree);
                  /* send a literal byte */
                  //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
                } else {
                  /* Here, lc is the match length - MIN_MATCH */
                  code = _length_code[lc];
                  send_code(s, code + LITERALS + 1, ltree);
                  /* send the length code */

                  extra = extra_lbits[code];

                  if (extra !== 0) {
                    lc -= base_length[code];
                    send_bits(s, lc, extra);
                    /* send the extra length bits */
                  }

                  dist--;
                  /* dist is now the match distance - 1 */

                  code = d_code(dist); //Assert (code < D_CODES, "bad d_code");

                  send_code(s, code, dtree);
                  /* send the distance code */

                  extra = extra_dbits[code];

                  if (extra !== 0) {
                    dist -= base_dist[code];
                    send_bits(s, dist, extra);
                    /* send the extra distance bits */
                  }
                }
                /* literal or match pair ? */

                /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
                //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
                //       "pendingBuf overflow");

              } while (lx < s.last_lit);
            }

            send_code(s, END_BLOCK, ltree);
          }
          /* ===========================================================================
           * Construct one Huffman tree and assigns the code bit strings and lengths.
           * Update the total bit length for the current block.
           * IN assertion: the field freq is set for all tree elements.
           * OUT assertions: the fields len and code are set to the optimal bit length
           *     and corresponding code. The length opt_len is updated; static_len is
           *     also updated if stree is not null. The field max_code is set.
           */


          function build_tree(s, desc) //    deflate_state *s;
          //    tree_desc *desc; /* the tree descriptor */
          {
            var tree = desc.dyn_tree;
            var stree = desc.stat_desc.static_tree;
            var has_stree = desc.stat_desc.has_stree;
            var elems = desc.stat_desc.elems;
            var n, m;
            /* iterate over heap elements */

            var max_code = -1;
            /* largest code with non zero frequency */

            var node;
            /* new node being created */

            /* Construct the initial heap, with least frequent element in
             * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
             * heap[0] is not used.
             */

            s.heap_len = 0;
            s.heap_max = HEAP_SIZE;

            for (n = 0; n < elems; n++) {
              if (tree[n * 2]
              /*.Freq*/
              !== 0) {
                s.heap[++s.heap_len] = max_code = n;
                s.depth[n] = 0;
              } else {
                tree[n * 2 + 1]
                /*.Len*/
                = 0;
              }
            }
            /* The pkzip format requires that at least one distance code exists,
             * and that at least one bit should be sent even if there is only one
             * possible code. So to avoid special checks later on we force at least
             * two codes of non zero frequency.
             */


            while (s.heap_len < 2) {
              node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
              tree[node * 2]
              /*.Freq*/
              = 1;
              s.depth[node] = 0;
              s.opt_len--;

              if (has_stree) {
                s.static_len -= stree[node * 2 + 1]
                /*.Len*/
                ;
              }
              /* node is 0 or 1 so it does not have extra bits */

            }

            desc.max_code = max_code;
            /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
             * establish sub-heaps of increasing lengths:
             */

            for (n = s.heap_len >> 1
            /*int /2*/
            ; n >= 1; n--) {
              pqdownheap(s, tree, n);
            }
            /* Construct the Huffman tree by repeatedly combining the least two
             * frequent nodes.
             */


            node = elems;
            /* next internal node of the tree */

            do {
              //pqremove(s, tree, n);  /* n = node of least frequency */

              /*** pqremove ***/
              n = s.heap[1
              /*SMALLEST*/
              ];
              s.heap[1
              /*SMALLEST*/
              ] = s.heap[s.heap_len--];
              pqdownheap(s, tree, 1
              /*SMALLEST*/
              );
              /***/

              m = s.heap[1
              /*SMALLEST*/
              ];
              /* m = node of next least frequency */

              s.heap[--s.heap_max] = n;
              /* keep the nodes sorted by frequency */

              s.heap[--s.heap_max] = m;
              /* Create a new node father of n and m */

              tree[node * 2]
              /*.Freq*/
              = tree[n * 2]
              /*.Freq*/
              + tree[m * 2]
              /*.Freq*/
              ;
              s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
              tree[n * 2 + 1]
              /*.Dad*/
              = tree[m * 2 + 1]
              /*.Dad*/
              = node;
              /* and insert the new node in the heap */

              s.heap[1
              /*SMALLEST*/
              ] = node++;
              pqdownheap(s, tree, 1
              /*SMALLEST*/
              );
            } while (s.heap_len >= 2);

            s.heap[--s.heap_max] = s.heap[1
            /*SMALLEST*/
            ];
            /* At this point, the fields freq and dad are set. We can now
             * generate the bit lengths.
             */

            gen_bitlen(s, desc);
            /* The field len is now set, we can generate the bit codes */

            gen_codes(tree, max_code, s.bl_count);
          }
          /* ===========================================================================
           * Scan a literal or distance tree to determine the frequencies of the codes
           * in the bit length tree.
           */


          function scan_tree(s, tree, max_code) //    deflate_state *s;
          //    ct_data *tree;   /* the tree to be scanned */
          //    int max_code;    /* and its largest code of non zero frequency */
          {
            var n;
            /* iterates over all tree elements */

            var prevlen = -1;
            /* last emitted length */

            var curlen;
            /* length of current code */

            var nextlen = tree[0 * 2 + 1]
            /*.Len*/
            ;
            /* length of next code */

            var count = 0;
            /* repeat count of the current code */

            var max_count = 7;
            /* max repeat count */

            var min_count = 4;
            /* min repeat count */

            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            }

            tree[(max_code + 1) * 2 + 1]
            /*.Len*/
            = 0xffff;
            /* guard */

            for (n = 0; n <= max_code; n++) {
              curlen = nextlen;
              nextlen = tree[(n + 1) * 2 + 1]
              /*.Len*/
              ;

              if (++count < max_count && curlen === nextlen) {
                continue;
              } else if (count < min_count) {
                s.bl_tree[curlen * 2]
                /*.Freq*/
                += count;
              } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                  s.bl_tree[curlen * 2] /*.Freq*/++;
                }

                s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
              } else if (count <= 10) {
                s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
              } else {
                s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
              }

              count = 0;
              prevlen = curlen;

              if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
              } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
              } else {
                max_count = 7;
                min_count = 4;
              }
            }
          }
          /* ===========================================================================
           * Send a literal or distance tree in compressed form, using the codes in
           * bl_tree.
           */


          function send_tree(s, tree, max_code) //    deflate_state *s;
          //    ct_data *tree; /* the tree to be scanned */
          //    int max_code;       /* and its largest code of non zero frequency */
          {
            var n;
            /* iterates over all tree elements */

            var prevlen = -1;
            /* last emitted length */

            var curlen;
            /* length of current code */

            var nextlen = tree[0 * 2 + 1]
            /*.Len*/
            ;
            /* length of next code */

            var count = 0;
            /* repeat count of the current code */

            var max_count = 7;
            /* max repeat count */

            var min_count = 4;
            /* min repeat count */

            /* tree[max_code+1].Len = -1; */

            /* guard already set */

            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            }

            for (n = 0; n <= max_code; n++) {
              curlen = nextlen;
              nextlen = tree[(n + 1) * 2 + 1]
              /*.Len*/
              ;

              if (++count < max_count && curlen === nextlen) {
                continue;
              } else if (count < min_count) {
                do {
                  send_code(s, curlen, s.bl_tree);
                } while (--count !== 0);
              } else if (curlen !== 0) {
                if (curlen !== prevlen) {
                  send_code(s, curlen, s.bl_tree);
                  count--;
                } //Assert(count >= 3 && count <= 6, " 3_6?");


                send_code(s, REP_3_6, s.bl_tree);
                send_bits(s, count - 3, 2);
              } else if (count <= 10) {
                send_code(s, REPZ_3_10, s.bl_tree);
                send_bits(s, count - 3, 3);
              } else {
                send_code(s, REPZ_11_138, s.bl_tree);
                send_bits(s, count - 11, 7);
              }

              count = 0;
              prevlen = curlen;

              if (nextlen === 0) {
                max_count = 138;
                min_count = 3;
              } else if (curlen === nextlen) {
                max_count = 6;
                min_count = 3;
              } else {
                max_count = 7;
                min_count = 4;
              }
            }
          }
          /* ===========================================================================
           * Construct the Huffman tree for the bit lengths and return the index in
           * bl_order of the last bit length code to send.
           */


          function build_bl_tree(s) {
            var max_blindex;
            /* index of last bit length code of non zero freq */

            /* Determine the bit length frequencies for literal and distance trees */

            scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
            scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
            /* Build the bit length tree: */

            build_tree(s, s.bl_desc);
            /* opt_len now includes the length of the tree representations, except
             * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
             */

            /* Determine the number of bit length codes to send. The pkzip format
             * requires that at least 4 bit length codes be sent. (appnote.txt says
             * 3 but the actual value used is 4.)
             */

            for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
              if (s.bl_tree[bl_order[max_blindex] * 2 + 1]
              /*.Len*/
              !== 0) {
                break;
              }
            }
            /* Update opt_len to include the bit length tree and counts */


            s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            //        s->opt_len, s->static_len));

            return max_blindex;
          }
          /* ===========================================================================
           * Send the header for a block using dynamic Huffman trees: the counts, the
           * lengths of the bit length codes, the literal tree and the distance tree.
           * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
           */


          function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
          //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
          {
            var rank;
            /* index in bl_order */
            //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
            //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            //        "too many codes");
            //Tracev((stderr, "\nbl counts: "));

            send_bits(s, lcodes - 257, 5);
            /* not +255 as stated in appnote.txt */

            send_bits(s, dcodes - 1, 5);
            send_bits(s, blcodes - 4, 4);
            /* not -3 as stated in appnote.txt */

            for (rank = 0; rank < blcodes; rank++) {
              //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
              send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]
              /*.Len*/
              , 3);
            } //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));


            send_tree(s, s.dyn_ltree, lcodes - 1);
            /* literal tree */
            //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

            send_tree(s, s.dyn_dtree, dcodes - 1);
            /* distance tree */
            //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
          }
          /* ===========================================================================
           * Check if the data type is TEXT or BINARY, using the following algorithm:
           * - TEXT if the two conditions below are satisfied:
           *    a) There are no non-portable control characters belonging to the
           *       "black list" (0..6, 14..25, 28..31).
           *    b) There is at least one printable character belonging to the
           *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
           * - BINARY otherwise.
           * - The following partially-portable control characters form a
           *   "gray list" that is ignored in this detection algorithm:
           *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
           * IN assertion: the fields Freq of dyn_ltree are set.
           */


          function detect_data_type(s) {
            /* black_mask is the bit mask of black-listed bytes
             * set bits 0..6, 14..25, and 28..31
             * 0xf3ffc07f = binary 11110011111111111100000001111111
             */
            var black_mask = 0xf3ffc07f;
            var n;
            /* Check for non-textual ("black-listed") bytes. */

            for (n = 0; n <= 31; n++, black_mask >>>= 1) {
              if (black_mask & 1 && s.dyn_ltree[n * 2]
              /*.Freq*/
              !== 0) {
                return Z_BINARY;
              }
            }
            /* Check for textual ("white-listed") bytes. */


            if (s.dyn_ltree[9 * 2]
            /*.Freq*/
            !== 0 || s.dyn_ltree[10 * 2]
            /*.Freq*/
            !== 0 || s.dyn_ltree[13 * 2]
            /*.Freq*/
            !== 0) {
              return Z_TEXT;
            }

            for (n = 32; n < LITERALS; n++) {
              if (s.dyn_ltree[n * 2]
              /*.Freq*/
              !== 0) {
                return Z_TEXT;
              }
            }
            /* There are no "black-listed" or "white-listed" bytes:
             * this stream either is empty or has tolerated ("gray-listed") bytes only.
             */


            return Z_BINARY;
          }

          var static_init_done = false;
          /* ===========================================================================
           * Initialize the tree data structures for a new zlib stream.
           */

          function _tr_init(s) {
            if (!static_init_done) {
              tr_static_init();
              static_init_done = true;
            }

            s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
            s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
            s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
            s.bi_buf = 0;
            s.bi_valid = 0;
            /* Initialize the first block of the first file: */

            init_block(s);
          }
          /* ===========================================================================
           * Send a stored block
           */


          function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
          //charf *buf;       /* input block */
          //ulg stored_len;   /* length of input block */
          //int last;         /* one if this is the last block for a file */
          {
            send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
            /* send block type */

            copy_block(s, buf, stored_len, true);
            /* with header */
          }
          /* ===========================================================================
           * Send one empty static block to give enough lookahead for inflate.
           * This takes 10 bits, of which 7 may remain in the bit buffer.
           */


          function _tr_align(s) {
            send_bits(s, STATIC_TREES << 1, 3);
            send_code(s, END_BLOCK, static_ltree);
            bi_flush(s);
          }
          /* ===========================================================================
           * Determine the best encoding for the current block: dynamic trees, static
           * trees or store, and output the encoded block to the zip file.
           */


          function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
          //charf *buf;       /* input block, or NULL if too old */
          //ulg stored_len;   /* length of input block */
          //int last;         /* one if this is the last block for a file */
          {
            var opt_lenb, static_lenb;
            /* opt_len and static_len in bytes */

            var max_blindex = 0;
            /* index of last bit length code of non zero freq */

            /* Build the Huffman trees unless a stored block is forced */

            if (s.level > 0) {
              /* Check if the file is binary or text */
              if (s.strm.data_type === Z_UNKNOWN) {
                s.strm.data_type = detect_data_type(s);
              }
              /* Construct the literal and distance trees */


              build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
              //        s->static_len));

              build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
              //        s->static_len));

              /* At this point, opt_len and static_len are the total bit lengths of
               * the compressed block data, excluding the tree representations.
               */

              /* Build the bit length tree for the above two trees, and get the index
               * in bl_order of the last bit length code to send.
               */

              max_blindex = build_bl_tree(s);
              /* Determine the best encoding. Compute the block lengths in bytes. */

              opt_lenb = s.opt_len + 3 + 7 >>> 3;
              static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
              //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
              //        s->last_lit));

              if (static_lenb <= opt_lenb) {
                opt_lenb = static_lenb;
              }
            } else {
              // Assert(buf != (char*)0, "lost buf");
              opt_lenb = static_lenb = stored_len + 5;
              /* force a stored block */
            }

            if (stored_len + 4 <= opt_lenb && buf !== -1) {
              /* 4: two words for the lengths */

              /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
               * Otherwise we can't have processed more than WSIZE input bytes since
               * the last block flush, because compression would have been
               * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
               * transform a block into a stored block.
               */
              _tr_stored_block(s, buf, stored_len, last);
            } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
              send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
              compress_block(s, static_ltree, static_dtree);
            } else {
              send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
              send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
              compress_block(s, s.dyn_ltree, s.dyn_dtree);
            } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

            /* The above check is made mod 2^32, for files larger than 512 MB
             * and uLong implemented on 32 bits.
             */


            init_block(s);

            if (last) {
              bi_windup(s);
            } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
            //       s->compressed_len-7*last));

          }
          /* ===========================================================================
           * Save the match info and tally the frequency counts. Return true if
           * the current block must be flushed.
           */


          function _tr_tally(s, dist, lc) //    deflate_state *s;
          //    unsigned dist;  /* distance of matched string */
          //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
          {
            //var out_length, in_length, dcode;
            s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
            s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
            s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
            s.last_lit++;

            if (dist === 0) {
              /* lc is the unmatched char */
              s.dyn_ltree[lc * 2] /*.Freq*/++;
            } else {
              s.matches++;
              /* Here, lc is the match length - MIN_MATCH */

              dist--;
              /* dist = match distance - 1 */
              //Assert((ush)dist < (ush)MAX_DIST(s) &&
              //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
              //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

              s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
              s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
            } // (!) This block is disabled in zlib defailts,
            // don't enable it for binary compatibility
            //#ifdef TRUNCATE_BLOCK
            //  /* Try to guess if it is profitable to stop the current block here */
            //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
            //    /* Compute an upper bound for the compressed length */
            //    out_length = s.last_lit*8;
            //    in_length = s.strstart - s.block_start;
            //
            //    for (dcode = 0; dcode < D_CODES; dcode++) {
            //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
            //    }
            //    out_length >>>= 3;
            //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
            //    //       s->last_lit, in_length, out_length,
            //    //       100L - out_length*100L/in_length));
            //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
            //      return true;
            //    }
            //  }
            //#endif


            return s.last_lit === s.lit_bufsize - 1;
            /* We avoid equality with lit_bufsize because of wraparound at 64K
             * on 16 bit machines and because stored blocks are restricted to
             * 64K-1 bytes.
             */
          }

          exports._tr_init = _tr_init;
          exports._tr_stored_block = _tr_stored_block;
          exports._tr_flush_block = _tr_flush_block;
          exports._tr_tally = _tr_tally;
          exports._tr_align = _tr_align;
        }, {
          "../utils/common": 41
        }],
        53: [function (require, module, exports) {
          'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler
          // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
          //
          // This software is provided 'as-is', without any express or implied
          // warranty. In no event will the authors be held liable for any damages
          // arising from the use of this software.
          //
          // Permission is granted to anyone to use this software for any purpose,
          // including commercial applications, and to alter it and redistribute it
          // freely, subject to the following restrictions:
          //
          // 1. The origin of this software must not be misrepresented; you must not
          //   claim that you wrote the original software. If you use this software
          //   in a product, an acknowledgment in the product documentation would be
          //   appreciated but is not required.
          // 2. Altered source versions must be plainly marked as such, and must not be
          //   misrepresented as being the original software.
          // 3. This notice may not be removed or altered from any source distribution.

          function ZStream() {
            /* next input byte */
            this.input = null; // JS specific, because we have no pointers

            this.next_in = 0;
            /* number of bytes available at input */

            this.avail_in = 0;
            /* total number of input bytes read so far */

            this.total_in = 0;
            /* next output byte should be put there */

            this.output = null; // JS specific, because we have no pointers

            this.next_out = 0;
            /* remaining free space at output */

            this.avail_out = 0;
            /* total number of bytes output so far */

            this.total_out = 0;
            /* last error message, NULL if no error */

            this.msg = ''
            /*Z_NULL*/
            ;
            /* not visible by applications */

            this.state = null;
            /* best guess about the data type: binary or text */

            this.data_type = 2
            /*Z_UNKNOWN*/
            ;
            /* adler32 value of the uncompressed data */

            this.adler = 0;
          }

          module.exports = ZStream;
        }, {}],
        54: [function (require, module, exports) {
          'use strict';

          module.exports = typeof setImmediate === 'function' ? setImmediate : function setImmediate() {
            var args = [].slice.apply(arguments);
            args.splice(1, 0, 0);
            setTimeout.apply(null, args);
          };
        }, {}]
      }, {}, [10])(10);
    });
    /***/

  },

  /***/
  "../../node_modules/raw-loader/dist/cjs.js!./src/app/modules/fields/dialog/dialog.component.html":
  /*!**********************************************************************************************************************************************************!*\
    !*** C:/Users/KING/Desktop/Economic-Statistic/e-statistics/UI/node_modules/raw-loader/dist/cjs.js!./src/app/modules/fields/dialog/dialog.component.html ***!
    \**********************************************************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppModulesFieldsDialogDialogComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<form class=\"example-form\" [formGroup]=\"form\">\r\n  <h1 mat-dialog-title>Information</h1>\r\n  <div mat-dialog-content>\r\n    <div class=\"content\" fxLayout=\"row\" fxLayout.xs=\"column\" fxFlexFill>\r\n      <div fxFlex=\"50\" fxFlex.xs=\"50\">\r\n        \r\n        <mat-form-field>\r\n          <mat-label>Field</mat-label>\r\n          <input matInput formControlName=\"name\" placeholder=\"Nông nghiệp\">\r\n        </mat-form-field>\r\n      </div>\r\n      <div fxFlex=\"50\" fxFlex.xs=\"50\">\r\n        <mat-form-field>\r\n          <mat-label>Code</mat-label>\r\n          <input matInput formControlName=\"code\" placeholder=\"01\">\r\n        </mat-form-field>\r\n      </div>\r\n    </div>\r\n  </div>\r\n    <div mat-dialog-actions>\r\n      <button mat-button (click)=\"onNoClick()\">No Thanks</button>\r\n      <button mat-button (click)=\"submit()\">Submit</button>\r\n    </div>\r\n</form>\r\n";
    /***/
  },

  /***/
  "../../node_modules/raw-loader/dist/cjs.js!./src/app/modules/fields/fields.component.html":
  /*!***************************************************************************************************************************************************!*\
    !*** C:/Users/KING/Desktop/Economic-Statistic/e-statistics/UI/node_modules/raw-loader/dist/cjs.js!./src/app/modules/fields/fields.component.html ***!
    \***************************************************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppModulesFieldsFieldsComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div class=\"row\">\r\n    <div class=\"col-12\">\r\n        <button id=\"addNew\" mat-raised-button (click)=\"openDialog()\">Thêm mới</button>\r\n        <div class=\"card\">\r\n            <div class=\"card-header card-header-primary\">\r\n                <h4 class=\"card-title\">Ngành</h4>\r\n            </div>\r\n            <div class=\"card-body\">\r\n                <!-- <mat-paginator [length]=\"100\" [pageSize]=\"10\" [pageSizeOptions]=\"[5, 10, 25, 100]\"> -->\r\n                <table mat-table [dataSource]=\"field\" class=\"mat-elevation-z8\">\r\n                    <!-- Position Column -->\r\n                    <ng-container matColumnDef=\"position\">\r\n                        <th mat-header-cell *matHeaderCellDef> No. </th>\r\n                        <td mat-cell *matCellDef=\"let element; index as i\"> {{i + 1}} </td>\r\n                    </ng-container>\r\n\r\n                    <!-- Code Column -->\r\n                    <ng-container matColumnDef=\"code\">\r\n                        <th mat-header-cell *matHeaderCellDef> Mã ngành </th>\r\n                        <td mat-cell *matCellDef=\"let element;index as index\">\r\n                            <ng-container *ngIf=\"index == editIndex;else editInput\">\r\n                                <input type=\"text\" [(ngModel)]=\"currentField.code\" />\r\n                            </ng-container>\r\n                            <ng-template #editInput>\r\n                                {{element?.code}}\r\n                            </ng-template>\r\n                        </td>\r\n                    </ng-container>\r\n\r\n                    <!-- Name Column -->\r\n                    <ng-container matColumnDef=\"name\">\r\n                        <th mat-header-cell *matHeaderCellDef> Tên ngành </th>\r\n                        <td mat-cell *matCellDef=\"let element;index as index\">\r\n                            <ng-container *ngIf=\"index == editIndex; else editInput\">\r\n                                <input type=\"text\" [(ngModel)]=\"currentField.name\" />\r\n                            </ng-container>\r\n                            <ng-template #editInput>\r\n                                {{element?.name}}\r\n                            </ng-template>\r\n                        </td>\r\n                    </ng-container>\r\n                    <ng-container matColumnDef=\"action\">\r\n                        <th mat-header-cell *matHeaderCellDef> Thao tác </th>\r\n                        <td mat-cell *matCellDef=\"let element; index as index\">\r\n                            <ng-container *ngIf=\"index == editIndex; else acceptButton\">\r\n                                <button mat-raised-button (click)=\"updateField()\">Xong</button>\r\n                                <button mat-raised-button (click)=\"cancelEdit()\">Hủy</button>\r\n                            </ng-container>\r\n                            <ng-template #acceptButton>\r\n                                <ng-container *ngIf=\"editIndex == null\">\r\n                                    <button mat-raised-button (click)=\"toggleEdit(index, element)\">Sửa</button>\r\n                                    <button mat-raised-button (click)=\"deleteField(element.id)\">Xóa</button>\r\n                                </ng-container>\r\n                            </ng-template>\r\n                        </td>\r\n                    </ng-container>\r\n                    <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\r\n                    <tr mat-row *matRowDef=\"let row; columns: displayedColumns;\"></tr>\r\n                </table>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<!-- </mat-paginator> -->";
    /***/
  },

  /***/
  "../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
  /*!********************************************************************************************************************************!*\
    !*** C:/Users/KING/Desktop/Economic-Statistic/e-statistics/UI/node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
    \********************************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesResizeObserverPolyfillDistResizeObserverEsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /**
     * A collection of shims that provide minimal functionality of the ES6 collections.
     *
     * These implementations are not meant to be used outside of the ResizeObserver
     * modules as they cover only a limited range of use cases.
     */

    /* eslint-disable require-jsdoc, valid-jsdoc */


    var MapShim = function () {
      if (typeof Map !== 'undefined') {
        return Map;
      }
      /**
       * Returns index in provided array that matches the specified key.
       *
       * @param {Array<Array>} arr
       * @param {*} key
       * @returns {number}
       */


      function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
          if (entry[0] === key) {
            result = index;
            return true;
          }

          return false;
        });
        return result;
      }

      return (
        /** @class */
        function () {
          function class_1() {
            this.__entries__ = [];
          }

          Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function get() {
              return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
          });
          /**
           * @param {*} key
           * @returns {*}
           */

          class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
          };
          /**
           * @param {*} key
           * @param {*} value
           * @returns {void}
           */


          class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);

            if (~index) {
              this.__entries__[index][1] = value;
            } else {
              this.__entries__.push([key, value]);
            }
          };
          /**
           * @param {*} key
           * @returns {void}
           */


          class_1.prototype["delete"] = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);

            if (~index) {
              entries.splice(index, 1);
            }
          };
          /**
           * @param {*} key
           * @returns {void}
           */


          class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
          };
          /**
           * @returns {void}
           */


          class_1.prototype.clear = function () {
            this.__entries__.splice(0);
          };
          /**
           * @param {Function} callback
           * @param {*} [ctx=null]
           * @returns {void}
           */


          class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) {
              ctx = null;
            }

            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
              var entry = _a[_i];
              callback.call(ctx, entry[1], entry[0]);
            }
          };

          return class_1;
        }()
      );
    }();
    /**
     * Detects whether window and document objects are available in current environment.
     */


    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

    var global$1 = function () {
      if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
      }

      if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
      }

      if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
      } // eslint-disable-next-line no-new-func


      return Function('return this')();
    }();
    /**
     * A shim for the requestAnimationFrame which falls back to the setTimeout if
     * first one is not supported.
     *
     * @returns {number} Requests' identifier.
     */


    var requestAnimationFrame$1 = function () {
      if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
      }

      return function (callback) {
        return setTimeout(function () {
          return callback(Date.now());
        }, 1000 / 60);
      };
    }(); // Defines minimum timeout before adding a trailing call.


    var trailingTimeout = 2;
    /**
     * Creates a wrapper function which ensures that provided callback will be
     * invoked only once during the specified delay period.
     *
     * @param {Function} callback - Function to be invoked after the delay period.
     * @param {number} delay - Delay after which to invoke callback.
     * @returns {Function}
     */

    function throttle(callback, delay) {
      var leadingCall = false,
          trailingCall = false,
          lastCallTime = 0;
      /**
       * Invokes the original callback function and schedules new invocation if
       * the "proxy" was called during current request.
       *
       * @returns {void}
       */

      function resolvePending() {
        if (leadingCall) {
          leadingCall = false;
          callback();
        }

        if (trailingCall) {
          proxy();
        }
      }
      /**
       * Callback invoked after the specified delay. It will further postpone
       * invocation of the original function delegating it to the
       * requestAnimationFrame.
       *
       * @returns {void}
       */


      function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
      }
      /**
       * Schedules invocation of the original function.
       *
       * @returns {void}
       */


      function proxy() {
        var timeStamp = Date.now();

        if (leadingCall) {
          // Reject immediately following calls.
          if (timeStamp - lastCallTime < trailingTimeout) {
            return;
          } // Schedule new call to be in invoked when the pending one is resolved.
          // This is important for "transitions" which never actually start
          // immediately so there is a chance that we might miss one if change
          // happens amids the pending invocation.


          trailingCall = true;
        } else {
          leadingCall = true;
          trailingCall = false;
          setTimeout(timeoutCallback, delay);
        }

        lastCallTime = timeStamp;
      }

      return proxy;
    } // Minimum delay before invoking the update of observers.


    var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
    // might affect dimensions of observed elements.

    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

    var mutationObserverSupported = typeof MutationObserver !== 'undefined';
    /**
     * Singleton controller class which handles updates of ResizeObserver instances.
     */

    var ResizeObserverController =
    /** @class */
    function () {
      /**
       * Creates a new instance of ResizeObserverController.
       *
       * @private
       */
      function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */

        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */

        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */

        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
      }
      /**
       * Adds observer to observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be added.
       * @returns {void}
       */


      ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
          this.observers_.push(observer);
        } // Add listeners if they haven't been added yet.


        if (!this.connected_) {
          this.connect_();
        }
      };
      /**
       * Removes observer from observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be removed.
       * @returns {void}
       */


      ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer); // Remove observer if it's present in registry.

        if (~index) {
          observers.splice(index, 1);
        } // Remove listeners if controller has no connected observers.


        if (!observers.length && this.connected_) {
          this.disconnect_();
        }
      };
      /**
       * Invokes the update of observers. It will continue running updates insofar
       * it detects changes.
       *
       * @returns {void}
       */


      ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.

        if (changesDetected) {
          this.refresh();
        }
      };
      /**
       * Updates every observer from observers list and notifies them of queued
       * entries.
       *
       * @private
       * @returns {boolean} Returns "true" if any observer has detected changes in
       *      dimensions of it's elements.
       */


      ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
          return observer.gatherActive(), observer.hasActive();
        }); // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.

        activeObservers.forEach(function (observer) {
          return observer.broadcastActive();
        });
        return activeObservers.length > 0;
      };
      /**
       * Initializes DOM listeners.
       *
       * @private
       * @returns {void}
       */


      ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
          return;
        } // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.


        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);

        if (mutationObserverSupported) {
          this.mutationsObserver_ = new MutationObserver(this.refresh);
          this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        } else {
          document.addEventListener('DOMSubtreeModified', this.refresh);
          this.mutationEventsAdded_ = true;
        }

        this.connected_ = true;
      };
      /**
       * Removes DOM listeners.
       *
       * @private
       * @returns {void}
       */


      ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
          return;
        }

        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);

        if (this.mutationsObserver_) {
          this.mutationsObserver_.disconnect();
        }

        if (this.mutationEventsAdded_) {
          document.removeEventListener('DOMSubtreeModified', this.refresh);
        }

        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
      };
      /**
       * "Transitionend" event handler.
       *
       * @private
       * @param {TransitionEvent} event
       * @returns {void}
       */


      ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName,
            propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

        var isReflowProperty = transitionKeys.some(function (key) {
          return !!~propertyName.indexOf(key);
        });

        if (isReflowProperty) {
          this.refresh();
        }
      };
      /**
       * Returns instance of the ResizeObserverController.
       *
       * @returns {ResizeObserverController}
       */


      ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
          this.instance_ = new ResizeObserverController();
        }

        return this.instance_;
      };
      /**
       * Holds reference to the controller's instance.
       *
       * @private {ResizeObserverController}
       */


      ResizeObserverController.instance_ = null;
      return ResizeObserverController;
    }();
    /**
     * Defines non-writable/enumerable properties of the provided target object.
     *
     * @param {Object} target - Object for which to define properties.
     * @param {Object} props - Properties to be defined.
     * @returns {Object} Target object.
     */


    var defineConfigurable = function defineConfigurable(target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
          value: props[key],
          enumerable: false,
          writable: false,
          configurable: true
        });
      }

      return target;
    };
    /**
     * Returns the global object associated with provided element.
     *
     * @param {Object} target
     * @returns {Object}
     */


    var getWindowOf = function getWindowOf(target) {
      // Assume that the element is an instance of Node, which means that it
      // has the "ownerDocument" property from which we can retrieve a
      // corresponding global object.
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
      // provided element.

      return ownerGlobal || global$1;
    }; // Placeholder of an empty content rectangle.


    var emptyRect = createRectInit(0, 0, 0, 0);
    /**
     * Converts provided string to a number.
     *
     * @param {number|string} value
     * @returns {number}
     */

    function toFloat(value) {
      return parseFloat(value) || 0;
    }
    /**
     * Extracts borders size from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @param {...string} positions - Borders positions (top, right, ...)
     * @returns {number}
     */


    function getBordersSize(styles) {
      var positions = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
      }

      return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
      }, 0);
    }
    /**
     * Extracts paddings sizes from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @returns {Object} Paddings box.
     */


    function getPaddings(styles) {
      var positions = ['top', 'right', 'bottom', 'left'];
      var paddings = {};

      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
      }

      return paddings;
    }
    /**
     * Calculates content rectangle of provided SVG element.
     *
     * @param {SVGGraphicsElement} target - Element content rectangle of which needs
     *      to be calculated.
     * @returns {DOMRectInit}
     */


    function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
    }
    /**
     * Calculates content rectangle of provided HTMLElement.
     *
     * @param {HTMLElement} target - Element for which to calculate the content rectangle.
     * @returns {DOMRectInit}
     */


    function getHTMLElementContentRect(target) {
      // Client width & height properties can't be
      // used exclusively as they provide rounded values.
      var clientWidth = target.clientWidth,
          clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
      // detached elements. Though elements with width & height properties less
      // than 0.5 will be discarded as well.
      //
      // Without it we would need to implement separate methods for each of
      // those cases and it's not possible to perform a precise and performance
      // effective test for hidden elements. E.g. even jQuery's ':visible' filter
      // gives wrong results for elements with width & height less than 0.5.

      if (!clientWidth && !clientHeight) {
        return emptyRect;
      }

      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
      // only dimensions available to JS that contain non-rounded values. It could
      // be possible to utilize the getBoundingClientRect if only it's data wasn't
      // affected by CSS transformations let alone paddings, borders and scroll bars.

      var width = toFloat(styles.width),
          height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
      // model is applied (except for IE).

      if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
          width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }

        if (Math.round(height + vertPad) !== clientHeight) {
          height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
      } // Following steps can't be applied to the document's root element as its
      // client[Width/Height] properties represent viewport area of the window.
      // Besides, it's as well not necessary as the <html> itself neither has
      // rendered scroll bars nor it can be clipped.


      if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.

        if (Math.abs(vertScrollbar) !== 1) {
          width -= vertScrollbar;
        }

        if (Math.abs(horizScrollbar) !== 1) {
          height -= horizScrollbar;
        }
      }

      return createRectInit(paddings.left, paddings.top, width, height);
    }
    /**
     * Checks whether provided element is an instance of the SVGGraphicsElement.
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */


    var isSVGGraphicsElement = function () {
      // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
      // interface.
      if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) {
          return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
      } // If it's so, then check that element is at least an instance of the
      // SVGElement and that it has the "getBBox" method.
      // eslint-disable-next-line no-extra-parens


      return function (target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
      };
    }();
    /**
     * Checks whether provided element is a document element (<html>).
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */


    function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
    }
    /**
     * Calculates an appropriate content rectangle for provided html or svg element.
     *
     * @param {Element} target - Element content rectangle of which needs to be calculated.
     * @returns {DOMRectInit}
     */


    function getContentRect(target) {
      if (!isBrowser) {
        return emptyRect;
      }

      if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
      }

      return getHTMLElementContentRect(target);
    }
    /**
     * Creates rectangle with an interface of the DOMRectReadOnly.
     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
     *
     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
     * @returns {DOMRectReadOnly}
     */


    function createReadOnlyRect(_a) {
      var x = _a.x,
          y = _a.y,
          width = _a.width,
          height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

      var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

      defineConfigurable(rect, {
        x: x,
        y: y,
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
      });
      return rect;
    }
    /**
     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
     *
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} width - Rectangle's width.
     * @param {number} height - Rectangle's height.
     * @returns {DOMRectInit}
     */


    function createRectInit(x, y, width, height) {
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    }
    /**
     * Class that is responsible for computations of the content rectangle of
     * provided DOM element and for keeping track of it's changes.
     */


    var ResizeObservation =
    /** @class */
    function () {
      /**
       * Creates an instance of ResizeObservation.
       *
       * @param {Element} target - Element to be observed.
       */
      function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */

        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */

        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
      }
      /**
       * Updates content rectangle and tells whether it's width or height properties
       * have changed since the last broadcast.
       *
       * @returns {boolean}
       */


      ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
      };
      /**
       * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
       * from the corresponding properties of the last observed content rectangle.
       *
       * @returns {DOMRectInit} Last observed content rectangle.
       */


      ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
      };

      return ResizeObservation;
    }();

    var ResizeObserverEntry =
    /** @class */
    function () {
      /**
       * Creates an instance of ResizeObserverEntry.
       *
       * @param {Element} target - Element that is being observed.
       * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
       */
      function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.

        defineConfigurable(this, {
          target: target,
          contentRect: contentRect
        });
      }

      return ResizeObserverEntry;
    }();

    var ResizeObserverSPI =
    /** @class */
    function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback function that is invoked
       *      when one of the observed elements changes it's content dimensions.
       * @param {ResizeObserverController} controller - Controller instance which
       *      is responsible for the updates of observer.
       * @param {ResizeObserver} callbackCtx - Reference to the public
       *      ResizeObserver instance which will be passed to callback function.
       */
      function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */

        this.observations_ = new MapShim();

        if (typeof callback !== 'function') {
          throw new TypeError('The callback provided as parameter 1 is not a function.');
        }

        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
      }
      /**
       * Starts observing provided element.
       *
       * @param {Element} target - Element to be observed.
       * @returns {void}
       */


      ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
          throw new TypeError('1 argument required, but only 0 present.');
        } // Do nothing if current environment doesn't have the Element interface.


        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
          return;
        }

        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }

        var observations = this.observations_; // Do nothing if element is already being observed.

        if (observations.has(target)) {
          return;
        }

        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this); // Force the update of observations.

        this.controller_.refresh();
      };
      /**
       * Stops observing provided element.
       *
       * @param {Element} target - Element to stop observing.
       * @returns {void}
       */


      ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
          throw new TypeError('1 argument required, but only 0 present.');
        } // Do nothing if current environment doesn't have the Element interface.


        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
          return;
        }

        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }

        var observations = this.observations_; // Do nothing if element is not being observed.

        if (!observations.has(target)) {
          return;
        }

        observations["delete"](target);

        if (!observations.size) {
          this.controller_.removeObserver(this);
        }
      };
      /**
       * Stops observing all elements.
       *
       * @returns {void}
       */


      ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
      };
      /**
       * Collects observation instances the associated element of which has changed
       * it's content rectangle.
       *
       * @returns {void}
       */


      ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;

        this.clearActive();
        this.observations_.forEach(function (observation) {
          if (observation.isActive()) {
            _this.activeObservations_.push(observation);
          }
        });
      };
      /**
       * Invokes initial callback function with a list of ResizeObserverEntry
       * instances collected from active resize observations.
       *
       * @returns {void}
       */


      ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
          return;
        }

        var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

        var entries = this.activeObservations_.map(function (observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
      };
      /**
       * Clears the collection of active observations.
       *
       * @returns {void}
       */


      ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
      };
      /**
       * Tells whether observer has active observations.
       *
       * @returns {boolean}
       */


      ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
      };

      return ResizeObserverSPI;
    }(); // Registry of internal observers. If WeakMap is not available use current shim
    // for the Map collection as it has all required methods and because WeakMap
    // can't be fully polyfilled anyway.


    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
    /**
     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
     * exposing only those methods and properties that are defined in the spec.
     */

    var ResizeObserver =
    /** @class */
    function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback that is invoked when
       *      dimensions of the observed elements change.
       */
      function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
          throw new TypeError('Cannot call a class as a function.');
        }

        if (!arguments.length) {
          throw new TypeError('1 argument required, but only 0 present.');
        }

        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
      }

      return ResizeObserver;
    }(); // Expose public methods of ResizeObserver.


    ['observe', 'unobserve', 'disconnect'].forEach(function (method) {
      ResizeObserver.prototype[method] = function () {
        var _a;

        return (_a = observers.get(this))[method].apply(_a, arguments);
      };
    });

    var index = function () {
      // Export existing implementation if available.
      if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
      }

      return ResizeObserver;
    }();
    /* harmony default export */


    __webpack_exports__["default"] = index;
    /***/
  },

  /***/
  "./src/app/modules/fields/dialog/dialog.component.scss":
  /*!*************************************************************!*\
    !*** ./src/app/modules/fields/dialog/dialog.component.scss ***!
    \*************************************************************/

  /*! exports provided: default */

  /***/
  function srcAppModulesFieldsDialogDialogComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJBZG1pbi9zcmMvYXBwL21vZHVsZXMvZmllbGRzL2RpYWxvZy9kaWFsb2cuY29tcG9uZW50LnNjc3MifQ== */";
    /***/
  },

  /***/
  "./src/app/modules/fields/dialog/dialog.component.ts":
  /*!***********************************************************!*\
    !*** ./src/app/modules/fields/dialog/dialog.component.ts ***!
    \***********************************************************/

  /*! exports provided: DialogComponent */

  /***/
  function srcAppModulesFieldsDialogDialogComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DialogComponent", function () {
      return DialogComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "../../node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "../../node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/material */
    "../../node_modules/@angular/material/esm2015/material.js");
    /* harmony import */


    var _services_fields_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../services/fields.service */
    "./src/app/modules/fields/services/fields.service.ts");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @angular/forms */
    "../../node_modules/@angular/forms/fesm2015/forms.js");

    var DialogComponent =
    /*#__PURE__*/
    function () {
      function DialogComponent(dialogRef, data, fieldSv, formBuilder) {
        _classCallCheck(this, DialogComponent);

        this.dialogRef = dialogRef;
        this.data = data;
        this.fieldSv = fieldSv;
        this.formBuilder = formBuilder;
      }

      _createClass(DialogComponent, [{
        key: "onNoClick",
        value: function onNoClick() {
          this.dialogRef.close({});
        }
      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          this.form = this.formBuilder.group({
            name: [''],
            code: ['', _angular_forms__WEBPACK_IMPORTED_MODULE_4__["Validators"].required]
          });
        }
      }, {
        key: "submit",
        value: function submit() {
          var field = this.form.value;
          this.fieldSv.addField(field);
          this.dialogRef.close();
        }
      }]);

      return DialogComponent;
    }();

    DialogComponent.ctorParameters = function () {
      return [{
        type: _angular_material__WEBPACK_IMPORTED_MODULE_2__["MatDialogRef"]
      }, {
        type: undefined,
        decorators: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"],
          args: [_angular_material__WEBPACK_IMPORTED_MODULE_2__["MAT_DIALOG_DATA"]]
        }]
      }, {
        type: _services_fields_service__WEBPACK_IMPORTED_MODULE_3__["FieldsService"]
      }, {
        type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["FormBuilder"]
      }];
    };

    DialogComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-dialog',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(
      /*! raw-loader!./dialog.component.html */
      "../../node_modules/raw-loader/dist/cjs.js!./src/app/modules/fields/dialog/dialog.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(
      /*! ./dialog.component.scss */
      "./src/app/modules/fields/dialog/dialog.component.scss"))["default"]]
    }), tslib__WEBPACK_IMPORTED_MODULE_0__["__param"](1, Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"])(_angular_material__WEBPACK_IMPORTED_MODULE_2__["MAT_DIALOG_DATA"]))], DialogComponent);
    /***/
  },

  /***/
  "./src/app/modules/fields/fields.component.scss":
  /*!******************************************************!*\
    !*** ./src/app/modules/fields/fields.component.scss ***!
    \******************************************************/

  /*! exports provided: default */

  /***/
  function srcAppModulesFieldsFieldsComponentScss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "table {\n  width: 100%;\n}\n\n#addNew {\n  width: 300px;\n  height: 50px;\n  margin: 5px;\n  background-color: #2020cf;\n  color: white;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkFkbWluL3NyYy9hcHAvbW9kdWxlcy9maWVsZHMvQzpcXFVzZXJzXFxLSU5HXFxEZXNrdG9wXFxFY29ub21pYy1TdGF0aXN0aWNcXGUtc3RhdGlzdGljc1xcVUlcXHByb2plY3RzL0FkbWluXFxzcmNcXGFwcFxcbW9kdWxlc1xcZmllbGRzXFxmaWVsZHMuY29tcG9uZW50LnNjc3MiLCJBZG1pbi9zcmMvYXBwL21vZHVsZXMvZmllbGRzL2ZpZWxkcy5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNJLFdBQUE7QUNDSjs7QURDQTtFQUNJLFlBQUE7RUFDQSxZQUFBO0VBQ0EsV0FBQTtFQUNBLHlCQUFBO0VBQ0EsWUFBQTtBQ0VKIiwiZmlsZSI6IkFkbWluL3NyYy9hcHAvbW9kdWxlcy9maWVsZHMvZmllbGRzLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsidGFibGV7XHJcbiAgICB3aWR0aDogMTAwJTtcclxufVxyXG4jYWRkTmV3e1xyXG4gICAgd2lkdGg6IDMwMHB4O1xyXG4gICAgaGVpZ2h0OiA1MHB4O1xyXG4gICAgbWFyZ2luOjVweDtcclxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigzMiwgMzIsIDIwNyk7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbn1cclxuIiwidGFibGUge1xuICB3aWR0aDogMTAwJTtcbn1cblxuI2FkZE5ldyB7XG4gIHdpZHRoOiAzMDBweDtcbiAgaGVpZ2h0OiA1MHB4O1xuICBtYXJnaW46IDVweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIwMjBjZjtcbiAgY29sb3I6IHdoaXRlO1xufSJdfQ== */";
    /***/
  },

  /***/
  "./src/app/modules/fields/fields.component.ts":
  /*!****************************************************!*\
    !*** ./src/app/modules/fields/fields.component.ts ***!
    \****************************************************/

  /*! exports provided: FieldsComponent */

  /***/
  function srcAppModulesFieldsFieldsComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FieldsComponent", function () {
      return FieldsComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "../../node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "../../node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _services_fields_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./services/fields.service */
    "./src/app/modules/fields/services/fields.service.ts");
    /* harmony import */


    var _angular_material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/material */
    "../../node_modules/@angular/material/esm2015/material.js");
    /* harmony import */


    var _dialog_dialog_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./dialog/dialog.component */
    "./src/app/modules/fields/dialog/dialog.component.ts");

    var FieldsComponent =
    /*#__PURE__*/
    function () {
      function FieldsComponent(fieldService, dialog) {
        _classCallCheck(this, FieldsComponent);

        this.fieldService = fieldService;
        this.dialog = dialog;
        this.displayedColumns = ['position', 'code', 'name', 'action'];
        this.field = null;
        this.editIndex = null;
        this.currentField = null;
        this.oldField = null;
      }

      _createClass(FieldsComponent, [{
        key: "openDialog",
        value: function openDialog() {
          var dialogRef = this.dialog.open(_dialog_dialog_component__WEBPACK_IMPORTED_MODULE_4__["DialogComponent"], {
            width: '550px',
            data: {
              field: this.field
            }
          });
        }
      }, {
        key: "updateField",
        value: function updateField() {
          var _this386 = this;

          this.fieldService.update(this.currentField).subscribe(function (_) {
            return _this386.currentField = _this386.editIndex = null;
          });
        }
      }, {
        key: "cancelEdit",
        value: function cancelEdit() {
          this.currentField.name = this.oldField.name;
          this.currentField.code = this.oldField.code;
          this.editIndex = this.currentField = null;
        }
      }, {
        key: "toggleEdit",
        value: function toggleEdit(index, field) {
          this.editIndex = index;
          this.currentField = field;
          this.oldField = Object.assign({}, field);
        }
      }, {
        key: "deleteField",
        value: function deleteField(id) {
          this.fieldService["delete"](id);
        }
      }, {
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this387 = this;

          this.fieldService.field$.subscribe(function (l) {
            return _this387.field = l;
          });
        }
      }]);

      return FieldsComponent;
    }();

    FieldsComponent.ctorParameters = function () {
      return [{
        type: _services_fields_service__WEBPACK_IMPORTED_MODULE_2__["FieldsService"]
      }, {
        type: _angular_material__WEBPACK_IMPORTED_MODULE_3__["MatDialog"]
      }];
    };

    FieldsComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-fields',
      template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(
      /*! raw-loader!./fields.component.html */
      "../../node_modules/raw-loader/dist/cjs.js!./src/app/modules/fields/fields.component.html"))["default"],
      styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(
      /*! ./fields.component.scss */
      "./src/app/modules/fields/fields.component.scss"))["default"]]
    })], FieldsComponent);
    /***/
  },

  /***/
  "./src/app/modules/fields/fields.module.ts":
  /*!*************************************************!*\
    !*** ./src/app/modules/fields/fields.module.ts ***!
    \*************************************************/

  /*! exports provided: FieldsModule */

  /***/
  function srcAppModulesFieldsFieldsModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FieldsModule", function () {
      return FieldsModule;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "../../node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "../../node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/common */
    "../../node_modules/@angular/common/fesm2015/common.js");
    /* harmony import */


    var _angular_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @angular/router */
    "../../node_modules/@angular/router/fesm2015/router.js");
    /* harmony import */


    var _fields_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./fields.component */
    "./src/app/modules/fields/fields.component.ts");
    /* harmony import */


    var _angular_material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/material */
    "../../node_modules/@angular/material/esm2015/material.js");
    /* harmony import */


    var _angular_forms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! @angular/forms */
    "../../node_modules/@angular/forms/fesm2015/forms.js");
    /* harmony import */


    var _angular_flex_layout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! @angular/flex-layout */
    "../../node_modules/@angular/flex-layout/esm2015/flex-layout.js");
    /* harmony import */


    var _services_fields_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ./services/fields.service */
    "./src/app/modules/fields/services/fields.service.ts");
    /* harmony import */


    var _dialog_dialog_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ./dialog/dialog.component */
    "./src/app/modules/fields/dialog/dialog.component.ts");
    /* harmony import */


    var igniteui_angular__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! igniteui-angular */
    "../../node_modules/igniteui-angular/fesm2015/igniteui-angular.js");

    var ROUTES = [{
      path: '',
      component: _fields_component__WEBPACK_IMPORTED_MODULE_4__["FieldsComponent"],
      children: []
    }];

    var FieldsModule = function FieldsModule() {
      _classCallCheck(this, FieldsModule);
    };

    FieldsModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
      declarations: [_fields_component__WEBPACK_IMPORTED_MODULE_4__["FieldsComponent"], _dialog_dialog_component__WEBPACK_IMPORTED_MODULE_9__["DialogComponent"]],
      imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], _angular_router__WEBPACK_IMPORTED_MODULE_3__["RouterModule"].forChild(ROUTES), _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatTableModule"], _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatInputModule"], _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatTabsModule"], _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatFormFieldModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["FormsModule"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["ReactiveFormsModule"], _angular_flex_layout__WEBPACK_IMPORTED_MODULE_7__["FlexLayoutModule"], _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatDialogModule"], _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatButtonModule"], _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatPaginatorModule"], _angular_material__WEBPACK_IMPORTED_MODULE_5__["MatSortModule"], igniteui_angular__WEBPACK_IMPORTED_MODULE_10__["IgxDialogModule"]],
      providers: [_services_fields_service__WEBPACK_IMPORTED_MODULE_8__["FieldsService"]],
      entryComponents: [_dialog_dialog_component__WEBPACK_IMPORTED_MODULE_9__["DialogComponent"]]
    })], FieldsModule);
    /***/
  },

  /***/
  "./src/app/modules/fields/services/fields.service.ts":
  /*!***********************************************************!*\
    !*** ./src/app/modules/fields/services/fields.service.ts ***!
    \***********************************************************/

  /*! exports provided: FieldsService */

  /***/
  function srcAppModulesFieldsServicesFieldsServiceTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FieldsService", function () {
      return FieldsService;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "../../node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "../../node_modules/@angular/core/fesm2015/core.js");
    /* harmony import */


    var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/common/http */
    "../../node_modules/@angular/common/fesm2015/http.js");
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! rxjs */
    "../../node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! rxjs/operators */
    "../../node_modules/rxjs/_esm2015/operators/index.js");

    var DOMAIN = "";

    var FieldsService =
    /*#__PURE__*/
    function () {
      function FieldsService(httpClient) {
        _classCallCheck(this, FieldsService);

        this.httpClient = httpClient;
        this.fieldsSubject = new rxjs__WEBPACK_IMPORTED_MODULE_3__["BehaviorSubject"]([]);
        this.getList();
      }

      _createClass(FieldsService, [{
        key: "getList",
        value: function getList() {
          var _this388 = this;

          this.httpClient.get("fields").subscribe(function (res) {
            return _this388.fieldsSubject.next(res);
          });
        }
      }, {
        key: "delete",
        value: function _delete(id) {
          var _this389 = this;

          this.httpClient["delete"]('fields/' + id).subscribe(function (res) {
            var value = _this389.fieldsSubject.value;
            var newList = value.filter(function (e) {
              return e.id != id;
            });

            _this389.fieldsSubject.next(newList);
          });
        }
      }, {
        key: "update",
        value: function update(field) {
          var _this390 = this;

          return this.httpClient.patch("fields", field).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["tap"])(function (res) {
            var value = _this390.fieldsSubject.value;
            var index = value.findIndex(function (e) {
              return e.id == field.id;
            });

            var newList = _toConsumableArray(value);

            newList[index] = field;

            _this390.fieldsSubject.next(newList);
          }));
        }
      }, {
        key: "addField",
        value: function addField(field) {
          var _this391 = this;

          this.httpClient.post("fields", field).subscribe(function (res) {
            var newList = [res].concat(_toConsumableArray(_this391.fieldsSubject.value));
            {
              _this391.fieldsSubject.next(newList);
            }
          });
        }
      }, {
        key: "field$",
        get: function get() {
          return this.fieldsSubject.asObservable();
        }
      }]);

      return FieldsService;
    }();

    FieldsService.ctorParameters = function () {
      return [{
        type: _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"]
      }];
    };

    FieldsService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])()], FieldsService);
    /***/
  }
}]);
//# sourceMappingURL=modules-fields-fields-module-es5.js.map